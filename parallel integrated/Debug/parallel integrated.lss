
parallel integrated.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001d978  00400000  00400000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0041d978  0041d978  0002d978  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000804  20400000  0041d980  00030000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          000068e8  20400808  0041e188  00030804  2**3
                  ALLOC
  4 .stack        00002000  204070f0  00424a70  00030804  2**0
                  ALLOC
  5 .heap         00000200  204090f0  00426a70  00030804  2**0
                  ALLOC
  6 .ARM.attributes 0000002c  00000000  00000000  00030804  2**0
                  CONTENTS, READONLY
  7 .comment      000000b4  00000000  00000000  00030830  2**0
                  CONTENTS, READONLY
  8 .debug_info   000c5031  00000000  00000000  000308e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00017b24  00000000  00000000  000f5915  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00022e5d  00000000  00000000  0010d439  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 000033c8  00000000  00000000  00130296  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00006b78  00000000  00000000  0013365e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0005f726  00000000  00000000  0013a1d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000902e6  00000000  00000000  001998fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000a04d6  00000000  00000000  00229be2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00008e10  00000000  00000000  002ca0b8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	f0 90 40 20 11 07 40 00 0d 07 40 00 0d 07 40 00     ..@ ..@...@...@.
  400010:	0d 07 40 00 0d 07 40 00 0d 07 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	0d 07 40 00 0d 07 40 00 00 00 00 00 0d 07 40 00     ..@...@.......@.
  40003c:	0d 07 40 00 0d 07 40 00 0d 07 40 00 79 c0 40 00     ..@...@...@.y.@.
  40004c:	0d 07 40 00 99 7c 41 00 0d 07 40 00 0d 07 40 00     ..@..|A...@...@.
  40005c:	0d 07 40 00 0d 07 40 00 00 00 00 00 41 1e 41 00     ..@...@.....A.A.
  40006c:	51 1e 41 00 61 1e 41 00 0d 07 40 00 0d 07 40 00     Q.A.a.A...@...@.
  40007c:	f5 34 41 00 71 1e 41 00 81 1e 41 00 0d 07 40 00     .4A.q.A...A...@.
  40008c:	0d 07 40 00 0d 07 40 00 0d 07 40 00 0d 07 40 00     ..@...@...@...@.
  40009c:	0d 07 40 00 0d 07 40 00 0d 07 40 00 0d 07 40 00     ..@...@...@...@.
  4000ac:	0d 07 40 00 0d 07 40 00 31 78 41 00 0d 07 40 00     ..@...@.1xA...@.
  4000bc:	39 4b 41 00 0d 07 40 00 0d 07 40 00 0d 07 40 00     9KA...@...@...@.
  4000cc:	0d 07 40 00 00 00 00 00 0d 07 40 00 00 00 00 00     ..@.......@.....
  4000dc:	0d 07 40 00 41 78 41 00 0d 07 40 00 0d 07 40 00     ..@.AxA...@...@.
  4000ec:	0d 07 40 00 0d 07 40 00 0d 07 40 00 0d 07 40 00     ..@...@...@...@.
  4000fc:	0d 07 40 00 75 7c 41 00 39 7c 41 00 0d 07 40 00     ..@.u|A.9|A...@.
  40010c:	0d 07 40 00 0d 07 40 00 00 00 00 00 00 00 00 00     ..@...@.........
  40011c:	00 00 00 00 0d 07 40 00 0d 07 40 00 0d 07 40 00     ......@...@...@.
  40012c:	0d 07 40 00 0d 07 40 00 00 00 00 00 0d 07 40 00     ..@...@.......@.
  40013c:	a9 7c 41 00                                         .|A.

00400140 <__do_global_dtors_aux>:
  400140:	b510      	push	{r4, lr}
  400142:	4c05      	ldr	r4, [pc, #20]	; (400158 <__do_global_dtors_aux+0x18>)
  400144:	7823      	ldrb	r3, [r4, #0]
  400146:	b933      	cbnz	r3, 400156 <__do_global_dtors_aux+0x16>
  400148:	4b04      	ldr	r3, [pc, #16]	; (40015c <__do_global_dtors_aux+0x1c>)
  40014a:	b113      	cbz	r3, 400152 <__do_global_dtors_aux+0x12>
  40014c:	4804      	ldr	r0, [pc, #16]	; (400160 <__do_global_dtors_aux+0x20>)
  40014e:	f3af 8000 	nop.w
  400152:	2301      	movs	r3, #1
  400154:	7023      	strb	r3, [r4, #0]
  400156:	bd10      	pop	{r4, pc}
  400158:	20400808 	.word	0x20400808
  40015c:	00000000 	.word	0x00000000
  400160:	0041d980 	.word	0x0041d980

00400164 <frame_dummy>:
  400164:	4b0c      	ldr	r3, [pc, #48]	; (400198 <frame_dummy+0x34>)
  400166:	b143      	cbz	r3, 40017a <frame_dummy+0x16>
  400168:	480c      	ldr	r0, [pc, #48]	; (40019c <frame_dummy+0x38>)
  40016a:	490d      	ldr	r1, [pc, #52]	; (4001a0 <frame_dummy+0x3c>)
  40016c:	b510      	push	{r4, lr}
  40016e:	f3af 8000 	nop.w
  400172:	480c      	ldr	r0, [pc, #48]	; (4001a4 <frame_dummy+0x40>)
  400174:	6803      	ldr	r3, [r0, #0]
  400176:	b923      	cbnz	r3, 400182 <frame_dummy+0x1e>
  400178:	bd10      	pop	{r4, pc}
  40017a:	480a      	ldr	r0, [pc, #40]	; (4001a4 <frame_dummy+0x40>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b933      	cbnz	r3, 40018e <frame_dummy+0x2a>
  400180:	4770      	bx	lr
  400182:	4b09      	ldr	r3, [pc, #36]	; (4001a8 <frame_dummy+0x44>)
  400184:	2b00      	cmp	r3, #0
  400186:	d0f7      	beq.n	400178 <frame_dummy+0x14>
  400188:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  40018c:	4718      	bx	r3
  40018e:	4b06      	ldr	r3, [pc, #24]	; (4001a8 <frame_dummy+0x44>)
  400190:	2b00      	cmp	r3, #0
  400192:	d0f5      	beq.n	400180 <frame_dummy+0x1c>
  400194:	4718      	bx	r3
  400196:	bf00      	nop
  400198:	00000000 	.word	0x00000000
  40019c:	0041d980 	.word	0x0041d980
  4001a0:	2040080c 	.word	0x2040080c
  4001a4:	0041d980 	.word	0x0041d980
  4001a8:	00000000 	.word	0x00000000

004001ac <board_init>:


const twihs_options_t temp_tw_options = {.master_clk = (150000000), .speed = (50000), .chip = (0), .smbus = 0};
	
void board_init(void)
{
  4001ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
	
	delay_ms(20);
  4001b0:	4899      	ldr	r0, [pc, #612]	; (400418 <board_init+0x26c>)
{
  4001b2:	b083      	sub	sp, #12
	delay_ms(20);
  4001b4:	f8df 82c4 	ldr.w	r8, [pc, #708]	; 40047c <board_init+0x2d0>
	
	//supc_backup_sram_off(SUPC);
		
		//vfd_trip();
		//sleep_err_set;
	pio_set_output(PIOA, 0xFFFFFFFF & (~PIO_PA5), LOW, DISABLE, ENABLE);
  4001b8:	2401      	movs	r4, #1
	delay_ms(20);
  4001ba:	47c0      	blx	r8
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  4001bc:	4e97      	ldr	r6, [pc, #604]	; (40041c <board_init+0x270>)
  4001be:	200a      	movs	r0, #10
	pio_set_input(PIOA, PIO_PA5, 0);
  4001c0:	4f97      	ldr	r7, [pc, #604]	; (400420 <board_init+0x274>)
  4001c2:	47b0      	blx	r6
  4001c4:	200b      	movs	r0, #11
  4001c6:	47b0      	blx	r6
  4001c8:	200c      	movs	r0, #12
  4001ca:	47b0      	blx	r6
  4001cc:	2010      	movs	r0, #16
  4001ce:	47b0      	blx	r6
  4001d0:	2011      	movs	r0, #17
  4001d2:	47b0      	blx	r6
  4001d4:	f8df 92a8 	ldr.w	r9, [pc, #680]	; 400480 <board_init+0x2d4>
  4001d8:	4638      	mov	r0, r7
  4001da:	2200      	movs	r2, #0
  4001dc:	2120      	movs	r1, #32
	pio_set_output(PIOA, 0xFFFFFFFF & (~PIO_PA5), LOW, DISABLE, ENABLE);
  4001de:	4d91      	ldr	r5, [pc, #580]	; (400424 <board_init+0x278>)
	pio_set_input(PIOA, PIO_PA5, 0);
  4001e0:	47c8      	blx	r9
	pio_set_input(PIOC, PIO_PC28, 0);
  4001e2:	2200      	movs	r2, #0
  4001e4:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4001e8:	488f      	ldr	r0, [pc, #572]	; (400428 <board_init+0x27c>)
  4001ea:	47c8      	blx	r9
	supc_set_wakeup_inputs(SUPC, SUPC_WUIR_WKUPEN4, SUPC_WUIR_WKUPT4);
  4001ec:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  4001f0:	2110      	movs	r1, #16
  4001f2:	488e      	ldr	r0, [pc, #568]	; (40042c <board_init+0x280>)
  4001f4:	4b8e      	ldr	r3, [pc, #568]	; (400430 <board_init+0x284>)
  4001f6:	4798      	blx	r3
	supc_set_wakeup_mode(SUPC, SUPC_WUMR_WKUPDBC_32768_SLCK);
  4001f8:	f44f 41a0 	mov.w	r1, #20480	; 0x5000
  4001fc:	488b      	ldr	r0, [pc, #556]	; (40042c <board_init+0x280>)
  4001fe:	4b8d      	ldr	r3, [pc, #564]	; (400434 <board_init+0x288>)
  400200:	4798      	blx	r3
	pio_set_output(PIOA, 0xFFFFFFFF & (~PIO_PA5), LOW, DISABLE, ENABLE);
  400202:	2300      	movs	r3, #0
  400204:	4638      	mov	r0, r7
  400206:	f06f 0120 	mvn.w	r1, #32
  40020a:	461a      	mov	r2, r3
  40020c:	9400      	str	r4, [sp, #0]
  40020e:	47a8      	blx	r5
	pio_set_output(PIOB, 0xFFFFFFFF, LOW, DISABLE, ENABLE);
  400210:	2300      	movs	r3, #0
  400212:	f04f 31ff 	mov.w	r1, #4294967295
  400216:	4888      	ldr	r0, [pc, #544]	; (400438 <board_init+0x28c>)
  400218:	461a      	mov	r2, r3
  40021a:	9400      	str	r4, [sp, #0]
  40021c:	47a8      	blx	r5
	pio_set_output(PIOC, 0xFFFFFFFF & (~PIO_PC28), LOW, DISABLE, ENABLE);
  40021e:	2300      	movs	r3, #0
  400220:	f06f 5180 	mvn.w	r1, #268435456	; 0x10000000
  400224:	4880      	ldr	r0, [pc, #512]	; (400428 <board_init+0x27c>)
  400226:	461a      	mov	r2, r3
  400228:	9400      	str	r4, [sp, #0]
  40022a:	47a8      	blx	r5
	pio_set_output(PIOD, 0xFFFFFFFF, LOW, DISABLE, ENABLE);
  40022c:	2300      	movs	r3, #0
  40022e:	f04f 31ff 	mov.w	r1, #4294967295
  400232:	4882      	ldr	r0, [pc, #520]	; (40043c <board_init+0x290>)
  400234:	461a      	mov	r2, r3
  400236:	9400      	str	r4, [sp, #0]
  400238:	47a8      	blx	r5
	pio_set_output(PIOE, 0xFFFFFFFF, LOW, DISABLE, ENABLE);
  40023a:	2300      	movs	r3, #0
  40023c:	f04f 31ff 	mov.w	r1, #4294967295
  400240:	487f      	ldr	r0, [pc, #508]	; (400440 <board_init+0x294>)
  400242:	461a      	mov	r2, r3
  400244:	9400      	str	r4, [sp, #0]
  400246:	47a8      	blx	r5
	pio_set_input(PIOA, PIO_PA5, 0);
  400248:	4638      	mov	r0, r7
  40024a:	2200      	movs	r2, #0
  40024c:	2120      	movs	r1, #32
  40024e:	47c8      	blx	r9
	pio_set_input(PIOC, PIO_PC28, 0);
  400250:	2200      	movs	r2, #0
  400252:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  400256:	4874      	ldr	r0, [pc, #464]	; (400428 <board_init+0x27c>)
  400258:	47c8      	blx	r9
	}
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  40025a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
	if (ioport_get_pin_level(IOPORT_CREATE_PIN(PIOA, 5)) == 0)
  40025c:	069b      	lsls	r3, r3, #26
  40025e:	f140 80d2 	bpl.w	400406 <board_init+0x25a>
		return;
	}
	
	
	
	delay_ms(250 / 25);
  400262:	4878      	ldr	r0, [pc, #480]	; (400444 <board_init+0x298>)
  400264:	47c0      	blx	r8
	sysclk_init();
  400266:	4b78      	ldr	r3, [pc, #480]	; (400448 <board_init+0x29c>)
  400268:	4798      	blx	r3
  40026a:	200a      	movs	r0, #10
  40026c:	47b0      	blx	r6
  40026e:	200b      	movs	r0, #11
  400270:	47b0      	blx	r6
  400272:	200c      	movs	r0, #12
  400274:	47b0      	blx	r6
  400276:	2010      	movs	r0, #16
  400278:	47b0      	blx	r6
  40027a:	2011      	movs	r0, #17
  40027c:	47b0      	blx	r6
	//SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_VROFF_STOP_VREG;
	//these both need configuring in their respective places
	/*
	 * ENABLE CLOCK FOR pio peripherals
	*/
	pmc_enable_periph_clk(ID_PIOB);
  40027e:	200b      	movs	r0, #11
  400280:	47b0      	blx	r6
	pmc_enable_periph_clk(ID_PIOC);
  400282:	200c      	movs	r0, #12
  400284:	47b0      	blx	r6
	pmc_enable_periph_clk(ID_PIOD);
  400286:	2010      	movs	r0, #16
  400288:	47b0      	blx	r6
	pmc_enable_periph_clk(ID_PIOA);
  40028a:	200a      	movs	r0, #10
  40028c:	47b0      	blx	r6
	pmc_enable_periph_clk(ID_PIOE);
  40028e:	2011      	movs	r0, #17
  400290:	47b0      	blx	r6
	
	//Set soft charge relay pin out low
	pio_set_output(PIOC, PIO_PC25, LOW, DISABLE, ENABLE);
  400292:	2300      	movs	r3, #0
  400294:	9400      	str	r4, [sp, #0]
  400296:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  40029a:	461a      	mov	r2, r3
  40029c:	4862      	ldr	r0, [pc, #392]	; (400428 <board_init+0x27c>)
  40029e:	47a8      	blx	r5

	//Set Fan pin out low
	pio_set_output(PIOD, PIO_PD31, LOW, DISABLE, ENABLE);
  4002a0:	2300      	movs	r3, #0
  4002a2:	9400      	str	r4, [sp, #0]
  4002a4:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  4002a8:	461a      	mov	r2, r3
  4002aa:	4864      	ldr	r0, [pc, #400]	; (40043c <board_init+0x290>)
  4002ac:	47a8      	blx	r5

	//Set Status LEDs pins out low
	pio_set_output(PIOC, PIO_PC30, HIGH, DISABLE, ENABLE);
  4002ae:	4622      	mov	r2, r4
  4002b0:	9400      	str	r4, [sp, #0]
  4002b2:	2300      	movs	r3, #0
  4002b4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  4002b8:	485b      	ldr	r0, [pc, #364]	; (400428 <board_init+0x27c>)
  4002ba:	47a8      	blx	r5
	pio_set_output(PIOC, PIO_PC31, HIGH, DISABLE, ENABLE);
  4002bc:	2300      	movs	r3, #0
  4002be:	4622      	mov	r2, r4
  4002c0:	9400      	str	r4, [sp, #0]
  4002c2:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  4002c6:	4858      	ldr	r0, [pc, #352]	; (400428 <board_init+0x27c>)
  4002c8:	47a8      	blx	r5
	
	//disable all pullups for all ADC inputs
	pio_pull_up(PIOD, PIO_PD30,0);
  4002ca:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 400484 <board_init+0x2d8>
  4002ce:	2200      	movs	r2, #0
  4002d0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  4002d4:	4859      	ldr	r0, [pc, #356]	; (40043c <board_init+0x290>)
  4002d6:	47c0      	blx	r8
	//pio_pull_up(PIOA, PIO_PA17,0);
	pio_pull_up(PIOE, PIO_PE5,0);
  4002d8:	2200      	movs	r2, #0
  4002da:	2120      	movs	r1, #32
  4002dc:	4858      	ldr	r0, [pc, #352]	; (400440 <board_init+0x294>)
  4002de:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC12,0);
  4002e0:	2200      	movs	r2, #0
  4002e2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  4002e6:	4850      	ldr	r0, [pc, #320]	; (400428 <board_init+0x27c>)
  4002e8:	47c0      	blx	r8
	pio_pull_up(PIOA, PIO_PA20,0);
  4002ea:	4638      	mov	r0, r7
  4002ec:	2200      	movs	r2, #0
  4002ee:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  4002f2:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC0,0);
  4002f4:	4621      	mov	r1, r4
  4002f6:	2200      	movs	r2, #0
  4002f8:	484b      	ldr	r0, [pc, #300]	; (400428 <board_init+0x27c>)
  4002fa:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC15,0);
  4002fc:	2200      	movs	r2, #0
  4002fe:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  400302:	4849      	ldr	r0, [pc, #292]	; (400428 <board_init+0x27c>)
  400304:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC27,0);
  400306:	2200      	movs	r2, #0
  400308:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  40030c:	4846      	ldr	r0, [pc, #280]	; (400428 <board_init+0x27c>)
  40030e:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC13,0);
  400310:	2200      	movs	r2, #0
  400312:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400316:	4844      	ldr	r0, [pc, #272]	; (400428 <board_init+0x27c>)
  400318:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC26,0);
  40031a:	2200      	movs	r2, #0
  40031c:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
  400320:	4841      	ldr	r0, [pc, #260]	; (400428 <board_init+0x27c>)
  400322:	47c0      	blx	r8
	pio_pull_up(PIOC, PIO_PC29,0);
  400324:	2200      	movs	r2, #0
  400326:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  40032a:	483f      	ldr	r0, [pc, #252]	; (400428 <board_init+0x27c>)
  40032c:	47c0      	blx	r8
	pio_pull_up(PIOE, PIO_PE3,0);
  40032e:	2200      	movs	r2, #0
  400330:	2108      	movs	r1, #8
  400332:	4843      	ldr	r0, [pc, #268]	; (400440 <board_init+0x294>)
  400334:	47c0      	blx	r8
	
	//LCD PORTS init
	pio_set_output(PIOD, (PIO_PD21|PIO_PD22|PIO_PD23), LOW, DISABLE, ENABLE);
  400336:	2300      	movs	r3, #0
  400338:	9400      	str	r4, [sp, #0]
  40033a:	f44f 0160 	mov.w	r1, #14680064	; 0xe00000
  40033e:	461a      	mov	r2, r3
  400340:	483e      	ldr	r0, [pc, #248]	; (40043c <board_init+0x290>)
  400342:	47a8      	blx	r5
	pio_set_output(PIOA, (PIO_PA25|PIO_PA26|PIO_PA11), LOW, DISABLE, ENABLE);
  400344:	2300      	movs	r3, #0
  400346:	4638      	mov	r0, r7
  400348:	9400      	str	r4, [sp, #0]
  40034a:	461a      	mov	r2, r3
  40034c:	493f      	ldr	r1, [pc, #252]	; (40044c <board_init+0x2a0>)
  40034e:	47a8      	blx	r5
	pio_set_output(PIOC, (0xFFul << 1), LOW, DISABLE, ENABLE);
  400350:	2300      	movs	r3, #0
  400352:	9400      	str	r4, [sp, #0]
  400354:	f44f 71ff 	mov.w	r1, #510	; 0x1fe
  400358:	461a      	mov	r2, r3
  40035a:	4833      	ldr	r0, [pc, #204]	; (400428 <board_init+0x27c>)
  40035c:	47a8      	blx	r5
	/*
	 * ENABLE CLOCK FOR twi peripherals
	*/

	//twi0 periph A set
	pio_set_peripheral(PIOA,PIO_PERIPH_A,PIO_PA3);
  40035e:	f8df 8128 	ldr.w	r8, [pc, #296]	; 400488 <board_init+0x2dc>
  400362:	4638      	mov	r0, r7
  400364:	2208      	movs	r2, #8
  400366:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  40036a:	47c0      	blx	r8
	pio_set_peripheral(PIOA,PIO_PERIPH_A,PIO_PA4);
  40036c:	4638      	mov	r0, r7
  40036e:	2210      	movs	r2, #16
  400370:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  400374:	47c0      	blx	r8
	
	//Set EEPROM Wr protect pins out low
	pio_set_output(PIOC, PIO_PC21, LOW, DISABLE, ENABLE);
  400376:	2300      	movs	r3, #0
  400378:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40037c:	9400      	str	r4, [sp, #0]
  40037e:	461a      	mov	r2, r3
  400380:	4829      	ldr	r0, [pc, #164]	; (400428 <board_init+0x27c>)
  400382:	47a8      	blx	r5
	pmc_enable_periph_clk(ID_TWIHS0);
  400384:	2013      	movs	r0, #19
  400386:	47b0      	blx	r6
	
	twihs_master_init(TWIHS0, &temp_tw_options);
  400388:	4931      	ldr	r1, [pc, #196]	; (400450 <board_init+0x2a4>)
  40038a:	4b32      	ldr	r3, [pc, #200]	; (400454 <board_init+0x2a8>)
  40038c:	4832      	ldr	r0, [pc, #200]	; (400458 <board_init+0x2ac>)
  40038e:	4798      	blx	r3
	
	//Enable XDMA controller
	pmc_enable_periph_clk(ID_XDMAC);
  400390:	203a      	movs	r0, #58	; 0x3a
  400392:	47b0      	blx	r6
	
	dac_interface_init();
  400394:	4b31      	ldr	r3, [pc, #196]	; (40045c <board_init+0x2b0>)
  400396:	4798      	blx	r3
	//pio_set_output(PIOD, PIO_PD26|PIO_PD25, HIGH, DISABLE, ENABLE);
	//pmc_enable_periph_clk(ID_RTC);
	rtc_init();
  400398:	4b31      	ldr	r3, [pc, #196]	; (400460 <board_init+0x2b4>)
  40039a:	4798      	blx	r3
	// wakeup pins
	pio_set_input(PIOC, PIO_PC28, 0);
  40039c:	2200      	movs	r2, #0
  40039e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4003a2:	4821      	ldr	r0, [pc, #132]	; (400428 <board_init+0x27c>)
  4003a4:	47c8      	blx	r9
	pio_set_input(PIOA, PIO_PA5, 0);
  4003a6:	2200      	movs	r2, #0
  4003a8:	2120      	movs	r1, #32
  4003aa:	4638      	mov	r0, r7
  4003ac:	47c8      	blx	r9
	
	matrix_set_system_io(CCFG_SYSIO_SYSIO4|CCFG_SYSIO_SYSIO12);
  4003ae:	f241 0010 	movw	r0, #4112	; 0x1010
  4003b2:	4b2c      	ldr	r3, [pc, #176]	; (400464 <board_init+0x2b8>)
  4003b4:	4798      	blx	r3
	//matrix_set_system_io(CCFG_SYSIO_SYSIO12);

	//set sc_level selector limit out high
	pio_set_output(PIOE, PIO_PE4, HIGH, DISABLE, ENABLE);	
  4003b6:	4622      	mov	r2, r4
  4003b8:	9400      	str	r4, [sp, #0]
  4003ba:	2300      	movs	r3, #0
  4003bc:	2110      	movs	r1, #16
  4003be:	4820      	ldr	r0, [pc, #128]	; (400440 <board_init+0x294>)
  4003c0:	47a8      	blx	r5
	
	//Set unused Pins out low
  	pio_set_output(PIOA, PIO_PA6|PIO_PA7|PIO_PA8|PIO_PA9|PIO_PA10|PIO_PA28|PIO_PA29|PIO_PA31, LOW, DISABLE, ENABLE);
  4003c2:	2300      	movs	r3, #0
  4003c4:	4638      	mov	r0, r7
  4003c6:	9400      	str	r4, [sp, #0]
  4003c8:	461a      	mov	r2, r3
  4003ca:	4927      	ldr	r1, [pc, #156]	; (400468 <board_init+0x2bc>)
  4003cc:	47a8      	blx	r5
  	pio_set_output(PIOB, PIO_PB2|PIO_PB8|PIO_PB9, LOW, DISABLE, ENABLE);
  4003ce:	2300      	movs	r3, #0
  4003d0:	9400      	str	r4, [sp, #0]
  4003d2:	f44f 7141 	mov.w	r1, #772	; 0x304
  4003d6:	461a      	mov	r2, r3
  4003d8:	4817      	ldr	r0, [pc, #92]	; (400438 <board_init+0x28c>)
  4003da:	47a8      	blx	r5
  	pio_set_output(PIOC, PIO_PC0|PIO_PC11|PIO_PC14|PIO_PC16|PIO_PC17|PIO_PC18|PIO_PC20|PIO_PC23|PIO_PC24|PIO_PC29, LOW, DISABLE, ENABLE);
  4003dc:	2300      	movs	r3, #0
  4003de:	9400      	str	r4, [sp, #0]
  4003e0:	461a      	mov	r2, r3
  4003e2:	4922      	ldr	r1, [pc, #136]	; (40046c <board_init+0x2c0>)
  4003e4:	4810      	ldr	r0, [pc, #64]	; (400428 <board_init+0x27c>)
  4003e6:	47a8      	blx	r5
  	pio_set_output(PIOD, PIO_PD1|PIO_PD2|PIO_PD3|PIO_PD4|PIO_PD5|PIO_PD6|PIO_PD7|PIO_PD12|PIO_PD14|PIO_PD28|PIO_PD29, LOW, DISABLE, ENABLE);
  4003e8:	2300      	movs	r3, #0
  4003ea:	9400      	str	r4, [sp, #0]
  4003ec:	461a      	mov	r2, r3
  4003ee:	4920      	ldr	r1, [pc, #128]	; (400470 <board_init+0x2c4>)
  4003f0:	4812      	ldr	r0, [pc, #72]	; (40043c <board_init+0x290>)
  4003f2:	47a8      	blx	r5
  	pio_set_output(PIOE, PIO_PE2|PIO_PE0|PIO_PE1|PIO_PE2|PIO_PE3, LOW, DISABLE, ENABLE);
  4003f4:	2300      	movs	r3, #0
  4003f6:	210f      	movs	r1, #15
  4003f8:	4811      	ldr	r0, [pc, #68]	; (400440 <board_init+0x294>)
  4003fa:	461a      	mov	r2, r3
  4003fc:	9400      	str	r4, [sp, #0]
  4003fe:	47a8      	blx	r5
}
  400400:	b003      	add	sp, #12
  400402:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		supc_backup_sram_off(SUPC);
  400406:	4809      	ldr	r0, [pc, #36]	; (40042c <board_init+0x280>)
  400408:	4b1a      	ldr	r3, [pc, #104]	; (400474 <board_init+0x2c8>)
  40040a:	4798      	blx	r3
		supc_enable_backup_mode(SUPC);
  40040c:	4807      	ldr	r0, [pc, #28]	; (40042c <board_init+0x280>)
  40040e:	4b1a      	ldr	r3, [pc, #104]	; (400478 <board_init+0x2cc>)
}
  400410:	b003      	add	sp, #12
  400412:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		supc_enable_backup_mode(SUPC);
  400416:	4718      	bx	r3
  400418:	000f6f08 	.word	0x000f6f08
  40041c:	00417a25 	.word	0x00417a25
  400420:	400e0e00 	.word	0x400e0e00
  400424:	00417515 	.word	0x00417515
  400428:	400e1200 	.word	0x400e1200
  40042c:	400e1810 	.word	0x400e1810
  400430:	004006b9 	.word	0x004006b9
  400434:	004006b5 	.word	0x004006b5
  400438:	400e1000 	.word	0x400e1000
  40043c:	400e1400 	.word	0x400e1400
  400440:	400e1600 	.word	0x400e1600
  400444:	0007b784 	.word	0x0007b784
  400448:	00417589 	.word	0x00417589
  40044c:	06000800 	.word	0x06000800
  400450:	0041985c 	.word	0x0041985c
  400454:	00412341 	.word	0x00412341
  400458:	40018000 	.word	0x40018000
  40045c:	0040d0d1 	.word	0x0040d0d1
  400460:	0040c0cd 	.word	0x0040c0cd
  400464:	00400559 	.word	0x00400559
  400468:	b00007c0 	.word	0xb00007c0
  40046c:	21974801 	.word	0x21974801
  400470:	300050fe 	.word	0x300050fe
  400474:	004006c1 	.word	0x004006c1
  400478:	004006a1 	.word	0x004006a1
  40047c:	20400001 	.word	0x20400001
  400480:	004174dd 	.word	0x004174dd
  400484:	00417431 	.word	0x00417431
  400488:	00417445 	.word	0x00417445

0040048c <at24macxx_write_byte>:
 *
 * \return AT24MAC_WRITE_SUCCESS if single byte was written, AT24MAC_WRITE_FAIL
 * otherwise.
 */
uint32_t at24macxx_write_byte(uint32_t u32_address, uint8_t u8_value)
{
  40048c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40048e:	b089      	sub	sp, #36	; 0x24
	twihs_package_t twihs_package;

	/* Configure the data packet to be transmitted */
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
	at24mac_build_word_address(twihs_package.addr, u32_address);
  400490:	0a05      	lsrs	r5, r0, #8
{
  400492:	4603      	mov	r3, r0
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
  400494:	2750      	movs	r7, #80	; 0x50
	twihs_package.addr_length = AT24MAC_MEM_ADDR_LEN;
  400496:	2602      	movs	r6, #2
	twihs_package.buffer = &u8_value;
  400498:	f10d 0207 	add.w	r2, sp, #7
	twihs_package.length = 1;
  40049c:	2401      	movs	r4, #1
{
  40049e:	f88d 1007 	strb.w	r1, [sp, #7]
	at24mac_build_word_address(twihs_package.addr, u32_address);
  4004a2:	f88d 500c 	strb.w	r5, [sp, #12]

	if (twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, &twihs_package) != TWIHS_SUCCESS) {
  4004a6:	a903      	add	r1, sp, #12
  4004a8:	480f      	ldr	r0, [pc, #60]	; (4004e8 <at24macxx_write_byte+0x5c>)
  4004aa:	4d10      	ldr	r5, [pc, #64]	; (4004ec <at24macxx_write_byte+0x60>)
	at24mac_build_word_address(twihs_package.addr, u32_address);
  4004ac:	f88d 300d 	strb.w	r3, [sp, #13]
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
  4004b0:	f88d 701c 	strb.w	r7, [sp, #28]
	twihs_package.addr_length = AT24MAC_MEM_ADDR_LEN;
  4004b4:	9604      	str	r6, [sp, #16]
	twihs_package.buffer = &u8_value;
  4004b6:	9205      	str	r2, [sp, #20]
	twihs_package.length = 1;
  4004b8:	9406      	str	r4, [sp, #24]
	if (twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, &twihs_package) != TWIHS_SUCCESS) {
  4004ba:	47a8      	blx	r5
  4004bc:	b110      	cbz	r0, 4004c4 <at24macxx_write_byte+0x38>
		return AT24MAC_WRITE_FAIL;
  4004be:	4620      	mov	r0, r4
	}
	at24macxx_acknowledge_polling(&twihs_package);

	return AT24MAC_WRITE_SUCCESS;
}
  4004c0:	b009      	add	sp, #36	; 0x24
  4004c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	twihs_package->buffer = &data;
  4004c4:	f10d 030b 	add.w	r3, sp, #11
	while (twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, twihs_package) !=
  4004c8:	4e07      	ldr	r6, [pc, #28]	; (4004e8 <at24macxx_write_byte+0x5c>)
	uint8_t data = 0;
  4004ca:	f88d 000b 	strb.w	r0, [sp, #11]
	twihs_package->addr[0] = 0;
  4004ce:	f88d 000c 	strb.w	r0, [sp, #12]
	twihs_package->addr_length = 0;
  4004d2:	9004      	str	r0, [sp, #16]
	twihs_package->length = 1;
  4004d4:	9406      	str	r4, [sp, #24]
	twihs_package->buffer = &data;
  4004d6:	9305      	str	r3, [sp, #20]
	while (twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, twihs_package) !=
  4004d8:	a903      	add	r1, sp, #12
  4004da:	4630      	mov	r0, r6
  4004dc:	47a8      	blx	r5
  4004de:	2800      	cmp	r0, #0
  4004e0:	d1fa      	bne.n	4004d8 <at24macxx_write_byte+0x4c>
}
  4004e2:	b009      	add	sp, #36	; 0x24
  4004e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4004e6:	bf00      	nop
  4004e8:	40018000 	.word	0x40018000
  4004ec:	00412415 	.word	0x00412415

004004f0 <at24macxx_write_continuous>:
uint32_t at24macxx_write_continuous(uint32_t u32_start_address,
		uint16_t u16_length, uint8_t const *p_wr_buffer)
{
	uint32_t i;

	for(i=0;i<u16_length;i++) {
  4004f0:	b189      	cbz	r1, 400516 <at24macxx_write_continuous+0x26>
{
  4004f2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for(i=0;i<u16_length;i++) {
  4004f4:	4614      	mov	r4, r2
  4004f6:	1855      	adds	r5, r2, r1
  4004f8:	4f08      	ldr	r7, [pc, #32]	; (40051c <at24macxx_write_continuous+0x2c>)
  4004fa:	1a86      	subs	r6, r0, r2
  4004fc:	e001      	b.n	400502 <at24macxx_write_continuous+0x12>
  4004fe:	42ac      	cmp	r4, r5
  400500:	d007      	beq.n	400512 <at24macxx_write_continuous+0x22>
  400502:	1930      	adds	r0, r6, r4
		if (at24macxx_write_byte(u32_start_address, *p_wr_buffer) != AT24MAC_WRITE_SUCCESS) {
  400504:	f814 1b01 	ldrb.w	r1, [r4], #1
  400508:	47b8      	blx	r7
  40050a:	2800      	cmp	r0, #0
  40050c:	d0f7      	beq.n	4004fe <at24macxx_write_continuous+0xe>
			return AT24MAC_WRITE_FAIL;
  40050e:	2001      	movs	r0, #1
		u32_start_address++;
		p_wr_buffer++;
	}

	return AT24MAC_WRITE_SUCCESS;
}
  400510:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return AT24MAC_WRITE_SUCCESS;
  400512:	2000      	movs	r0, #0
  400514:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400516:	2000      	movs	r0, #0
}
  400518:	4770      	bx	lr
  40051a:	bf00      	nop
  40051c:	0040048d 	.word	0x0040048d

00400520 <at24macxx_read_continuous>:
 *
 * \return AT24MAC_READ_SUCCESS if one byte was read, AT24MAC_READ_FAIL otherwise.
 */
uint32_t at24macxx_read_continuous(uint32_t u32_start_address,
		uint16_t u16_length, uint8_t *p_rd_buffer)
{
  400520:	b5f0      	push	{r4, r5, r6, r7, lr}
  400522:	b087      	sub	sp, #28
  400524:	4603      	mov	r3, r0
	twihs_package_t twihs_package;

	/* Configure the data packet to be received */
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
	at24mac_build_word_address(twihs_package.addr, u32_start_address);
  400526:	0a07      	lsrs	r7, r0, #8
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
  400528:	2650      	movs	r6, #80	; 0x50
	twihs_package.addr_length = AT24MAC_MEM_ADDR_LEN;
  40052a:	2502      	movs	r5, #2
	twihs_package.buffer = p_rd_buffer;
	twihs_package.length = u16_length;
  40052c:	9104      	str	r1, [sp, #16]

	if (twihs_master_read(BOARD_AT24MAC_TWIHS_INSTANCE, &twihs_package) !=
  40052e:	4c08      	ldr	r4, [pc, #32]	; (400550 <at24macxx_read_continuous+0x30>)
  400530:	a901      	add	r1, sp, #4
  400532:	4808      	ldr	r0, [pc, #32]	; (400554 <at24macxx_read_continuous+0x34>)
	at24mac_build_word_address(twihs_package.addr, u32_start_address);
  400534:	f88d 3005 	strb.w	r3, [sp, #5]
  400538:	f88d 7004 	strb.w	r7, [sp, #4]
	twihs_package.buffer = p_rd_buffer;
  40053c:	9203      	str	r2, [sp, #12]
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
  40053e:	f88d 6014 	strb.w	r6, [sp, #20]
	twihs_package.addr_length = AT24MAC_MEM_ADDR_LEN;
  400542:	9502      	str	r5, [sp, #8]
	if (twihs_master_read(BOARD_AT24MAC_TWIHS_INSTANCE, &twihs_package) !=
  400544:	47a0      	blx	r4
			TWIHS_SUCCESS) {
		return AT24MAC_READ_FAIL;
	}

	return AT24MAC_READ_SUCCESS;
}
  400546:	3000      	adds	r0, #0
  400548:	bf18      	it	ne
  40054a:	2001      	movne	r0, #1
  40054c:	b007      	add	sp, #28
  40054e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400550:	00412375 	.word	0x00412375
  400554:	40018000 	.word	0x40018000

00400558 <matrix_set_system_io>:

	p_matrix->MATRIX_SYSIO = ul_io;

#elif (SAMV71 || SAMV70 || SAMS70 || SAME70)
	
	p_matrix->CCFG_SYSIO &= 0xFFFF0000;
  400558:	4b06      	ldr	r3, [pc, #24]	; (400574 <matrix_set_system_io+0x1c>)
	p_matrix->CCFG_SYSIO |= (ul_io & 0xFFFF);
  40055a:	b280      	uxth	r0, r0
	p_matrix->CCFG_SYSIO &= 0xFFFF0000;
  40055c:	4a06      	ldr	r2, [pc, #24]	; (400578 <matrix_set_system_io+0x20>)
  40055e:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
  400562:	400a      	ands	r2, r1
  400564:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	p_matrix->CCFG_SYSIO |= (ul_io & 0xFFFF);
  400568:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  40056c:	4310      	orrs	r0, r2
  40056e:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
  400572:	4770      	bx	lr
  400574:	40088000 	.word	0x40088000
  400578:	ffff0000 	.word	0xffff0000

0040057c <rstc_start_software_reset>:
 */
void rstc_start_software_reset(
		Rstc *p_rstc)
{
#if (SAMV71 || SAMV70 || SAMS70 || SAME70)
	p_rstc->RSTC_CR = RSTC_KEY | RSTC_CR_PROCRST;
  40057c:	4b01      	ldr	r3, [pc, #4]	; (400584 <rstc_start_software_reset+0x8>)
  40057e:	6003      	str	r3, [r0, #0]
  400580:	4770      	bx	lr
  400582:	bf00      	nop
  400584:	a5000001 	.word	0xa5000001

00400588 <rswdt_init>:
void rswdt_init(Rswdt *p_rswdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
#if (SAMV71 || SAMV70 || SAME70 || SAMS70)
	p_rswdt->RSWDT_MR = ul_mode |
			RSWDT_MR_WDV(us_counter);
  400588:	f3c2 020b 	ubfx	r2, r2, #0, #12
	p_rswdt->RSWDT_MR = ul_mode |
  40058c:	430a      	orrs	r2, r1
  40058e:	6042      	str	r2, [r0, #4]
  400590:	4770      	bx	lr
  400592:	bf00      	nop

00400594 <rswdt_restart>:
/**
 * \brief Restart the reinforced safety watchdog timer.
 */
void rswdt_restart(Rswdt *p_rswdt)
{
	if (p_rswdt == RSWDT) {
  400594:	4b03      	ldr	r3, [pc, #12]	; (4005a4 <rswdt_restart+0x10>)
  400596:	4298      	cmp	r0, r3
  400598:	d000      	beq.n	40059c <rswdt_restart+0x8>
  40059a:	4770      	bx	lr
		p_rswdt->RSWDT_CR = RSWDT_KEY_PASSWORD | RSWDT_CR_WDRSTT;
  40059c:	4b02      	ldr	r3, [pc, #8]	; (4005a8 <rswdt_restart+0x14>)
  40059e:	6003      	str	r3, [r0, #0]
  4005a0:	4770      	bx	lr
  4005a2:	bf00      	nop
  4005a4:	400e1900 	.word	0x400e1900
  4005a8:	c4000001 	.word	0xc4000001

004005ac <rswdt_get_status>:
 *
 * \return Bitmask of reinforced safety watchdog timer status.
 */
uint32_t rswdt_get_status(Rswdt *p_rswdt)
{
	return p_rswdt->RSWDT_SR;
  4005ac:	6880      	ldr	r0, [r0, #8]
}
  4005ae:	4770      	bx	lr

004005b0 <rtc_enable_interrupt>:
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_sources Interrupts to be enabled.
 */
void rtc_enable_interrupt(Rtc *p_rtc, uint32_t ul_sources)
{
	p_rtc->RTC_IER = ul_sources;
  4005b0:	6201      	str	r1, [r0, #32]
  4005b2:	4770      	bx	lr

004005b4 <rtc_disable_interrupt>:
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_sources Interrupts to be disabled.
 */
void rtc_disable_interrupt(Rtc *p_rtc, uint32_t ul_sources)
{
	p_rtc->RTC_IDR = ul_sources;
  4005b4:	6241      	str	r1, [r0, #36]	; 0x24
  4005b6:	4770      	bx	lr

004005b8 <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  4005b8:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  4005ba:	6885      	ldr	r5, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  4005bc:	6884      	ldr	r4, [r0, #8]
  4005be:	42a5      	cmp	r5, r4
  4005c0:	d003      	beq.n	4005ca <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  4005c2:	6885      	ldr	r5, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  4005c4:	6884      	ldr	r4, [r0, #8]
  4005c6:	42ac      	cmp	r4, r5
  4005c8:	d1fb      	bne.n	4005c2 <rtc_get_time+0xa>
	}

	/* Hour */
	if (pul_hour) {
  4005ca:	b159      	cbz	r1, 4005e4 <rtc_get_time+0x2c>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4005cc:	f3c4 5501 	ubfx	r5, r4, #20, #2
  4005d0:	f3c4 4003 	ubfx	r0, r4, #16, #4
  4005d4:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  4005d8:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  4005dc:	0265      	lsls	r5, r4, #9
			*pul_hour += 12;
  4005de:	bf48      	it	mi
  4005e0:	300c      	addmi	r0, #12
  4005e2:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  4005e4:	b142      	cbz	r2, 4005f8 <rtc_get_time+0x40>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  4005e6:	f3c4 3102 	ubfx	r1, r4, #12, #3
  4005ea:	f3c4 2003 	ubfx	r0, r4, #8, #4
  4005ee:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  4005f2:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  4005f6:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  4005f8:	b143      	cbz	r3, 40060c <rtc_get_time+0x54>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4005fa:	f3c4 1202 	ubfx	r2, r4, #4, #3
  4005fe:	f004 040f 	and.w	r4, r4, #15
  400602:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  400606:	eb04 0442 	add.w	r4, r4, r2, lsl #1
  40060a:	601c      	str	r4, [r3, #0]
	}
}
  40060c:	bc30      	pop	{r4, r5}
  40060e:	4770      	bx	lr

00400610 <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  400610:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  400612:	68c5      	ldr	r5, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  400614:	68c4      	ldr	r4, [r0, #12]
{
  400616:	9e05      	ldr	r6, [sp, #20]
	while (ul_date != p_rtc->RTC_CALR) {
  400618:	42a5      	cmp	r5, r4
  40061a:	d003      	beq.n	400624 <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  40061c:	68c5      	ldr	r5, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  40061e:	68c4      	ldr	r4, [r0, #12]
  400620:	42ac      	cmp	r4, r5
  400622:	d1fb      	bne.n	40061c <rtc_get_date+0xc>
	}

	/* Retrieve year */
	if (pul_year) {
  400624:	b1a1      	cbz	r1, 400650 <rtc_get_date+0x40>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  400626:	f3c4 3703 	ubfx	r7, r4, #12, #4
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40062a:	f3c4 1502 	ubfx	r5, r4, #4, #3
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40062e:	f3c4 2e03 	ubfx	lr, r4, #8, #4
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  400632:	f004 000f 	and.w	r0, r4, #15
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  400636:	eb07 0787 	add.w	r7, r7, r7, lsl #2
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40063a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40063e:	eb0e 0747 	add.w	r7, lr, r7, lsl #1
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  400642:	f04f 0e64 	mov.w	lr, #100	; 0x64
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  400646:	eb00 0045 	add.w	r0, r0, r5, lsl #1
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40064a:	fb0e 7000 	mla	r0, lr, r0, r7
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  40064e:	6008      	str	r0, [r1, #0]
	}

	/* Retrieve month */
	if (pul_month) {
  400650:	b142      	cbz	r2, 400664 <rtc_get_date+0x54>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  400652:	f3c4 5500 	ubfx	r5, r4, #20, #1
  400656:	f3c4 4103 	ubfx	r1, r4, #16, #4
  40065a:	00a8      	lsls	r0, r5, #2
  40065c:	4428      	add	r0, r5
  40065e:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  400662:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  400664:	b143      	cbz	r3, 400678 <rtc_get_date+0x68>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  400666:	f3c4 7201 	ubfx	r2, r4, #28, #2
  40066a:	f3c4 6103 	ubfx	r1, r4, #24, #4
  40066e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  400672:	eb01 0242 	add.w	r2, r1, r2, lsl #1
  400676:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  400678:	b116      	cbz	r6, 400680 <rtc_get_date+0x70>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  40067a:	f3c4 5442 	ubfx	r4, r4, #21, #3
  40067e:	6034      	str	r4, [r6, #0]
  400680:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400682:	bf00      	nop

00400684 <rtc_clear_time_alarm>:
 *
 * \param p_rtc Pointer to an RTC instance.
 */
void rtc_clear_time_alarm(Rtc *p_rtc)
{
	p_rtc->RTC_TIMALR = 0;
  400684:	2300      	movs	r3, #0
  400686:	6103      	str	r3, [r0, #16]
  400688:	4770      	bx	lr
  40068a:	bf00      	nop

0040068c <rtc_clear_date_alarm>:
 * \param p_rtc Pointer to an RTC instance.
 */
void rtc_clear_date_alarm(Rtc *p_rtc)
{
	/* Need a valid value without enabling */
	p_rtc->RTC_CALALR = RTC_CALALR_MONTH(0x01) | RTC_CALALR_DATE(0x01);
  40068c:	4b01      	ldr	r3, [pc, #4]	; (400694 <rtc_clear_date_alarm+0x8>)
  40068e:	6143      	str	r3, [r0, #20]
  400690:	4770      	bx	lr
  400692:	bf00      	nop
  400694:	01010000 	.word	0x01010000

00400698 <rtc_get_status>:
 *
 * \return Status of the RTC.
 */
uint32_t rtc_get_status(Rtc *p_rtc)
{
	return (p_rtc->RTC_SR);
  400698:	6980      	ldr	r0, [r0, #24]
}
  40069a:	4770      	bx	lr

0040069c <rtc_clear_status>:
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_clear Some flag bits which will be cleared.
 */
void rtc_clear_status(Rtc *p_rtc, uint32_t ul_clear)
{
	p_rtc->RTC_SCCR = ul_clear;
  40069c:	61c1      	str	r1, [r0, #28]
  40069e:	4770      	bx	lr

004006a0 <supc_enable_backup_mode>:
 *
 * \param p_supc Pointer to a SUPC instance.
 */
void supc_enable_backup_mode(Supc *p_supc)
{
	p_supc->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_VROFF;
  4006a0:	4b03      	ldr	r3, [pc, #12]	; (4006b0 <supc_enable_backup_mode+0x10>)
  4006a2:	6003      	str	r3, [r0, #0]
	uint32_t ul_dummy = p_supc->SUPC_MR;
  4006a4:	6883      	ldr	r3, [r0, #8]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
  4006a6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("wfe");
  4006aa:	bf20      	wfe
  __ASM volatile ("wfi");
  4006ac:	bf30      	wfi
  4006ae:	4770      	bx	lr
  4006b0:	a5000004 	.word	0xa5000004

004006b4 <supc_set_wakeup_mode>:
 * \param p_supc Pointer to a SUPC instance.
 * \param ul_mode Bitmask of wake up mode (please refer to datasheet for more details).
 */
void supc_set_wakeup_mode(Supc *p_supc, uint32_t ul_mode)
{
	p_supc->SUPC_WUMR = ul_mode;
  4006b4:	60c1      	str	r1, [r0, #12]
  4006b6:	4770      	bx	lr

004006b8 <supc_set_wakeup_inputs>:
 * 0 means a low-to-high level transition forces the wake up of core power supply.
 */
void supc_set_wakeup_inputs(Supc *p_supc, uint32_t ul_inputs,
		uint32_t ul_transition)
{
	p_supc->SUPC_WUIR = ul_inputs | ul_transition;
  4006b8:	430a      	orrs	r2, r1
  4006ba:	6102      	str	r2, [r0, #16]
  4006bc:	4770      	bx	lr
  4006be:	bf00      	nop

004006c0 <supc_backup_sram_off>:
 * \param p_supc Pointer to a SUPC instance.
 *
 */
void supc_backup_sram_off(Supc *p_supc)
{
	p_supc->SUPC_MR &= (~(SUPC_MR_KEY_PASSWD | SUPC_MR_BKUPRETON));	
  4006c0:	6882      	ldr	r2, [r0, #8]
  4006c2:	4b02      	ldr	r3, [pc, #8]	; (4006cc <supc_backup_sram_off+0xc>)
  4006c4:	4013      	ands	r3, r2
  4006c6:	6083      	str	r3, [r0, #8]
  4006c8:	4770      	bx	lr
  4006ca:	bf00      	nop
  4006cc:	5afdffff 	.word	0x5afdffff

004006d0 <xdmac_configure_transfer>:
 */
static inline uint32_t xdmac_channel_get_interrupt_status(Xdmac *xdmac, uint32_t channel_num)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	return xdmac->XDMAC_CHID[channel_num].XDMAC_CIS;
  4006d0:	eb00 1181 	add.w	r1, r0, r1, lsl #6
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	Assert(cfg);
	
	xdmac_channel_get_interrupt_status( xdmac, channel_num);
	xdmac_channel_set_source_addr(xdmac, channel_num, cfg->mbr_sa);
  4006d4:	6853      	ldr	r3, [r2, #4]
  4006d6:	6dc8      	ldr	r0, [r1, #92]	; 0x5c
 */
static inline void xdmac_channel_set_source_addr(Xdmac *xdmac, uint32_t channel_num, uint32_t src_addr)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CSA = src_addr;
  4006d8:	660b      	str	r3, [r1, #96]	; 0x60
	xdmac_channel_set_destination_addr(xdmac, channel_num, cfg->mbr_da);
  4006da:	6893      	ldr	r3, [r2, #8]
 */
static inline void xdmac_channel_set_destination_addr(Xdmac *xdmac, uint32_t channel_num, uint32_t dst_addr)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CDA = dst_addr;
  4006dc:	664b      	str	r3, [r1, #100]	; 0x64
 */
static inline void xdmac_channel_set_microblock_control(Xdmac *xdmac, uint32_t channel_num, uint32_t ublen)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CUBC = XDMAC_CUBC_UBLEN(ublen);
  4006de:	6813      	ldr	r3, [r2, #0]
  4006e0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  4006e4:	670b      	str	r3, [r1, #112]	; 0x70
 */
static inline void xdmac_channel_set_block_control(Xdmac *xdmac, uint32_t channel_num, uint32_t blen)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CBC = XDMAC_CBC_BLEN(blen);
  4006e6:	6913      	ldr	r3, [r2, #16]
  4006e8:	f3c3 030b 	ubfx	r3, r3, #0, #12
  4006ec:	674b      	str	r3, [r1, #116]	; 0x74
	xdmac_channel_set_microblock_control(xdmac, channel_num, cfg->mbr_ubc);
	xdmac_channel_set_block_control(xdmac, channel_num, cfg->mbr_bc);
	xdmac_channel_set_datastride_mempattern(xdmac, channel_num, cfg->mbr_ds);
  4006ee:	6953      	ldr	r3, [r2, #20]
 */
static inline void xdmac_channel_set_datastride_mempattern(Xdmac *xdmac, uint32_t channel_num, uint32_t dds_msp)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CDS_MSP = dds_msp;
  4006f0:	67cb      	str	r3, [r1, #124]	; 0x7c
static inline void xdmac_channel_set_source_microblock_stride(Xdmac *xdmac,
		uint32_t channel_num, uint32_t subs)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CSUS = XDMAC_CSUS_SUBS(subs);
  4006f2:	6993      	ldr	r3, [r2, #24]
  4006f4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  4006f8:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
static inline void xdmac_channel_set_destination_microblock_stride(Xdmac *xdmac,
		uint32_t channel_num, uint32_t dubs)
{
	Assert(xdmac);
	Assert(channel_num < XDMACCHID_NUMBER);
	xdmac->XDMAC_CHID[channel_num].XDMAC_CDUS = XDMAC_CDUS_DUBS(dubs);
  4006fc:	69d3      	ldr	r3, [r2, #28]
  4006fe:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  400702:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
	xdmac_channel_set_source_microblock_stride(xdmac, channel_num, cfg->mbr_sus);
	xdmac_channel_set_destination_microblock_stride(xdmac, channel_num, cfg->mbr_dus);
	xdmac_channel_set_config(xdmac, channel_num, cfg->mbr_cfg );
  400706:	68d3      	ldr	r3, [r2, #12]
	xdmac->XDMAC_CHID[channel_num].XDMAC_CC = config;
  400708:	678b      	str	r3, [r1, #120]	; 0x78
  40070a:	4770      	bx	lr

0040070c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40070c:	e7fe      	b.n	40070c <Dummy_Handler>
  40070e:	bf00      	nop

00400710 <Reset_Handler>:
        if (pSrc != pDest) {
  400710:	4924      	ldr	r1, [pc, #144]	; (4007a4 <Reset_Handler+0x94>)
  400712:	4a25      	ldr	r2, [pc, #148]	; (4007a8 <Reset_Handler+0x98>)
  400714:	4291      	cmp	r1, r2
{
  400716:	b500      	push	{lr}
  400718:	b083      	sub	sp, #12
        if (pSrc != pDest) {
  40071a:	d00e      	beq.n	40073a <Reset_Handler+0x2a>
                for (; pDest < &_erelocate;) {
  40071c:	4823      	ldr	r0, [pc, #140]	; (4007ac <Reset_Handler+0x9c>)
  40071e:	4282      	cmp	r2, r0
  400720:	d20b      	bcs.n	40073a <Reset_Handler+0x2a>
  400722:	43d3      	mvns	r3, r2
  400724:	4403      	add	r3, r0
  400726:	f023 0303 	bic.w	r3, r3, #3
  40072a:	3304      	adds	r3, #4
  40072c:	4413      	add	r3, r2
                        *pDest++ = *pSrc++;
  40072e:	f851 0b04 	ldr.w	r0, [r1], #4
  400732:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
  400736:	429a      	cmp	r2, r3
  400738:	d1f9      	bne.n	40072e <Reset_Handler+0x1e>
        for (pDest = &_szero; pDest < &_ezero;) {
  40073a:	4a1d      	ldr	r2, [pc, #116]	; (4007b0 <Reset_Handler+0xa0>)
  40073c:	491d      	ldr	r1, [pc, #116]	; (4007b4 <Reset_Handler+0xa4>)
  40073e:	428a      	cmp	r2, r1
  400740:	d20a      	bcs.n	400758 <Reset_Handler+0x48>
  400742:	43d3      	mvns	r3, r2
                *pDest++ = 0;
  400744:	2000      	movs	r0, #0
  400746:	440b      	add	r3, r1
  400748:	f023 0303 	bic.w	r3, r3, #3
  40074c:	3304      	adds	r3, #4
  40074e:	4413      	add	r3, r2
  400750:	f842 0b04 	str.w	r0, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
  400754:	429a      	cmp	r2, r3
  400756:	d1fb      	bne.n	400750 <Reset_Handler+0x40>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  400758:	4b17      	ldr	r3, [pc, #92]	; (4007b8 <Reset_Handler+0xa8>)
  40075a:	4a18      	ldr	r2, [pc, #96]	; (4007bc <Reset_Handler+0xac>)
  40075c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400760:	6093      	str	r3, [r2, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  400762:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = cpu_irq_is_enabled();
  400766:	fab3 f383 	clz	r3, r3
  40076a:	095b      	lsrs	r3, r3, #5
  40076c:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
  40076e:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  400770:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  400774:	4a12      	ldr	r2, [pc, #72]	; (4007c0 <Reset_Handler+0xb0>)
  400776:	2300      	movs	r3, #0
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
	REG_CPACR |=  (0xFu << 20);
  400778:	4912      	ldr	r1, [pc, #72]	; (4007c4 <Reset_Handler+0xb4>)
  40077a:	7013      	strb	r3, [r2, #0]
	return flags;
  40077c:	9801      	ldr	r0, [sp, #4]
  40077e:	680b      	ldr	r3, [r1, #0]
  400780:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  400784:	600b      	str	r3, [r1, #0]
  __ASM volatile ("dsb");
  400786:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  40078a:	f3bf 8f6f 	isb	sy
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  40078e:	b120      	cbz	r0, 40079a <Reset_Handler+0x8a>
		cpu_irq_enable();
  400790:	2301      	movs	r3, #1
  400792:	7013      	strb	r3, [r2, #0]
  __ASM volatile ("dmb");
  400794:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  400798:	b662      	cpsie	i
        __libc_init_array();
  40079a:	4b0b      	ldr	r3, [pc, #44]	; (4007c8 <Reset_Handler+0xb8>)
  40079c:	4798      	blx	r3
        main();
  40079e:	4b0b      	ldr	r3, [pc, #44]	; (4007cc <Reset_Handler+0xbc>)
  4007a0:	4798      	blx	r3
  4007a2:	e7fe      	b.n	4007a2 <Reset_Handler+0x92>
  4007a4:	0041d980 	.word	0x0041d980
  4007a8:	20400000 	.word	0x20400000
  4007ac:	20400804 	.word	0x20400804
  4007b0:	20400808 	.word	0x20400808
  4007b4:	204070f0 	.word	0x204070f0
  4007b8:	00400000 	.word	0x00400000
  4007bc:	e000ed00 	.word	0xe000ed00
  4007c0:	2040000a 	.word	0x2040000a
  4007c4:	e000ed88 	.word	0xe000ed88
  4007c8:	004195b9 	.word	0x004195b9
  4007cc:	00417e29 	.word	0x00417e29

004007d0 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate( void )
{
  /* Determine clock frequency according to clock register values */
  switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk)
  4007d0:	4a31      	ldr	r2, [pc, #196]	; (400898 <SystemCoreClockUpdate+0xc8>)
  4007d2:	6b13      	ldr	r3, [r2, #48]	; 0x30
  4007d4:	f003 0303 	and.w	r3, r3, #3
  4007d8:	2b01      	cmp	r3, #1
  4007da:	d03d      	beq.n	400858 <SystemCoreClockUpdate+0x88>
  4007dc:	d326      	bcc.n	40082c <SystemCoreClockUpdate+0x5c>
  4007de:	2b02      	cmp	r3, #2
  4007e0:	d00d      	beq.n	4007fe <SystemCoreClockUpdate+0x2e>
  4007e2:	492e      	ldr	r1, [pc, #184]	; (40089c <SystemCoreClockUpdate+0xcc>)
  4007e4:	680b      	ldr	r3, [r1, #0]

    default:
    break;
  }

  if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 )
  4007e6:	482c      	ldr	r0, [pc, #176]	; (400898 <SystemCoreClockUpdate+0xc8>)
  4007e8:	6b02      	ldr	r2, [r0, #48]	; 0x30
  4007ea:	f002 0270 	and.w	r2, r2, #112	; 0x70
  4007ee:	2a70      	cmp	r2, #112	; 0x70
  4007f0:	d02c      	beq.n	40084c <SystemCoreClockUpdate+0x7c>
  {
    SystemCoreClock /= 3U;
  }
  else
  {
    SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4007f2:	6b02      	ldr	r2, [r0, #48]	; 0x30
  4007f4:	f3c2 1202 	ubfx	r2, r2, #4, #3
  4007f8:	40d3      	lsrs	r3, r2
  4007fa:	600b      	str	r3, [r1, #0]
  4007fc:	4770      	bx	lr
      if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL )
  4007fe:	6a13      	ldr	r3, [r2, #32]
        SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  400800:	4926      	ldr	r1, [pc, #152]	; (40089c <SystemCoreClockUpdate+0xcc>)
      if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL )
  400802:	01db      	lsls	r3, r3, #7
  400804:	d538      	bpl.n	400878 <SystemCoreClockUpdate+0xa8>
            SystemCoreClock *= 3U;
  400806:	4b26      	ldr	r3, [pc, #152]	; (4008a0 <SystemCoreClockUpdate+0xd0>)
  400808:	600b      	str	r3, [r1, #0]
      if ( (uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK )
  40080a:	4823      	ldr	r0, [pc, #140]	; (400898 <SystemCoreClockUpdate+0xc8>)
  40080c:	6b02      	ldr	r2, [r0, #48]	; 0x30
  40080e:	f002 0203 	and.w	r2, r2, #3
  400812:	2a02      	cmp	r2, #2
  400814:	d1e7      	bne.n	4007e6 <SystemCoreClockUpdate+0x16>
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  400816:	6a82      	ldr	r2, [r0, #40]	; 0x28
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  400818:	6a80      	ldr	r0, [r0, #40]	; 0x28
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  40081a:	f3c2 420a 	ubfx	r2, r2, #16, #11
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  40081e:	b2c0      	uxtb	r0, r0
        SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  400820:	fb02 3303 	mla	r3, r2, r3, r3
        SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  400824:	fbb3 f3f0 	udiv	r3, r3, r0
  400828:	600b      	str	r3, [r1, #0]
  40082a:	e7dc      	b.n	4007e6 <SystemCoreClockUpdate+0x16>
      if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL )
  40082c:	4b1d      	ldr	r3, [pc, #116]	; (4008a4 <SystemCoreClockUpdate+0xd4>)
        SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40082e:	491b      	ldr	r1, [pc, #108]	; (40089c <SystemCoreClockUpdate+0xcc>)
      if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL )
  400830:	695b      	ldr	r3, [r3, #20]
  if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 )
  400832:	4819      	ldr	r0, [pc, #100]	; (400898 <SystemCoreClockUpdate+0xc8>)
      if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL )
  400834:	061b      	lsls	r3, r3, #24
        SystemCoreClock = CHIP_FREQ_XTAL_32K;
  400836:	bf4c      	ite	mi
  400838:	f44f 4300 	movmi.w	r3, #32768	; 0x8000
        SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40083c:	f44f 43fa 	movpl.w	r3, #32000	; 0x7d00
  400840:	600b      	str	r3, [r1, #0]
  if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 )
  400842:	6b02      	ldr	r2, [r0, #48]	; 0x30
  400844:	f002 0270 	and.w	r2, r2, #112	; 0x70
  400848:	2a70      	cmp	r2, #112	; 0x70
  40084a:	d1d2      	bne.n	4007f2 <SystemCoreClockUpdate+0x22>
    SystemCoreClock /= 3U;
  40084c:	4a16      	ldr	r2, [pc, #88]	; (4008a8 <SystemCoreClockUpdate+0xd8>)
  40084e:	fba2 2303 	umull	r2, r3, r2, r3
  400852:	085b      	lsrs	r3, r3, #1
  400854:	600b      	str	r3, [r1, #0]
  400856:	4770      	bx	lr
      if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL )
  400858:	6a13      	ldr	r3, [r2, #32]
        SystemCoreClock = CHIP_FREQ_XTAL_12M;
  40085a:	4910      	ldr	r1, [pc, #64]	; (40089c <SystemCoreClockUpdate+0xcc>)
      if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL )
  40085c:	01d8      	lsls	r0, r3, #7
  40085e:	d408      	bmi.n	400872 <SystemCoreClockUpdate+0xa2>
        SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  400860:	4b12      	ldr	r3, [pc, #72]	; (4008ac <SystemCoreClockUpdate+0xdc>)
  400862:	600b      	str	r3, [r1, #0]
        switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk )
  400864:	6a12      	ldr	r2, [r2, #32]
  400866:	f002 0270 	and.w	r2, r2, #112	; 0x70
  40086a:	2a10      	cmp	r2, #16
  40086c:	d011      	beq.n	400892 <SystemCoreClockUpdate+0xc2>
  40086e:	2a20      	cmp	r2, #32
  400870:	d1b9      	bne.n	4007e6 <SystemCoreClockUpdate+0x16>
            SystemCoreClock *= 3U;
  400872:	4b0b      	ldr	r3, [pc, #44]	; (4008a0 <SystemCoreClockUpdate+0xd0>)
  400874:	600b      	str	r3, [r1, #0]
          break;
  400876:	e7b6      	b.n	4007e6 <SystemCoreClockUpdate+0x16>
        SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  400878:	4b0c      	ldr	r3, [pc, #48]	; (4008ac <SystemCoreClockUpdate+0xdc>)
  40087a:	600b      	str	r3, [r1, #0]
        switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk )
  40087c:	6a12      	ldr	r2, [r2, #32]
  40087e:	f002 0270 	and.w	r2, r2, #112	; 0x70
  400882:	2a10      	cmp	r2, #16
  400884:	d002      	beq.n	40088c <SystemCoreClockUpdate+0xbc>
  400886:	2a20      	cmp	r2, #32
  400888:	d0bd      	beq.n	400806 <SystemCoreClockUpdate+0x36>
  40088a:	e7be      	b.n	40080a <SystemCoreClockUpdate+0x3a>
            SystemCoreClock *= 2U;
  40088c:	4b08      	ldr	r3, [pc, #32]	; (4008b0 <SystemCoreClockUpdate+0xe0>)
  40088e:	600b      	str	r3, [r1, #0]
          break;
  400890:	e7bb      	b.n	40080a <SystemCoreClockUpdate+0x3a>
            SystemCoreClock *= 2U;
  400892:	4b07      	ldr	r3, [pc, #28]	; (4008b0 <SystemCoreClockUpdate+0xe0>)
  400894:	600b      	str	r3, [r1, #0]
          break;
  400896:	e7a6      	b.n	4007e6 <SystemCoreClockUpdate+0x16>
  400898:	400e0600 	.word	0x400e0600
  40089c:	2040000c 	.word	0x2040000c
  4008a0:	00b71b00 	.word	0x00b71b00
  4008a4:	400e1810 	.word	0x400e1810
  4008a8:	aaaaaaab 	.word	0xaaaaaaab
  4008ac:	003d0900 	.word	0x003d0900
  4008b0:	007a1200 	.word	0x007a1200

004008b4 <system_init_flash>:
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
  if ( ul_clk < CHIP_FREQ_FWS_0 )
  4008b4:	4b16      	ldr	r3, [pc, #88]	; (400910 <system_init_flash+0x5c>)
  4008b6:	4298      	cmp	r0, r3
  4008b8:	d917      	bls.n	4008ea <system_init_flash+0x36>
  {
    EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  }
  else
  {
    if (ul_clk < CHIP_FREQ_FWS_1)
  4008ba:	4b16      	ldr	r3, [pc, #88]	; (400914 <system_init_flash+0x60>)
  4008bc:	4298      	cmp	r0, r3
  4008be:	d910      	bls.n	4008e2 <system_init_flash+0x2e>
    {
      EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
    }
    else
    {
      if (ul_clk < CHIP_FREQ_FWS_2)
  4008c0:	4b15      	ldr	r3, [pc, #84]	; (400918 <system_init_flash+0x64>)
  4008c2:	4298      	cmp	r0, r3
  4008c4:	d91a      	bls.n	4008fc <system_init_flash+0x48>
      {
        EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
      }
      else
      {
        if ( ul_clk < CHIP_FREQ_FWS_3 )
  4008c6:	4b15      	ldr	r3, [pc, #84]	; (40091c <system_init_flash+0x68>)
  4008c8:	4298      	cmp	r0, r3
  4008ca:	d913      	bls.n	4008f4 <system_init_flash+0x40>
        {
          EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
        }
        else
        {
          if ( ul_clk < CHIP_FREQ_FWS_4 )
  4008cc:	4b14      	ldr	r3, [pc, #80]	; (400920 <system_init_flash+0x6c>)
  4008ce:	4298      	cmp	r0, r3
  4008d0:	d918      	bls.n	400904 <system_init_flash+0x50>
          {
            EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
          }
          else
          {
            if ( ul_clk < CHIP_FREQ_FWS_5 )
  4008d2:	4b14      	ldr	r3, [pc, #80]	; (400924 <system_init_flash+0x70>)
  4008d4:	4298      	cmp	r0, r3
            {
              EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4008d6:	4b14      	ldr	r3, [pc, #80]	; (400928 <system_init_flash+0x74>)
  4008d8:	bf94      	ite	ls
  4008da:	4a14      	ldrls	r2, [pc, #80]	; (40092c <system_init_flash+0x78>)
            }
            else
            {
              EFC->EEFC_FMR = EEFC_FMR_FWS(6)|EEFC_FMR_CLOE;
  4008dc:	4a14      	ldrhi	r2, [pc, #80]	; (400930 <system_init_flash+0x7c>)
  4008de:	601a      	str	r2, [r3, #0]
  4008e0:	4770      	bx	lr
      EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4008e2:	4b11      	ldr	r3, [pc, #68]	; (400928 <system_init_flash+0x74>)
  4008e4:	4a13      	ldr	r2, [pc, #76]	; (400934 <system_init_flash+0x80>)
  4008e6:	601a      	str	r2, [r3, #0]
  4008e8:	4770      	bx	lr
    EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  4008ea:	4b0f      	ldr	r3, [pc, #60]	; (400928 <system_init_flash+0x74>)
  4008ec:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  4008f0:	601a      	str	r2, [r3, #0]
  4008f2:	4770      	bx	lr
          EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  4008f4:	4b0c      	ldr	r3, [pc, #48]	; (400928 <system_init_flash+0x74>)
  4008f6:	4a10      	ldr	r2, [pc, #64]	; (400938 <system_init_flash+0x84>)
  4008f8:	601a      	str	r2, [r3, #0]
  4008fa:	4770      	bx	lr
        EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4008fc:	4b0a      	ldr	r3, [pc, #40]	; (400928 <system_init_flash+0x74>)
  4008fe:	4a0f      	ldr	r2, [pc, #60]	; (40093c <system_init_flash+0x88>)
  400900:	601a      	str	r2, [r3, #0]
  400902:	4770      	bx	lr
            EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  400904:	4b08      	ldr	r3, [pc, #32]	; (400928 <system_init_flash+0x74>)
  400906:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  40090a:	601a      	str	r2, [r3, #0]
  40090c:	4770      	bx	lr
  40090e:	bf00      	nop
  400910:	015ef3bf 	.word	0x015ef3bf
  400914:	02bde77f 	.word	0x02bde77f
  400918:	041cdb3f 	.word	0x041cdb3f
  40091c:	057bceff 	.word	0x057bceff
  400920:	06dac2bf 	.word	0x06dac2bf
  400924:	0839b67f 	.word	0x0839b67f
  400928:	400e0c00 	.word	0x400e0c00
  40092c:	04000500 	.word	0x04000500
  400930:	04000600 	.word	0x04000600
  400934:	04000100 	.word	0x04000100
  400938:	04000300 	.word	0x04000300
  40093c:	04000200 	.word	0x04000200

00400940 <sedacio_setOutputSignal>:

uint32_t outputs = 0, out_assigned = 0;

void sedacio_setOutputSignal(input_sigType O_signal, uint32_t val)
{
	if (val)
  400940:	b941      	cbnz	r1, 400954 <sedacio_setOutputSignal+0x14>
	{
		outputs |= (1ul << O_signal);
	} 
	else
	{
		outputs &= ~(1ul << O_signal);
  400942:	4908      	ldr	r1, [pc, #32]	; (400964 <sedacio_setOutputSignal+0x24>)
  400944:	2201      	movs	r2, #1
  400946:	680b      	ldr	r3, [r1, #0]
  400948:	fa02 f000 	lsl.w	r0, r2, r0
  40094c:	ea23 0300 	bic.w	r3, r3, r0
  400950:	600b      	str	r3, [r1, #0]
  400952:	4770      	bx	lr
		outputs |= (1ul << O_signal);
  400954:	4b03      	ldr	r3, [pc, #12]	; (400964 <sedacio_setOutputSignal+0x24>)
  400956:	2201      	movs	r2, #1
  400958:	6819      	ldr	r1, [r3, #0]
  40095a:	fa02 f000 	lsl.w	r0, r2, r0
  40095e:	4308      	orrs	r0, r1
  400960:	6018      	str	r0, [r3, #0]
  400962:	4770      	bx	lr
  400964:	20400828 	.word	0x20400828

00400968 <sedacio_output_handler>:
	}
}

void sedacio_output_handler(void)
{
  400968:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t i = 0, l, out_assigned_image = 0;
  40096c:	2500      	movs	r5, #0
  40096e:	4e17      	ldr	r6, [pc, #92]	; (4009cc <sedacio_output_handler+0x64>)
	for (i=0; i<15; i++)
	{
		l = menue_lift_data_applied.m_outputs[i];
		out_assigned_image |= (1ul << l);
  400970:	2701      	movs	r7, #1
		} 
		else
		{
			if (l < 16)
			{
				io_interface_update((i + 2 - 9) | (7 << IO_I_A_GR_POS), outputs & (1ul << l), 2);
  400972:	f8df 9060 	ldr.w	r9, [pc, #96]	; 4009d4 <sedacio_output_handler+0x6c>
	for (i=0; i<15; i++)
  400976:	462c      	mov	r4, r5
				io_interface_update((i + 2 - 9) | (7 << IO_I_A_GR_POS), outputs & (1ul << l), 2);
  400978:	f8df 805c 	ldr.w	r8, [pc, #92]	; 4009d8 <sedacio_output_handler+0x70>
  40097c:	e004      	b.n	400988 <sedacio_output_handler+0x20>
			if (l < 16)
  40097e:	2b0f      	cmp	r3, #15
  400980:	d91b      	bls.n	4009ba <sedacio_output_handler+0x52>
	for (i=0; i<15; i++)
  400982:	3401      	adds	r4, #1
  400984:	2c0f      	cmp	r4, #15
  400986:	d014      	beq.n	4009b2 <sedacio_output_handler+0x4a>
		l = menue_lift_data_applied.m_outputs[i];
  400988:	f816 3b01 	ldrb.w	r3, [r6], #1
		if (i < 9)
  40098c:	2c08      	cmp	r4, #8
		out_assigned_image |= (1ul << l);
  40098e:	fa07 f103 	lsl.w	r1, r7, r3
  400992:	ea45 0501 	orr.w	r5, r5, r1
		if (i < 9)
  400996:	d9f2      	bls.n	40097e <sedacio_output_handler+0x16>
			if (l < 16)
  400998:	2b0f      	cmp	r3, #15
  40099a:	d8f2      	bhi.n	400982 <sedacio_output_handler+0x1a>
				io_interface_update((i + 2 - 9) | (7 << IO_I_A_GR_POS), outputs & (1ul << l), 2);
  40099c:	f8d9 3000 	ldr.w	r3, [r9]
  4009a0:	1fe0      	subs	r0, r4, #7
	for (i=0; i<15; i++)
  4009a2:	3401      	adds	r4, #1
				io_interface_update((i + 2 - 9) | (7 << IO_I_A_GR_POS), outputs & (1ul << l), 2);
  4009a4:	2202      	movs	r2, #2
  4009a6:	4019      	ands	r1, r3
  4009a8:	f040 60e0 	orr.w	r0, r0, #117440512	; 0x7000000
  4009ac:	47c0      	blx	r8
	for (i=0; i<15; i++)
  4009ae:	2c0f      	cmp	r4, #15
  4009b0:	d1ea      	bne.n	400988 <sedacio_output_handler+0x20>
			}
		}
	}
	out_assigned = out_assigned_image;
  4009b2:	4b07      	ldr	r3, [pc, #28]	; (4009d0 <sedacio_output_handler+0x68>)
  4009b4:	601d      	str	r5, [r3, #0]
  4009b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				io_interface_update(i | (5 << IO_I_A_GR_POS), outputs & (1ul << l), 2);
  4009ba:	f8d9 3000 	ldr.w	r3, [r9]
  4009be:	2202      	movs	r2, #2
  4009c0:	f044 60a0 	orr.w	r0, r4, #83886080	; 0x5000000
  4009c4:	4019      	ands	r1, r3
  4009c6:	47c0      	blx	r8
  4009c8:	e7db      	b.n	400982 <sedacio_output_handler+0x1a>
  4009ca:	bf00      	nop
  4009cc:	20405366 	.word	0x20405366
  4009d0:	20400824 	.word	0x20400824
  4009d4:	20400828 	.word	0x20400828
  4009d8:	0040d879 	.word	0x0040d879

004009dc <sedacio_is_output_assigned>:
}

int32_t sedacio_is_output_assigned(input_sigType o_signal)
{
	if (out_assigned & (1ul << o_signal)) return 1;
  4009dc:	4b03      	ldr	r3, [pc, #12]	; (4009ec <sedacio_is_output_assigned+0x10>)
  4009de:	681b      	ldr	r3, [r3, #0]
  4009e0:	fa23 f000 	lsr.w	r0, r3, r0
	return 0;
  4009e4:	f000 0001 	and.w	r0, r0, #1
  4009e8:	4770      	bx	lr
  4009ea:	bf00      	nop
  4009ec:	20400824 	.word	0x20400824

004009f0 <e_faults_inti>:
uint8_t fault_dnfdl0_err_idx, fault_upfdl0_err_idx, fault_dnfl_err_idx, fault_upfl_err_idx, fault_fl_err_idx;
uint8_t fault_LRN_err_idx, fault_LRN_req_err_idx;
uint8_t fault_ctb_idx, fault_ccb0_idx, fault_ccb1_idx;
uint8_t fault_fdoorab_idx, fault_bdoorab_idx;
void e_faults_inti(void)
{
  4009f0:	b510      	push	{r4, lr}
	fault_ph_fail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 1, "Phase failure");
  4009f2:	2301      	movs	r3, #1
{
  4009f4:	b082      	sub	sp, #8
	fault_ph_fail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 1, "Phase failure");
  4009f6:	485b      	ldr	r0, [pc, #364]	; (400b64 <e_faults_inti+0x174>)
  4009f8:	2202      	movs	r2, #2
  4009fa:	4c5b      	ldr	r4, [pc, #364]	; (400b68 <e_faults_inti+0x178>)
  4009fc:	f241 3188 	movw	r1, #5000	; 0x1388
  400a00:	9000      	str	r0, [sp, #0]
  400a02:	4618      	mov	r0, r3
  400a04:	47a0      	blx	r4
	fault_e_stop_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 2, "Emergency stop");
  400a06:	2302      	movs	r3, #2
	fault_ph_fail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 1, "Phase failure");
  400a08:	4958      	ldr	r1, [pc, #352]	; (400b6c <e_faults_inti+0x17c>)
	fault_e_stop_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 2, "Emergency stop");
  400a0a:	4a59      	ldr	r2, [pc, #356]	; (400b70 <e_faults_inti+0x180>)
	fault_ph_fail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 1, "Phase failure");
  400a0c:	7008      	strb	r0, [r1, #0]
	fault_e_stop_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 2, "Emergency stop");
  400a0e:	f241 3188 	movw	r1, #5000	; 0x1388
  400a12:	9200      	str	r2, [sp, #0]
  400a14:	2001      	movs	r0, #1
  400a16:	461a      	mov	r2, r3
  400a18:	47a0      	blx	r4
  400a1a:	4a56      	ldr	r2, [pc, #344]	; (400b74 <e_faults_inti+0x184>)
	fault_lock_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 3, "Lock fail");
  400a1c:	4956      	ldr	r1, [pc, #344]	; (400b78 <e_faults_inti+0x188>)
  400a1e:	2303      	movs	r3, #3
	fault_e_stop_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 2, "Emergency stop");
  400a20:	7010      	strb	r0, [r2, #0]
	fault_lock_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 3, "Lock fail");
  400a22:	2202      	movs	r2, #2
  400a24:	9100      	str	r1, [sp, #0]
  400a26:	2001      	movs	r0, #1
  400a28:	f241 3188 	movw	r1, #5000	; 0x1388
  400a2c:	47a0      	blx	r4
  400a2e:	4a53      	ldr	r2, [pc, #332]	; (400b7c <e_faults_inti+0x18c>)
	fault_fork_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 4, "Fork cont fail");
  400a30:	4953      	ldr	r1, [pc, #332]	; (400b80 <e_faults_inti+0x190>)
  400a32:	2304      	movs	r3, #4
	fault_lock_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 3, "Lock fail");
  400a34:	7010      	strb	r0, [r2, #0]
	fault_fork_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 4, "Fork cont fail");
  400a36:	2202      	movs	r2, #2
  400a38:	9100      	str	r1, [sp, #0]
  400a3a:	2001      	movs	r0, #1
  400a3c:	f241 3188 	movw	r1, #5000	; 0x1388
  400a40:	47a0      	blx	r4
  400a42:	4a50      	ldr	r2, [pc, #320]	; (400b84 <e_faults_inti+0x194>)
//______________________________________
	fault_fast_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 5, "Fast timeout");
  400a44:	4950      	ldr	r1, [pc, #320]	; (400b88 <e_faults_inti+0x198>)
  400a46:	2305      	movs	r3, #5
	fault_fork_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 4, "Fork cont fail");
  400a48:	7010      	strb	r0, [r2, #0]
	fault_fast_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 5, "Fast timeout");
  400a4a:	2202      	movs	r2, #2
  400a4c:	9100      	str	r1, [sp, #0]
  400a4e:	2003      	movs	r0, #3
  400a50:	f241 3188 	movw	r1, #5000	; 0x1388
  400a54:	47a0      	blx	r4
  400a56:	4a4d      	ldr	r2, [pc, #308]	; (400b8c <e_faults_inti+0x19c>)
	fault_slow_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 6, "Slow timeout");
  400a58:	494d      	ldr	r1, [pc, #308]	; (400b90 <e_faults_inti+0x1a0>)
  400a5a:	2306      	movs	r3, #6
	fault_fast_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 5, "Fast timeout");
  400a5c:	7010      	strb	r0, [r2, #0]
	fault_slow_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 6, "Slow timeout");
  400a5e:	2202      	movs	r2, #2
  400a60:	9100      	str	r1, [sp, #0]
  400a62:	2001      	movs	r0, #1
  400a64:	f241 3188 	movw	r1, #5000	; 0x1388
  400a68:	47a0      	blx	r4
  400a6a:	4a4a      	ldr	r2, [pc, #296]	; (400b94 <e_faults_inti+0x1a4>)
//////////////////////////////////////////////////////////////////////////
	fault_dnfdl0_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 7, "Down fd limit0");
  400a6c:	494a      	ldr	r1, [pc, #296]	; (400b98 <e_faults_inti+0x1a8>)
  400a6e:	2307      	movs	r3, #7
	fault_slow_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 6, "Slow timeout");
  400a70:	7010      	strb	r0, [r2, #0]
	fault_dnfdl0_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 7, "Down fd limit0");
  400a72:	2202      	movs	r2, #2
  400a74:	9100      	str	r1, [sp, #0]
  400a76:	2001      	movs	r0, #1
  400a78:	f241 3188 	movw	r1, #5000	; 0x1388
  400a7c:	47a0      	blx	r4
  400a7e:	4a47      	ldr	r2, [pc, #284]	; (400b9c <e_faults_inti+0x1ac>)
	fault_upfdl0_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 8, "Up fd limit0");
  400a80:	4947      	ldr	r1, [pc, #284]	; (400ba0 <e_faults_inti+0x1b0>)
  400a82:	2308      	movs	r3, #8
	fault_dnfdl0_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 7, "Down fd limit0");
  400a84:	7010      	strb	r0, [r2, #0]
	fault_upfdl0_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 8, "Up fd limit0");
  400a86:	2202      	movs	r2, #2
  400a88:	9100      	str	r1, [sp, #0]
  400a8a:	2001      	movs	r0, #1
  400a8c:	f241 3188 	movw	r1, #5000	; 0x1388
  400a90:	47a0      	blx	r4
  400a92:	4a44      	ldr	r2, [pc, #272]	; (400ba4 <e_faults_inti+0x1b4>)
	fault_dnfl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 14, "Down final lim");
  400a94:	4944      	ldr	r1, [pc, #272]	; (400ba8 <e_faults_inti+0x1b8>)
  400a96:	230e      	movs	r3, #14
	fault_upfdl0_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 8, "Up fd limit0");
  400a98:	7010      	strb	r0, [r2, #0]
	fault_dnfl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 14, "Down final lim");
  400a9a:	2202      	movs	r2, #2
  400a9c:	9100      	str	r1, [sp, #0]
  400a9e:	2001      	movs	r0, #1
  400aa0:	f241 3188 	movw	r1, #5000	; 0x1388
  400aa4:	47a0      	blx	r4
  400aa6:	4a41      	ldr	r2, [pc, #260]	; (400bac <e_faults_inti+0x1bc>)
	fault_upfl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 15, "Up final lim");
  400aa8:	4941      	ldr	r1, [pc, #260]	; (400bb0 <e_faults_inti+0x1c0>)
  400aaa:	230f      	movs	r3, #15
	fault_dnfl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 14, "Down final lim");
  400aac:	7010      	strb	r0, [r2, #0]
	fault_upfl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 15, "Up final lim");
  400aae:	2202      	movs	r2, #2
  400ab0:	9100      	str	r1, [sp, #0]
  400ab2:	2001      	movs	r0, #1
  400ab4:	f241 3188 	movw	r1, #5000	; 0x1388
  400ab8:	47a0      	blx	r4
  400aba:	4a3e      	ldr	r2, [pc, #248]	; (400bb4 <e_faults_inti+0x1c4>)
	fault_fl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 16, "Final limits check");
  400abc:	493e      	ldr	r1, [pc, #248]	; (400bb8 <e_faults_inti+0x1c8>)
  400abe:	2310      	movs	r3, #16
	fault_upfl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 15, "Up final lim");
  400ac0:	7010      	strb	r0, [r2, #0]
	fault_fl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 16, "Final limits check");
  400ac2:	2202      	movs	r2, #2
  400ac4:	9100      	str	r1, [sp, #0]
  400ac6:	2001      	movs	r0, #1
  400ac8:	f241 3188 	movw	r1, #5000	; 0x1388
  400acc:	47a0      	blx	r4
  400ace:	4a3b      	ldr	r2, [pc, #236]	; (400bbc <e_faults_inti+0x1cc>)
//////////////////////////////////////////////////////////////////////////
	fault_LRN_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 2, 9, "Hoist LRN error");
  400ad0:	493b      	ldr	r1, [pc, #236]	; (400bc0 <e_faults_inti+0x1d0>)
  400ad2:	2309      	movs	r3, #9
	fault_fl_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 2, 16, "Final limits check");
  400ad4:	7010      	strb	r0, [r2, #0]
	fault_LRN_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 2, 9, "Hoist LRN error");
  400ad6:	2202      	movs	r2, #2
  400ad8:	9100      	str	r1, [sp, #0]
  400ada:	2001      	movs	r0, #1
  400adc:	f242 7110 	movw	r1, #10000	; 0x2710
  400ae0:	47a0      	blx	r4
  400ae2:	4a38      	ldr	r2, [pc, #224]	; (400bc4 <e_faults_inti+0x1d4>)
	fault_LRN_req_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 6000, 2, 10, "HoistWay LRN required");
  400ae4:	4938      	ldr	r1, [pc, #224]	; (400bc8 <e_faults_inti+0x1d8>)
  400ae6:	230a      	movs	r3, #10
	fault_LRN_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 2, 9, "Hoist LRN error");
  400ae8:	7010      	strb	r0, [r2, #0]
	fault_LRN_req_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 6000, 2, 10, "HoistWay LRN required");
  400aea:	2202      	movs	r2, #2
  400aec:	9100      	str	r1, [sp, #0]
  400aee:	2001      	movs	r0, #1
  400af0:	f241 7170 	movw	r1, #6000	; 0x1770
  400af4:	47a0      	blx	r4
  400af6:	4a35      	ldr	r2, [pc, #212]	; (400bcc <e_faults_inti+0x1dc>)
//////////////////////////////////////////////////////////////////////////	
	fault_ctb_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 9, "CTB Comm loss");
  400af8:	4935      	ldr	r1, [pc, #212]	; (400bd0 <e_faults_inti+0x1e0>)
  400afa:	2309      	movs	r3, #9
	fault_LRN_req_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 6000, 2, 10, "HoistWay LRN required");
  400afc:	7010      	strb	r0, [r2, #0]
	fault_ctb_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 9, "CTB Comm loss");
  400afe:	2202      	movs	r2, #2
  400b00:	9100      	str	r1, [sp, #0]
  400b02:	2003      	movs	r0, #3
  400b04:	f640 11c4 	movw	r1, #2500	; 0x9c4
  400b08:	47a0      	blx	r4
  400b0a:	4a32      	ldr	r2, [pc, #200]	; (400bd4 <e_faults_inti+0x1e4>)
	fault_ccb0_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 10, "CCB0 Comm loss");
  400b0c:	4932      	ldr	r1, [pc, #200]	; (400bd8 <e_faults_inti+0x1e8>)
  400b0e:	230a      	movs	r3, #10
	fault_ctb_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 9, "CTB Comm loss");
  400b10:	7010      	strb	r0, [r2, #0]
	fault_ccb0_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 10, "CCB0 Comm loss");
  400b12:	2202      	movs	r2, #2
  400b14:	9100      	str	r1, [sp, #0]
  400b16:	2003      	movs	r0, #3
  400b18:	f640 11c4 	movw	r1, #2500	; 0x9c4
  400b1c:	47a0      	blx	r4
  400b1e:	4a2f      	ldr	r2, [pc, #188]	; (400bdc <e_faults_inti+0x1ec>)
	fault_ccb1_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 11, "CCB1 Comm loss");
  400b20:	492f      	ldr	r1, [pc, #188]	; (400be0 <e_faults_inti+0x1f0>)
  400b22:	230b      	movs	r3, #11
	fault_ccb0_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 10, "CCB0 Comm loss");
  400b24:	7010      	strb	r0, [r2, #0]
	fault_ccb1_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 11, "CCB1 Comm loss");
  400b26:	2202      	movs	r2, #2
  400b28:	9100      	str	r1, [sp, #0]
  400b2a:	2003      	movs	r0, #3
  400b2c:	f640 11c4 	movw	r1, #2500	; 0x9c4
  400b30:	47a0      	blx	r4
  400b32:	4a2c      	ldr	r2, [pc, #176]	; (400be4 <e_faults_inti+0x1f4>)
//////////////////////////////////////////////////////////////////////////	
	fault_fdoorab_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 12, "ab Front door");
  400b34:	492c      	ldr	r1, [pc, #176]	; (400be8 <e_faults_inti+0x1f8>)
  400b36:	230c      	movs	r3, #12
	fault_ccb1_idx = sph_faults_add_fault(T_POS_FAULT, 2500, 2, 11, "CCB1 Comm loss");
  400b38:	7010      	strb	r0, [r2, #0]
	fault_fdoorab_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 12, "ab Front door");
  400b3a:	2202      	movs	r2, #2
  400b3c:	9100      	str	r1, [sp, #0]
  400b3e:	2003      	movs	r0, #3
  400b40:	f241 3188 	movw	r1, #5000	; 0x1388
  400b44:	47a0      	blx	r4
  400b46:	4a29      	ldr	r2, [pc, #164]	; (400bec <e_faults_inti+0x1fc>)
	fault_bdoorab_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 13, "ab back door");
  400b48:	4929      	ldr	r1, [pc, #164]	; (400bf0 <e_faults_inti+0x200>)
  400b4a:	230d      	movs	r3, #13
	fault_fdoorab_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 12, "ab Front door");
  400b4c:	7010      	strb	r0, [r2, #0]
	fault_bdoorab_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 2, 13, "ab back door");
  400b4e:	2202      	movs	r2, #2
  400b50:	9100      	str	r1, [sp, #0]
  400b52:	2003      	movs	r0, #3
  400b54:	f241 3188 	movw	r1, #5000	; 0x1388
  400b58:	47a0      	blx	r4
  400b5a:	4b26      	ldr	r3, [pc, #152]	; (400bf4 <e_faults_inti+0x204>)
  400b5c:	7018      	strb	r0, [r3, #0]

}
  400b5e:	b002      	add	sp, #8
  400b60:	bd10      	pop	{r4, pc}
  400b62:	bf00      	nop
  400b64:	00419868 	.word	0x00419868
  400b68:	004127c1 	.word	0x004127c1
  400b6c:	20400c4c 	.word	0x20400c4c
  400b70:	00419878 	.word	0x00419878
  400b74:	20400c1a 	.word	0x20400c1a
  400b78:	00419888 	.word	0x00419888
  400b7c:	20400c4d 	.word	0x20400c4d
  400b80:	00419894 	.word	0x00419894
  400b84:	20400c1c 	.word	0x20400c1c
  400b88:	004198a4 	.word	0x004198a4
  400b8c:	20400c1b 	.word	0x20400c1b
  400b90:	004198b4 	.word	0x004198b4
  400b94:	20400c50 	.word	0x20400c50
  400b98:	004198c4 	.word	0x004198c4
  400b9c:	20400c1d 	.word	0x20400c1d
  400ba0:	004198d4 	.word	0x004198d4
  400ba4:	20400c19 	.word	0x20400c19
  400ba8:	004198e4 	.word	0x004198e4
  400bac:	20400c34 	.word	0x20400c34
  400bb0:	004198f4 	.word	0x004198f4
  400bb4:	20400c31 	.word	0x20400c31
  400bb8:	00419904 	.word	0x00419904
  400bbc:	20400c33 	.word	0x20400c33
  400bc0:	00419918 	.word	0x00419918
  400bc4:	20400c4e 	.word	0x20400c4e
  400bc8:	00419928 	.word	0x00419928
  400bcc:	20400c4f 	.word	0x20400c4f
  400bd0:	00419940 	.word	0x00419940
  400bd4:	20400c51 	.word	0x20400c51
  400bd8:	00419950 	.word	0x00419950
  400bdc:	20400c32 	.word	0x20400c32
  400be0:	00419960 	.word	0x00419960
  400be4:	20400c18 	.word	0x20400c18
  400be8:	00419970 	.word	0x00419970
  400bec:	20400c30 	.word	0x20400c30
  400bf0:	00419980 	.word	0x00419980
  400bf4:	20400c1e 	.word	0x20400c1e

00400bf8 <s_i_err>:

uint8_t s_i_err(void)
{
  400bf8:	b508      	push	{r3, lr}
	return sph_faults_sie_check();
  400bfa:	4b02      	ldr	r3, [pc, #8]	; (400c04 <s_i_err+0xc>)
  400bfc:	4798      	blx	r3
}
  400bfe:	b2c0      	uxtb	r0, r0
  400c00:	bd08      	pop	{r3, pc}
  400c02:	bf00      	nop
  400c04:	004128d5 	.word	0x004128d5

00400c08 <floor_dislplay_menue_enter>:
	menue_lift_data_newdata_flag = 1;	
}
void floor_display_analyze(void)
{
	#define floor_display_floor menue_lift_data_setup.floor_display[start_floor_floor_display]
	if (floor_display_floor > 100) floor_display_floor = 100;
  400c08:	4b13      	ldr	r3, [pc, #76]	; (400c58 <floor_dislplay_menue_enter+0x50>)
	disSegmentData[0] += 0x30;
	disSegmentData[1] += 0x30;
}
void floor_dislplay_menue_enter(void)
{
	displayIndex = 0;
  400c0a:	2100      	movs	r1, #0
	if (floor_display_floor > 100) floor_display_floor = 100;
  400c0c:	4a13      	ldr	r2, [pc, #76]	; (400c5c <floor_dislplay_menue_enter+0x54>)
  400c0e:	7818      	ldrb	r0, [r3, #0]
	displayIndex = 0;
  400c10:	4b13      	ldr	r3, [pc, #76]	; (400c60 <floor_dislplay_menue_enter+0x58>)
	if (floor_display_floor > 100) floor_display_floor = 100;
  400c12:	4402      	add	r2, r0
	displayIndex = 0;
  400c14:	7019      	strb	r1, [r3, #0]
	if (floor_display_floor > 100) floor_display_floor = 100;
  400c16:	f892 309a 	ldrb.w	r3, [r2, #154]	; 0x9a
  400c1a:	2b64      	cmp	r3, #100	; 0x64
  400c1c:	d908      	bls.n	400c30 <floor_dislplay_menue_enter+0x28>
  400c1e:	2064      	movs	r0, #100	; 0x64
  400c20:	2330      	movs	r3, #48	; 0x30
  400c22:	213a      	movs	r1, #58	; 0x3a
  400c24:	f882 009a 	strb.w	r0, [r2, #154]	; 0x9a
	disSegmentData[0] += 0x30;
  400c28:	4a0e      	ldr	r2, [pc, #56]	; (400c64 <floor_dislplay_menue_enter+0x5c>)
  400c2a:	7011      	strb	r1, [r2, #0]
	disSegmentData[1] += 0x30;
  400c2c:	7053      	strb	r3, [r2, #1]
  400c2e:	4770      	bx	lr
  400c30:	f1a1 3133 	sub.w	r1, r1, #858993459	; 0x33333333
  400c34:	f103 0230 	add.w	r2, r3, #48	; 0x30
  400c38:	fba1 1303 	umull	r1, r3, r1, r3
  400c3c:	08db      	lsrs	r3, r3, #3
  400c3e:	ebc3 1043 	rsb	r0, r3, r3, lsl #5
  400c42:	f103 0130 	add.w	r1, r3, #48	; 0x30
  400c46:	ebc3 0380 	rsb	r3, r3, r0, lsl #2
  400c4a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	disSegmentData[0] += 0x30;
  400c4e:	4a05      	ldr	r2, [pc, #20]	; (400c64 <floor_dislplay_menue_enter+0x5c>)
  400c50:	b2db      	uxtb	r3, r3
  400c52:	7011      	strb	r1, [r2, #0]
	disSegmentData[1] += 0x30;
  400c54:	7053      	strb	r3, [r2, #1]
  400c56:	4770      	bx	lr
  400c58:	2040082d 	.word	0x2040082d
  400c5c:	204051e0 	.word	0x204051e0
  400c60:	2040082c 	.word	0x2040082c
  400c64:	20400010 	.word	0x20400010

00400c68 <floor_dislplay_menue_exe>:
	floor_display_analyze();
}

char floor_dislplay_menue_exe(char enter, char esc, char up, char down, char left, char right)
{
  400c68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400c6c:	b082      	sub	sp, #8
  400c6e:	f89d 5020 	ldrb.w	r5, [sp, #32]
  400c72:	f89d 4024 	ldrb.w	r4, [sp, #36]	; 0x24
	if (esc)
  400c76:	2900      	cmp	r1, #0
  400c78:	d179      	bne.n	400d6e <floor_dislplay_menue_exe+0x106>
	{
		return 0;
	}
	else if(right)
  400c7a:	2c00      	cmp	r4, #0
  400c7c:	d06c      	beq.n	400d58 <floor_dislplay_menue_exe+0xf0>
	{
		if(++displayIndex > 1) displayIndex = 1;
  400c7e:	4a56      	ldr	r2, [pc, #344]	; (400dd8 <floor_dislplay_menue_exe+0x170>)
  400c80:	7813      	ldrb	r3, [r2, #0]
  400c82:	3301      	adds	r3, #1
  400c84:	b2db      	uxtb	r3, r3
  400c86:	2b01      	cmp	r3, #1
  400c88:	f240 8092 	bls.w	400db0 <floor_dislplay_menue_exe+0x148>
  400c8c:	2301      	movs	r3, #1
  400c8e:	4c53      	ldr	r4, [pc, #332]	; (400ddc <floor_dislplay_menue_exe+0x174>)
  400c90:	7013      	strb	r3, [r2, #0]
	else if (down)
	{
		if(dispOptionsCounter[displayIndex] > 0) dispOptionsCounter[displayIndex]--;
		disSegmentData[displayIndex] = dispOptions[dispOptionsCounter[displayIndex]];
	}
	if (enter)
  400c92:	2800      	cmp	r0, #0
  400c94:	d069      	beq.n	400d6a <floor_dislplay_menue_exe+0x102>
	volatile char floor_disp_val = (disSegmentData[0] - 0x30) * 10;
  400c96:	7823      	ldrb	r3, [r4, #0]
	menue_lift_data_newdata_flag = 1;	
  400c98:	2701      	movs	r7, #1
	menue_lift_data_setup.floor_display[start_floor_floor_display] = floor_disp_val;
  400c9a:	4d51      	ldr	r5, [pc, #324]	; (400de0 <floor_dislplay_menue_exe+0x178>)
	volatile char floor_disp_val = (disSegmentData[0] - 0x30) * 10;
  400c9c:	3b30      	subs	r3, #48	; 0x30
	floor_disp_val += (disSegmentData[1] - 0x30);
  400c9e:	7866      	ldrb	r6, [r4, #1]
	menue_lift_data_setup.floor_display[start_floor_floor_display] = floor_disp_val;
  400ca0:	7829      	ldrb	r1, [r5, #0]
	volatile char floor_disp_val = (disSegmentData[0] - 0x30) * 10;
  400ca2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	menue_lift_data_newdata_flag = 1;	
  400ca6:	4a4f      	ldr	r2, [pc, #316]	; (400de4 <floor_dislplay_menue_exe+0x17c>)
	menue_lift_data_setup.floor_display[start_floor_floor_display] = floor_disp_val;
  400ca8:	484f      	ldr	r0, [pc, #316]	; (400de8 <floor_dislplay_menue_exe+0x180>)
	volatile char floor_disp_val = (disSegmentData[0] - 0x30) * 10;
  400caa:	40bb      	lsls	r3, r7
	menue_lift_data_newdata_flag = 1;	
  400cac:	7017      	strb	r7, [r2, #0]
	{
		floor_display_save_data();
		if(++start_floor_floor_display >= 24) 
  400cae:	19ca      	adds	r2, r1, r7
	menue_lift_data_setup.floor_display[start_floor_floor_display] = floor_disp_val;
  400cb0:	4401      	add	r1, r0
	volatile char floor_disp_val = (disSegmentData[0] - 0x30) * 10;
  400cb2:	b2db      	uxtb	r3, r3
		if(++start_floor_floor_display >= 24) 
  400cb4:	b2d2      	uxtb	r2, r2
	volatile char floor_disp_val = (disSegmentData[0] - 0x30) * 10;
  400cb6:	f88d 3007 	strb.w	r3, [sp, #7]
	floor_disp_val += (disSegmentData[1] - 0x30);
  400cba:	f89d 3007 	ldrb.w	r3, [sp, #7]
		if(++start_floor_floor_display >= 24) 
  400cbe:	2a17      	cmp	r2, #23
  400cc0:	702a      	strb	r2, [r5, #0]
	floor_disp_val += (disSegmentData[1] - 0x30);
  400cc2:	4433      	add	r3, r6
  400cc4:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
  400cc8:	b2db      	uxtb	r3, r3
  400cca:	f88d 3007 	strb.w	r3, [sp, #7]
	menue_lift_data_setup.floor_display[start_floor_floor_display] = floor_disp_val;
  400cce:	f89d 3007 	ldrb.w	r3, [sp, #7]
  400cd2:	f881 309a 	strb.w	r3, [r1, #154]	; 0x9a
		if(++start_floor_floor_display >= 24) 
  400cd6:	d863      	bhi.n	400da0 <floor_dislplay_menue_exe+0x138>
	if (floor_display_floor > 100) floor_display_floor = 100;
  400cd8:	4402      	add	r2, r0
  400cda:	f892 309a 	ldrb.w	r3, [r2, #154]	; 0x9a
  400cde:	2b64      	cmp	r3, #100	; 0x64
  400ce0:	d858      	bhi.n	400d94 <floor_dislplay_menue_exe+0x12c>
  400ce2:	4942      	ldr	r1, [pc, #264]	; (400dec <floor_dislplay_menue_exe+0x184>)
  400ce4:	f103 0230 	add.w	r2, r3, #48	; 0x30
  400ce8:	fba1 1303 	umull	r1, r3, r1, r3
  400cec:	08db      	lsrs	r3, r3, #3
  400cee:	ebc3 1043 	rsb	r0, r3, r3, lsl #5
  400cf2:	f103 0130 	add.w	r1, r3, #48	; 0x30
  400cf6:	ebc3 0380 	rsb	r3, r3, r0, lsl #2
  400cfa:	eb02 0343 	add.w	r3, r2, r3, lsl #1
  400cfe:	b2db      	uxtb	r3, r3
	disSegmentData[0] += 0x30;
  400d00:	7021      	strb	r1, [r4, #0]
	disSegmentData[1] += 0x30;
  400d02:	7063      	strb	r3, [r4, #1]
			return 0;
		}
		floor_display_analyze();
	}
	
	glcd_gotoxy(1, 18);
  400d04:	4f3a      	ldr	r7, [pc, #232]	; (400df0 <floor_dislplay_menue_exe+0x188>)
  400d06:	2112      	movs	r1, #18
  400d08:	2001      	movs	r0, #1
	write_r_text("Floor(", 0);
  400d0a:	f8df 8104 	ldr.w	r8, [pc, #260]	; 400e10 <floor_dislplay_menue_exe+0x1a8>
	glcd_gotoxy(1, 18);
  400d0e:	47b8      	blx	r7
	write_r_text("Floor(", 0);
  400d10:	2100      	movs	r1, #0
  400d12:	4838      	ldr	r0, [pc, #224]	; (400df4 <floor_dislplay_menue_exe+0x18c>)
  400d14:	47c0      	blx	r8
	glcd_puts(itos(start_floor_floor_display), 0);
  400d16:	7828      	ldrb	r0, [r5, #0]
  400d18:	2100      	movs	r1, #0
  400d1a:	4b37      	ldr	r3, [pc, #220]	; (400df8 <floor_dislplay_menue_exe+0x190>)
  400d1c:	4798      	blx	r3
  400d1e:	4b37      	ldr	r3, [pc, #220]	; (400dfc <floor_dislplay_menue_exe+0x194>)
  400d20:	2100      	movs	r1, #0
	write_r_text(")", 0);
	
	glcd_gotoxy(50, 54);
	out_char(disSegmentData[0], displayIndex == 0);
  400d22:	4e2d      	ldr	r6, [pc, #180]	; (400dd8 <floor_dislplay_menue_exe+0x170>)
	glcd_puts(itos(start_floor_floor_display), 0);
  400d24:	4798      	blx	r3
	write_r_text(")", 0);
  400d26:	2100      	movs	r1, #0
  400d28:	4835      	ldr	r0, [pc, #212]	; (400e00 <floor_dislplay_menue_exe+0x198>)
  400d2a:	47c0      	blx	r8
	glcd_gotoxy(50, 54);
  400d2c:	2136      	movs	r1, #54	; 0x36
  400d2e:	2032      	movs	r0, #50	; 0x32
	out_char(disSegmentData[0], displayIndex == 0);
  400d30:	4d34      	ldr	r5, [pc, #208]	; (400e04 <floor_dislplay_menue_exe+0x19c>)
	glcd_gotoxy(50, 54);
  400d32:	47b8      	blx	r7
	out_char(disSegmentData[0], displayIndex == 0);
  400d34:	7831      	ldrb	r1, [r6, #0]
  400d36:	7820      	ldrb	r0, [r4, #0]
  400d38:	fab1 f181 	clz	r1, r1
  400d3c:	0949      	lsrs	r1, r1, #5
  400d3e:	47a8      	blx	r5
	out_char(disSegmentData[1], displayIndex == 1);
  400d40:	7831      	ldrb	r1, [r6, #0]
  400d42:	7860      	ldrb	r0, [r4, #1]
  400d44:	f1a1 0101 	sub.w	r1, r1, #1
  400d48:	fab1 f181 	clz	r1, r1
  400d4c:	0949      	lsrs	r1, r1, #5
  400d4e:	47a8      	blx	r5

	return 1;
  400d50:	2001      	movs	r0, #1
  400d52:	b002      	add	sp, #8
  400d54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	else if (left)
  400d58:	b16d      	cbz	r5, 400d76 <floor_dislplay_menue_exe+0x10e>
		if(displayIndex > 0) displayIndex--;
  400d5a:	4a1f      	ldr	r2, [pc, #124]	; (400dd8 <floor_dislplay_menue_exe+0x170>)
  400d5c:	7813      	ldrb	r3, [r2, #0]
  400d5e:	b32b      	cbz	r3, 400dac <floor_dislplay_menue_exe+0x144>
  400d60:	3b01      	subs	r3, #1
  400d62:	4c1e      	ldr	r4, [pc, #120]	; (400ddc <floor_dislplay_menue_exe+0x174>)
  400d64:	7013      	strb	r3, [r2, #0]
	if (enter)
  400d66:	2800      	cmp	r0, #0
  400d68:	d195      	bne.n	400c96 <floor_dislplay_menue_exe+0x2e>
  400d6a:	4d1d      	ldr	r5, [pc, #116]	; (400de0 <floor_dislplay_menue_exe+0x178>)
  400d6c:	e7ca      	b.n	400d04 <floor_dislplay_menue_exe+0x9c>
		return 0;
  400d6e:	2000      	movs	r0, #0
  400d70:	b002      	add	sp, #8
  400d72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	else if(up)
  400d76:	b1c2      	cbz	r2, 400daa <floor_dislplay_menue_exe+0x142>
		if(++dispOptionsCounter[displayIndex] >= DISPLAY_OPTIONS_MAX) dispOptionsCounter[displayIndex] = DISPLAY_OPTIONS_MAX -1;
  400d78:	4b17      	ldr	r3, [pc, #92]	; (400dd8 <floor_dislplay_menue_exe+0x170>)
  400d7a:	4923      	ldr	r1, [pc, #140]	; (400e08 <floor_dislplay_menue_exe+0x1a0>)
  400d7c:	781a      	ldrb	r2, [r3, #0]
  400d7e:	5c8b      	ldrb	r3, [r1, r2]
  400d80:	3301      	adds	r3, #1
  400d82:	b2db      	uxtb	r3, r3
  400d84:	2b09      	cmp	r3, #9
  400d86:	548b      	strb	r3, [r1, r2]
  400d88:	d822      	bhi.n	400dd0 <floor_dislplay_menue_exe+0x168>
  400d8a:	4920      	ldr	r1, [pc, #128]	; (400e0c <floor_dislplay_menue_exe+0x1a4>)
  400d8c:	5ccb      	ldrb	r3, [r1, r3]
		disSegmentData[displayIndex] = dispOptions[dispOptionsCounter[displayIndex]];
  400d8e:	4c13      	ldr	r4, [pc, #76]	; (400ddc <floor_dislplay_menue_exe+0x174>)
  400d90:	54a3      	strb	r3, [r4, r2]
  400d92:	e77e      	b.n	400c92 <floor_dislplay_menue_exe+0x2a>
	if (floor_display_floor > 100) floor_display_floor = 100;
  400d94:	2064      	movs	r0, #100	; 0x64
  400d96:	2330      	movs	r3, #48	; 0x30
  400d98:	213a      	movs	r1, #58	; 0x3a
  400d9a:	f882 009a 	strb.w	r0, [r2, #154]	; 0x9a
  400d9e:	e7af      	b.n	400d00 <floor_dislplay_menue_exe+0x98>
			start_floor_floor_display = 0;
  400da0:	2000      	movs	r0, #0
  400da2:	7028      	strb	r0, [r5, #0]
  400da4:	b002      	add	sp, #8
  400da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	else if (down)
  400daa:	b923      	cbnz	r3, 400db6 <floor_dislplay_menue_exe+0x14e>
  400dac:	4c0b      	ldr	r4, [pc, #44]	; (400ddc <floor_dislplay_menue_exe+0x174>)
  400dae:	e770      	b.n	400c92 <floor_dislplay_menue_exe+0x2a>
		if(++displayIndex > 1) displayIndex = 1;
  400db0:	7013      	strb	r3, [r2, #0]
  400db2:	4c0a      	ldr	r4, [pc, #40]	; (400ddc <floor_dislplay_menue_exe+0x174>)
  400db4:	e76d      	b.n	400c92 <floor_dislplay_menue_exe+0x2a>
		if(dispOptionsCounter[displayIndex] > 0) dispOptionsCounter[displayIndex]--;
  400db6:	4b08      	ldr	r3, [pc, #32]	; (400dd8 <floor_dislplay_menue_exe+0x170>)
  400db8:	4913      	ldr	r1, [pc, #76]	; (400e08 <floor_dislplay_menue_exe+0x1a0>)
  400dba:	781a      	ldrb	r2, [r3, #0]
  400dbc:	5c8b      	ldrb	r3, [r1, r2]
  400dbe:	b113      	cbz	r3, 400dc6 <floor_dislplay_menue_exe+0x15e>
  400dc0:	3b01      	subs	r3, #1
  400dc2:	b2db      	uxtb	r3, r3
  400dc4:	548b      	strb	r3, [r1, r2]
		disSegmentData[displayIndex] = dispOptions[dispOptionsCounter[displayIndex]];
  400dc6:	4911      	ldr	r1, [pc, #68]	; (400e0c <floor_dislplay_menue_exe+0x1a4>)
  400dc8:	4c04      	ldr	r4, [pc, #16]	; (400ddc <floor_dislplay_menue_exe+0x174>)
  400dca:	5ccb      	ldrb	r3, [r1, r3]
  400dcc:	54a3      	strb	r3, [r4, r2]
  400dce:	e760      	b.n	400c92 <floor_dislplay_menue_exe+0x2a>
		if(++dispOptionsCounter[displayIndex] >= DISPLAY_OPTIONS_MAX) dispOptionsCounter[displayIndex] = DISPLAY_OPTIONS_MAX -1;
  400dd0:	2409      	movs	r4, #9
  400dd2:	2339      	movs	r3, #57	; 0x39
  400dd4:	548c      	strb	r4, [r1, r2]
  400dd6:	e7da      	b.n	400d8e <floor_dislplay_menue_exe+0x126>
  400dd8:	2040082c 	.word	0x2040082c
  400ddc:	20400010 	.word	0x20400010
  400de0:	2040082d 	.word	0x2040082d
  400de4:	204008ea 	.word	0x204008ea
  400de8:	204051e0 	.word	0x204051e0
  400dec:	cccccccd 	.word	0xcccccccd
  400df0:	0040c7a5 	.word	0x0040c7a5
  400df4:	0041999c 	.word	0x0041999c
  400df8:	0040c205 	.word	0x0040c205
  400dfc:	0040ca05 	.word	0x0040ca05
  400e00:	0041a9b0 	.word	0x0041a9b0
  400e04:	0040c6f9 	.word	0x0040c6f9
  400e08:	20400c64 	.word	0x20400c64
  400e0c:	00419990 	.word	0x00419990
  400e10:	0040cf51 	.word	0x0040cf51

00400e14 <get_current_floor>:



uByte_t get_current_floor(void)
{
	return (selector_counter>>1);
  400e14:	4b01      	ldr	r3, [pc, #4]	; (400e1c <get_current_floor+0x8>)
  400e16:	6818      	ldr	r0, [r3, #0]
}
  400e18:	0840      	lsrs	r0, r0, #1
  400e1a:	4770      	bx	lr
  400e1c:	20400014 	.word	0x20400014

00400e20 <infloorzone>:

uByte_t infloorzone(void)
{
	if(selector_counter&1)
  400e20:	4b02      	ldr	r3, [pc, #8]	; (400e2c <infloorzone+0xc>)
		return 0;
  400e22:	6818      	ldr	r0, [r3, #0]
  400e24:	43c0      	mvns	r0, r0
	return 1;
}
  400e26:	f000 0001 	and.w	r0, r0, #1
  400e2a:	4770      	bx	lr
  400e2c:	20400014 	.word	0x20400014

00400e30 <sel_set>:

void display_out(char data)
{
	mb_display_data = menue_lift_data_applied.floor_display[data];
  400e30:	4b08      	ldr	r3, [pc, #32]	; (400e54 <sel_set+0x24>)
  400e32:	4909      	ldr	r1, [pc, #36]	; (400e58 <sel_set+0x28>)
  400e34:	eb03 0250 	add.w	r2, r3, r0, lsr #1
	mb_display_type(menue_lift_data_applied.m_display_type);		
}

void sel_set(char selector)
{
  400e38:	b430      	push	{r4, r5}
	mb_display_type(menue_lift_data_applied.m_display_type);		
  400e3a:	781b      	ldrb	r3, [r3, #0]
	mb_display_data = menue_lift_data_applied.floor_display[data];
  400e3c:	f892 409a 	ldrb.w	r4, [r2, #154]	; 0x9a

	selector_counter = selector;
  400e40:	4d06      	ldr	r5, [pc, #24]	; (400e5c <sel_set+0x2c>)
	mb_display_type(menue_lift_data_applied.m_display_type);		
  400e42:	f003 030f 	and.w	r3, r3, #15
  400e46:	4a06      	ldr	r2, [pc, #24]	; (400e60 <sel_set+0x30>)
	selector_counter = selector;
  400e48:	6028      	str	r0, [r5, #0]
	mb_display_data = menue_lift_data_applied.floor_display[data];
  400e4a:	728c      	strb	r4, [r1, #10]
	mb_display_type(menue_lift_data_applied.m_display_type);		
  400e4c:	71d3      	strb	r3, [r2, #7]
	display_out(selector >> 1);

}
  400e4e:	bc30      	pop	{r4, r5}
  400e50:	4770      	bx	lr
  400e52:	bf00      	nop
  400e54:	204052b4 	.word	0x204052b4
  400e58:	20406278 	.word	0x20406278
  400e5c:	20400014 	.word	0x20400014
  400e60:	204062d0 	.word	0x204062d0

00400e64 <selector_count>:

void selector_count(void)
{	
  400e64:	b538      	push	{r3, r4, r5, lr}
	if((sel) && !DIRECT_STOP)
  400e66:	4c1e      	ldr	r4, [pc, #120]	; (400ee0 <selector_count+0x7c>)
  400e68:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  400e6c:	b18b      	cbz	r3, 400e92 <selector_count+0x2e>
  400e6e:	4b1d      	ldr	r3, [pc, #116]	; (400ee4 <selector_count+0x80>)
  400e70:	4a1d      	ldr	r2, [pc, #116]	; (400ee8 <selector_count+0x84>)
			{
				if(selector_counter > 0)
				selector_counter--;
			}
			if(fast_cntr < FAST_TIME_OUT)
				fast_cntr=0;//reset fast counter
  400e72:	2100      	movs	r1, #0
  400e74:	6011      	str	r1, [r2, #0]
	{
		//direct stop mode
		//selector control is on encoder motion control module EMCM
		fast_cntr=0;//reset fast counter, no time out to be issued
	}
	display_out(selector_counter>>1);
  400e76:	681a      	ldr	r2, [r3, #0]
	mb_display_type(menue_lift_data_applied.m_display_type);		
  400e78:	7823      	ldrb	r3, [r4, #0]
	mb_display_data = menue_lift_data_applied.floor_display[data];
  400e7a:	f3c2 0247 	ubfx	r2, r2, #1, #8
	mb_display_type(menue_lift_data_applied.m_display_type);		
  400e7e:	481b      	ldr	r0, [pc, #108]	; (400eec <selector_count+0x88>)
  400e80:	f003 030f 	and.w	r3, r3, #15
	mb_display_data = menue_lift_data_applied.floor_display[data];
  400e84:	491a      	ldr	r1, [pc, #104]	; (400ef0 <selector_count+0x8c>)
  400e86:	4414      	add	r4, r2
	mb_display_type(menue_lift_data_applied.m_display_type);		
  400e88:	71c3      	strb	r3, [r0, #7]
	mb_display_data = menue_lift_data_applied.floor_display[data];
  400e8a:	f894 309a 	ldrb.w	r3, [r4, #154]	; 0x9a
  400e8e:	728b      	strb	r3, [r1, #10]
  400e90:	bd38      	pop	{r3, r4, r5, pc}
		if((auto_instate(auto_hspd)==1)||((auto_instate(auto_lspd)==1)&&(mnt==1)))//chek if car is moving
  400e92:	2001      	movs	r0, #1
  400e94:	4d17      	ldr	r5, [pc, #92]	; (400ef4 <selector_count+0x90>)
  400e96:	47a8      	blx	r5
  400e98:	2801      	cmp	r0, #1
  400e9a:	d005      	beq.n	400ea8 <selector_count+0x44>
  400e9c:	2002      	movs	r0, #2
  400e9e:	47a8      	blx	r5
  400ea0:	2801      	cmp	r0, #1
  400ea2:	d001      	beq.n	400ea8 <selector_count+0x44>
  400ea4:	4b0f      	ldr	r3, [pc, #60]	; (400ee4 <selector_count+0x80>)
  400ea6:	e7e6      	b.n	400e76 <selector_count+0x12>
			if(direction_up)
  400ea8:	4b13      	ldr	r3, [pc, #76]	; (400ef8 <selector_count+0x94>)
  400eaa:	781b      	ldrb	r3, [r3, #0]
  400eac:	b18b      	cbz	r3, 400ed2 <selector_count+0x6e>
				if(selector_counter < (f_max<<1))
  400eae:	4b0d      	ldr	r3, [pc, #52]	; (400ee4 <selector_count+0x80>)
  400eb0:	7aa1      	ldrb	r1, [r4, #10]
  400eb2:	681a      	ldr	r2, [r3, #0]
  400eb4:	ebb2 0f41 	cmp.w	r2, r1, lsl #1
  400eb8:	d201      	bcs.n	400ebe <selector_count+0x5a>
				selector_counter++;
  400eba:	3201      	adds	r2, #1
  400ebc:	601a      	str	r2, [r3, #0]
			if(fast_cntr < FAST_TIME_OUT)
  400ebe:	7921      	ldrb	r1, [r4, #4]
  400ec0:	4a09      	ldr	r2, [pc, #36]	; (400ee8 <selector_count+0x84>)
  400ec2:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  400ec6:	6810      	ldr	r0, [r2, #0]
  400ec8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  400ecc:	4281      	cmp	r1, r0
  400ece:	d9d2      	bls.n	400e76 <selector_count+0x12>
  400ed0:	e7cf      	b.n	400e72 <selector_count+0xe>
				if(selector_counter > 0)
  400ed2:	4b04      	ldr	r3, [pc, #16]	; (400ee4 <selector_count+0x80>)
  400ed4:	681a      	ldr	r2, [r3, #0]
  400ed6:	2a00      	cmp	r2, #0
  400ed8:	d0f1      	beq.n	400ebe <selector_count+0x5a>
				selector_counter--;
  400eda:	3a01      	subs	r2, #1
  400edc:	601a      	str	r2, [r3, #0]
  400ede:	e7ee      	b.n	400ebe <selector_count+0x5a>
  400ee0:	204052b4 	.word	0x204052b4
  400ee4:	20400014 	.word	0x20400014
  400ee8:	204008c8 	.word	0x204008c8
  400eec:	204062d0 	.word	0x204062d0
  400ef0:	20406278 	.word	0x20406278
  400ef4:	004081c5 	.word	0x004081c5
  400ef8:	20400c66 	.word	0x20400c66

00400efc <direction_limits_check>:
char dir_limit_started = 1;
void direction_limits_check()
{
	char select;
	
	if(dir_limit_started) return; // to avoid direction limit startup fault
  400efc:	4b07      	ldr	r3, [pc, #28]	; (400f1c <direction_limits_check+0x20>)
  400efe:	781b      	ldrb	r3, [r3, #0]
  400f00:	b103      	cbz	r3, 400f04 <direction_limits_check+0x8>
  400f02:	4770      	bx	lr
{
  400f04:	b510      	push	{r4, lr}
	{
		dnfdl0_err;
		upfdl0_err;
	}
	
	if(auto_instate(auto_hspd) || auto_instate(auto_lspd))
  400f06:	2001      	movs	r0, #1
  400f08:	4c05      	ldr	r4, [pc, #20]	; (400f20 <direction_limits_check+0x24>)
  400f0a:	47a0      	blx	r4
  400f0c:	b100      	cbz	r0, 400f10 <direction_limits_check+0x14>
  400f0e:	bd10      	pop	{r4, pc}
  400f10:	4623      	mov	r3, r4
  400f12:	2002      	movs	r0, #2
				upfdl0_err;
			}
		}
	}
	
}
  400f14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if(auto_instate(auto_hspd) || auto_instate(auto_lspd))
  400f18:	4718      	bx	r3
  400f1a:	bf00      	nop
  400f1c:	20400013 	.word	0x20400013
  400f20:	004081c5 	.word	0x004081c5

00400f24 <dir_limit_startup>:

void dir_limit_startup()
{
	dir_limit_started = 0;
  400f24:	4b01      	ldr	r3, [pc, #4]	; (400f2c <dir_limit_startup+0x8>)
  400f26:	2200      	movs	r2, #0
  400f28:	701a      	strb	r2, [r3, #0]
  400f2a:	4770      	bx	lr
  400f2c:	20400013 	.word	0x20400013

00400f30 <insert_irequest>:
#define park_timer  (menue_lift_data_applied.m_parking_time * 25)
#define parking_floor (menue_lift_data_applied.m_parking_floor)
unsigned int park_counter=0;

void insert_irequest(uint32_t request)
{
  400f30:	b510      	push	{r4, lr}
  400f32:	4604      	mov	r4, r0
	if((get_current_floor() != request) && (request < f_max))
  400f34:	4b07      	ldr	r3, [pc, #28]	; (400f54 <insert_irequest+0x24>)
  400f36:	4798      	blx	r3
  400f38:	42a0      	cmp	r0, r4
  400f3a:	d00a      	beq.n	400f52 <insert_irequest+0x22>
  400f3c:	4b06      	ldr	r3, [pc, #24]	; (400f58 <insert_irequest+0x28>)
  400f3e:	7a9b      	ldrb	r3, [r3, #10]
  400f40:	429c      	cmp	r4, r3
  400f42:	d206      	bcs.n	400f52 <insert_irequest+0x22>
	{
		ireq |= msk(request);
  400f44:	4a05      	ldr	r2, [pc, #20]	; (400f5c <insert_irequest+0x2c>)
  400f46:	2301      	movs	r3, #1
  400f48:	6811      	ldr	r1, [r2, #0]
  400f4a:	fa03 f404 	lsl.w	r4, r3, r4
  400f4e:	430c      	orrs	r4, r1
  400f50:	6014      	str	r4, [r2, #0]
  400f52:	bd10      	pop	{r4, pc}
  400f54:	00400e15 	.word	0x00400e15
  400f58:	204052b4 	.word	0x204052b4
  400f5c:	20400838 	.word	0x20400838

00400f60 <parking_check>:
	request_init_selector_handler = sch_add_task_ms(&request_init_selector, task_delay, 3000);
}


void parking_check()
{
  400f60:	b538      	push	{r3, r4, r5, lr}
	if(device_off)
  400f62:	4b19      	ldr	r3, [pc, #100]	; (400fc8 <parking_check+0x68>)
  400f64:	681b      	ldr	r3, [r3, #0]
  400f66:	b9ab      	cbnz	r3, 400f94 <parking_check+0x34>
		return;
	if(park_timer)//parking operation
  400f68:	4c18      	ldr	r4, [pc, #96]	; (400fcc <parking_check+0x6c>)
  400f6a:	8a23      	ldrh	r3, [r4, #16]
  400f6c:	b193      	cbz	r3, 400f94 <parking_check+0x34>
	if(ireq||ereq||eereq)
  400f6e:	4d18      	ldr	r5, [pc, #96]	; (400fd0 <parking_check+0x70>)
  400f70:	682a      	ldr	r2, [r5, #0]
  400f72:	b982      	cbnz	r2, 400f96 <parking_check+0x36>
  400f74:	4a17      	ldr	r2, [pc, #92]	; (400fd4 <parking_check+0x74>)
  400f76:	6812      	ldr	r2, [r2, #0]
  400f78:	b96a      	cbnz	r2, 400f96 <parking_check+0x36>
  400f7a:	4a17      	ldr	r2, [pc, #92]	; (400fd8 <parking_check+0x78>)
  400f7c:	6810      	ldr	r0, [r2, #0]
  400f7e:	b950      	cbnz	r0, 400f96 <parking_check+0x36>
		{
			park_counter=0;
		}
		else
		{
			park_counter++;
  400f80:	4916      	ldr	r1, [pc, #88]	; (400fdc <parking_check+0x7c>)
			if(park_counter>=park_timer)
  400f82:	eb03 0383 	add.w	r3, r3, r3, lsl #2
			park_counter++;
  400f86:	680a      	ldr	r2, [r1, #0]
			if(park_counter>=park_timer)
  400f88:	eb03 0383 	add.w	r3, r3, r3, lsl #2
			park_counter++;
  400f8c:	3201      	adds	r2, #1
			if(park_counter>=park_timer)
  400f8e:	429a      	cmp	r2, r3
  400f90:	d205      	bcs.n	400f9e <parking_check+0x3e>
			park_counter++;
  400f92:	600a      	str	r2, [r1, #0]
  400f94:	bd38      	pop	{r3, r4, r5, pc}
			park_counter=0;
  400f96:	4b11      	ldr	r3, [pc, #68]	; (400fdc <parking_check+0x7c>)
  400f98:	2200      	movs	r2, #0
  400f9a:	601a      	str	r2, [r3, #0]
  400f9c:	bd38      	pop	{r3, r4, r5, pc}
			{
				park_counter=0;
				if((get_current_floor()!=parking_floor) && (parking_floor < f_max))
  400f9e:	4b10      	ldr	r3, [pc, #64]	; (400fe0 <parking_check+0x80>)
				park_counter=0;
  400fa0:	6008      	str	r0, [r1, #0]
				if((get_current_floor()!=parking_floor) && (parking_floor < f_max))
  400fa2:	4798      	blx	r3
  400fa4:	7b23      	ldrb	r3, [r4, #12]
  400fa6:	4298      	cmp	r0, r3
  400fa8:	d0f4      	beq.n	400f94 <parking_check+0x34>
  400faa:	7aa2      	ldrb	r2, [r4, #10]
  400fac:	429a      	cmp	r2, r3
  400fae:	d9f1      	bls.n	400f94 <parking_check+0x34>
				{
					if(auto_instate(auto_idle))
  400fb0:	2005      	movs	r0, #5
  400fb2:	4b0c      	ldr	r3, [pc, #48]	; (400fe4 <parking_check+0x84>)
  400fb4:	4798      	blx	r3
  400fb6:	2800      	cmp	r0, #0
  400fb8:	d0ec      	beq.n	400f94 <parking_check+0x34>
						ireq |= msk(parking_floor);
  400fba:	7b21      	ldrb	r1, [r4, #12]
  400fbc:	2301      	movs	r3, #1
  400fbe:	682a      	ldr	r2, [r5, #0]
  400fc0:	408b      	lsls	r3, r1
  400fc2:	4313      	orrs	r3, r2
  400fc4:	602b      	str	r3, [r5, #0]
  400fc6:	bd38      	pop	{r3, r4, r5, pc}
  400fc8:	204008f0 	.word	0x204008f0
  400fcc:	204052b4 	.word	0x204052b4
  400fd0:	20400838 	.word	0x20400838
  400fd4:	20400834 	.word	0x20400834
  400fd8:	20400830 	.word	0x20400830
  400fdc:	2040083c 	.word	0x2040083c
  400fe0:	00400e15 	.word	0x00400e15
  400fe4:	004081c5 	.word	0x004081c5

00400fe8 <pos_next_floor>:
			}
		}
	}
}
void pos_next_floor() //passenger out safe in case like overload detection
{
  400fe8:	b510      	push	{r4, lr}
	char nreq=0;
	if(auto_instate(auto_hspd))
  400fea:	2001      	movs	r0, #1
  400fec:	4b1b      	ldr	r3, [pc, #108]	; (40105c <pos_next_floor+0x74>)
  400fee:	4798      	blx	r3
  400ff0:	b900      	cbnz	r0, 400ff4 <pos_next_floor+0xc>
  400ff2:	bd10      	pop	{r4, pc}
	{
		nreq=get_current_floor();
  400ff4:	4b1a      	ldr	r3, [pc, #104]	; (401060 <pos_next_floor+0x78>)
  400ff6:	4798      	blx	r3
		if(infloorzone())
  400ff8:	4b1a      	ldr	r3, [pc, #104]	; (401064 <pos_next_floor+0x7c>)
		nreq=get_current_floor();
  400ffa:	b2c4      	uxtb	r4, r0
		if(infloorzone())
  400ffc:	4798      	blx	r3
		{//if car infloor zone schedule next floor
			if(!direction_up)
  400ffe:	4b1a      	ldr	r3, [pc, #104]	; (401068 <pos_next_floor+0x80>)
  401000:	781b      	ldrb	r3, [r3, #0]
		if(infloorzone())
  401002:	b158      	cbz	r0, 40101c <pos_next_floor+0x34>
			if(!direction_up)
  401004:	b9d3      	cbnz	r3, 40103c <pos_next_floor+0x54>
			{
				if(nreq>0)
  401006:	b33c      	cbz	r4, 401058 <pos_next_floor+0x70>
				nreq-=1;
  401008:	3c01      	subs	r4, #1
  40100a:	2301      	movs	r3, #1
  40100c:	b2e4      	uxtb	r4, r4
  40100e:	40a3      	lsls	r3, r4
				if(nreq < f_max)
				nreq++;
				else
				nreq = f_max;
			}
			ireq=msk(nreq);
  401010:	4816      	ldr	r0, [pc, #88]	; (40106c <pos_next_floor+0x84>)
			ereq=0;
  401012:	2100      	movs	r1, #0
  401014:	4a16      	ldr	r2, [pc, #88]	; (401070 <pos_next_floor+0x88>)
			ireq=msk(nreq);
  401016:	6003      	str	r3, [r0, #0]
			ereq=0;
  401018:	6011      	str	r1, [r2, #0]
			return;
  40101a:	bd10      	pop	{r4, pc}
		}
		//if not infloorzone schedule next floor or current floor if you're heading downstairs
		if(direction_up)
  40101c:	b12b      	cbz	r3, 40102a <pos_next_floor+0x42>
		{
			if(nreq < f_max)
  40101e:	4b15      	ldr	r3, [pc, #84]	; (401074 <pos_next_floor+0x8c>)
  401020:	7a9b      	ldrb	r3, [r3, #10]
  401022:	429c      	cmp	r4, r3
  401024:	d213      	bcs.n	40104e <pos_next_floor+0x66>
			nreq++;
  401026:	3401      	adds	r4, #1
  401028:	b2e4      	uxtb	r4, r4
			else
			nreq = f_max;
		}
		ireq = msk(nreq);
  40102a:	2301      	movs	r3, #1
  40102c:	4a0f      	ldr	r2, [pc, #60]	; (40106c <pos_next_floor+0x84>)
		ereq = 0;
  40102e:	4910      	ldr	r1, [pc, #64]	; (401070 <pos_next_floor+0x88>)
  401030:	2000      	movs	r0, #0
		ireq = msk(nreq);
  401032:	fa03 f404 	lsl.w	r4, r3, r4
		ereq = 0;
  401036:	6008      	str	r0, [r1, #0]
		ireq = msk(nreq);
  401038:	6014      	str	r4, [r2, #0]
  40103a:	bd10      	pop	{r4, pc}
				if(nreq < f_max)
  40103c:	4b0d      	ldr	r3, [pc, #52]	; (401074 <pos_next_floor+0x8c>)
  40103e:	7a9a      	ldrb	r2, [r3, #10]
  401040:	4294      	cmp	r4, r2
  401042:	d206      	bcs.n	401052 <pos_next_floor+0x6a>
				nreq++;
  401044:	3401      	adds	r4, #1
  401046:	2301      	movs	r3, #1
  401048:	b2e4      	uxtb	r4, r4
  40104a:	40a3      	lsls	r3, r4
  40104c:	e7e0      	b.n	401010 <pos_next_floor+0x28>
  40104e:	461c      	mov	r4, r3
  401050:	e7eb      	b.n	40102a <pos_next_floor+0x42>
  401052:	2301      	movs	r3, #1
  401054:	4093      	lsls	r3, r2
  401056:	e7db      	b.n	401010 <pos_next_floor+0x28>
  401058:	2301      	movs	r3, #1
  40105a:	e7d9      	b.n	401010 <pos_next_floor+0x28>
  40105c:	004081c5 	.word	0x004081c5
  401060:	00400e15 	.word	0x00400e15
  401064:	00400e21 	.word	0x00400e21
  401068:	20400c66 	.word	0x20400c66
  40106c:	20400838 	.word	0x20400838
  401070:	20400834 	.word	0x20400834
  401074:	204052b4 	.word	0x204052b4

00401078 <drop_all_req>:
	}
	
}
void drop_all_req(void)
{
    ireq=0;
  401078:	2300      	movs	r3, #0
  40107a:	4803      	ldr	r0, [pc, #12]	; (401088 <drop_all_req+0x10>)
    ereq=0;
  40107c:	4903      	ldr	r1, [pc, #12]	; (40108c <drop_all_req+0x14>)
	eereq=0;    
  40107e:	4a04      	ldr	r2, [pc, #16]	; (401090 <drop_all_req+0x18>)
    ireq=0;
  401080:	6003      	str	r3, [r0, #0]
    ereq=0;
  401082:	600b      	str	r3, [r1, #0]
	eereq=0;    
  401084:	6013      	str	r3, [r2, #0]
  401086:	4770      	bx	lr
  401088:	20400838 	.word	0x20400838
  40108c:	20400834 	.word	0x20400834
  401090:	20400830 	.word	0x20400830

00401094 <drop_req>:
}

void drop_req(char req_num)
{
	ireq&=~msk(req_num);
  401094:	2301      	movs	r3, #1
  401096:	491c      	ldr	r1, [pc, #112]	; (401108 <drop_req+0x74>)
{
  401098:	b5f0      	push	{r4, r5, r6, r7, lr}
	ireq&=~msk(req_num);
  40109a:	4083      	lsls	r3, r0
	uint32_t tmp;
	if ((req_num == f_max) || (req_num == 0))
  40109c:	4c1b      	ldr	r4, [pc, #108]	; (40110c <drop_req+0x78>)
	ireq&=~msk(req_num);
  40109e:	680a      	ldr	r2, [r1, #0]
  4010a0:	43db      	mvns	r3, r3
	if ((req_num == f_max) || (req_num == 0))
  4010a2:	7aa5      	ldrb	r5, [r4, #10]
	ireq&=~msk(req_num);
  4010a4:	401a      	ands	r2, r3
	if ((req_num == f_max) || (req_num == 0))
  4010a6:	4285      	cmp	r5, r0
	ireq&=~msk(req_num);
  4010a8:	600a      	str	r2, [r1, #0]
	if ((req_num == f_max) || (req_num == 0))
  4010aa:	d003      	beq.n	4010b4 <drop_req+0x20>
  4010ac:	b110      	cbz	r0, 4010b4 <drop_req+0x20>
	{
		ereq&=~msk(req_num);
		eereq&=~msk(req_num);
	}
	else if (collect == 2)
  4010ae:	78a1      	ldrb	r1, [r4, #2]
  4010b0:	2902      	cmp	r1, #2
  4010b2:	d008      	beq.n	4010c6 <drop_req+0x32>
			if(tmp == 0) eereq&=~msk(req_num);
		}
	} 
	else
	{
		ereq&=~msk(req_num);
  4010b4:	4c16      	ldr	r4, [pc, #88]	; (401110 <drop_req+0x7c>)
		eereq&=~msk(req_num);
  4010b6:	4817      	ldr	r0, [pc, #92]	; (401114 <drop_req+0x80>)
		ereq&=~msk(req_num);
  4010b8:	6821      	ldr	r1, [r4, #0]
		eereq&=~msk(req_num);
  4010ba:	6802      	ldr	r2, [r0, #0]
		ereq&=~msk(req_num);
  4010bc:	4019      	ands	r1, r3
		eereq&=~msk(req_num);
  4010be:	4013      	ands	r3, r2
		ereq&=~msk(req_num);
  4010c0:	6021      	str	r1, [r4, #0]
		eereq&=~msk(req_num);
  4010c2:	6003      	str	r3, [r0, #0]
  4010c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tmp = ireq|ereq|eereq;
  4010c6:	4e12      	ldr	r6, [pc, #72]	; (401110 <drop_req+0x7c>)
  4010c8:	4d12      	ldr	r5, [pc, #72]	; (401114 <drop_req+0x80>)
  4010ca:	6834      	ldr	r4, [r6, #0]
  4010cc:	6829      	ldr	r1, [r5, #0]
		if (direction_up)
  4010ce:	4f12      	ldr	r7, [pc, #72]	; (401118 <drop_req+0x84>)
		tmp = ireq|ereq|eereq;
  4010d0:	ea44 0e01 	orr.w	lr, r4, r1
		if (direction_up)
  4010d4:	783f      	ldrb	r7, [r7, #0]
		tmp = ireq|ereq|eereq;
  4010d6:	ea4e 0202 	orr.w	r2, lr, r2
		if (direction_up)
  4010da:	b157      	cbz	r7, 4010f2 <drop_req+0x5e>
			tmp &= (0xFFFFFFFF << (req_num + 1));
  4010dc:	1c47      	adds	r7, r0, #1
  4010de:	f04f 30ff 	mov.w	r0, #4294967295
			eereq&=~msk(req_num);
  4010e2:	4019      	ands	r1, r3
			tmp &= (0xFFFFFFFF << (req_num + 1));
  4010e4:	40b8      	lsls	r0, r7
			eereq&=~msk(req_num);
  4010e6:	6029      	str	r1, [r5, #0]
			if(tmp == 0) ereq&=~msk(req_num);
  4010e8:	4210      	tst	r0, r2
  4010ea:	d1eb      	bne.n	4010c4 <drop_req+0x30>
  4010ec:	4023      	ands	r3, r4
  4010ee:	6033      	str	r3, [r6, #0]
  4010f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			tmp &= ~(0xFFFFFFFF << req_num);
  4010f2:	f04f 37ff 	mov.w	r7, #4294967295
			ereq&=~msk(req_num);
  4010f6:	401c      	ands	r4, r3
			tmp &= ~(0xFFFFFFFF << req_num);
  4010f8:	fa07 f000 	lsl.w	r0, r7, r0
			ereq&=~msk(req_num);
  4010fc:	6034      	str	r4, [r6, #0]
			if(tmp == 0) eereq&=~msk(req_num);
  4010fe:	4382      	bics	r2, r0
  401100:	d1e0      	bne.n	4010c4 <drop_req+0x30>
  401102:	400b      	ands	r3, r1
  401104:	602b      	str	r3, [r5, #0]
  401106:	bdf0      	pop	{r4, r5, r6, r7, pc}
  401108:	20400838 	.word	0x20400838
  40110c:	204052b4 	.word	0x204052b4
  401110:	20400834 	.word	0x20400834
  401114:	20400830 	.word	0x20400830
  401118:	20400c66 	.word	0x20400c66

0040111c <req_enable>:
}

uint8_t req_enabled = 0;
void req_enable(uint8_t command)
{
	req_enabled = command;	
  40111c:	4b01      	ldr	r3, [pc, #4]	; (401124 <req_enable+0x8>)
  40111e:	7018      	strb	r0, [r3, #0]
  401120:	4770      	bx	lr
  401122:	bf00      	nop
  401124:	20400840 	.word	0x20400840

00401128 <req_scan>:
		parking_check();
	}
}
#else
void req_scan(void)
{
  401128:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t i, c_f, req_disable_led;
	
	if(ireq|ereq|eereq) light_timer_reset();
  40112c:	f8df 9288 	ldr.w	r9, [pc, #648]	; 4013b8 <req_scan+0x290>
{
  401130:	b083      	sub	sp, #12
	if(ireq|ereq|eereq) light_timer_reset();
  401132:	f8df b288 	ldr.w	fp, [pc, #648]	; 4013bc <req_scan+0x294>
  401136:	f8d9 3000 	ldr.w	r3, [r9]
  40113a:	f8db 2000 	ldr.w	r2, [fp]
  40113e:	4313      	orrs	r3, r2
  401140:	4a94      	ldr	r2, [pc, #592]	; (401394 <req_scan+0x26c>)
  401142:	6812      	ldr	r2, [r2, #0]
  401144:	4313      	orrs	r3, r2
  401146:	f040 80f2 	bne.w	40132e <req_scan+0x206>
	if(device_off == 0)
  40114a:	4b93      	ldr	r3, [pc, #588]	; (401398 <req_scan+0x270>)
  40114c:	681c      	ldr	r4, [r3, #0]
  40114e:	b114      	cbz	r4, 401156 <req_scan+0x2e>
			set_ireq_ledMask (f_max + 2, 1);
		}
		if(!req_enabled) return;
		parking_check();
	}
}
  401150:	b003      	add	sp, #12
  401152:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401156:	4f91      	ldr	r7, [pc, #580]	; (40139c <req_scan+0x274>)
		c_f = get_current_floor();
  401158:	4b91      	ldr	r3, [pc, #580]	; (4013a0 <req_scan+0x278>)
  40115a:	4798      	blx	r3
				if( (get_ireq(i, ireq&msk(i)) == 1) || (get_ereq(i, ereq&msk(i)) == 1) )
  40115c:	4e91      	ldr	r6, [pc, #580]	; (4013a4 <req_scan+0x27c>)
		c_f = get_current_floor();
  40115e:	9000      	str	r0, [sp, #0]
  401160:	7abb      	ldrb	r3, [r7, #10]
  401162:	e002      	b.n	40116a <req_scan+0x42>
		for(i=0; i<28; i++)
  401164:	3401      	adds	r4, #1
  401166:	2c1c      	cmp	r4, #28
  401168:	d052      	beq.n	401210 <req_scan+0xe8>
			if(i <= f_max)
  40116a:	42a3      	cmp	r3, r4
  40116c:	d3fa      	bcc.n	401164 <req_scan+0x3c>
				if( (get_ireq(i, ireq&msk(i)) == 1) || (get_ereq(i, ereq&msk(i)) == 1) )
  40116e:	2501      	movs	r5, #1
  401170:	f8d9 1000 	ldr.w	r1, [r9]
  401174:	f044 7840 	orr.w	r8, r4, #50331648	; 0x3000000
  401178:	2202      	movs	r2, #2
  40117a:	40a5      	lsls	r5, r4
  40117c:	f044 6a80 	orr.w	sl, r4, #67108864	; 0x4000000
  401180:	4640      	mov	r0, r8
  401182:	4029      	ands	r1, r5
  401184:	47b0      	blx	r6
  401186:	2801      	cmp	r0, #1
  401188:	d04e      	beq.n	401228 <req_scan+0x100>
  40118a:	f8db 1000 	ldr.w	r1, [fp]
  40118e:	2202      	movs	r2, #2
  401190:	4650      	mov	r0, sl
  401192:	4029      	ands	r1, r5
  401194:	47b0      	blx	r6
  401196:	2801      	cmp	r0, #1
  401198:	d046      	beq.n	401228 <req_scan+0x100>
				if(collect == 2)
  40119a:	78ba      	ldrb	r2, [r7, #2]
  40119c:	2a02      	cmp	r2, #2
  40119e:	d048      	beq.n	401232 <req_scan+0x10a>
				if ((get_ireq(i, ireq & msk(i)) == 1) && (req_enabled))
  4011a0:	f8d9 1000 	ldr.w	r1, [r9]
  4011a4:	2202      	movs	r2, #2
  4011a6:	4640      	mov	r0, r8
  4011a8:	4029      	ands	r1, r5
  4011aa:	47b0      	blx	r6
  4011ac:	2801      	cmp	r0, #1
  4011ae:	d072      	beq.n	401296 <req_scan+0x16e>
				if ((get_ereq(i, ereq & msk(i)) == 1) && (req_enabled))
  4011b0:	f8db 1000 	ldr.w	r1, [fp]
  4011b4:	2202      	movs	r2, #2
  4011b6:	4650      	mov	r0, sl
  4011b8:	4029      	ands	r1, r5
  4011ba:	47b0      	blx	r6
  4011bc:	2801      	cmp	r0, #1
  4011be:	d043      	beq.n	401248 <req_scan+0x120>
				if (collect == 2)
  4011c0:	78bb      	ldrb	r3, [r7, #2]
  4011c2:	2b02      	cmp	r3, #2
  4011c4:	d07d      	beq.n	4012c2 <req_scan+0x19a>
				get_ireq(i, ireq&msk(i));
  4011c6:	f8d9 1000 	ldr.w	r1, [r9]
  4011ca:	2202      	movs	r2, #2
  4011cc:	4640      	mov	r0, r8
  4011ce:	4029      	ands	r1, r5
  4011d0:	47b0      	blx	r6
				get_ereq(i, ereq&msk(i));
  4011d2:	f8db 1000 	ldr.w	r1, [fp]
  4011d6:	4650      	mov	r0, sl
  4011d8:	2202      	movs	r2, #2
  4011da:	4029      	ands	r1, r5
  4011dc:	47b0      	blx	r6
				if (collect == 2) get_eereq(i, eereq&msk(i));
  4011de:	78bb      	ldrb	r3, [r7, #2]
  4011e0:	2b02      	cmp	r3, #2
  4011e2:	d04f      	beq.n	401284 <req_scan+0x15c>
				if (i != c_f)
  4011e4:	9b00      	ldr	r3, [sp, #0]
  4011e6:	42a3      	cmp	r3, r4
  4011e8:	f000 80b9 	beq.w	40135e <req_scan+0x236>
					set_ireq_ledMask(i, 1);
  4011ec:	2202      	movs	r2, #2
  4011ee:	2101      	movs	r1, #1
  4011f0:	f044 60c0 	orr.w	r0, r4, #100663296	; 0x6000000
  4011f4:	47b0      	blx	r6
					set_ereq_ledMask(i, 1);
  4011f6:	2202      	movs	r2, #2
  4011f8:	2101      	movs	r1, #1
  4011fa:	f044 6010 	orr.w	r0, r4, #150994944	; 0x9000000
  4011fe:	47b0      	blx	r6
					if(collect == 2) set_eereq_ledMask(i, 1);
  401200:	78ba      	ldrb	r2, [r7, #2]
  401202:	2a02      	cmp	r2, #2
  401204:	f000 808d 	beq.w	401322 <req_scan+0x1fa>
		for(i=0; i<28; i++)
  401208:	3401      	adds	r4, #1
  40120a:	7abb      	ldrb	r3, [r7, #10]
  40120c:	2c1c      	cmp	r4, #28
  40120e:	d1ac      	bne.n	40116a <req_scan+0x42>
		if (f_max < 30)
  401210:	2b1d      	cmp	r3, #29
  401212:	f240 808f 	bls.w	401334 <req_scan+0x20c>
		if(!req_enabled) return;
  401216:	4b64      	ldr	r3, [pc, #400]	; (4013a8 <req_scan+0x280>)
  401218:	781b      	ldrb	r3, [r3, #0]
  40121a:	2b00      	cmp	r3, #0
  40121c:	d098      	beq.n	401150 <req_scan+0x28>
		parking_check();
  40121e:	4b63      	ldr	r3, [pc, #396]	; (4013ac <req_scan+0x284>)
}
  401220:	b003      	add	sp, #12
  401222:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		parking_check();
  401226:	4718      	bx	r3
					light_timer_reset();
  401228:	4b61      	ldr	r3, [pc, #388]	; (4013b0 <req_scan+0x288>)
  40122a:	4798      	blx	r3
				if(collect == 2)
  40122c:	78ba      	ldrb	r2, [r7, #2]
  40122e:	2a02      	cmp	r2, #2
  401230:	d1b6      	bne.n	4011a0 <req_scan+0x78>
				if ((get_eereq(i, eereq&msk(i)) == 1)) light_timer_reset();
  401232:	4b58      	ldr	r3, [pc, #352]	; (401394 <req_scan+0x26c>)
  401234:	f044 6000 	orr.w	r0, r4, #134217728	; 0x8000000
  401238:	6819      	ldr	r1, [r3, #0]
  40123a:	4029      	ands	r1, r5
  40123c:	47b0      	blx	r6
  40123e:	2801      	cmp	r0, #1
  401240:	d1ae      	bne.n	4011a0 <req_scan+0x78>
  401242:	4b5b      	ldr	r3, [pc, #364]	; (4013b0 <req_scan+0x288>)
  401244:	4798      	blx	r3
  401246:	e7ab      	b.n	4011a0 <req_scan+0x78>
				if ((get_ereq(i, ereq & msk(i)) == 1) && (req_enabled))
  401248:	4b57      	ldr	r3, [pc, #348]	; (4013a8 <req_scan+0x280>)
  40124a:	781b      	ldrb	r3, [r3, #0]
  40124c:	2b00      	cmp	r3, #0
  40124e:	d0b7      	beq.n	4011c0 <req_scan+0x98>
					if(collect != 2)
  401250:	78bb      	ldrb	r3, [r7, #2]
  401252:	2b02      	cmp	r3, #2
						if (i != c_f)
  401254:	9b00      	ldr	r3, [sp, #0]
					if(collect != 2)
  401256:	d02b      	beq.n	4012b0 <req_scan+0x188>
						if (i != c_f)
  401258:	42a3      	cmp	r3, r4
  40125a:	d07d      	beq.n	401358 <req_scan+0x230>
						ereq |= msk(i);
  40125c:	f8db 3000 	ldr.w	r3, [fp]
				get_ireq(i, ireq&msk(i));
  401260:	2202      	movs	r2, #2
  401262:	f8d9 1000 	ldr.w	r1, [r9]
  401266:	4640      	mov	r0, r8
						ereq |= msk(i);
  401268:	432b      	orrs	r3, r5
				get_ireq(i, ireq&msk(i));
  40126a:	4029      	ands	r1, r5
						ereq |= msk(i);
  40126c:	f8cb 3000 	str.w	r3, [fp]
				get_ireq(i, ireq&msk(i));
  401270:	47b0      	blx	r6
				get_ereq(i, ereq&msk(i));
  401272:	f8db 1000 	ldr.w	r1, [fp]
  401276:	4650      	mov	r0, sl
  401278:	2202      	movs	r2, #2
  40127a:	4029      	ands	r1, r5
  40127c:	47b0      	blx	r6
				if (collect == 2) get_eereq(i, eereq&msk(i));
  40127e:	78bb      	ldrb	r3, [r7, #2]
  401280:	2b02      	cmp	r3, #2
  401282:	d1b3      	bne.n	4011ec <req_scan+0xc4>
  401284:	f044 6300 	orr.w	r3, r4, #134217728	; 0x8000000
  401288:	4a42      	ldr	r2, [pc, #264]	; (401394 <req_scan+0x26c>)
  40128a:	4618      	mov	r0, r3
  40128c:	6811      	ldr	r1, [r2, #0]
  40128e:	2202      	movs	r2, #2
  401290:	4029      	ands	r1, r5
  401292:	47b0      	blx	r6
  401294:	e7a6      	b.n	4011e4 <req_scan+0xbc>
				if ((get_ireq(i, ireq & msk(i)) == 1) && (req_enabled))
  401296:	4b44      	ldr	r3, [pc, #272]	; (4013a8 <req_scan+0x280>)
  401298:	781b      	ldrb	r3, [r3, #0]
					if(i != c_f)
  40129a:	2b00      	cmp	r3, #0
  40129c:	d088      	beq.n	4011b0 <req_scan+0x88>
  40129e:	9b00      	ldr	r3, [sp, #0]
  4012a0:	42a3      	cmp	r3, r4
  4012a2:	d085      	beq.n	4011b0 <req_scan+0x88>
					ireq |= msk(i);
  4012a4:	f8d9 3000 	ldr.w	r3, [r9]
  4012a8:	432b      	orrs	r3, r5
  4012aa:	f8c9 3000 	str.w	r3, [r9]
  4012ae:	e77f      	b.n	4011b0 <req_scan+0x88>
						if ( (i != c_f) && (i != 0))
  4012b0:	42a3      	cmp	r3, r4
  4012b2:	d051      	beq.n	401358 <req_scan+0x230>
  4012b4:	2c00      	cmp	r4, #0
  4012b6:	d04f      	beq.n	401358 <req_scan+0x230>
						ereq |= msk(i);
  4012b8:	f8db 3000 	ldr.w	r3, [fp]
  4012bc:	432b      	orrs	r3, r5
  4012be:	f8cb 3000 	str.w	r3, [fp]
					if (((get_eereq(i, eereq&msk(i)) == 1)) && (req_enabled))
  4012c2:	4a34      	ldr	r2, [pc, #208]	; (401394 <req_scan+0x26c>)
  4012c4:	f044 6300 	orr.w	r3, r4, #134217728	; 0x8000000
  4012c8:	6811      	ldr	r1, [r2, #0]
  4012ca:	4618      	mov	r0, r3
  4012cc:	2202      	movs	r2, #2
  4012ce:	9301      	str	r3, [sp, #4]
  4012d0:	4029      	ands	r1, r5
  4012d2:	47b0      	blx	r6
  4012d4:	2801      	cmp	r0, #1
  4012d6:	f47f af76 	bne.w	4011c6 <req_scan+0x9e>
  4012da:	4b33      	ldr	r3, [pc, #204]	; (4013a8 <req_scan+0x280>)
  4012dc:	781a      	ldrb	r2, [r3, #0]
  4012de:	2a00      	cmp	r2, #0
  4012e0:	f43f af71 	beq.w	4011c6 <req_scan+0x9e>
						if((i != c_f) && (i != f_max))
  4012e4:	9b00      	ldr	r3, [sp, #0]
  4012e6:	42a3      	cmp	r3, r4
  4012e8:	d033      	beq.n	401352 <req_scan+0x22a>
  4012ea:	7aba      	ldrb	r2, [r7, #10]
  4012ec:	42a2      	cmp	r2, r4
  4012ee:	d030      	beq.n	401352 <req_scan+0x22a>
						eereq |= msk(i);
  4012f0:	4b28      	ldr	r3, [pc, #160]	; (401394 <req_scan+0x26c>)
				get_ireq(i, ireq&msk(i));
  4012f2:	2202      	movs	r2, #2
  4012f4:	f8d9 1000 	ldr.w	r1, [r9]
  4012f8:	4640      	mov	r0, r8
						eereq |= msk(i);
  4012fa:	681b      	ldr	r3, [r3, #0]
				get_ireq(i, ireq&msk(i));
  4012fc:	4029      	ands	r1, r5
						eereq |= msk(i);
  4012fe:	ea43 0e05 	orr.w	lr, r3, r5
  401302:	4b24      	ldr	r3, [pc, #144]	; (401394 <req_scan+0x26c>)
  401304:	f8c3 e000 	str.w	lr, [r3]
				get_ireq(i, ireq&msk(i));
  401308:	47b0      	blx	r6
				get_ereq(i, ereq&msk(i));
  40130a:	f8db 1000 	ldr.w	r1, [fp]
  40130e:	2202      	movs	r2, #2
  401310:	4650      	mov	r0, sl
  401312:	4029      	ands	r1, r5
  401314:	47b0      	blx	r6
				if (collect == 2) get_eereq(i, eereq&msk(i));
  401316:	78ba      	ldrb	r2, [r7, #2]
  401318:	9b01      	ldr	r3, [sp, #4]
  40131a:	2a02      	cmp	r2, #2
  40131c:	f47f af66 	bne.w	4011ec <req_scan+0xc4>
  401320:	e7b2      	b.n	401288 <req_scan+0x160>
					if(collect == 2) set_eereq_ledMask(i, 1);
  401322:	2101      	movs	r1, #1
  401324:	f044 6020 	orr.w	r0, r4, #167772160	; 0xa000000
  401328:	47b0      	blx	r6
  40132a:	7abb      	ldrb	r3, [r7, #10]
  40132c:	e71a      	b.n	401164 <req_scan+0x3c>
	if(ireq|ereq|eereq) light_timer_reset();
  40132e:	4b20      	ldr	r3, [pc, #128]	; (4013b0 <req_scan+0x288>)
  401330:	4798      	blx	r3
  401332:	e70a      	b.n	40114a <req_scan+0x22>
			set_ireq_ledMask (f_max + 1, 1);
  401334:	3301      	adds	r3, #1
  401336:	2202      	movs	r2, #2
  401338:	2101      	movs	r1, #1
  40133a:	4c1a      	ldr	r4, [pc, #104]	; (4013a4 <req_scan+0x27c>)
  40133c:	f043 60c0 	orr.w	r0, r3, #100663296	; 0x6000000
  401340:	47a0      	blx	r4
			set_ireq_ledMask (f_max + 2, 1);
  401342:	7ab8      	ldrb	r0, [r7, #10]
  401344:	2202      	movs	r2, #2
  401346:	2101      	movs	r1, #1
  401348:	4410      	add	r0, r2
  40134a:	f040 60c0 	orr.w	r0, r0, #100663296	; 0x6000000
  40134e:	47a0      	blx	r4
  401350:	e761      	b.n	401216 <req_scan+0xee>
						else auto_reopen_door();//reopen door automatic
  401352:	4b18      	ldr	r3, [pc, #96]	; (4013b4 <req_scan+0x28c>)
  401354:	4798      	blx	r3
  401356:	e736      	b.n	4011c6 <req_scan+0x9e>
						else auto_reopen_door();//reopen door automatic
  401358:	4b16      	ldr	r3, [pc, #88]	; (4013b4 <req_scan+0x28c>)
  40135a:	4798      	blx	r3
  40135c:	e730      	b.n	4011c0 <req_scan+0x98>
					set_ireq_ledMask(i, 0);
  40135e:	9b00      	ldr	r3, [sp, #0]
  401360:	2202      	movs	r2, #2
  401362:	2100      	movs	r1, #0
  401364:	f043 60c0 	orr.w	r0, r3, #100663296	; 0x6000000
  401368:	47b0      	blx	r6
					set_ereq_ledMask(i, ereq&msk(i));
  40136a:	f8db 1000 	ldr.w	r1, [fp]
  40136e:	9b00      	ldr	r3, [sp, #0]
  401370:	2202      	movs	r2, #2
  401372:	4029      	ands	r1, r5
  401374:	f043 6010 	orr.w	r0, r3, #150994944	; 0x9000000
  401378:	47b0      	blx	r6
					if(collect == 2) set_eereq_ledMask(i, eereq&msk(i));
  40137a:	78ba      	ldrb	r2, [r7, #2]
  40137c:	2a02      	cmp	r2, #2
  40137e:	f47f af43 	bne.w	401208 <req_scan+0xe0>
  401382:	4b04      	ldr	r3, [pc, #16]	; (401394 <req_scan+0x26c>)
  401384:	6819      	ldr	r1, [r3, #0]
  401386:	9b00      	ldr	r3, [sp, #0]
  401388:	4029      	ands	r1, r5
  40138a:	f043 6020 	orr.w	r0, r3, #167772160	; 0xa000000
  40138e:	47b0      	blx	r6
  401390:	e73a      	b.n	401208 <req_scan+0xe0>
  401392:	bf00      	nop
  401394:	20400830 	.word	0x20400830
  401398:	204008f0 	.word	0x204008f0
  40139c:	204052b4 	.word	0x204052b4
  4013a0:	00400e15 	.word	0x00400e15
  4013a4:	0040d879 	.word	0x0040d879
  4013a8:	20400840 	.word	0x20400840
  4013ac:	00400f61 	.word	0x00400f61
  4013b0:	0040180d 	.word	0x0040180d
  4013b4:	004083d5 	.word	0x004083d5
  4013b8:	20400838 	.word	0x20400838
  4013bc:	20400834 	.word	0x20400834

004013c0 <get_nearest_floor>:
    }   
}


int get_nearest_floor(char type)
{
  4013c0:	b538      	push	{r3, r4, r5, lr}
  4013c2:	4605      	mov	r5, r0
    char current_f,c_start;
    int i;
    unsigned int search_pattern;//to search in
    current_f=get_current_floor();
  4013c4:	4b1c      	ldr	r3, [pc, #112]	; (401438 <get_nearest_floor+0x78>)
  4013c6:	4798      	blx	r3
    switch(type)
  4013c8:	2d03      	cmp	r5, #3
  4013ca:	d808      	bhi.n	4013de <get_nearest_floor+0x1e>
  4013cc:	e8df f005 	tbb	[pc, r5]
  4013d0:	02272d30 	.word	0x02272d30
        break;
        case r_dir_both:
            search_pattern=ireq|eereq;
        break;    
		case r_dir_both_down:
		search_pattern = ireq|ereq;
  4013d4:	4a19      	ldr	r2, [pc, #100]	; (40143c <get_nearest_floor+0x7c>)
  4013d6:	4b1a      	ldr	r3, [pc, #104]	; (401440 <get_nearest_floor+0x80>)
  4013d8:	6814      	ldr	r4, [r2, #0]
  4013da:	681b      	ldr	r3, [r3, #0]
  4013dc:	431c      	orrs	r4, r3
		break;
	}
        
    if(!direction_up)
  4013de:	4b19      	ldr	r3, [pc, #100]	; (401444 <get_nearest_floor+0x84>)
  4013e0:	781b      	ldrb	r3, [r3, #0]
  4013e2:	b943      	cbnz	r3, 4013f6 <get_nearest_floor+0x36>
    {
        c_start=current_f;
        /*
        if(infloorzone()==0)
            ++c_start;    */
        for(i=c_start; i>=0; i--)
  4013e4:	b2c0      	uxtb	r0, r0
        {
            if((search_pattern & msk(i))!=0)
  4013e6:	fa24 f300 	lsr.w	r3, r4, r0
  4013ea:	07dd      	lsls	r5, r3, #31
  4013ec:	d416      	bmi.n	40141c <get_nearest_floor+0x5c>
        for(i=c_start; i>=0; i--)
  4013ee:	f110 30ff 	adds.w	r0, r0, #4294967295
  4013f2:	d2f8      	bcs.n	4013e6 <get_nearest_floor+0x26>
  4013f4:	bd38      	pop	{r3, r4, r5, pc}
        }
        return -1;
    }
    else
    {
        for(i=current_f; i<=f_max; i++)//till maximum floor search
  4013f6:	4b14      	ldr	r3, [pc, #80]	; (401448 <get_nearest_floor+0x88>)
  4013f8:	b2c0      	uxtb	r0, r0
  4013fa:	7a9a      	ldrb	r2, [r3, #10]
  4013fc:	4290      	cmp	r0, r2
  4013fe:	dc0b      	bgt.n	401418 <get_nearest_floor+0x58>
        {
            if((search_pattern & msk(i))!=0)
  401400:	fa24 f300 	lsr.w	r3, r4, r0
  401404:	07d9      	lsls	r1, r3, #31
  401406:	d502      	bpl.n	40140e <get_nearest_floor+0x4e>
  401408:	e015      	b.n	401436 <get_nearest_floor+0x76>
  40140a:	07db      	lsls	r3, r3, #31
  40140c:	d406      	bmi.n	40141c <get_nearest_floor+0x5c>
        for(i=current_f; i<=f_max; i++)//till maximum floor search
  40140e:	3001      	adds	r0, #1
  401410:	4290      	cmp	r0, r2
            if((search_pattern & msk(i))!=0)
  401412:	fa24 f300 	lsr.w	r3, r4, r0
        for(i=current_f; i<=f_max; i++)//till maximum floor search
  401416:	ddf8      	ble.n	40140a <get_nearest_floor+0x4a>
        return -1;
  401418:	f04f 30ff 	mov.w	r0, #4294967295
                return i;
        }
        return -1;    
    }

}
  40141c:	bd38      	pop	{r3, r4, r5, pc}
            search_pattern=ireq|eereq;
  40141e:	4a07      	ldr	r2, [pc, #28]	; (40143c <get_nearest_floor+0x7c>)
  401420:	4b0a      	ldr	r3, [pc, #40]	; (40144c <get_nearest_floor+0x8c>)
  401422:	6814      	ldr	r4, [r2, #0]
  401424:	681b      	ldr	r3, [r3, #0]
  401426:	431c      	orrs	r4, r3
        break;    
  401428:	e7d9      	b.n	4013de <get_nearest_floor+0x1e>
            search_pattern=ereq;
  40142a:	4b05      	ldr	r3, [pc, #20]	; (401440 <get_nearest_floor+0x80>)
  40142c:	681c      	ldr	r4, [r3, #0]
        break;
  40142e:	e7d6      	b.n	4013de <get_nearest_floor+0x1e>
            search_pattern=ireq;
  401430:	4b02      	ldr	r3, [pc, #8]	; (40143c <get_nearest_floor+0x7c>)
  401432:	681c      	ldr	r4, [r3, #0]
        break;
  401434:	e7d3      	b.n	4013de <get_nearest_floor+0x1e>
  401436:	bd38      	pop	{r3, r4, r5, pc}
  401438:	00400e15 	.word	0x00400e15
  40143c:	20400838 	.word	0x20400838
  401440:	20400834 	.word	0x20400834
  401444:	20400c66 	.word	0x20400c66
  401448:	204052b4 	.word	0x204052b4
  40144c:	20400830 	.word	0x20400830

00401450 <down_coll>:
{
  401450:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if(get_current_floor() > f_max) 
  401454:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 401524 <down_coll+0xd4>
  401458:	4b2c      	ldr	r3, [pc, #176]	; (40150c <down_coll+0xbc>)
  40145a:	4798      	blx	r3
  40145c:	f89a 300a 	ldrb.w	r3, [sl, #10]
  401460:	4298      	cmp	r0, r3
  401462:	d84d      	bhi.n	401500 <down_coll+0xb0>
    if((ireq|ereq)==0)//if there no request left exit this function
  401464:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 401528 <down_coll+0xd8>
  401468:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 40152c <down_coll+0xdc>
  40146c:	f8d8 2000 	ldr.w	r2, [r8]
  401470:	f8d9 3000 	ldr.w	r3, [r9]
  401474:	4313      	orrs	r3, r2
  401476:	d03c      	beq.n	4014f2 <down_coll+0xa2>
  401478:	4f25      	ldr	r7, [pc, #148]	; (401510 <down_coll+0xc0>)
    nearest_int_floor=get_nearest_floor(r_internal);
  40147a:	2600      	movs	r6, #0
  40147c:	4d25      	ldr	r5, [pc, #148]	; (401514 <down_coll+0xc4>)
                if((auto_instate(auto_hspd)==1)||(auto_instate(auto_lspd)==1))
  40147e:	4c26      	ldr	r4, [pc, #152]	; (401518 <down_coll+0xc8>)
    nearest_int_floor=get_nearest_floor(r_internal);
  401480:	2000      	movs	r0, #0
  401482:	47b8      	blx	r7
  401484:	4683      	mov	fp, r0
        nearest_ext_floor = get_nearest_floor(r_external);
  401486:	2001      	movs	r0, #1
  401488:	47b8      	blx	r7
        break;
        case r_eexternal:
			search_pattern=eereq;
        break;
		case r_dir_both:
            search_pattern=ireq|ereq;
  40148a:	f8d8 2000 	ldr.w	r2, [r8]
  40148e:	f8d9 3000 	ldr.w	r3, [r9]
        nearest_ext_floor = get_nearest_floor(r_external);
  401492:	4601      	mov	r1, r0
        break;    
    }
        

        for(i=f_max;i>=0;i--)
  401494:	f89a 000a 	ldrb.w	r0, [sl, #10]
            search_pattern=ireq|ereq;
  401498:	431a      	orrs	r2, r3
        {
            if((search_pattern & msk(i))!=0)
  40149a:	fa22 f300 	lsr.w	r3, r2, r0
  40149e:	07db      	lsls	r3, r3, #31
  4014a0:	d402      	bmi.n	4014a8 <down_coll+0x58>
        for(i=f_max;i>=0;i--)
  4014a2:	f110 30ff 	adds.w	r0, r0, #4294967295
  4014a6:	d2f8      	bcs.n	40149a <down_coll+0x4a>
    if(direction_up)    
  4014a8:	782b      	ldrb	r3, [r5, #0]
  4014aa:	b16b      	cbz	r3, 4014c8 <down_coll+0x78>
        if(nearest_int_floor!=-1)//there is internal request to serve
  4014ac:	f1bb 3fff 	cmp.w	fp, #4294967295
  4014b0:	d123      	bne.n	4014fa <down_coll+0xaa>
            if(nearest_ext_floor!=-1)//there is external floor in that direction
  4014b2:	3101      	adds	r1, #1
  4014b4:	d122      	bne.n	4014fc <down_coll+0xac>
                if((auto_instate(auto_hspd)==1)||(auto_instate(auto_lspd)==1))
  4014b6:	2001      	movs	r0, #1
  4014b8:	47a0      	blx	r4
  4014ba:	2801      	cmp	r0, #1
  4014bc:	d019      	beq.n	4014f2 <down_coll+0xa2>
  4014be:	2002      	movs	r0, #2
  4014c0:	47a0      	blx	r4
  4014c2:	2801      	cmp	r0, #1
  4014c4:	d015      	beq.n	4014f2 <down_coll+0xa2>
                    direction_up=0;
  4014c6:	702e      	strb	r6, [r5, #0]
            nearest_ext_floor=get_nearest_floor(r_dir_both_down);//get mixed (internal and external) down calls    
  4014c8:	2003      	movs	r0, #3
  4014ca:	47b8      	blx	r7
        if(nearest_ext_floor==-1)//down direction is empty
  4014cc:	1c43      	adds	r3, r0, #1
  4014ce:	d115      	bne.n	4014fc <down_coll+0xac>
            if((auto_instate(auto_hspd)==1)||(auto_instate(auto_lspd)==1))
  4014d0:	2001      	movs	r0, #1
  4014d2:	47a0      	blx	r4
  4014d4:	2801      	cmp	r0, #1
  4014d6:	d00c      	beq.n	4014f2 <down_coll+0xa2>
  4014d8:	2002      	movs	r0, #2
  4014da:	47a0      	blx	r4
  4014dc:	2801      	cmp	r0, #1
  4014de:	d008      	beq.n	4014f2 <down_coll+0xa2>
    if((ireq|ereq)==0)//if there no request left exit this function
  4014e0:	f8d8 2000 	ldr.w	r2, [r8]
            direction_up=1;
  4014e4:	f04f 0101 	mov.w	r1, #1
    if((ireq|ereq)==0)//if there no request left exit this function
  4014e8:	f8d9 3000 	ldr.w	r3, [r9]
            direction_up=1;
  4014ec:	7029      	strb	r1, [r5, #0]
    if((ireq|ereq)==0)//if there no request left exit this function
  4014ee:	4313      	orrs	r3, r2
  4014f0:	d1c6      	bne.n	401480 <down_coll+0x30>
		return -1;	
  4014f2:	f04f 30ff 	mov.w	r0, #4294967295
  4014f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    nearest_int_floor=get_nearest_floor(r_internal);
  4014fa:	4658      	mov	r0, fp
}
  4014fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		selector_counter = 0;
  401500:	4a06      	ldr	r2, [pc, #24]	; (40151c <down_coll+0xcc>)
  401502:	2100      	movs	r1, #0
		drop_all_req();
  401504:	4b06      	ldr	r3, [pc, #24]	; (401520 <down_coll+0xd0>)
		selector_counter = 0;
  401506:	6011      	str	r1, [r2, #0]
		drop_all_req();
  401508:	4798      	blx	r3
  40150a:	e7f2      	b.n	4014f2 <down_coll+0xa2>
  40150c:	00400e15 	.word	0x00400e15
  401510:	004013c1 	.word	0x004013c1
  401514:	20400c66 	.word	0x20400c66
  401518:	004081c5 	.word	0x004081c5
  40151c:	20400014 	.word	0x20400014
  401520:	00401079 	.word	0x00401079
  401524:	204052b4 	.word	0x204052b4
  401528:	20400838 	.word	0x20400838
  40152c:	20400834 	.word	0x20400834

00401530 <all_coll>:
{
  401530:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if((ireq|ereq|eereq)==0)//if there no request left exit this function
  401534:	4b33      	ldr	r3, [pc, #204]	; (401604 <all_coll+0xd4>)
  401536:	4d34      	ldr	r5, [pc, #208]	; (401608 <all_coll+0xd8>)
  401538:	681b      	ldr	r3, [r3, #0]
  40153a:	682a      	ldr	r2, [r5, #0]
  40153c:	4e33      	ldr	r6, [pc, #204]	; (40160c <all_coll+0xdc>)
  40153e:	4313      	orrs	r3, r2
  401540:	6832      	ldr	r2, [r6, #0]
  401542:	4313      	orrs	r3, r2
  401544:	d033      	beq.n	4015ae <all_coll+0x7e>
    if(direction_up)
  401546:	4f32      	ldr	r7, [pc, #200]	; (401610 <all_coll+0xe0>)
  401548:	783b      	ldrb	r3, [r7, #0]
  40154a:	b9e3      	cbnz	r3, 401586 <all_coll+0x56>
  40154c:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 401620 <all_coll+0xf0>
		nearest_both_floor=get_nearest_floor(r_dir_both_down);//get mixed (internal and external) down calls    
  401550:	2003      	movs	r0, #3
  401552:	47c0      	blx	r8
        if(nearest_both_floor == -1 ) nearest_both_floor = get_lowest_floor(r_eexternal);
  401554:	1c43      	adds	r3, r0, #1
		nearest_both_floor=get_nearest_floor(r_dir_both_down);//get mixed (internal and external) down calls    
  401556:	4604      	mov	r4, r0
        if(nearest_both_floor == -1 ) nearest_both_floor = get_lowest_floor(r_eexternal);
  401558:	d040      	beq.n	4015dc <all_coll+0xac>
		if ( (nearest_both_floor != -1) && (nearest_both_floor > get_current_floor()) )
  40155a:	4b2e      	ldr	r3, [pc, #184]	; (401614 <all_coll+0xe4>)
  40155c:	4798      	blx	r3
  40155e:	42a0      	cmp	r0, r4
  401560:	d227      	bcs.n	4015b2 <all_coll+0x82>
            if((auto_instate(auto_hspd)==1)||(auto_instate(auto_lspd)==1)||(auto_instate(auto_stopping)==1))
  401562:	2001      	movs	r0, #1
  401564:	4c2c      	ldr	r4, [pc, #176]	; (401618 <all_coll+0xe8>)
  401566:	47a0      	blx	r4
  401568:	2801      	cmp	r0, #1
  40156a:	d020      	beq.n	4015ae <all_coll+0x7e>
  40156c:	2002      	movs	r0, #2
  40156e:	47a0      	blx	r4
  401570:	2801      	cmp	r0, #1
  401572:	d01c      	beq.n	4015ae <all_coll+0x7e>
  401574:	2007      	movs	r0, #7
  401576:	47a0      	blx	r4
  401578:	2801      	cmp	r0, #1
  40157a:	d018      	beq.n	4015ae <all_coll+0x7e>
            direction_up=1;
  40157c:	2301      	movs	r3, #1
}
  40157e:	4620      	mov	r0, r4
            direction_up=1;
  401580:	703b      	strb	r3, [r7, #0]
}
  401582:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		nearest_both_floor = get_nearest_floor(r_dir_both); //get mixed internal and external up calls
  401586:	2002      	movs	r0, #2
  401588:	f8df 8094 	ldr.w	r8, [pc, #148]	; 401620 <all_coll+0xf0>
  40158c:	47c0      	blx	r8
		if(nearest_both_floor == -1 ) nearest_both_floor = get_highest_floor(r_external);
  40158e:	1c43      	adds	r3, r0, #1
		nearest_both_floor = get_nearest_floor(r_dir_both); //get mixed internal and external up calls
  401590:	4604      	mov	r4, r0
		if(nearest_both_floor == -1 ) nearest_both_floor = get_highest_floor(r_external);
  401592:	d018      	beq.n	4015c6 <all_coll+0x96>
		if ( (nearest_both_floor != -1) && (nearest_both_floor < get_current_floor()) )
  401594:	4b1f      	ldr	r3, [pc, #124]	; (401614 <all_coll+0xe4>)
  401596:	4798      	blx	r3
  401598:	42a0      	cmp	r0, r4
  40159a:	d90a      	bls.n	4015b2 <all_coll+0x82>
                if((auto_instate(auto_hspd)==1)||(auto_instate(auto_lspd)==1)||(auto_instate(auto_stopping)==1))
  40159c:	2001      	movs	r0, #1
  40159e:	4c1e      	ldr	r4, [pc, #120]	; (401618 <all_coll+0xe8>)
  4015a0:	47a0      	blx	r4
  4015a2:	2801      	cmp	r0, #1
  4015a4:	d003      	beq.n	4015ae <all_coll+0x7e>
  4015a6:	2002      	movs	r0, #2
  4015a8:	47a0      	blx	r4
  4015aa:	2801      	cmp	r0, #1
  4015ac:	d104      	bne.n	4015b8 <all_coll+0x88>
            return -1;
  4015ae:	f04f 34ff 	mov.w	r4, #4294967295
}
  4015b2:	4620      	mov	r0, r4
  4015b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                if((auto_instate(auto_hspd)==1)||(auto_instate(auto_lspd)==1)||(auto_instate(auto_stopping)==1))
  4015b8:	2007      	movs	r0, #7
  4015ba:	47a0      	blx	r4
  4015bc:	2801      	cmp	r0, #1
  4015be:	d0f6      	beq.n	4015ae <all_coll+0x7e>
                    direction_up=0;
  4015c0:	2300      	movs	r3, #0
  4015c2:	703b      	strb	r3, [r7, #0]
  4015c4:	e7c4      	b.n	401550 <all_coll+0x20>
        for(i=f_max;i>=0;i--)
  4015c6:	4b15      	ldr	r3, [pc, #84]	; (40161c <all_coll+0xec>)
            search_pattern=ereq;
  4015c8:	682a      	ldr	r2, [r5, #0]
        for(i=f_max;i>=0;i--)
  4015ca:	7a9c      	ldrb	r4, [r3, #10]
            if((search_pattern & msk(i))!=0)
  4015cc:	fa22 f304 	lsr.w	r3, r2, r4
  4015d0:	07dd      	lsls	r5, r3, #31
  4015d2:	d4df      	bmi.n	401594 <all_coll+0x64>
        for(i=f_max;i>=0;i--)
  4015d4:	f114 34ff 	adds.w	r4, r4, #4294967295
  4015d8:	d2f8      	bcs.n	4015cc <all_coll+0x9c>
  4015da:	e7df      	b.n	40159c <all_coll+0x6c>
        break;
        case r_external:
            search_pattern=ereq;
        break;
        case r_eexternal:
			search_pattern=eereq;
  4015dc:	6832      	ldr	r2, [r6, #0]
            search_pattern=ireq|ereq;
        break;    
    }
        

        for(i=0;i<=f_max;i++)
  4015de:	4b0f      	ldr	r3, [pc, #60]	; (40161c <all_coll+0xec>)
        {
            if((search_pattern & msk(i))!=0)
  4015e0:	f012 0401 	ands.w	r4, r2, #1
        for(i=0;i<=f_max;i++)
  4015e4:	7a99      	ldrb	r1, [r3, #10]
            if((search_pattern & msk(i))!=0)
  4015e6:	d002      	beq.n	4015ee <all_coll+0xbe>
  4015e8:	e007      	b.n	4015fa <all_coll+0xca>
  4015ea:	07d8      	lsls	r0, r3, #31
  4015ec:	d4b5      	bmi.n	40155a <all_coll+0x2a>
        for(i=0;i<=f_max;i++)
  4015ee:	3401      	adds	r4, #1
  4015f0:	42a1      	cmp	r1, r4
            if((search_pattern & msk(i))!=0)
  4015f2:	fa22 f304 	lsr.w	r3, r2, r4
        for(i=0;i<=f_max;i++)
  4015f6:	daf8      	bge.n	4015ea <all_coll+0xba>
  4015f8:	e7b3      	b.n	401562 <all_coll+0x32>
		if ( (nearest_both_floor != -1) && (nearest_both_floor > get_current_floor()) )
  4015fa:	4b06      	ldr	r3, [pc, #24]	; (401614 <all_coll+0xe4>)
        for(i=0;i<=f_max;i++)
  4015fc:	2400      	movs	r4, #0
		if ( (nearest_both_floor != -1) && (nearest_both_floor > get_current_floor()) )
  4015fe:	4798      	blx	r3
  401600:	e7d7      	b.n	4015b2 <all_coll+0x82>
  401602:	bf00      	nop
  401604:	20400838 	.word	0x20400838
  401608:	20400834 	.word	0x20400834
  40160c:	20400830 	.word	0x20400830
  401610:	20400c66 	.word	0x20400c66
  401614:	00400e15 	.word	0x00400e15
  401618:	004081c5 	.word	0x004081c5
  40161c:	204052b4 	.word	0x204052b4
  401620:	004013c1 	.word	0x004013c1

00401624 <get_scheduled_floor>:
	switch (collect)
  401624:	4b0f      	ldr	r3, [pc, #60]	; (401664 <get_scheduled_floor+0x40>)
{
  401626:	b570      	push	{r4, r5, r6, lr}
	switch (collect)
  401628:	789b      	ldrb	r3, [r3, #2]
  40162a:	2b01      	cmp	r3, #1
  40162c:	d006      	beq.n	40163c <get_scheduled_floor+0x18>
  40162e:	d305      	bcc.n	40163c <get_scheduled_floor+0x18>
  401630:	2b02      	cmp	r3, #2
  401632:	d115      	bne.n	401660 <get_scheduled_floor+0x3c>
		temp = all_coll();
  401634:	4b0c      	ldr	r3, [pc, #48]	; (401668 <get_scheduled_floor+0x44>)
  401636:	4798      	blx	r3
  401638:	4604      	mov	r4, r0
		break;
  40163a:	e002      	b.n	401642 <get_scheduled_floor+0x1e>
		temp = down_coll();
  40163c:	4b0b      	ldr	r3, [pc, #44]	; (40166c <get_scheduled_floor+0x48>)
  40163e:	4798      	blx	r3
  401640:	4604      	mov	r4, r0
	if(temp!=-1)
  401642:	1c63      	adds	r3, r4, #1
  401644:	d00a      	beq.n	40165c <get_scheduled_floor+0x38>
		ar_up(direction_up);
  401646:	4e0a      	ldr	r6, [pc, #40]	; (401670 <get_scheduled_floor+0x4c>)
  401648:	2004      	movs	r0, #4
  40164a:	4d0a      	ldr	r5, [pc, #40]	; (401674 <get_scheduled_floor+0x50>)
  40164c:	7831      	ldrb	r1, [r6, #0]
  40164e:	47a8      	blx	r5
		ar_dwn(!direction_up);
  401650:	7831      	ldrb	r1, [r6, #0]
  401652:	2005      	movs	r0, #5
  401654:	fab1 f181 	clz	r1, r1
  401658:	40c1      	lsrs	r1, r0
  40165a:	47a8      	blx	r5
}
  40165c:	4620      	mov	r0, r4
  40165e:	bd70      	pop	{r4, r5, r6, pc}
	switch (collect)
  401660:	2400      	movs	r4, #0
  401662:	e7ee      	b.n	401642 <get_scheduled_floor+0x1e>
  401664:	204052b4 	.word	0x204052b4
  401668:	00401531 	.word	0x00401531
  40166c:	00401451 	.word	0x00401451
  401670:	20400c66 	.word	0x20400c66
  401674:	00400941 	.word	0x00400941

00401678 <light_timer_ton>:
void light_timer_reset(void)
{
	sph_timer_reset(light_tmer_indx);
}
void light_timer_ton(void)
{
  401678:	b510      	push	{r4, lr}
	march_light(1);
  40167a:	2101      	movs	r1, #1
  40167c:	2002      	movs	r0, #2
  40167e:	4b05      	ldr	r3, [pc, #20]	; (401694 <light_timer_ton+0x1c>)
  401680:	4798      	blx	r3
  401682:	2202      	movs	r2, #2
  401684:	2101      	movs	r1, #1
  401686:	f04f 60e0 	mov.w	r0, #117440512	; 0x7000000
  40168a:	4b03      	ldr	r3, [pc, #12]	; (401698 <light_timer_ton+0x20>)
}
  40168c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	march_light(1);
  401690:	4718      	bx	r3
  401692:	bf00      	nop
  401694:	00400941 	.word	0x00400941
  401698:	0040d879 	.word	0x0040d879

0040169c <light_timer_turnOff>:
void light_timer_turnOff(void)
{
  40169c:	b510      	push	{r4, lr}
	march_light(0);
  40169e:	2100      	movs	r1, #0
  4016a0:	2002      	movs	r0, #2
  4016a2:	4b05      	ldr	r3, [pc, #20]	; (4016b8 <light_timer_turnOff+0x1c>)
  4016a4:	4798      	blx	r3
  4016a6:	2202      	movs	r2, #2
  4016a8:	2100      	movs	r1, #0
  4016aa:	f04f 60e0 	mov.w	r0, #117440512	; 0x7000000
  4016ae:	4b03      	ldr	r3, [pc, #12]	; (4016bc <light_timer_turnOff+0x20>)
}
  4016b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	march_light(0);
  4016b4:	4718      	bx	r3
  4016b6:	bf00      	nop
  4016b8:	00400941 	.word	0x00400941
  4016bc:	0040d879 	.word	0x0040d879

004016c0 <stop_idle_turnOn>:
{
  4016c0:	b510      	push	{r4, lr}
    if(auto_instate(auto_stop)==1)
  4016c2:	2003      	movs	r0, #3
  4016c4:	4b0a      	ldr	r3, [pc, #40]	; (4016f0 <stop_idle_turnOn+0x30>)
  4016c6:	4798      	blx	r3
  4016c8:	2801      	cmp	r0, #1
  4016ca:	d000      	beq.n	4016ce <stop_idle_turnOn+0xe>
  4016cc:	bd10      	pop	{r4, pc}
		if (ctb_light_curtain_fb) stop_idle_reset();
  4016ce:	2202      	movs	r2, #2
  4016d0:	2100      	movs	r1, #0
  4016d2:	4808      	ldr	r0, [pc, #32]	; (4016f4 <stop_idle_turnOn+0x34>)
  4016d4:	4b08      	ldr	r3, [pc, #32]	; (4016f8 <stop_idle_turnOn+0x38>)
  4016d6:	4798      	blx	r3
  4016d8:	b918      	cbnz	r0, 4016e2 <stop_idle_turnOn+0x22>
		else auto_idle_enter();
  4016da:	4b08      	ldr	r3, [pc, #32]	; (4016fc <stop_idle_turnOn+0x3c>)
}
  4016dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		else auto_idle_enter();
  4016e0:	4718      	bx	r3
	sph_timer_reset(stop_idle_delay_indx);
  4016e2:	4a07      	ldr	r2, [pc, #28]	; (401700 <stop_idle_turnOn+0x40>)
  4016e4:	4b07      	ldr	r3, [pc, #28]	; (401704 <stop_idle_turnOn+0x44>)
  4016e6:	6810      	ldr	r0, [r2, #0]
}
  4016e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	sph_timer_reset(stop_idle_delay_indx);
  4016ec:	4718      	bx	r3
  4016ee:	bf00      	nop
  4016f0:	004081c5 	.word	0x004081c5
  4016f4:	0b000006 	.word	0x0b000006
  4016f8:	0040d879 	.word	0x0040d879
  4016fc:	004083ed 	.word	0x004083ed
  401700:	20400c70 	.word	0x20400c70
  401704:	0040d099 	.word	0x0040d099

00401708 <timers_init>:
{
  401708:	b538      	push	{r3, r4, r5, lr}
void light_timer_init(void)
{
	light_tmer_indx = sph_timer_add(&menue_lift_data_applied.m_light_time, 1000, &light_timer_ton, &light_timer_turnOff);
  40170a:	4d09      	ldr	r5, [pc, #36]	; (401730 <timers_init+0x28>)
  40170c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  401710:	4b08      	ldr	r3, [pc, #32]	; (401734 <timers_init+0x2c>)
  401712:	4a09      	ldr	r2, [pc, #36]	; (401738 <timers_init+0x30>)
  401714:	4628      	mov	r0, r5
  401716:	4c09      	ldr	r4, [pc, #36]	; (40173c <timers_init+0x34>)
  401718:	47a0      	blx	r4
  40171a:	4909      	ldr	r1, [pc, #36]	; (401740 <timers_init+0x38>)
	stop_idle_delay_indx = sph_timer_add(&menue_lift_data_applied.m_stop_wait_time, 1000, 0, &stop_idle_turnOn);
  40171c:	4b09      	ldr	r3, [pc, #36]	; (401744 <timers_init+0x3c>)
  40171e:	2200      	movs	r2, #0
	light_tmer_indx = sph_timer_add(&menue_lift_data_applied.m_light_time, 1000, &light_timer_ton, &light_timer_turnOff);
  401720:	6008      	str	r0, [r1, #0]
	stop_idle_delay_indx = sph_timer_add(&menue_lift_data_applied.m_stop_wait_time, 1000, 0, &stop_idle_turnOn);
  401722:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  401726:	1e68      	subs	r0, r5, #1
  401728:	47a0      	blx	r4
  40172a:	4b07      	ldr	r3, [pc, #28]	; (401748 <timers_init+0x40>)
  40172c:	6018      	str	r0, [r3, #0]
  40172e:	bd38      	pop	{r3, r4, r5, pc}
  401730:	204052bb 	.word	0x204052bb
  401734:	0040169d 	.word	0x0040169d
  401738:	00401679 	.word	0x00401679
  40173c:	0040d05d 	.word	0x0040d05d
  401740:	20400c6c 	.word	0x20400c6c
  401744:	004016c1 	.word	0x004016c1
  401748:	20400c70 	.word	0x20400c70

0040174c <stop_idle_reset>:
	sph_timer_reset(stop_idle_delay_indx);
  40174c:	4a01      	ldr	r2, [pc, #4]	; (401754 <stop_idle_reset+0x8>)
  40174e:	4b02      	ldr	r3, [pc, #8]	; (401758 <stop_idle_reset+0xc>)
  401750:	6810      	ldr	r0, [r2, #0]
  401752:	4718      	bx	r3
  401754:	20400c70 	.word	0x20400c70
  401758:	0040d099 	.word	0x0040d099

0040175c <idle_camt_reset>:
	idle_camt_counter=0;
  40175c:	2300      	movs	r3, #0
  40175e:	4902      	ldr	r1, [pc, #8]	; (401768 <idle_camt_reset+0xc>)
	idle_camt_run=0;
  401760:	4a02      	ldr	r2, [pc, #8]	; (40176c <idle_camt_reset+0x10>)
	idle_camt_counter=0;
  401762:	600b      	str	r3, [r1, #0]
	idle_camt_run=0;
  401764:	6013      	str	r3, [r2, #0]
  401766:	4770      	bx	lr
  401768:	20400844 	.word	0x20400844
  40176c:	20400848 	.word	0x20400848

00401770 <idle_camt_turnOn>:
{
  401770:	b510      	push	{r4, lr}
	if (auto_instate(auto_idle) == 1)
  401772:	2005      	movs	r0, #5
  401774:	4b04      	ldr	r3, [pc, #16]	; (401788 <idle_camt_turnOn+0x18>)
  401776:	4798      	blx	r3
  401778:	2801      	cmp	r0, #1
  40177a:	d000      	beq.n	40177e <idle_camt_turnOn+0xe>
  40177c:	bd10      	pop	{r4, pc}
		auto_idle_exit();
  40177e:	4b03      	ldr	r3, [pc, #12]	; (40178c <idle_camt_turnOn+0x1c>)
}
  401780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		auto_idle_exit();
  401784:	4718      	bx	r3
  401786:	bf00      	nop
  401788:	004081c5 	.word	0x004081c5
  40178c:	004092a9 	.word	0x004092a9

00401790 <idle_camt_count>:
{
  401790:	b538      	push	{r3, r4, r5, lr}
	if(idle_camt_run) if((idle_camt_preset-idle_camt_counter)>0)
  401792:	4c0c      	ldr	r4, [pc, #48]	; (4017c4 <idle_camt_count+0x34>)
  401794:	6823      	ldr	r3, [r4, #0]
  401796:	b16b      	cbz	r3, 4017b4 <idle_camt_count+0x24>
  401798:	4b0b      	ldr	r3, [pc, #44]	; (4017c8 <idle_camt_count+0x38>)
  40179a:	4d0c      	ldr	r5, [pc, #48]	; (4017cc <idle_camt_count+0x3c>)
  40179c:	681a      	ldr	r2, [r3, #0]
  40179e:	682b      	ldr	r3, [r5, #0]
  4017a0:	429a      	cmp	r2, r3
  4017a2:	d005      	beq.n	4017b0 <idle_camt_count+0x20>
		if((idle_camt_preset-idle_camt_counter)==1)
  4017a4:	1ad2      	subs	r2, r2, r3
  4017a6:	2a01      	cmp	r2, #1
  4017a8:	d005      	beq.n	4017b6 <idle_camt_count+0x26>
		idle_camt_counter++;
  4017aa:	3301      	adds	r3, #1
  4017ac:	602b      	str	r3, [r5, #0]
  4017ae:	bd38      	pop	{r3, r4, r5, pc}
		idle_camt_run=0;
  4017b0:	2300      	movs	r3, #0
  4017b2:	6023      	str	r3, [r4, #0]
  4017b4:	bd38      	pop	{r3, r4, r5, pc}
			idle_camt_turnOn();
  4017b6:	4b06      	ldr	r3, [pc, #24]	; (4017d0 <idle_camt_count+0x40>)
  4017b8:	4798      	blx	r3
			idle_camt_run=0;
  4017ba:	2200      	movs	r2, #0
  4017bc:	682b      	ldr	r3, [r5, #0]
  4017be:	6022      	str	r2, [r4, #0]
  4017c0:	e7f3      	b.n	4017aa <idle_camt_count+0x1a>
  4017c2:	bf00      	nop
  4017c4:	20400848 	.word	0x20400848
  4017c8:	20400c68 	.word	0x20400c68
  4017cc:	20400844 	.word	0x20400844
  4017d0:	00401771 	.word	0x00401771

004017d4 <timer_count_handler>:
	idle_camt_count();
  4017d4:	4b00      	ldr	r3, [pc, #0]	; (4017d8 <timer_count_handler+0x4>)
  4017d6:	4718      	bx	r3
  4017d8:	00401791 	.word	0x00401791

004017dc <idle_camt_init>:
	idle_camt_preset=pre;
  4017dc:	4905      	ldr	r1, [pc, #20]	; (4017f4 <idle_camt_init+0x18>)
	idle_camt_run=0;
  4017de:	2200      	movs	r2, #0
  4017e0:	4b05      	ldr	r3, [pc, #20]	; (4017f8 <idle_camt_init+0x1c>)
{
  4017e2:	b410      	push	{r4}
	idle_camt_counter=pre;
  4017e4:	4c05      	ldr	r4, [pc, #20]	; (4017fc <idle_camt_init+0x20>)
	idle_camt_preset=pre;
  4017e6:	6008      	str	r0, [r1, #0]
	idle_camt_run=0;
  4017e8:	601a      	str	r2, [r3, #0]
	idle_camt_counter=pre;
  4017ea:	6020      	str	r0, [r4, #0]
}
  4017ec:	f85d 4b04 	ldr.w	r4, [sp], #4
  4017f0:	4770      	bx	lr
  4017f2:	bf00      	nop
  4017f4:	20400c68 	.word	0x20400c68
  4017f8:	20400848 	.word	0x20400848
  4017fc:	20400844 	.word	0x20400844

00401800 <idle_camt_start>:
	idle_camt_run=1;
  401800:	4b01      	ldr	r3, [pc, #4]	; (401808 <idle_camt_start+0x8>)
  401802:	2201      	movs	r2, #1
  401804:	601a      	str	r2, [r3, #0]
  401806:	4770      	bx	lr
  401808:	20400848 	.word	0x20400848

0040180c <light_timer_reset>:
	sph_timer_reset(light_tmer_indx);
  40180c:	4a01      	ldr	r2, [pc, #4]	; (401814 <light_timer_reset+0x8>)
  40180e:	4b02      	ldr	r3, [pc, #8]	; (401818 <light_timer_reset+0xc>)
  401810:	6810      	ldr	r0, [r2, #0]
  401812:	4718      	bx	r3
  401814:	20400c6c 	.word	0x20400c6c
  401818:	0040d099 	.word	0x0040d099

0040181c <check_elevator_inmotion>:
	}
	lcd_update();	
}

uByte_t check_elevator_inmotion(void)
{
  40181c:	b510      	push	{r4, lr}
	if(auto_instate(auto_stop)||auto_instate(auto_idle)||auto_instate(auto_camtest)) return 0;
  40181e:	2003      	movs	r0, #3
  401820:	4c07      	ldr	r4, [pc, #28]	; (401840 <check_elevator_inmotion+0x24>)
  401822:	47a0      	blx	r4
  401824:	b108      	cbz	r0, 40182a <check_elevator_inmotion+0xe>
  401826:	2000      	movs	r0, #0
  401828:	bd10      	pop	{r4, pc}
  40182a:	2005      	movs	r0, #5
  40182c:	47a0      	blx	r4
  40182e:	2800      	cmp	r0, #0
  401830:	d1f9      	bne.n	401826 <check_elevator_inmotion+0xa>
  401832:	2004      	movs	r0, #4
  401834:	47a0      	blx	r4
  401836:	fab0 f080 	clz	r0, r0
  40183a:	0940      	lsrs	r0, r0, #5
	else return 1;
}
  40183c:	bd10      	pop	{r4, pc}
  40183e:	bf00      	nop
  401840:	004081c5 	.word	0x004081c5

00401844 <main_screen_play>:

#define M_S_FLASH_MAX (7)
uint32_t main_screen_flsh_counter = 0;
void main_screen_play(void)
{
  401844:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t shiftchar = 0;
	
	if (++main_screen_flsh_counter > 2 * M_S_FLASH_MAX) main_screen_flsh_counter = 0;
  401848:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 401a40 <main_screen_play+0x1fc>
{
  40184c:	b08f      	sub	sp, #60	; 0x3c
	const char *str;
	char fault_code, fault_prefix;	
	int res;
	char *tmp;
	
	selc=selector_counter;
  40184e:	4a67      	ldr	r2, [pc, #412]	; (4019ec <main_screen_play+0x1a8>)
	if (++main_screen_flsh_counter > 2 * M_S_FLASH_MAX) main_screen_flsh_counter = 0;
  401850:	f8db 3000 	ldr.w	r3, [fp]
	selc=selector_counter;
  401854:	6815      	ldr	r5, [r2, #0]
	if (++main_screen_flsh_counter > 2 * M_S_FLASH_MAX) main_screen_flsh_counter = 0;
  401856:	3301      	adds	r3, #1
  401858:	2b0e      	cmp	r3, #14
  40185a:	bf88      	it	hi
  40185c:	2300      	movhi	r3, #0
  40185e:	f8cb 3000 	str.w	r3, [fp]
	glcd_clear();
  401862:	4b63      	ldr	r3, [pc, #396]	; (4019f0 <main_screen_play+0x1ac>)
  401864:	4798      	blx	r3
	glcd_gotoxy(0,0);
  401866:	2100      	movs	r1, #0
  401868:	4b62      	ldr	r3, [pc, #392]	; (4019f4 <main_screen_play+0x1b0>)
  40186a:	4608      	mov	r0, r1
  40186c:	4798      	blx	r3
	
	
	if (menue_lift_data_applied.m_direct_stop == 0)
  40186e:	4b62      	ldr	r3, [pc, #392]	; (4019f8 <main_screen_play+0x1b4>)
  401870:	f893 4080 	ldrb.w	r4, [r3, #128]	; 0x80
  401874:	2c00      	cmp	r4, #0
  401876:	f040 82a1 	bne.w	401dbc <main_screen_play+0x578>
	{
		shiftchar = 0;
		putIt('S');
  40187a:	4b60      	ldr	r3, [pc, #384]	; (4019fc <main_screen_play+0x1b8>)
  40187c:	2053      	movs	r0, #83	; 0x53
  40187e:	9302      	str	r3, [sp, #8]
  401880:	4798      	blx	r3
		glcd_puts(itos(selc),0);
  401882:	4b5f      	ldr	r3, [pc, #380]	; (401a00 <main_screen_play+0x1bc>)
  401884:	b2e8      	uxtb	r0, r5
  401886:	4a5f      	ldr	r2, [pc, #380]	; (401a04 <main_screen_play+0x1c0>)
  401888:	2100      	movs	r1, #0
  40188a:	9305      	str	r3, [sp, #20]
  40188c:	4615      	mov	r5, r2
  40188e:	9203      	str	r2, [sp, #12]
  401890:	4798      	blx	r3
  401892:	4621      	mov	r1, r4
  401894:	47a8      	blx	r5
  401896:	ab0b      	add	r3, sp, #44	; 0x2c
  401898:	242e      	movs	r4, #46	; 0x2e
  40189a:	2018      	movs	r0, #24
  40189c:	9301      	str	r3, [sp, #4]
  40189e:	4b5a      	ldr	r3, [pc, #360]	; (401a08 <main_screen_play+0x1c4>)
  4018a0:	4d5a      	ldr	r5, [pc, #360]	; (401a0c <main_screen_play+0x1c8>)
  4018a2:	9300      	str	r3, [sp, #0]
  4018a4:	4b5a      	ldr	r3, [pc, #360]	; (401a10 <main_screen_play+0x1cc>)
  4018a6:	9304      	str	r3, [sp, #16]
		glcd_puts(fixedpt_cstr(lift_speed, 2),0);
		glcd_putsf("M/s",0);
	}
	
	
	glcd_gotoxy(24 + shiftchar,0);
  4018a8:	2100      	movs	r1, #0
  4018aa:	4b52      	ldr	r3, [pc, #328]	; (4019f4 <main_screen_play+0x1b0>)
  4018ac:	4798      	blx	r3
	if((mstop==0)&&((selc&1)==0)) putIt('=');
	putIt('F');
  4018ae:	2046      	movs	r0, #70	; 0x46
  4018b0:	9e02      	ldr	r6, [sp, #8]
  4018b2:	47b0      	blx	r6

	glcd_puts(itos(get_current_floor()), 0);
  4018b4:	4b57      	ldr	r3, [pc, #348]	; (401a14 <main_screen_play+0x1d0>)
  4018b6:	4798      	blx	r3
  4018b8:	2100      	movs	r1, #0
  4018ba:	9b05      	ldr	r3, [sp, #20]
  4018bc:	4798      	blx	r3
  4018be:	2100      	movs	r1, #0
  4018c0:	9b03      	ldr	r3, [sp, #12]
  4018c2:	4798      	blx	r3
		
	glcd_gotoxy(46 + shiftchar, 0);
  4018c4:	4b4b      	ldr	r3, [pc, #300]	; (4019f4 <main_screen_play+0x1b0>)
  4018c6:	4620      	mov	r0, r4
  4018c8:	2100      	movs	r1, #0
  4018ca:	4798      	blx	r3
	if(check_elevator_inmotion())
  4018cc:	4b52      	ldr	r3, [pc, #328]	; (401a18 <main_screen_play+0x1d4>)
  4018ce:	4798      	blx	r3
  4018d0:	2800      	cmp	r0, #0
  4018d2:	f000 8332 	beq.w	401f3a <main_screen_play+0x6f6>
	{
		//motion state
		if(direction_up)
  4018d6:	4b51      	ldr	r3, [pc, #324]	; (401a1c <main_screen_play+0x1d8>)
  4018d8:	781b      	ldrb	r3, [r3, #0]
  4018da:	2b00      	cmp	r3, #0
  4018dc:	f040 82f3 	bne.w	401ec6 <main_screen_play+0x682>
			putIt(0);
			req_mb_setUpMotion();
		}
		else
		{
			putIt(1);
  4018e0:	9b02      	ldr	r3, [sp, #8]
  4018e2:	2001      	movs	r0, #1
  4018e4:	4798      	blx	r3
			req_mb_setDnMotion();
  4018e6:	4b4e      	ldr	r3, [pc, #312]	; (401a20 <main_screen_play+0x1dc>)
  4018e8:	4798      	blx	r3
	else
	{
		req_mb_setStill();
	}
	if(mnt==0) req_mb_clrINS();
	if (selfLearn_isLearning()) glcd_putsf("LRN", 0);
  4018ea:	4b4e      	ldr	r3, [pc, #312]	; (401a24 <main_screen_play+0x1e0>)
  4018ec:	4798      	blx	r3
  4018ee:	4604      	mov	r4, r0
  4018f0:	2800      	cmp	r0, #0
  4018f2:	f000 82f2 	beq.w	401eda <main_screen_play+0x696>
  4018f6:	2100      	movs	r1, #0
  4018f8:	484b      	ldr	r0, [pc, #300]	; (401a28 <main_screen_play+0x1e4>)
  4018fa:	9b04      	ldr	r3, [sp, #16]
  4018fc:	4798      	blx	r3
		putIt('t');
		res=get_scheduled_floor();
		if(res==-1) glcd_putsf("__",0);
		else glcd_puts(itos(res),0);
	}
	glcd_gotoxy(92,0);
  4018fe:	4b3d      	ldr	r3, [pc, #244]	; (4019f4 <main_screen_play+0x1b0>)
  401900:	2100      	movs	r1, #0
  401902:	205c      	movs	r0, #92	; 0x5c
  401904:	4798      	blx	r3
	if (device_off) putIt('O');
  401906:	4b49      	ldr	r3, [pc, #292]	; (401a2c <main_screen_play+0x1e8>)
  401908:	681b      	ldr	r3, [r3, #0]
  40190a:	2b00      	cmp	r3, #0
  40190c:	f040 8318 	bne.w	401f40 <main_screen_play+0x6fc>
	else if (main_screen_flsh_counter < M_S_FLASH_MAX)
  401910:	f8db 3000 	ldr.w	r3, [fp]
  401914:	2b06      	cmp	r3, #6
  401916:	d808      	bhi.n	40192a <main_screen_play+0xe6>
	{
		if (menue_lift_data_applied.m_cont_dis_technique == 1) putIt('S');
  401918:	4b37      	ldr	r3, [pc, #220]	; (4019f8 <main_screen_play+0x1b4>)
  40191a:	f893 30c2 	ldrb.w	r3, [r3, #194]	; 0xc2
  40191e:	2b01      	cmp	r3, #1
  401920:	f000 8571 	beq.w	402406 <main_screen_play+0xbc2>
		else if (menue_lift_data_applied.m_cont_dis_technique == 2) putIt('T');
  401924:	2b02      	cmp	r3, #2
  401926:	f000 85ee 	beq.w	402506 <main_screen_play+0xcc2>
	}
	
		
	glcd_gotoxy(101,0);
  40192a:	2100      	movs	r1, #0
  40192c:	4b31      	ldr	r3, [pc, #196]	; (4019f4 <main_screen_play+0x1b0>)
  40192e:	2065      	movs	r0, #101	; 0x65
  401930:	4798      	blx	r3
	if(Estop) putIt('_');
  401932:	9c02      	ldr	r4, [sp, #8]
  401934:	205f      	movs	r0, #95	; 0x5f
  401936:	47a0      	blx	r4
	else putIt('P');
	glcd_gotoxy(108,0);
  401938:	2100      	movs	r1, #0
  40193a:	4b2e      	ldr	r3, [pc, #184]	; (4019f4 <main_screen_play+0x1b0>)
  40193c:	206c      	movs	r0, #108	; 0x6c
  40193e:	4798      	blx	r3
	if(lock) putIt('_');
  401940:	205f      	movs	r0, #95	; 0x5f
  401942:	47a0      	blx	r4
	else putIt('L');
	glcd_gotoxy(115,0);
  401944:	4b2b      	ldr	r3, [pc, #172]	; (4019f4 <main_screen_play+0x1b0>)
  401946:	2100      	movs	r1, #0
  401948:	2073      	movs	r0, #115	; 0x73
  40194a:	4798      	blx	r3
	if(vfd_enable_isEnabled()) putIt('_');
  40194c:	4b38      	ldr	r3, [pc, #224]	; (401a30 <main_screen_play+0x1ec>)
  40194e:	4798      	blx	r3
  401950:	2800      	cmp	r0, #0
  401952:	f000 82e9 	beq.w	401f28 <main_screen_play+0x6e4>
  401956:	205f      	movs	r0, #95	; 0x5f
  401958:	47a0      	blx	r4
	else putIt('E');
		
	glcd_gotoxy(122,0);
  40195a:	2100      	movs	r1, #0
  40195c:	207a      	movs	r0, #122	; 0x7a
  40195e:	4b25      	ldr	r3, [pc, #148]	; (4019f4 <main_screen_play+0x1b0>)
	if(shk==1) putIt('_');
	else putIt('F');
	
	
	glcd_gotoxy(0,9);
  401960:	f04f 0800 	mov.w	r8, #0
	glcd_gotoxy(122,0);
  401964:	4798      	blx	r3
	if(shk==1) putIt('_');
  401966:	9b02      	ldr	r3, [sp, #8]
  401968:	205f      	movs	r0, #95	; 0x5f
			else if((ereq&msk(i)))
			{
				//putIt(5);
				putIt(9);
			}
			else if((eereq&msk(i)))
  40196a:	46a9      	mov	r9, r5
	if(shk==1) putIt('_');
  40196c:	4798      	blx	r3
	glcd_gotoxy(0,9);
  40196e:	2109      	movs	r1, #9
  401970:	4640      	mov	r0, r8
  401972:	4a20      	ldr	r2, [pc, #128]	; (4019f4 <main_screen_play+0x1b0>)
  401974:	4790      	blx	r2
  401976:	4c2f      	ldr	r4, [pc, #188]	; (401a34 <main_screen_play+0x1f0>)
			//up down collective mode
			if((ireq&msk(i))!=0)
			{
				putIt(6);
			}
			else if((ereq&msk(i)))
  401978:	4e2f      	ldr	r6, [pc, #188]	; (401a38 <main_screen_play+0x1f4>)
			else if((eereq&msk(i)))
  40197a:	4f30      	ldr	r7, [pc, #192]	; (401a3c <main_screen_play+0x1f8>)
  40197c:	9d02      	ldr	r5, [sp, #8]
  40197e:	e00f      	b.n	4019a0 <main_screen_play+0x15c>
			if((ireq&msk(i))!=0)
  401980:	07d9      	lsls	r1, r3, #31
  401982:	f100 82b7 	bmi.w	401ef4 <main_screen_play+0x6b0>
			else if((ereq&msk(i)))
  401986:	6833      	ldr	r3, [r6, #0]
  401988:	fa23 f308 	lsr.w	r3, r3, r8
  40198c:	07da      	lsls	r2, r3, #31
  40198e:	f140 82ae 	bpl.w	401eee <main_screen_play+0x6aa>
			{
				putIt(5);
  401992:	2005      	movs	r0, #5
  401994:	47a8      	blx	r5
  401996:	f108 0801 	add.w	r8, r8, #1
	for(i=0;i<16;i++)
  40199a:	f1b8 0f10 	cmp.w	r8, #16
  40199e:	d01d      	beq.n	4019dc <main_screen_play+0x198>
		if(collect == 2)
  4019a0:	4b15      	ldr	r3, [pc, #84]	; (4019f8 <main_screen_play+0x1b4>)
  4019a2:	789b      	ldrb	r3, [r3, #2]
  4019a4:	2b02      	cmp	r3, #2
			if((ireq&msk(i))!=0)
  4019a6:	6823      	ldr	r3, [r4, #0]
  4019a8:	fa23 f308 	lsr.w	r3, r3, r8
		if(collect == 2)
  4019ac:	d1e8      	bne.n	401980 <main_screen_play+0x13c>
			if((ireq&msk(i))!=0)
  4019ae:	07da      	lsls	r2, r3, #31
  4019b0:	f100 82a0 	bmi.w	401ef4 <main_screen_play+0x6b0>
			else if((ereq&msk(i)) && (eereq&msk(i)))
  4019b4:	6833      	ldr	r3, [r6, #0]
  4019b6:	fa23 f308 	lsr.w	r3, r3, r8
  4019ba:	f013 0f01 	tst.w	r3, #1
  4019be:	683b      	ldr	r3, [r7, #0]
  4019c0:	fa23 f308 	lsr.w	r3, r3, r8
  4019c4:	f000 8299 	beq.w	401efa <main_screen_play+0x6b6>
  4019c8:	07db      	lsls	r3, r3, #31
  4019ca:	f108 0801 	add.w	r8, r8, #1
				putIt(10);
  4019ce:	bf4c      	ite	mi
  4019d0:	200a      	movmi	r0, #10
				putIt(9);
  4019d2:	2009      	movpl	r0, #9
  4019d4:	47a8      	blx	r5
	for(i=0;i<16;i++)
  4019d6:	f1b8 0f10 	cmp.w	r8, #16
  4019da:	d1e1      	bne.n	4019a0 <main_screen_play+0x15c>
		}
			
	}
	
	
	glcd_gotoxy(0,18);
  4019dc:	2112      	movs	r1, #18
  4019de:	2000      	movs	r0, #0
  4019e0:	4b04      	ldr	r3, [pc, #16]	; (4019f4 <main_screen_play+0x1b0>)
  4019e2:	4798      	blx	r3
			//up down collective mode
			if((ireq&msk(i+16))!=0)
			{
				putIt(6);
			}
			else if((ereq&msk(i+16)))
  4019e4:	4e14      	ldr	r6, [pc, #80]	; (401a38 <main_screen_play+0x1f4>)
			else if((eereq&msk(i+16)))
  4019e6:	4f15      	ldr	r7, [pc, #84]	; (401a3c <main_screen_play+0x1f8>)
	glcd_gotoxy(0,18);
  4019e8:	9d02      	ldr	r5, [sp, #8]
  4019ea:	e03b      	b.n	401a64 <main_screen_play+0x220>
  4019ec:	20400014 	.word	0x20400014
  4019f0:	0040c2e5 	.word	0x0040c2e5
  4019f4:	0040c7a5 	.word	0x0040c7a5
  4019f8:	204052b4 	.word	0x204052b4
  4019fc:	0040c755 	.word	0x0040c755
  401a00:	0040c205 	.word	0x0040c205
  401a04:	0040ca05 	.word	0x0040ca05
  401a08:	20400854 	.word	0x20400854
  401a0c:	004190fd 	.word	0x004190fd
  401a10:	0040c7b9 	.word	0x0040c7b9
  401a14:	00400e15 	.word	0x00400e15
  401a18:	0040181d 	.word	0x0040181d
  401a1c:	20400c66 	.word	0x20400c66
  401a20:	0040def1 	.word	0x0040def1
  401a24:	00404705 	.word	0x00404705
  401a28:	004199d0 	.word	0x004199d0
  401a2c:	204008f0 	.word	0x204008f0
  401a30:	00413241 	.word	0x00413241
  401a34:	20400838 	.word	0x20400838
  401a38:	20400834 	.word	0x20400834
  401a3c:	20400830 	.word	0x20400830
  401a40:	20400850 	.word	0x20400850
			if((ireq&msk(i+16))!=0)
  401a44:	07da      	lsls	r2, r3, #31
  401a46:	f100 8260 	bmi.w	401f0a <main_screen_play+0x6c6>
			else if((ereq&msk(i+16)))
  401a4a:	6833      	ldr	r3, [r6, #0]
  401a4c:	fa23 f308 	lsr.w	r3, r3, r8
  401a50:	07db      	lsls	r3, r3, #31
  401a52:	f140 8257 	bpl.w	401f04 <main_screen_play+0x6c0>
			{
				putIt(5);
  401a56:	2005      	movs	r0, #5
  401a58:	47a8      	blx	r5
  401a5a:	f108 0801 	add.w	r8, r8, #1
	for(i=0;i<8;i++)
  401a5e:	f1b8 0f18 	cmp.w	r8, #24
  401a62:	d01d      	beq.n	401aa0 <main_screen_play+0x25c>
		if(collect == 2)
  401a64:	4b98      	ldr	r3, [pc, #608]	; (401cc8 <main_screen_play+0x484>)
  401a66:	789b      	ldrb	r3, [r3, #2]
  401a68:	2b02      	cmp	r3, #2
			if((ireq&msk(i+16))!=0)
  401a6a:	6823      	ldr	r3, [r4, #0]
  401a6c:	fa23 f308 	lsr.w	r3, r3, r8
		if(collect == 2)
  401a70:	d1e8      	bne.n	401a44 <main_screen_play+0x200>
			if((ireq&msk(i+16))!=0)
  401a72:	07db      	lsls	r3, r3, #31
  401a74:	f100 8249 	bmi.w	401f0a <main_screen_play+0x6c6>
			else if((ereq&msk(i+16)) && (eereq&msk(i+16)))
  401a78:	6833      	ldr	r3, [r6, #0]
  401a7a:	fa23 f308 	lsr.w	r3, r3, r8
  401a7e:	f013 0f01 	tst.w	r3, #1
  401a82:	683b      	ldr	r3, [r7, #0]
  401a84:	fa23 f308 	lsr.w	r3, r3, r8
  401a88:	f000 8242 	beq.w	401f10 <main_screen_play+0x6cc>
  401a8c:	07d8      	lsls	r0, r3, #31
  401a8e:	f108 0801 	add.w	r8, r8, #1
				putIt(10);
  401a92:	bf4c      	ite	mi
  401a94:	200a      	movmi	r0, #10
				putIt(9);
  401a96:	2009      	movpl	r0, #9
  401a98:	47a8      	blx	r5
	for(i=0;i<8;i++)
  401a9a:	f1b8 0f18 	cmp.w	r8, #24
  401a9e:	d1e1      	bne.n	401a64 <main_screen_play+0x220>
			}
			else putIt(7);
		}
		
	}
	glcd_gotoxy(66, 18);
  401aa0:	2112      	movs	r1, #18
  401aa2:	2042      	movs	r0, #66	; 0x42
  401aa4:	4b89      	ldr	r3, [pc, #548]	; (401ccc <main_screen_play+0x488>)
  401aa6:	464d      	mov	r5, r9
  401aa8:	4798      	blx	r3
	uint32_t hour, minute, seconds, PM = 0;
	rtc_get_time(RTC, &hour, &minute, &seconds);
  401aaa:	4c89      	ldr	r4, [pc, #548]	; (401cd0 <main_screen_play+0x48c>)
  401aac:	ab0a      	add	r3, sp, #40	; 0x28
  401aae:	aa09      	add	r2, sp, #36	; 0x24
  401ab0:	a908      	add	r1, sp, #32
  401ab2:	4888      	ldr	r0, [pc, #544]	; (401cd4 <main_screen_play+0x490>)
  401ab4:	47a0      	blx	r4
	if (hour > 12)
  401ab6:	9c08      	ldr	r4, [sp, #32]
  401ab8:	2c0c      	cmp	r4, #12
  401aba:	f240 822e 	bls.w	401f1a <main_screen_play+0x6d6>
	{
		PM = 1;
		hour -= 12;
  401abe:	f1a4 000c 	sub.w	r0, r4, #12
		PM = 1;
  401ac2:	2401      	movs	r4, #1
		hour -= 12;
  401ac4:	9008      	str	r0, [sp, #32]
	}
	if (hour == 0) hour = 12;
	glcd_puts(itos(hour), 0);
  401ac6:	9e05      	ldr	r6, [sp, #20]
  401ac8:	2100      	movs	r1, #0
  401aca:	47b0      	blx	r6
  401acc:	2100      	movs	r1, #0
  401ace:	9f03      	ldr	r7, [sp, #12]
  401ad0:	47b8      	blx	r7
	putIt(':');
  401ad2:	9b02      	ldr	r3, [sp, #8]
  401ad4:	203a      	movs	r0, #58	; 0x3a
  401ad6:	4798      	blx	r3
	glcd_puts(itos(minute), 0);
  401ad8:	2100      	movs	r1, #0
  401ada:	9809      	ldr	r0, [sp, #36]	; 0x24
  401adc:	47b0      	blx	r6
  401ade:	2100      	movs	r1, #0
  401ae0:	47b8      	blx	r7
	putIt(':');
  401ae2:	9b02      	ldr	r3, [sp, #8]
  401ae4:	203a      	movs	r0, #58	; 0x3a
  401ae6:	4798      	blx	r3
	glcd_puts(itos(seconds), 0);
  401ae8:	2100      	movs	r1, #0
  401aea:	980a      	ldr	r0, [sp, #40]	; 0x28
  401aec:	47b0      	blx	r6
  401aee:	2100      	movs	r1, #0
  401af0:	47b8      	blx	r7
	
	glcd_gotoxy(128 - 15, 18);
  401af2:	2112      	movs	r1, #18
  401af4:	2071      	movs	r0, #113	; 0x71
  401af6:	4b75      	ldr	r3, [pc, #468]	; (401ccc <main_screen_play+0x488>)
  401af8:	4798      	blx	r3
	if (PM) glcd_putsf(" PM", 0);
  401afa:	2c00      	cmp	r4, #0
  401afc:	f000 8218 	beq.w	401f30 <main_screen_play+0x6ec>
  401b00:	2100      	movs	r1, #0
  401b02:	4875      	ldr	r0, [pc, #468]	; (401cd8 <main_screen_play+0x494>)
  401b04:	9b04      	ldr	r3, [sp, #16]
  401b06:	4798      	blx	r3
	else glcd_putsf(" AM", 0);
	
	glcd_gotoxy(0, 27);
  401b08:	211b      	movs	r1, #27
	glcd_puts(fixedpt_cstr(fixedpt_rconst(sqrt(axt_get_current_avg()/2)), 2),0);
  401b0a:	4c74      	ldr	r4, [pc, #464]	; (401cdc <main_screen_play+0x498>)
	glcd_gotoxy(0, 27);
  401b0c:	4b6f      	ldr	r3, [pc, #444]	; (401ccc <main_screen_play+0x488>)
  401b0e:	2000      	movs	r0, #0
  401b10:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(sqrt(axt_get_current_avg()/2)), 2),0);
  401b12:	47a0      	blx	r4
  401b14:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  401b18:	ee07 0a10 	vmov	s14, r0
  401b1c:	4b70      	ldr	r3, [pc, #448]	; (401ce0 <main_screen_play+0x49c>)
  401b1e:	ee67 7a27 	vmul.f32	s15, s14, s15
  401b22:	ee17 0a90 	vmov	r0, s15
  401b26:	4798      	blx	r3
  401b28:	4b6e      	ldr	r3, [pc, #440]	; (401ce4 <main_screen_play+0x4a0>)
  401b2a:	4798      	blx	r3
  401b2c:	4606      	mov	r6, r0
  401b2e:	460f      	mov	r7, r1
  401b30:	47a0      	blx	r4
  401b32:	4c6d      	ldr	r4, [pc, #436]	; (401ce8 <main_screen_play+0x4a4>)
  401b34:	2200      	movs	r2, #0
  401b36:	4b6d      	ldr	r3, [pc, #436]	; (401cec <main_screen_play+0x4a8>)
  401b38:	4630      	mov	r0, r6
  401b3a:	4639      	mov	r1, r7
  401b3c:	47a0      	blx	r4
  401b3e:	2200      	movs	r2, #0
  401b40:	4b6b      	ldr	r3, [pc, #428]	; (401cf0 <main_screen_play+0x4ac>)
  401b42:	4c6c      	ldr	r4, [pc, #432]	; (401cf4 <main_screen_play+0x4b0>)
  401b44:	47a0      	blx	r4
  401b46:	4b6c      	ldr	r3, [pc, #432]	; (401cf8 <main_screen_play+0x4b4>)
  401b48:	4798      	blx	r3
 */
static inline void
fixedpt_str(fixedpt A, char *str, int max_dec)
{
	int ndec = 0, slen = 0;
	char tmp[12] = {0};
  401b4a:	2300      	movs	r3, #0
  401b4c:	9901      	ldr	r1, [sp, #4]
#error Invalid width
#endif
	else if (max_dec == -2)
		max_dec = 15;

	if (A < 0) {
  401b4e:	f1b0 0a00 	subs.w	sl, r0, #0
	char tmp[12] = {0};
  401b52:	930b      	str	r3, [sp, #44]	; 0x2c
  401b54:	604b      	str	r3, [r1, #4]
  401b56:	608b      	str	r3, [r1, #8]
	if (A < 0) {
  401b58:	f2c0 8314 	blt.w	402184 <main_screen_play+0x940>
	int ndec = 0, slen = 0;
  401b5c:	4699      	mov	r9, r3
		str[slen++] = '-';
		A *= -1;
	}

	ip = fixedpt_toint(A);
  401b5e:	ea4f 36ea 	mov.w	r6, sl, asr #15
  401b62:	f8dd 8004 	ldr.w	r8, [sp, #4]
	int ndec = 0, slen = 0;
  401b66:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  401b68:	17f7      	asrs	r7, r6, #31
  401b6a:	e000      	b.n	401b6e <main_screen_play+0x32a>
	do {
		tmp[ndec++] = '0' + ip % 10;
  401b6c:	461c      	mov	r4, r3
  401b6e:	4630      	mov	r0, r6
  401b70:	4639      	mov	r1, r7
  401b72:	220a      	movs	r2, #10
  401b74:	2300      	movs	r3, #0
  401b76:	47a8      	blx	r5
  401b78:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  401b7c:	4630      	mov	r0, r6
  401b7e:	4639      	mov	r1, r7
  401b80:	220a      	movs	r2, #10
  401b82:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  401b84:	f808 eb01 	strb.w	lr, [r8], #1
		ip /= 10;
  401b88:	47a8      	blx	r5
  401b8a:	4606      	mov	r6, r0
  401b8c:	460f      	mov	r7, r1
		tmp[ndec++] = '0' + ip % 10;
  401b8e:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  401b90:	ea56 0207 	orrs.w	r2, r6, r7
  401b94:	d1ea      	bne.n	401b6c <main_screen_play+0x328>
  401b96:	f109 32ff 	add.w	r2, r9, #4294967295
  401b9a:	9801      	ldr	r0, [sp, #4]
  401b9c:	9900      	ldr	r1, [sp, #0]
  401b9e:	4403      	add	r3, r0
  401ba0:	440a      	add	r2, r1

	while (ndec > 0)
		str[slen++] = tmp[--ndec];
  401ba2:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  401ba6:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  401ba8:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  401bac:	d1f9      	bne.n	401ba2 <main_screen_play+0x35e>
  401bae:	eb04 0209 	add.w	r2, r4, r9
	str[slen++] = '.';
  401bb2:	9900      	ldr	r1, [sp, #0]
  401bb4:	232e      	movs	r3, #46	; 0x2e
  401bb6:	f109 0901 	add.w	r9, r9, #1
  401bba:	1c56      	adds	r6, r2, #1
  401bbc:	440c      	add	r4, r1

	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401bbe:	ea4f 4a4a 	mov.w	sl, sl, lsl #17
	str[slen++] = '.';
  401bc2:	3202      	adds	r2, #2
  401bc4:	f804 3009 	strb.w	r3, [r4, r9]
  401bc8:	440e      	add	r6, r1
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401bca:	2300      	movs	r3, #0
  401bcc:	e001      	b.n	401bd2 <main_screen_play+0x38e>
	do {
		fr = (fr & mask) * 10;

		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
		ndec++;
	} while (fr != 0 && ndec < max_dec);
  401bce:	2b01      	cmp	r3, #1
  401bd0:	dc18      	bgt.n	401c04 <main_screen_play+0x3c0>
		fr = (fr & mask) * 10;
  401bd2:	f04f 0b00 	mov.w	fp, #0
  401bd6:	ea4f 008a 	mov.w	r0, sl, lsl #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  401bda:	3201      	adds	r2, #1
		ndec++;
  401bdc:	3301      	adds	r3, #1
		fr = (fr & mask) * 10;
  401bde:	ea4f 048b 	mov.w	r4, fp, lsl #2
  401be2:	ea44 719a 	orr.w	r1, r4, sl, lsr #30
  401be6:	eb1a 0a00 	adds.w	sl, sl, r0
  401bea:	eb4b 0b01 	adc.w	fp, fp, r1
  401bee:	eb1a 0a0a 	adds.w	sl, sl, sl
  401bf2:	eb4b 0b0b 	adc.w	fp, fp, fp
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  401bf6:	f10b 0130 	add.w	r1, fp, #48	; 0x30
  401bfa:	f806 1f01 	strb.w	r1, [r6, #1]!
	} while (fr != 0 && ndec < max_dec);
  401bfe:	ea5a 010b 	orrs.w	r1, sl, fp
  401c02:	d1e4      	bne.n	401bce <main_screen_play+0x38a>

	if (ndec > 1 && str[slen-1] == '0')
  401c04:	2b02      	cmp	r3, #2
  401c06:	d105      	bne.n	401c14 <main_screen_play+0x3d0>
  401c08:	1e53      	subs	r3, r2, #1
  401c0a:	9900      	ldr	r1, [sp, #0]
  401c0c:	5cc9      	ldrb	r1, [r1, r3]
  401c0e:	2930      	cmp	r1, #48	; 0x30
  401c10:	f000 83cc 	beq.w	4023ac <main_screen_play+0xb68>
		str[slen-1] = '\0'; /* cut off trailing 0 */
	else
		str[slen] = '\0';
  401c14:	2300      	movs	r3, #0
  401c16:	9900      	ldr	r1, [sp, #0]
  401c18:	548b      	strb	r3, [r1, r2]
  401c1a:	2100      	movs	r1, #0
  401c1c:	4837      	ldr	r0, [pc, #220]	; (401cfc <main_screen_play+0x4b8>)
  401c1e:	9b03      	ldr	r3, [sp, #12]
  401c20:	4798      	blx	r3
	glcd_putsf("A",0);
  401c22:	2100      	movs	r1, #0
  401c24:	4836      	ldr	r0, [pc, #216]	; (401d00 <main_screen_play+0x4bc>)
  401c26:	9b04      	ldr	r3, [sp, #16]
  401c28:	4798      	blx	r3
	
	glcd_gotoxy(42,27);

	glcd_puts(fixedpt_cstr(fixedpt_abs(vfd_get_desired_speed()), 2),0);
  401c2a:	4c36      	ldr	r4, [pc, #216]	; (401d04 <main_screen_play+0x4c0>)
	glcd_gotoxy(42,27);
  401c2c:	211b      	movs	r1, #27
  401c2e:	202a      	movs	r0, #42	; 0x2a
  401c30:	4b26      	ldr	r3, [pc, #152]	; (401ccc <main_screen_play+0x488>)
  401c32:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_abs(vfd_get_desired_speed()), 2),0);
  401c34:	47a0      	blx	r4
  401c36:	2800      	cmp	r0, #0
  401c38:	f2c0 82a1 	blt.w	40217e <main_screen_play+0x93a>
  401c3c:	47a0      	blx	r4
  401c3e:	4604      	mov	r4, r0
	char tmp[12] = {0};
  401c40:	2300      	movs	r3, #0
  401c42:	9901      	ldr	r1, [sp, #4]
	if (A < 0) {
  401c44:	429c      	cmp	r4, r3
	char tmp[12] = {0};
  401c46:	930b      	str	r3, [sp, #44]	; 0x2c
  401c48:	604b      	str	r3, [r1, #4]
  401c4a:	608b      	str	r3, [r1, #8]
	if (A < 0) {
  401c4c:	f2c0 8290 	blt.w	402170 <main_screen_play+0x92c>
	int ndec = 0, slen = 0;
  401c50:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  401c52:	13e6      	asrs	r6, r4, #15
  401c54:	f8dd 9004 	ldr.w	r9, [sp, #4]
	int ndec = 0, slen = 0;
  401c58:	f04f 0800 	mov.w	r8, #0
	ip = fixedpt_toint(A);
  401c5c:	17f7      	asrs	r7, r6, #31
  401c5e:	e000      	b.n	401c62 <main_screen_play+0x41e>
		tmp[ndec++] = '0' + ip % 10;
  401c60:	4698      	mov	r8, r3
  401c62:	4630      	mov	r0, r6
  401c64:	4639      	mov	r1, r7
  401c66:	220a      	movs	r2, #10
  401c68:	2300      	movs	r3, #0
  401c6a:	47a8      	blx	r5
  401c6c:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  401c70:	4630      	mov	r0, r6
  401c72:	4639      	mov	r1, r7
  401c74:	220a      	movs	r2, #10
  401c76:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  401c78:	f809 eb01 	strb.w	lr, [r9], #1
		ip /= 10;
  401c7c:	47a8      	blx	r5
  401c7e:	4606      	mov	r6, r0
  401c80:	460f      	mov	r7, r1
		tmp[ndec++] = '0' + ip % 10;
  401c82:	f108 0301 	add.w	r3, r8, #1
	} while (ip != 0);
  401c86:	ea56 0207 	orrs.w	r2, r6, r7
  401c8a:	d1e9      	bne.n	401c60 <main_screen_play+0x41c>
  401c8c:	f10a 32ff 	add.w	r2, sl, #4294967295
  401c90:	9801      	ldr	r0, [sp, #4]
  401c92:	9900      	ldr	r1, [sp, #0]
  401c94:	4403      	add	r3, r0
  401c96:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  401c98:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  401c9c:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  401c9e:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  401ca2:	d1f9      	bne.n	401c98 <main_screen_play+0x454>
  401ca4:	eb08 020a 	add.w	r2, r8, sl
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401ca8:	0464      	lsls	r4, r4, #17
	str[slen++] = '.';
  401caa:	9f00      	ldr	r7, [sp, #0]
  401cac:	232e      	movs	r3, #46	; 0x2e
  401cae:	1c56      	adds	r6, r2, #1
  401cb0:	f10a 0a01 	add.w	sl, sl, #1
  401cb4:	44b8      	add	r8, r7
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401cb6:	4620      	mov	r0, r4
  401cb8:	463c      	mov	r4, r7
	str[slen++] = '.';
  401cba:	3202      	adds	r2, #2
  401cbc:	f808 300a 	strb.w	r3, [r8, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401cc0:	2300      	movs	r3, #0
  401cc2:	4434      	add	r4, r6
  401cc4:	e022      	b.n	401d0c <main_screen_play+0x4c8>
  401cc6:	bf00      	nop
  401cc8:	204052b4 	.word	0x204052b4
  401ccc:	0040c7a5 	.word	0x0040c7a5
  401cd0:	004005b9 	.word	0x004005b9
  401cd4:	400e1860 	.word	0x400e1860
  401cd8:	004199dc 	.word	0x004199dc
  401cdc:	0040e379 	.word	0x0040e379
  401ce0:	00418749 	.word	0x00418749
  401ce4:	00418249 	.word	0x00418249
  401ce8:	004187f1 	.word	0x004187f1
  401cec:	40e00000 	.word	0x40e00000
  401cf0:	3fe00000 	.word	0x3fe00000
  401cf4:	0041848d 	.word	0x0041848d
  401cf8:	00418d51 	.word	0x00418d51
  401cfc:	20400854 	.word	0x20400854
  401d00:	004199e4 	.word	0x004199e4
  401d04:	00416995 	.word	0x00416995
	} while (fr != 0 && ndec < max_dec);
  401d08:	2b01      	cmp	r3, #1
  401d0a:	dc12      	bgt.n	401d32 <main_screen_play+0x4ee>
		fr = (fr & mask) * 10;
  401d0c:	2100      	movs	r1, #0
  401d0e:	0086      	lsls	r6, r0, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  401d10:	3201      	adds	r2, #1
		ndec++;
  401d12:	3301      	adds	r3, #1
		fr = (fr & mask) * 10;
  401d14:	ea4f 0e81 	mov.w	lr, r1, lsl #2
  401d18:	ea4e 7790 	orr.w	r7, lr, r0, lsr #30
  401d1c:	1980      	adds	r0, r0, r6
  401d1e:	4179      	adcs	r1, r7
  401d20:	1800      	adds	r0, r0, r0
  401d22:	4149      	adcs	r1, r1
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  401d24:	f101 0630 	add.w	r6, r1, #48	; 0x30
  401d28:	f804 6f01 	strb.w	r6, [r4, #1]!
	} while (fr != 0 && ndec < max_dec);
  401d2c:	ea50 0601 	orrs.w	r6, r0, r1
  401d30:	d1ea      	bne.n	401d08 <main_screen_play+0x4c4>
	if (ndec > 1 && str[slen-1] == '0')
  401d32:	2b02      	cmp	r3, #2
  401d34:	d105      	bne.n	401d42 <main_screen_play+0x4fe>
  401d36:	1e53      	subs	r3, r2, #1
  401d38:	9900      	ldr	r1, [sp, #0]
  401d3a:	5cc9      	ldrb	r1, [r1, r3]
  401d3c:	2930      	cmp	r1, #48	; 0x30
  401d3e:	f000 8331 	beq.w	4023a4 <main_screen_play+0xb60>
		str[slen] = '\0';
  401d42:	2300      	movs	r3, #0
  401d44:	9900      	ldr	r1, [sp, #0]
  401d46:	548b      	strb	r3, [r1, r2]
  401d48:	2100      	movs	r1, #0
  401d4a:	487f      	ldr	r0, [pc, #508]	; (401f48 <main_screen_play+0x704>)
  401d4c:	9b03      	ldr	r3, [sp, #12]
  401d4e:	4798      	blx	r3
	glcd_putsf("Hz",0);
  401d50:	2100      	movs	r1, #0
  401d52:	487e      	ldr	r0, [pc, #504]	; (401f4c <main_screen_play+0x708>)
  401d54:	9b04      	ldr	r3, [sp, #16]
  401d56:	4798      	blx	r3
	
	
	
	glcd_gotoxy(96,27);
  401d58:	211b      	movs	r1, #27
  401d5a:	2060      	movs	r0, #96	; 0x60
  401d5c:	4b7c      	ldr	r3, [pc, #496]	; (401f50 <main_screen_play+0x70c>)
  401d5e:	4798      	blx	r3
	if (auto_instate(auto_stop)==1)
  401d60:	4c7c      	ldr	r4, [pc, #496]	; (401f54 <main_screen_play+0x710>)
  401d62:	2003      	movs	r0, #3
  401d64:	47a0      	blx	r4
  401d66:	2801      	cmp	r0, #1
  401d68:	f000 811c 	beq.w	401fa4 <main_screen_play+0x760>
	{
		write_r_text("Stop",0);
	}
	else if(auto_instate(auto_idle)==1)
  401d6c:	2005      	movs	r0, #5
  401d6e:	47a0      	blx	r4
  401d70:	2801      	cmp	r0, #1
  401d72:	f000 8217 	beq.w	4021a4 <main_screen_play+0x960>
	{
		write_r_text("Idle",0);
	}
	else if(auto_instate(auto_camtest)==1)
  401d76:	2004      	movs	r0, #4
  401d78:	47a0      	blx	r4
  401d7a:	2801      	cmp	r0, #1
  401d7c:	f000 830d 	beq.w	40239a <main_screen_play+0xb56>
	{
		write_r_text("Door",0);
	}
	else if(auto_instate(auto_hspd)==1)
  401d80:	2001      	movs	r0, #1
  401d82:	47a0      	blx	r4
  401d84:	2801      	cmp	r0, #1
  401d86:	f000 8322 	beq.w	4023ce <main_screen_play+0xb8a>
	{
		write_r_text("Hspd",0);
	}
	else if(auto_instate(auto_lspd)==1)
  401d8a:	2002      	movs	r0, #2
  401d8c:	47a0      	blx	r4
  401d8e:	2801      	cmp	r0, #1
  401d90:	f000 82fe 	beq.w	402390 <main_screen_play+0xb4c>
	{
		write_r_text("Lspd",0);
	}
	else if(auto_instate(auto_stopping)==1)
  401d94:	2007      	movs	r0, #7
  401d96:	47a0      	blx	r4
  401d98:	2801      	cmp	r0, #1
  401d9a:	f000 83b9 	beq.w	402510 <main_screen_play+0xccc>
	{
		write_r_text("Ariv",0);
	}
	
	if(get_enter_button())
  401d9e:	4b6e      	ldr	r3, [pc, #440]	; (401f58 <main_screen_play+0x714>)
  401da0:	4c6e      	ldr	r4, [pc, #440]	; (401f5c <main_screen_play+0x718>)
  401da2:	4798      	blx	r3
  401da4:	2800      	cmp	r0, #0
  401da6:	f040 8106 	bne.w	401fb6 <main_screen_play+0x772>
	{
		active_screen = IDF_SCREEN_PROGRAMMING;
	}
	else if(get_up_button())
  401daa:	4b6d      	ldr	r3, [pc, #436]	; (401f60 <main_screen_play+0x71c>)
  401dac:	4798      	blx	r3
  401dae:	2800      	cmp	r0, #0
  401db0:	f000 8312 	beq.w	4023d8 <main_screen_play+0xb94>
	{
		active_screen = IDF_SCREEN_MONITOR;
  401db4:	4b6b      	ldr	r3, [pc, #428]	; (401f64 <main_screen_play+0x720>)
  401db6:	2202      	movs	r2, #2
  401db8:	601a      	str	r2, [r3, #0]
  401dba:	e0ff      	b.n	401fbc <main_screen_play+0x778>
		int64_t lift_speed = fixedpt_abs(enc_get_omega_hat());// fixedpt_abs(vfd_get_desired_speed());
  401dbc:	4c6a      	ldr	r4, [pc, #424]	; (401f68 <main_screen_play+0x724>)
  401dbe:	47a0      	blx	r4
  401dc0:	2800      	cmp	r0, #0
  401dc2:	f2c0 82e2 	blt.w	40238a <main_screen_play+0xb46>
  401dc6:	47a0      	blx	r4
		lift_speed /= hoist_info.enc_count_per_meter;
  401dc8:	2500      	movs	r5, #0
	char tmp[12] = {0};
  401dca:	aa0b      	add	r2, sp, #44	; 0x2c
  401dcc:	4b67      	ldr	r3, [pc, #412]	; (401f6c <main_screen_play+0x728>)
  401dce:	17c1      	asrs	r1, r0, #31
  401dd0:	4616      	mov	r6, r2
  401dd2:	9201      	str	r2, [sp, #4]
  401dd4:	4c66      	ldr	r4, [pc, #408]	; (401f70 <main_screen_play+0x72c>)
  401dd6:	f8d3 219c 	ldr.w	r2, [r3, #412]	; 0x19c
  401dda:	462b      	mov	r3, r5
  401ddc:	47a0      	blx	r4
	if (A < 0) {
  401dde:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  401de0:	950b      	str	r5, [sp, #44]	; 0x2c
  401de2:	6075      	str	r5, [r6, #4]
  401de4:	60b5      	str	r5, [r6, #8]
	if (A < 0) {
  401de6:	f2c0 82e9 	blt.w	4023bc <main_screen_play+0xb78>
  401dea:	4b57      	ldr	r3, [pc, #348]	; (401f48 <main_screen_play+0x704>)
	int ndec = 0, slen = 0;
  401dec:	46aa      	mov	sl, r5
  401dee:	9300      	str	r3, [sp, #0]
	ip = fixedpt_toint(A);
  401df0:	13e6      	asrs	r6, r4, #15
  401df2:	f8dd 9004 	ldr.w	r9, [sp, #4]
	int ndec = 0, slen = 0;
  401df6:	f04f 0800 	mov.w	r8, #0
  401dfa:	4d5e      	ldr	r5, [pc, #376]	; (401f74 <main_screen_play+0x730>)
	ip = fixedpt_toint(A);
  401dfc:	17f7      	asrs	r7, r6, #31
  401dfe:	e000      	b.n	401e02 <main_screen_play+0x5be>
		tmp[ndec++] = '0' + ip % 10;
  401e00:	4698      	mov	r8, r3
  401e02:	4630      	mov	r0, r6
  401e04:	4639      	mov	r1, r7
  401e06:	220a      	movs	r2, #10
  401e08:	2300      	movs	r3, #0
  401e0a:	47a8      	blx	r5
  401e0c:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  401e10:	4630      	mov	r0, r6
  401e12:	4639      	mov	r1, r7
  401e14:	220a      	movs	r2, #10
  401e16:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  401e18:	f809 eb01 	strb.w	lr, [r9], #1
		ip /= 10;
  401e1c:	47a8      	blx	r5
  401e1e:	4606      	mov	r6, r0
  401e20:	460f      	mov	r7, r1
		tmp[ndec++] = '0' + ip % 10;
  401e22:	f108 0301 	add.w	r3, r8, #1
	} while (ip != 0);
  401e26:	ea56 0207 	orrs.w	r2, r6, r7
  401e2a:	d1e9      	bne.n	401e00 <main_screen_play+0x5bc>
  401e2c:	f10a 32ff 	add.w	r2, sl, #4294967295
  401e30:	9801      	ldr	r0, [sp, #4]
  401e32:	9900      	ldr	r1, [sp, #0]
  401e34:	4403      	add	r3, r0
  401e36:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  401e38:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  401e3c:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  401e3e:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  401e42:	d1f9      	bne.n	401e38 <main_screen_play+0x5f4>
  401e44:	eb08 060a 	add.w	r6, r8, sl
	str[slen++] = '.';
  401e48:	9800      	ldr	r0, [sp, #0]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401e4a:	0464      	lsls	r4, r4, #17
  401e4c:	f10a 0a01 	add.w	sl, sl, #1
  401e50:	1c77      	adds	r7, r6, #1
	str[slen++] = '.';
  401e52:	4480      	add	r8, r0
  401e54:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401e56:	4622      	mov	r2, r4
	str[slen++] = '.';
  401e58:	3602      	adds	r6, #2
  401e5a:	4407      	add	r7, r0
  401e5c:	f808 100a 	strb.w	r1, [r8, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  401e60:	2400      	movs	r4, #0
  401e62:	e001      	b.n	401e68 <main_screen_play+0x624>
	} while (fr != 0 && ndec < max_dec);
  401e64:	2c01      	cmp	r4, #1
  401e66:	dc12      	bgt.n	401e8e <main_screen_play+0x64a>
		fr = (fr & mask) * 10;
  401e68:	2300      	movs	r3, #0
  401e6a:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  401e6c:	3601      	adds	r6, #1
		ndec++;
  401e6e:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  401e70:	ea4f 0e83 	mov.w	lr, r3, lsl #2
  401e74:	ea4e 7192 	orr.w	r1, lr, r2, lsr #30
  401e78:	1812      	adds	r2, r2, r0
  401e7a:	414b      	adcs	r3, r1
  401e7c:	1892      	adds	r2, r2, r2
  401e7e:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  401e80:	f103 0130 	add.w	r1, r3, #48	; 0x30
  401e84:	f807 1f01 	strb.w	r1, [r7, #1]!
	} while (fr != 0 && ndec < max_dec);
  401e88:	ea52 0103 	orrs.w	r1, r2, r3
  401e8c:	d1ea      	bne.n	401e64 <main_screen_play+0x620>
	if (ndec > 1 && str[slen-1] == '0')
  401e8e:	2c02      	cmp	r4, #2
  401e90:	d105      	bne.n	401e9e <main_screen_play+0x65a>
  401e92:	1e73      	subs	r3, r6, #1
  401e94:	9a00      	ldr	r2, [sp, #0]
  401e96:	5cd2      	ldrb	r2, [r2, r3]
  401e98:	2a30      	cmp	r2, #48	; 0x30
  401e9a:	f000 82a6 	beq.w	4023ea <main_screen_play+0xba6>
		str[slen] = '\0';
  401e9e:	2300      	movs	r3, #0
  401ea0:	9a00      	ldr	r2, [sp, #0]
  401ea2:	5593      	strb	r3, [r2, r6]
		glcd_puts(fixedpt_cstr(lift_speed, 2),0);
  401ea4:	4b34      	ldr	r3, [pc, #208]	; (401f78 <main_screen_play+0x734>)
  401ea6:	2100      	movs	r1, #0
  401ea8:	4827      	ldr	r0, [pc, #156]	; (401f48 <main_screen_play+0x704>)
		glcd_putsf("M/s",0);
  401eaa:	2442      	movs	r4, #66	; 0x42
		glcd_puts(fixedpt_cstr(lift_speed, 2),0);
  401eac:	9303      	str	r3, [sp, #12]
  401eae:	4798      	blx	r3
		glcd_putsf("M/s",0);
  401eb0:	4b32      	ldr	r3, [pc, #200]	; (401f7c <main_screen_play+0x738>)
  401eb2:	2100      	movs	r1, #0
  401eb4:	4832      	ldr	r0, [pc, #200]	; (401f80 <main_screen_play+0x73c>)
  401eb6:	9304      	str	r3, [sp, #16]
  401eb8:	4798      	blx	r3
  401eba:	4b32      	ldr	r3, [pc, #200]	; (401f84 <main_screen_play+0x740>)
  401ebc:	202c      	movs	r0, #44	; 0x2c
  401ebe:	9302      	str	r3, [sp, #8]
  401ec0:	4b31      	ldr	r3, [pc, #196]	; (401f88 <main_screen_play+0x744>)
  401ec2:	9305      	str	r3, [sp, #20]
  401ec4:	e4f0      	b.n	4018a8 <main_screen_play+0x64>
			putIt(0);
  401ec6:	2000      	movs	r0, #0
  401ec8:	47b0      	blx	r6
			req_mb_setUpMotion();
  401eca:	4b30      	ldr	r3, [pc, #192]	; (401f8c <main_screen_play+0x748>)
  401ecc:	4798      	blx	r3
	if (selfLearn_isLearning()) glcd_putsf("LRN", 0);
  401ece:	4b30      	ldr	r3, [pc, #192]	; (401f90 <main_screen_play+0x74c>)
  401ed0:	4798      	blx	r3
  401ed2:	4604      	mov	r4, r0
  401ed4:	2800      	cmp	r0, #0
  401ed6:	f47f ad0e 	bne.w	4018f6 <main_screen_play+0xb2>
	else if (vfd_states_isTuning()) glcd_putsf("TUN", 0);
  401eda:	4b2e      	ldr	r3, [pc, #184]	; (401f94 <main_screen_play+0x750>)
  401edc:	4798      	blx	r3
  401ede:	2800      	cmp	r0, #0
  401ee0:	f000 8158 	beq.w	402194 <main_screen_play+0x950>
  401ee4:	4621      	mov	r1, r4
  401ee6:	482c      	ldr	r0, [pc, #176]	; (401f98 <main_screen_play+0x754>)
  401ee8:	9b04      	ldr	r3, [sp, #16]
  401eea:	4798      	blx	r3
  401eec:	e507      	b.n	4018fe <main_screen_play+0xba>
			else putIt(7);
  401eee:	2007      	movs	r0, #7
  401ef0:	47a8      	blx	r5
  401ef2:	e550      	b.n	401996 <main_screen_play+0x152>
				putIt(6);
  401ef4:	2006      	movs	r0, #6
  401ef6:	47a8      	blx	r5
  401ef8:	e54d      	b.n	401996 <main_screen_play+0x152>
			else if((eereq&msk(i)))
  401efa:	07d8      	lsls	r0, r3, #31
  401efc:	d5f7      	bpl.n	401eee <main_screen_play+0x6aa>
				putIt(8);
  401efe:	2008      	movs	r0, #8
  401f00:	47a8      	blx	r5
  401f02:	e548      	b.n	401996 <main_screen_play+0x152>
			else putIt(7);
  401f04:	2007      	movs	r0, #7
  401f06:	47a8      	blx	r5
  401f08:	e5a7      	b.n	401a5a <main_screen_play+0x216>
				putIt(6);
  401f0a:	2006      	movs	r0, #6
  401f0c:	47a8      	blx	r5
  401f0e:	e5a4      	b.n	401a5a <main_screen_play+0x216>
			else if((eereq&msk(i+16)))
  401f10:	07d9      	lsls	r1, r3, #31
  401f12:	d5f7      	bpl.n	401f04 <main_screen_play+0x6c0>
				putIt(8);
  401f14:	2008      	movs	r0, #8
  401f16:	47a8      	blx	r5
  401f18:	e59f      	b.n	401a5a <main_screen_play+0x216>
	if (hour == 0) hour = 12;
  401f1a:	2c00      	cmp	r4, #0
  401f1c:	f040 83fc 	bne.w	402718 <main_screen_play+0xed4>
  401f20:	230c      	movs	r3, #12
  401f22:	4618      	mov	r0, r3
  401f24:	9308      	str	r3, [sp, #32]
  401f26:	e5ce      	b.n	401ac6 <main_screen_play+0x282>
	else putIt('E');
  401f28:	9b02      	ldr	r3, [sp, #8]
  401f2a:	2045      	movs	r0, #69	; 0x45
  401f2c:	4798      	blx	r3
  401f2e:	e514      	b.n	40195a <main_screen_play+0x116>
	else glcd_putsf(" AM", 0);
  401f30:	4621      	mov	r1, r4
  401f32:	481a      	ldr	r0, [pc, #104]	; (401f9c <main_screen_play+0x758>)
  401f34:	9b04      	ldr	r3, [sp, #16]
  401f36:	4798      	blx	r3
  401f38:	e5e6      	b.n	401b08 <main_screen_play+0x2c4>
		req_mb_setStill();
  401f3a:	4b19      	ldr	r3, [pc, #100]	; (401fa0 <main_screen_play+0x75c>)
  401f3c:	4798      	blx	r3
  401f3e:	e4d4      	b.n	4018ea <main_screen_play+0xa6>
	if (device_off) putIt('O');
  401f40:	9b02      	ldr	r3, [sp, #8]
  401f42:	204f      	movs	r0, #79	; 0x4f
  401f44:	4798      	blx	r3
  401f46:	e4f0      	b.n	40192a <main_screen_play+0xe6>
  401f48:	20400854 	.word	0x20400854
  401f4c:	004199e8 	.word	0x004199e8
  401f50:	0040c7a5 	.word	0x0040c7a5
  401f54:	004081c5 	.word	0x004081c5
  401f58:	0040de29 	.word	0x0040de29
  401f5c:	0040cf51 	.word	0x0040cf51
  401f60:	0040de61 	.word	0x0040de61
  401f64:	2040084c 	.word	0x2040084c
  401f68:	00413cf1 	.word	0x00413cf1
  401f6c:	20400c80 	.word	0x20400c80
  401f70:	0041905d 	.word	0x0041905d
  401f74:	004190fd 	.word	0x004190fd
  401f78:	0040ca05 	.word	0x0040ca05
  401f7c:	0040c7b9 	.word	0x0040c7b9
  401f80:	004199cc 	.word	0x004199cc
  401f84:	0040c755 	.word	0x0040c755
  401f88:	0040c205 	.word	0x0040c205
  401f8c:	0040dedd 	.word	0x0040dedd
  401f90:	00404705 	.word	0x00404705
  401f94:	0041631d 	.word	0x0041631d
  401f98:	004199d4 	.word	0x004199d4
  401f9c:	004199e0 	.word	0x004199e0
  401fa0:	0040df05 	.word	0x0040df05
		write_r_text("Stop",0);
  401fa4:	2100      	movs	r1, #0
  401fa6:	48af      	ldr	r0, [pc, #700]	; (402264 <main_screen_play+0xa20>)
  401fa8:	4caf      	ldr	r4, [pc, #700]	; (402268 <main_screen_play+0xa24>)
  401faa:	47a0      	blx	r4
	if(get_enter_button())
  401fac:	4baf      	ldr	r3, [pc, #700]	; (40226c <main_screen_play+0xa28>)
  401fae:	4798      	blx	r3
  401fb0:	2800      	cmp	r0, #0
  401fb2:	f43f aefa 	beq.w	401daa <main_screen_play+0x566>
		active_screen = IDF_SCREEN_PROGRAMMING;
  401fb6:	4bae      	ldr	r3, [pc, #696]	; (402270 <main_screen_play+0xa2c>)
  401fb8:	2201      	movs	r2, #1
  401fba:	601a      	str	r2, [r3, #0]
	else if(get_right_button())
	{
		active_screen = IDF_SCREEN_TORQUE;
	}
//////////////////////////////////////////////////////////////////////////
	d_line(0,128,39,39);
  401fbc:	2327      	movs	r3, #39	; 0x27
  401fbe:	2180      	movs	r1, #128	; 0x80
  401fc0:	2000      	movs	r0, #0
  401fc2:	4eac      	ldr	r6, [pc, #688]	; (402274 <main_screen_play+0xa30>)
  401fc4:	461a      	mov	r2, r3
  401fc6:	47b0      	blx	r6
		
	glcd_gotoxy(50,36);
  401fc8:	4bab      	ldr	r3, [pc, #684]	; (402278 <main_screen_play+0xa34>)
  401fca:	2124      	movs	r1, #36	; 0x24
  401fcc:	2032      	movs	r0, #50	; 0x32
  401fce:	4798      	blx	r3
		
	if(public_lang) write_r_text("",1);
	else write_r_text("Faults",0);
  401fd0:	2100      	movs	r1, #0
  401fd2:	48aa      	ldr	r0, [pc, #680]	; (40227c <main_screen_play+0xa38>)
  401fd4:	47a0      	blx	r4
	
	if(sph_faults_get_fault_to_display(&str, &fault_prefix, &fault_code))
  401fd6:	f10d 011b 	add.w	r1, sp, #27
  401fda:	f10d 021a 	add.w	r2, sp, #26
  401fde:	a807      	add	r0, sp, #28
  401fe0:	4ba7      	ldr	r3, [pc, #668]	; (402280 <main_screen_play+0xa3c>)
  401fe2:	4798      	blx	r3
  401fe4:	4601      	mov	r1, r0
  401fe6:	2800      	cmp	r0, #0
  401fe8:	f000 80b8 	beq.w	40215c <main_screen_play+0x918>
	{
		//there is a fault to display
		glcd_gotoxy(0,46);
  401fec:	4ba2      	ldr	r3, [pc, #648]	; (402278 <main_screen_play+0xa34>)
  401fee:	212e      	movs	r1, #46	; 0x2e
  401ff0:	2000      	movs	r0, #0
  401ff2:	4798      	blx	r3
		if(fault_prefix == 1)
  401ff4:	f89d 301b 	ldrb.w	r3, [sp, #27]
  401ff8:	2b01      	cmp	r3, #1
  401ffa:	f000 81fa 	beq.w	4023f2 <main_screen_play+0xbae>
		{
			glcd_putsf("D",0);
		}
		else if (fault_prefix == 2)
  401ffe:	2b02      	cmp	r3, #2
  402000:	f000 81fc 	beq.w	4023fc <main_screen_play+0xbb8>
		{
			glcd_putsf("L",0);
		}
		glcd_puts(itos(fault_code), 0);
  402004:	2100      	movs	r1, #0
  402006:	9b05      	ldr	r3, [sp, #20]
  402008:	f89d 001a 	ldrb.w	r0, [sp, #26]
  40200c:	4798      	blx	r3
  40200e:	9b03      	ldr	r3, [sp, #12]
  402010:	2100      	movs	r1, #0
  402012:	4798      	blx	r3
		glcd_putsf(" ",0);
  402014:	2100      	movs	r1, #0
  402016:	489b      	ldr	r0, [pc, #620]	; (402284 <main_screen_play+0xa40>)
  402018:	9c04      	ldr	r4, [sp, #16]
  40201a:	47a0      	blx	r4
		glcd_putsf(str, 0);
  40201c:	2100      	movs	r1, #0
  40201e:	9807      	ldr	r0, [sp, #28]
  402020:	47a0      	blx	r4
		
		req_mb_setFault(fault_prefix, fault_code);
  402022:	f89d 101a 	ldrb.w	r1, [sp, #26]
  402026:	f89d 001b 	ldrb.w	r0, [sp, #27]
  40202a:	4b97      	ldr	r3, [pc, #604]	; (402288 <main_screen_play+0xa44>)
  40202c:	4798      	blx	r3
	}
	else
	{
		req_mb_setFault(0, 0);
	}	
	glcd_gotoxy(0,55);
  40202e:	2137      	movs	r1, #55	; 0x37
	//glcd_puts(sitos(EMCM_get_enc_flash()), 0);
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_zs_displacement()/2), 3), 0);
  402030:	4c96      	ldr	r4, [pc, #600]	; (40228c <main_screen_play+0xa48>)
	glcd_gotoxy(0,55);
  402032:	4b91      	ldr	r3, [pc, #580]	; (402278 <main_screen_play+0xa34>)
  402034:	2000      	movs	r0, #0
  402036:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_zs_displacement()/2), 3), 0);
  402038:	47a0      	blx	r4
  40203a:	eddf 7a95 	vldr	s15, [pc, #596]	; 402290 <main_screen_play+0xa4c>
  40203e:	ee07 0a10 	vmov	s14, r0
  402042:	4b94      	ldr	r3, [pc, #592]	; (402294 <main_screen_play+0xa50>)
  402044:	ee67 7a27 	vmul.f32	s15, s14, s15
  402048:	ee17 0a90 	vmov	r0, s15
  40204c:	4798      	blx	r3
  40204e:	460f      	mov	r7, r1
  402050:	4606      	mov	r6, r0
  402052:	47a0      	blx	r4
  402054:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  402058:	ee07 0a10 	vmov	s14, r0
  40205c:	4632      	mov	r2, r6
  40205e:	463b      	mov	r3, r7
  402060:	4c8d      	ldr	r4, [pc, #564]	; (402298 <main_screen_play+0xa54>)
  402062:	2000      	movs	r0, #0
  402064:	ee67 7a27 	vmul.f32	s15, s14, s15
  402068:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40206c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  402070:	bfac      	ite	ge
  402072:	498a      	ldrge	r1, [pc, #552]	; (40229c <main_screen_play+0xa58>)
  402074:	498a      	ldrlt	r1, [pc, #552]	; (4022a0 <main_screen_play+0xa5c>)
  402076:	47a0      	blx	r4
  402078:	4b8a      	ldr	r3, [pc, #552]	; (4022a4 <main_screen_play+0xa60>)
  40207a:	4798      	blx	r3
	char tmp[12] = {0};
  40207c:	2300      	movs	r3, #0
  40207e:	9901      	ldr	r1, [sp, #4]
	if (A < 0) {
  402080:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  402082:	930b      	str	r3, [sp, #44]	; 0x2c
  402084:	604b      	str	r3, [r1, #4]
  402086:	608b      	str	r3, [r1, #8]
	if (A < 0) {
  402088:	db6b      	blt.n	402162 <main_screen_play+0x91e>
	int ndec = 0, slen = 0;
  40208a:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  40208c:	13e6      	asrs	r6, r4, #15
  40208e:	f8dd 9004 	ldr.w	r9, [sp, #4]
	int ndec = 0, slen = 0;
  402092:	f04f 0800 	mov.w	r8, #0
	ip = fixedpt_toint(A);
  402096:	17f7      	asrs	r7, r6, #31
  402098:	e000      	b.n	40209c <main_screen_play+0x858>
		tmp[ndec++] = '0' + ip % 10;
  40209a:	4698      	mov	r8, r3
  40209c:	4630      	mov	r0, r6
  40209e:	4639      	mov	r1, r7
  4020a0:	220a      	movs	r2, #10
  4020a2:	2300      	movs	r3, #0
  4020a4:	47a8      	blx	r5
  4020a6:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  4020aa:	4630      	mov	r0, r6
  4020ac:	4639      	mov	r1, r7
  4020ae:	220a      	movs	r2, #10
  4020b0:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  4020b2:	f809 eb01 	strb.w	lr, [r9], #1
		ip /= 10;
  4020b6:	47a8      	blx	r5
  4020b8:	4606      	mov	r6, r0
  4020ba:	460f      	mov	r7, r1
		tmp[ndec++] = '0' + ip % 10;
  4020bc:	f108 0301 	add.w	r3, r8, #1
	} while (ip != 0);
  4020c0:	ea56 0207 	orrs.w	r2, r6, r7
  4020c4:	d1e9      	bne.n	40209a <main_screen_play+0x856>
  4020c6:	f10a 32ff 	add.w	r2, sl, #4294967295
  4020ca:	9801      	ldr	r0, [sp, #4]
  4020cc:	9900      	ldr	r1, [sp, #0]
  4020ce:	4403      	add	r3, r0
  4020d0:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  4020d2:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  4020d6:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  4020d8:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  4020dc:	d1f9      	bne.n	4020d2 <main_screen_play+0x88e>
  4020de:	eb08 020a 	add.w	r2, r8, sl
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4020e2:	0464      	lsls	r4, r4, #17
	str[slen++] = '.';
  4020e4:	9f00      	ldr	r7, [sp, #0]
  4020e6:	232e      	movs	r3, #46	; 0x2e
  4020e8:	1c56      	adds	r6, r2, #1
  4020ea:	f10a 0a01 	add.w	sl, sl, #1
  4020ee:	44b8      	add	r8, r7
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4020f0:	4620      	mov	r0, r4
  4020f2:	463c      	mov	r4, r7
	str[slen++] = '.';
  4020f4:	3202      	adds	r2, #2
  4020f6:	f808 300a 	strb.w	r3, [r8, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4020fa:	2300      	movs	r3, #0
  4020fc:	4434      	add	r4, r6
  4020fe:	e001      	b.n	402104 <main_screen_play+0x8c0>
	} while (fr != 0 && ndec < max_dec);
  402100:	2b02      	cmp	r3, #2
  402102:	dc12      	bgt.n	40212a <main_screen_play+0x8e6>
		fr = (fr & mask) * 10;
  402104:	2100      	movs	r1, #0
  402106:	0086      	lsls	r6, r0, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402108:	3201      	adds	r2, #1
		ndec++;
  40210a:	3301      	adds	r3, #1
		fr = (fr & mask) * 10;
  40210c:	ea4f 0e81 	mov.w	lr, r1, lsl #2
  402110:	ea4e 7790 	orr.w	r7, lr, r0, lsr #30
  402114:	1980      	adds	r0, r0, r6
  402116:	4179      	adcs	r1, r7
  402118:	1800      	adds	r0, r0, r0
  40211a:	4149      	adcs	r1, r1
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  40211c:	f101 0630 	add.w	r6, r1, #48	; 0x30
  402120:	f804 6f01 	strb.w	r6, [r4, #1]!
	} while (fr != 0 && ndec < max_dec);
  402124:	ea50 0601 	orrs.w	r6, r0, r1
  402128:	d1ea      	bne.n	402100 <main_screen_play+0x8bc>
	if (ndec > 1 && str[slen-1] == '0')
  40212a:	2b01      	cmp	r3, #1
  40212c:	d005      	beq.n	40213a <main_screen_play+0x8f6>
  40212e:	1e53      	subs	r3, r2, #1
  402130:	9900      	ldr	r1, [sp, #0]
  402132:	5cc9      	ldrb	r1, [r1, r3]
  402134:	2930      	cmp	r1, #48	; 0x30
  402136:	f000 813d 	beq.w	4023b4 <main_screen_play+0xb70>
		str[slen] = '\0';
  40213a:	2300      	movs	r3, #0
  40213c:	9900      	ldr	r1, [sp, #0]
  40213e:	548b      	strb	r3, [r1, r2]
  402140:	9b03      	ldr	r3, [sp, #12]
  402142:	2100      	movs	r1, #0
  402144:	4858      	ldr	r0, [pc, #352]	; (4022a8 <main_screen_play+0xa64>)
  402146:	4798      	blx	r3
	
	//glcd_puts(fixedpt_cstr(fixedpt_rconst(/*sqrt*/(pm_param_getdata1())), 2),0);
	if (menue_lift_data_applied.m_direct_stop == 1)
  402148:	4b58      	ldr	r3, [pc, #352]	; (4022ac <main_screen_play+0xa68>)
  40214a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  40214e:	2b01      	cmp	r3, #1
  402150:	d02d      	beq.n	4021ae <main_screen_play+0x96a>
		//glcd_puts(sitos(EMCM_get_enc_flash()),0);
		
	}
	
	
	drop_all_buttons();
  402152:	4b57      	ldr	r3, [pc, #348]	; (4022b0 <main_screen_play+0xa6c>)
  402154:	4798      	blx	r3

}
  402156:	b00f      	add	sp, #60	; 0x3c
  402158:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		req_mb_setFault(0, 0);
  40215c:	4b4a      	ldr	r3, [pc, #296]	; (402288 <main_screen_play+0xa44>)
  40215e:	4798      	blx	r3
  402160:	e765      	b.n	40202e <main_screen_play+0x7ea>
		str[slen++] = '-';
  402162:	232d      	movs	r3, #45	; 0x2d
  402164:	9a00      	ldr	r2, [sp, #0]
		A *= -1;
  402166:	4264      	negs	r4, r4
		str[slen++] = '-';
  402168:	f04f 0a01 	mov.w	sl, #1
  40216c:	7013      	strb	r3, [r2, #0]
  40216e:	e78d      	b.n	40208c <main_screen_play+0x848>
  402170:	232d      	movs	r3, #45	; 0x2d
  402172:	9a00      	ldr	r2, [sp, #0]
		A *= -1;
  402174:	4264      	negs	r4, r4
		str[slen++] = '-';
  402176:	f04f 0a01 	mov.w	sl, #1
  40217a:	7013      	strb	r3, [r2, #0]
  40217c:	e569      	b.n	401c52 <main_screen_play+0x40e>
	glcd_puts(fixedpt_cstr(fixedpt_abs(vfd_get_desired_speed()), 2),0);
  40217e:	47a0      	blx	r4
  402180:	4244      	negs	r4, r0
  402182:	e55d      	b.n	401c40 <main_screen_play+0x3fc>
  402184:	232d      	movs	r3, #45	; 0x2d
  402186:	9a00      	ldr	r2, [sp, #0]
		A *= -1;
  402188:	f1ca 0a00 	rsb	sl, sl, #0
		str[slen++] = '-';
  40218c:	f04f 0901 	mov.w	r9, #1
  402190:	7013      	strb	r3, [r2, #0]
  402192:	e4e4      	b.n	401b5e <main_screen_play+0x31a>
		glcd_putsf("INS",0);
  402194:	4601      	mov	r1, r0
  402196:	9b04      	ldr	r3, [sp, #16]
  402198:	4846      	ldr	r0, [pc, #280]	; (4022b4 <main_screen_play+0xa70>)
  40219a:	4798      	blx	r3
		req_mb_setINS();
  40219c:	4b46      	ldr	r3, [pc, #280]	; (4022b8 <main_screen_play+0xa74>)
  40219e:	4798      	blx	r3
  4021a0:	f7ff bbad 	b.w	4018fe <main_screen_play+0xba>
		write_r_text("Idle",0);
  4021a4:	2100      	movs	r1, #0
  4021a6:	4845      	ldr	r0, [pc, #276]	; (4022bc <main_screen_play+0xa78>)
  4021a8:	4c2f      	ldr	r4, [pc, #188]	; (402268 <main_screen_play+0xa24>)
  4021aa:	47a0      	blx	r4
  4021ac:	e6fe      	b.n	401fac <main_screen_play+0x768>
		if (check_elevator_inmotion() == 0)
  4021ae:	4b44      	ldr	r3, [pc, #272]	; (4022c0 <main_screen_play+0xa7c>)
  4021b0:	4798      	blx	r3
  4021b2:	4604      	mov	r4, r0
  4021b4:	2800      	cmp	r0, #0
  4021b6:	d1cc      	bne.n	402152 <main_screen_play+0x90e>
			glcd_putsf("  ", 0);
  4021b8:	4601      	mov	r1, r0
  4021ba:	9b04      	ldr	r3, [sp, #16]
  4021bc:	4841      	ldr	r0, [pc, #260]	; (4022c4 <main_screen_play+0xa80>)
  4021be:	4798      	blx	r3
			int64_t floor_err = EMCM_get_floorErr() * FIXEDPT_ONE;
  4021c0:	4b41      	ldr	r3, [pc, #260]	; (4022c8 <main_screen_play+0xa84>)
  4021c2:	4798      	blx	r3
			floor_err /= hoist_info.enc_count_per_meter;
  4021c4:	4a41      	ldr	r2, [pc, #260]	; (4022cc <main_screen_play+0xa88>)
			int64_t floor_err = EMCM_get_floorErr() * FIXEDPT_ONE;
  4021c6:	03c0      	lsls	r0, r0, #15
			floor_err /= hoist_info.enc_count_per_meter;
  4021c8:	4623      	mov	r3, r4
  4021ca:	f8d2 219c 	ldr.w	r2, [r2, #412]	; 0x19c
  4021ce:	17c1      	asrs	r1, r0, #31
  4021d0:	4c3f      	ldr	r4, [pc, #252]	; (4022d0 <main_screen_play+0xa8c>)
  4021d2:	47a0      	blx	r4
			if (fixedpt_abs(floor_err) >= FIXEDPT_ONE)
  4021d4:	2800      	cmp	r0, #0
  4021d6:	4606      	mov	r6, r0
  4021d8:	460f      	mov	r7, r1
  4021da:	f171 0300 	sbcs.w	r3, r1, #0
  4021de:	f2c0 823c 	blt.w	40265a <main_screen_play+0xe16>
  4021e2:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
  4021e6:	f177 0300 	sbcs.w	r3, r7, #0
  4021ea:	f280 8111 	bge.w	402410 <main_screen_play+0xbcc>
			else if (fixedpt_abs(floor_err) >= fixedpt_rconst(0.01))
  4021ee:	f5b6 7fa4 	cmp.w	r6, #328	; 0x148
  4021f2:	f177 0300 	sbcs.w	r3, r7, #0
  4021f6:	f2c0 8199 	blt.w	40252c <main_screen_play+0xce8>
				floor_err *= 100;
  4021fa:	1802      	adds	r2, r0, r0
				if (floor_err < fixedpt_rconst(-0.01))
  4021fc:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 4022d4 <main_screen_play+0xa90>
  402200:	f04f 39ff 	mov.w	r9, #4294967295
				floor_err *= 100;
  402204:	eb41 0301 	adc.w	r3, r1, r1
  402208:	1812      	adds	r2, r2, r0
  40220a:	414b      	adcs	r3, r1
  40220c:	0156      	lsls	r6, r2, #5
  40220e:	015f      	lsls	r7, r3, #5
  402210:	18b6      	adds	r6, r6, r2
  402212:	ea47 67d2 	orr.w	r7, r7, r2, lsr #27
  402216:	415f      	adcs	r7, r3
  402218:	1836      	adds	r6, r6, r0
  40221a:	414f      	adcs	r7, r1
				if (floor_err < fixedpt_rconst(-0.01))
  40221c:	4546      	cmp	r6, r8
  40221e:	eb77 0309 	sbcs.w	r3, r7, r9
  402222:	f2c0 8254 	blt.w	4026ce <main_screen_play+0xe8a>
				else if (floor_err > fixedpt_rconst(0.01))
  402226:	f44f 72a4 	mov.w	r2, #328	; 0x148
  40222a:	2300      	movs	r3, #0
  40222c:	42b2      	cmp	r2, r6
  40222e:	41bb      	sbcs	r3, r7
  402230:	da02      	bge.n	402238 <main_screen_play+0x9f4>
					putIt(0);
  402232:	2000      	movs	r0, #0
  402234:	9b02      	ldr	r3, [sp, #8]
  402236:	4798      	blx	r3
				floor_err = fixedpt_abs(floor_err);
  402238:	2e00      	cmp	r6, #0
  40223a:	f177 0300 	sbcs.w	r3, r7, #0
  40223e:	f2c0 825e 	blt.w	4026fe <main_screen_play+0xeba>
	char tmp[12] = {0};
  402242:	2300      	movs	r3, #0
  402244:	9901      	ldr	r1, [sp, #4]
				glcd_puts(fixedpt_cstr(floor_err, 2),0);
  402246:	46b2      	mov	sl, r6
	if (A < 0) {
  402248:	429e      	cmp	r6, r3
	char tmp[12] = {0};
  40224a:	930b      	str	r3, [sp, #44]	; 0x2c
  40224c:	604b      	str	r3, [r1, #4]
  40224e:	608b      	str	r3, [r1, #8]
	if (A < 0) {
  402250:	f2c0 8249 	blt.w	4026e6 <main_screen_play+0xea2>
	int ndec = 0, slen = 0;
  402254:	4699      	mov	r9, r3
	ip = fixedpt_toint(A);
  402256:	ea4f 36ea 	mov.w	r6, sl, asr #15
  40225a:	f8dd 8004 	ldr.w	r8, [sp, #4]
	int ndec = 0, slen = 0;
  40225e:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  402260:	17f7      	asrs	r7, r6, #31
  402262:	e03a      	b.n	4022da <main_screen_play+0xa96>
  402264:	004199ec 	.word	0x004199ec
  402268:	0040cf51 	.word	0x0040cf51
  40226c:	0040de29 	.word	0x0040de29
  402270:	2040084c 	.word	0x2040084c
  402274:	0040c541 	.word	0x0040c541
  402278:	0040c7a5 	.word	0x0040c7a5
  40227c:	00419a1c 	.word	0x00419a1c
  402280:	004128f5 	.word	0x004128f5
  402284:	00419a2c 	.word	0x00419a2c
  402288:	0040df29 	.word	0x0040df29
  40228c:	0040f1a1 	.word	0x0040f1a1
  402290:	46800000 	.word	0x46800000
  402294:	00418749 	.word	0x00418749
  402298:	0041848d 	.word	0x0041848d
  40229c:	3fe00000 	.word	0x3fe00000
  4022a0:	bfe00000 	.word	0xbfe00000
  4022a4:	00418d51 	.word	0x00418d51
  4022a8:	20400854 	.word	0x20400854
  4022ac:	204052b4 	.word	0x204052b4
  4022b0:	0040ded1 	.word	0x0040ded1
  4022b4:	004199d8 	.word	0x004199d8
  4022b8:	0040df15 	.word	0x0040df15
  4022bc:	004199f4 	.word	0x004199f4
  4022c0:	0040181d 	.word	0x0040181d
  4022c4:	00419a30 	.word	0x00419a30
  4022c8:	0040456d 	.word	0x0040456d
  4022cc:	20400c80 	.word	0x20400c80
  4022d0:	0041905d 	.word	0x0041905d
  4022d4:	fffffeb8 	.word	0xfffffeb8
		tmp[ndec++] = '0' + ip % 10;
  4022d8:	461c      	mov	r4, r3
  4022da:	4630      	mov	r0, r6
  4022dc:	4639      	mov	r1, r7
  4022de:	220a      	movs	r2, #10
  4022e0:	2300      	movs	r3, #0
  4022e2:	47a8      	blx	r5
  4022e4:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  4022e8:	4630      	mov	r0, r6
  4022ea:	4639      	mov	r1, r7
  4022ec:	220a      	movs	r2, #10
  4022ee:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  4022f0:	f808 eb01 	strb.w	lr, [r8], #1
		ip /= 10;
  4022f4:	47a8      	blx	r5
  4022f6:	4606      	mov	r6, r0
  4022f8:	460f      	mov	r7, r1
		tmp[ndec++] = '0' + ip % 10;
  4022fa:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  4022fc:	ea56 0207 	orrs.w	r2, r6, r7
  402300:	d1ea      	bne.n	4022d8 <main_screen_play+0xa94>
  402302:	f109 32ff 	add.w	r2, r9, #4294967295
  402306:	9801      	ldr	r0, [sp, #4]
  402308:	9900      	ldr	r1, [sp, #0]
  40230a:	4403      	add	r3, r0
  40230c:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  40230e:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402312:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  402314:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402318:	d1f9      	bne.n	40230e <main_screen_play+0xaca>
  40231a:	eb04 0509 	add.w	r5, r4, r9
	str[slen++] = '.';
  40231e:	9800      	ldr	r0, [sp, #0]
  402320:	f109 0901 	add.w	r9, r9, #1
  402324:	212e      	movs	r1, #46	; 0x2e
  402326:	4404      	add	r4, r0
  402328:	1c6e      	adds	r6, r5, #1
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40232a:	ea4f 424a 	mov.w	r2, sl, lsl #17
	str[slen++] = '.';
  40232e:	3502      	adds	r5, #2
  402330:	f804 1009 	strb.w	r1, [r4, r9]
  402334:	4406      	add	r6, r0
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402336:	2400      	movs	r4, #0
  402338:	e001      	b.n	40233e <main_screen_play+0xafa>
	} while (fr != 0 && ndec < max_dec);
  40233a:	2c01      	cmp	r4, #1
  40233c:	dc11      	bgt.n	402362 <main_screen_play+0xb1e>
		fr = (fr & mask) * 10;
  40233e:	2300      	movs	r3, #0
  402340:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402342:	3501      	adds	r5, #1
		ndec++;
  402344:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  402346:	009f      	lsls	r7, r3, #2
  402348:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  40234c:	1812      	adds	r2, r2, r0
  40234e:	414b      	adcs	r3, r1
  402350:	1892      	adds	r2, r2, r2
  402352:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402354:	f103 0130 	add.w	r1, r3, #48	; 0x30
  402358:	f806 1f01 	strb.w	r1, [r6, #1]!
	} while (fr != 0 && ndec < max_dec);
  40235c:	ea52 0103 	orrs.w	r1, r2, r3
  402360:	d1eb      	bne.n	40233a <main_screen_play+0xaf6>
	if (ndec > 1 && str[slen-1] == '0')
  402362:	2c02      	cmp	r4, #2
  402364:	d105      	bne.n	402372 <main_screen_play+0xb2e>
  402366:	1e6b      	subs	r3, r5, #1
  402368:	9a00      	ldr	r2, [sp, #0]
  40236a:	5cd2      	ldrb	r2, [r2, r3]
  40236c:	2a30      	cmp	r2, #48	; 0x30
  40236e:	f000 81c8 	beq.w	402702 <main_screen_play+0xebe>
		str[slen] = '\0';
  402372:	2300      	movs	r3, #0
  402374:	9a00      	ldr	r2, [sp, #0]
  402376:	5553      	strb	r3, [r2, r5]
  402378:	9b03      	ldr	r3, [sp, #12]
  40237a:	2100      	movs	r1, #0
  40237c:	48bb      	ldr	r0, [pc, #748]	; (40266c <main_screen_play+0xe28>)
  40237e:	4798      	blx	r3
				glcd_putsf(" cm", 0);
  402380:	2100      	movs	r1, #0
  402382:	48bb      	ldr	r0, [pc, #748]	; (402670 <main_screen_play+0xe2c>)
  402384:	9b04      	ldr	r3, [sp, #16]
  402386:	4798      	blx	r3
  402388:	e6e3      	b.n	402152 <main_screen_play+0x90e>
		int64_t lift_speed = fixedpt_abs(enc_get_omega_hat());// fixedpt_abs(vfd_get_desired_speed());
  40238a:	47a0      	blx	r4
  40238c:	4240      	negs	r0, r0
  40238e:	e51b      	b.n	401dc8 <main_screen_play+0x584>
		write_r_text("Lspd",0);
  402390:	2100      	movs	r1, #0
  402392:	48b8      	ldr	r0, [pc, #736]	; (402674 <main_screen_play+0xe30>)
  402394:	4cb8      	ldr	r4, [pc, #736]	; (402678 <main_screen_play+0xe34>)
  402396:	47a0      	blx	r4
  402398:	e608      	b.n	401fac <main_screen_play+0x768>
		write_r_text("Door",0);
  40239a:	2100      	movs	r1, #0
  40239c:	48b7      	ldr	r0, [pc, #732]	; (40267c <main_screen_play+0xe38>)
  40239e:	4cb6      	ldr	r4, [pc, #728]	; (402678 <main_screen_play+0xe34>)
  4023a0:	47a0      	blx	r4
  4023a2:	e603      	b.n	401fac <main_screen_play+0x768>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  4023a4:	2200      	movs	r2, #0
  4023a6:	9900      	ldr	r1, [sp, #0]
  4023a8:	54ca      	strb	r2, [r1, r3]
  4023aa:	e4cd      	b.n	401d48 <main_screen_play+0x504>
  4023ac:	2200      	movs	r2, #0
  4023ae:	9900      	ldr	r1, [sp, #0]
  4023b0:	54ca      	strb	r2, [r1, r3]
  4023b2:	e432      	b.n	401c1a <main_screen_play+0x3d6>
  4023b4:	2200      	movs	r2, #0
  4023b6:	9900      	ldr	r1, [sp, #0]
  4023b8:	54ca      	strb	r2, [r1, r3]
  4023ba:	e6c1      	b.n	402140 <main_screen_play+0x8fc>
		str[slen++] = '-';
  4023bc:	4bab      	ldr	r3, [pc, #684]	; (40266c <main_screen_play+0xe28>)
		A *= -1;
  4023be:	4264      	negs	r4, r4
		str[slen++] = '-';
  4023c0:	f04f 0a01 	mov.w	sl, #1
  4023c4:	461a      	mov	r2, r3
  4023c6:	9300      	str	r3, [sp, #0]
  4023c8:	232d      	movs	r3, #45	; 0x2d
  4023ca:	7013      	strb	r3, [r2, #0]
  4023cc:	e510      	b.n	401df0 <main_screen_play+0x5ac>
		write_r_text("Hspd",0);
  4023ce:	2100      	movs	r1, #0
  4023d0:	48ab      	ldr	r0, [pc, #684]	; (402680 <main_screen_play+0xe3c>)
  4023d2:	4ca9      	ldr	r4, [pc, #676]	; (402678 <main_screen_play+0xe34>)
  4023d4:	47a0      	blx	r4
  4023d6:	e5e9      	b.n	401fac <main_screen_play+0x768>
	else if(get_down_button())
  4023d8:	4baa      	ldr	r3, [pc, #680]	; (402684 <main_screen_play+0xe40>)
  4023da:	4798      	blx	r3
  4023dc:	2800      	cmp	r0, #0
  4023de:	f000 809c 	beq.w	40251a <main_screen_play+0xcd6>
		active_screen = IDF_SCREEN_ENCODER;
  4023e2:	4ba9      	ldr	r3, [pc, #676]	; (402688 <main_screen_play+0xe44>)
  4023e4:	2203      	movs	r2, #3
  4023e6:	601a      	str	r2, [r3, #0]
  4023e8:	e5e8      	b.n	401fbc <main_screen_play+0x778>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  4023ea:	2200      	movs	r2, #0
  4023ec:	9900      	ldr	r1, [sp, #0]
  4023ee:	54ca      	strb	r2, [r1, r3]
  4023f0:	e558      	b.n	401ea4 <main_screen_play+0x660>
			glcd_putsf("D",0);
  4023f2:	2100      	movs	r1, #0
  4023f4:	48a5      	ldr	r0, [pc, #660]	; (40268c <main_screen_play+0xe48>)
  4023f6:	9b04      	ldr	r3, [sp, #16]
  4023f8:	4798      	blx	r3
  4023fa:	e603      	b.n	402004 <main_screen_play+0x7c0>
			glcd_putsf("L",0);
  4023fc:	2100      	movs	r1, #0
  4023fe:	48a4      	ldr	r0, [pc, #656]	; (402690 <main_screen_play+0xe4c>)
  402400:	9b04      	ldr	r3, [sp, #16]
  402402:	4798      	blx	r3
  402404:	e5fe      	b.n	402004 <main_screen_play+0x7c0>
		if (menue_lift_data_applied.m_cont_dis_technique == 1) putIt('S');
  402406:	9b02      	ldr	r3, [sp, #8]
  402408:	2053      	movs	r0, #83	; 0x53
  40240a:	4798      	blx	r3
  40240c:	f7ff ba8d 	b.w	40192a <main_screen_play+0xe6>
				if (floor_err < fixedpt_rconst(-0.01))
  402410:	4aa0      	ldr	r2, [pc, #640]	; (402694 <main_screen_play+0xe50>)
  402412:	f04f 33ff 	mov.w	r3, #4294967295
  402416:	4290      	cmp	r0, r2
  402418:	eb71 0303 	sbcs.w	r3, r1, r3
  40241c:	f2c0 8121 	blt.w	402662 <main_screen_play+0xe1e>
				else if (floor_err > fixedpt_rconst(0.01))
  402420:	f44f 72a4 	mov.w	r2, #328	; 0x148
  402424:	2300      	movs	r3, #0
  402426:	4282      	cmp	r2, r0
  402428:	418b      	sbcs	r3, r1
  40242a:	da02      	bge.n	402432 <main_screen_play+0xbee>
					putIt(0);
  40242c:	2000      	movs	r0, #0
  40242e:	9b02      	ldr	r3, [sp, #8]
  402430:	4798      	blx	r3
	char tmp[12] = {0};
  402432:	2300      	movs	r3, #0
  402434:	9901      	ldr	r1, [sp, #4]
	if (A < 0) {
  402436:	429e      	cmp	r6, r3
	char tmp[12] = {0};
  402438:	930b      	str	r3, [sp, #44]	; 0x2c
  40243a:	604b      	str	r3, [r1, #4]
  40243c:	608b      	str	r3, [r1, #8]
	if (A < 0) {
  40243e:	f2c0 8133 	blt.w	4026a8 <main_screen_play+0xe64>
  402442:	ea4f 38e6 	mov.w	r8, r6, asr #15
	int ndec = 0, slen = 0;
  402446:	469b      	mov	fp, r3
  402448:	0476      	lsls	r6, r6, #17
  40244a:	ea4f 79e8 	mov.w	r9, r8, asr #31
		str[slen++] = '-';
  40244e:	f8dd a004 	ldr.w	sl, [sp, #4]
	int ndec = 0, slen = 0;
  402452:	2400      	movs	r4, #0
  402454:	e000      	b.n	402458 <main_screen_play+0xc14>
		tmp[ndec++] = '0' + ip % 10;
  402456:	461c      	mov	r4, r3
  402458:	4640      	mov	r0, r8
  40245a:	4649      	mov	r1, r9
  40245c:	220a      	movs	r2, #10
  40245e:	2300      	movs	r3, #0
  402460:	47a8      	blx	r5
  402462:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402466:	4640      	mov	r0, r8
  402468:	4649      	mov	r1, r9
  40246a:	220a      	movs	r2, #10
  40246c:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  40246e:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  402472:	47a8      	blx	r5
  402474:	4680      	mov	r8, r0
  402476:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  402478:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  40247a:	ea58 0209 	orrs.w	r2, r8, r9
  40247e:	d1ea      	bne.n	402456 <main_screen_play+0xc12>
  402480:	f10b 32ff 	add.w	r2, fp, #4294967295
  402484:	9801      	ldr	r0, [sp, #4]
  402486:	9900      	ldr	r1, [sp, #0]
  402488:	4403      	add	r3, r0
  40248a:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  40248c:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402490:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  402492:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402496:	d1f9      	bne.n	40248c <main_screen_play+0xc48>
  402498:	eb04 000b 	add.w	r0, r4, fp
	str[slen++] = '.';
  40249c:	9a00      	ldr	r2, [sp, #0]
  40249e:	f10b 0301 	add.w	r3, fp, #1
  4024a2:	f04f 0e2e 	mov.w	lr, #46	; 0x2e
  4024a6:	1c45      	adds	r5, r0, #1
  4024a8:	2100      	movs	r1, #0
  4024aa:	4413      	add	r3, r2
  4024ac:	3002      	adds	r0, #2
  4024ae:	4415      	add	r5, r2
  4024b0:	f803 e004 	strb.w	lr, [r3, r4]
  4024b4:	e001      	b.n	4024ba <main_screen_play+0xc76>
	} while (fr != 0 && ndec < max_dec);
  4024b6:	2901      	cmp	r1, #1
  4024b8:	dc11      	bgt.n	4024de <main_screen_play+0xc9a>
		fr = (fr & mask) * 10;
  4024ba:	2700      	movs	r7, #0
  4024bc:	00b2      	lsls	r2, r6, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4024be:	3001      	adds	r0, #1
		ndec++;
  4024c0:	3101      	adds	r1, #1
		fr = (fr & mask) * 10;
  4024c2:	00bc      	lsls	r4, r7, #2
  4024c4:	ea44 7396 	orr.w	r3, r4, r6, lsr #30
  4024c8:	18b6      	adds	r6, r6, r2
  4024ca:	415f      	adcs	r7, r3
  4024cc:	19b6      	adds	r6, r6, r6
  4024ce:	417f      	adcs	r7, r7
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4024d0:	f107 0330 	add.w	r3, r7, #48	; 0x30
  4024d4:	f805 3f01 	strb.w	r3, [r5, #1]!
	} while (fr != 0 && ndec < max_dec);
  4024d8:	ea56 0307 	orrs.w	r3, r6, r7
  4024dc:	d1eb      	bne.n	4024b6 <main_screen_play+0xc72>
	if (ndec > 1 && str[slen-1] == '0')
  4024de:	2902      	cmp	r1, #2
  4024e0:	d105      	bne.n	4024ee <main_screen_play+0xcaa>
  4024e2:	1e43      	subs	r3, r0, #1
  4024e4:	9a00      	ldr	r2, [sp, #0]
  4024e6:	5cd2      	ldrb	r2, [r2, r3]
  4024e8:	2a30      	cmp	r2, #48	; 0x30
  4024ea:	f000 80e8 	beq.w	4026be <main_screen_play+0xe7a>
		str[slen] = '\0';
  4024ee:	2300      	movs	r3, #0
  4024f0:	9a00      	ldr	r2, [sp, #0]
  4024f2:	5413      	strb	r3, [r2, r0]
				glcd_puts(fixedpt_cstr(floor_err, 2),0);
  4024f4:	9b03      	ldr	r3, [sp, #12]
  4024f6:	2100      	movs	r1, #0
  4024f8:	485c      	ldr	r0, [pc, #368]	; (40266c <main_screen_play+0xe28>)
  4024fa:	4798      	blx	r3
				glcd_putsf(" M", 0);
  4024fc:	2100      	movs	r1, #0
  4024fe:	4866      	ldr	r0, [pc, #408]	; (402698 <main_screen_play+0xe54>)
  402500:	9b04      	ldr	r3, [sp, #16]
  402502:	4798      	blx	r3
  402504:	e625      	b.n	402152 <main_screen_play+0x90e>
		else if (menue_lift_data_applied.m_cont_dis_technique == 2) putIt('T');
  402506:	9b02      	ldr	r3, [sp, #8]
  402508:	2054      	movs	r0, #84	; 0x54
  40250a:	4798      	blx	r3
  40250c:	f7ff ba0d 	b.w	40192a <main_screen_play+0xe6>
		write_r_text("Ariv",0);
  402510:	2100      	movs	r1, #0
  402512:	4862      	ldr	r0, [pc, #392]	; (40269c <main_screen_play+0xe58>)
  402514:	4c58      	ldr	r4, [pc, #352]	; (402678 <main_screen_play+0xe34>)
  402516:	47a0      	blx	r4
  402518:	e548      	b.n	401fac <main_screen_play+0x768>
	else if(get_right_button())
  40251a:	4b61      	ldr	r3, [pc, #388]	; (4026a0 <main_screen_play+0xe5c>)
  40251c:	4798      	blx	r3
  40251e:	2800      	cmp	r0, #0
  402520:	f43f ad4c 	beq.w	401fbc <main_screen_play+0x778>
		active_screen = IDF_SCREEN_TORQUE;
  402524:	4b58      	ldr	r3, [pc, #352]	; (402688 <main_screen_play+0xe44>)
  402526:	2204      	movs	r2, #4
  402528:	601a      	str	r2, [r3, #0]
  40252a:	e547      	b.n	401fbc <main_screen_play+0x778>
				floor_err *= 1000;
  40252c:	014c      	lsls	r4, r1, #5
				if (floor_err < fixedpt_rconst(-0.01))
  40252e:	4e59      	ldr	r6, [pc, #356]	; (402694 <main_screen_play+0xe50>)
				floor_err *= 1000;
  402530:	0142      	lsls	r2, r0, #5
				if (floor_err < fixedpt_rconst(-0.01))
  402532:	f04f 37ff 	mov.w	r7, #4294967295
				floor_err *= 1000;
  402536:	ea44 63d0 	orr.w	r3, r4, r0, lsr #27
  40253a:	1a12      	subs	r2, r2, r0
  40253c:	eb63 0301 	sbc.w	r3, r3, r1
  402540:	ea4f 0e82 	mov.w	lr, r2, lsl #2
  402544:	009c      	lsls	r4, r3, #2
  402546:	eb1e 0800 	adds.w	r8, lr, r0
  40254a:	ea44 7492 	orr.w	r4, r4, r2, lsr #30
  40254e:	ea4f 02c8 	mov.w	r2, r8, lsl #3
  402552:	eb44 0901 	adc.w	r9, r4, r1
				if (floor_err < fixedpt_rconst(-0.01))
  402556:	42b2      	cmp	r2, r6
				floor_err *= 1000;
  402558:	ea4f 03c9 	mov.w	r3, r9, lsl #3
  40255c:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
  402560:	4690      	mov	r8, r2
  402562:	4699      	mov	r9, r3
				if (floor_err < fixedpt_rconst(-0.01))
  402564:	eb79 0307 	sbcs.w	r3, r9, r7
  402568:	f2c0 80ad 	blt.w	4026c6 <main_screen_play+0xe82>
				else if (floor_err > fixedpt_rconst(0.01))
  40256c:	f44f 72a4 	mov.w	r2, #328	; 0x148
  402570:	2300      	movs	r3, #0
  402572:	4542      	cmp	r2, r8
  402574:	eb73 0309 	sbcs.w	r3, r3, r9
  402578:	f2c0 80ca 	blt.w	402710 <main_screen_play+0xecc>
				floor_err = fixedpt_abs(floor_err);
  40257c:	f1b8 0f00 	cmp.w	r8, #0
  402580:	f179 0300 	sbcs.w	r3, r9, #0
  402584:	f2c0 80c1 	blt.w	40270a <main_screen_play+0xec6>
	char tmp[12] = {0};
  402588:	2100      	movs	r1, #0
  40258a:	9a01      	ldr	r2, [sp, #4]
				glcd_puts(fixedpt_cstr(floor_err, 2),0);
  40258c:	46c2      	mov	sl, r8
	if (A < 0) {
  40258e:	4588      	cmp	r8, r1
	char tmp[12] = {0};
  402590:	910b      	str	r1, [sp, #44]	; 0x2c
  402592:	6051      	str	r1, [r2, #4]
  402594:	6091      	str	r1, [r2, #8]
	if (A < 0) {
  402596:	f2c0 809e 	blt.w	4026d6 <main_screen_play+0xe92>
	int ndec = 0, slen = 0;
  40259a:	4689      	mov	r9, r1
	ip = fixedpt_toint(A);
  40259c:	ea4f 36ea 	mov.w	r6, sl, asr #15
  4025a0:	f8dd 8004 	ldr.w	r8, [sp, #4]
	int ndec = 0, slen = 0;
  4025a4:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  4025a6:	17f7      	asrs	r7, r6, #31
  4025a8:	e000      	b.n	4025ac <main_screen_play+0xd68>
		tmp[ndec++] = '0' + ip % 10;
  4025aa:	461c      	mov	r4, r3
  4025ac:	4630      	mov	r0, r6
  4025ae:	4639      	mov	r1, r7
  4025b0:	220a      	movs	r2, #10
  4025b2:	2300      	movs	r3, #0
  4025b4:	47a8      	blx	r5
  4025b6:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  4025ba:	4630      	mov	r0, r6
  4025bc:	4639      	mov	r1, r7
  4025be:	220a      	movs	r2, #10
  4025c0:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  4025c2:	f808 eb01 	strb.w	lr, [r8], #1
		ip /= 10;
  4025c6:	47a8      	blx	r5
  4025c8:	4606      	mov	r6, r0
  4025ca:	460f      	mov	r7, r1
		tmp[ndec++] = '0' + ip % 10;
  4025cc:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  4025ce:	ea56 0207 	orrs.w	r2, r6, r7
  4025d2:	d1ea      	bne.n	4025aa <main_screen_play+0xd66>
  4025d4:	f109 32ff 	add.w	r2, r9, #4294967295
  4025d8:	9801      	ldr	r0, [sp, #4]
  4025da:	9900      	ldr	r1, [sp, #0]
  4025dc:	4403      	add	r3, r0
  4025de:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  4025e0:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  4025e4:	4298      	cmp	r0, r3
		str[slen++] = tmp[--ndec];
  4025e6:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  4025ea:	d1f9      	bne.n	4025e0 <main_screen_play+0xd9c>
  4025ec:	eb04 0509 	add.w	r5, r4, r9
	str[slen++] = '.';
  4025f0:	9800      	ldr	r0, [sp, #0]
  4025f2:	f109 0901 	add.w	r9, r9, #1
  4025f6:	212e      	movs	r1, #46	; 0x2e
  4025f8:	4404      	add	r4, r0
  4025fa:	1c6e      	adds	r6, r5, #1
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4025fc:	ea4f 424a 	mov.w	r2, sl, lsl #17
	str[slen++] = '.';
  402600:	3502      	adds	r5, #2
  402602:	f804 1009 	strb.w	r1, [r4, r9]
  402606:	4406      	add	r6, r0
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402608:	2400      	movs	r4, #0
  40260a:	e001      	b.n	402610 <main_screen_play+0xdcc>
	} while (fr != 0 && ndec < max_dec);
  40260c:	2c01      	cmp	r4, #1
  40260e:	dc11      	bgt.n	402634 <main_screen_play+0xdf0>
		fr = (fr & mask) * 10;
  402610:	2300      	movs	r3, #0
  402612:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402614:	3501      	adds	r5, #1
		ndec++;
  402616:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  402618:	009f      	lsls	r7, r3, #2
  40261a:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  40261e:	1812      	adds	r2, r2, r0
  402620:	414b      	adcs	r3, r1
  402622:	1892      	adds	r2, r2, r2
  402624:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402626:	f103 0130 	add.w	r1, r3, #48	; 0x30
  40262a:	f806 1f01 	strb.w	r1, [r6, #1]!
	} while (fr != 0 && ndec < max_dec);
  40262e:	ea52 0103 	orrs.w	r1, r2, r3
  402632:	d1eb      	bne.n	40260c <main_screen_play+0xdc8>
	if (ndec > 1 && str[slen-1] == '0')
  402634:	2c02      	cmp	r4, #2
  402636:	d104      	bne.n	402642 <main_screen_play+0xdfe>
  402638:	1e6b      	subs	r3, r5, #1
  40263a:	9a00      	ldr	r2, [sp, #0]
  40263c:	5cd2      	ldrb	r2, [r2, r3]
  40263e:	2a30      	cmp	r2, #48	; 0x30
  402640:	d059      	beq.n	4026f6 <main_screen_play+0xeb2>
		str[slen] = '\0';
  402642:	2300      	movs	r3, #0
  402644:	9a00      	ldr	r2, [sp, #0]
  402646:	5553      	strb	r3, [r2, r5]
  402648:	9b03      	ldr	r3, [sp, #12]
  40264a:	2100      	movs	r1, #0
  40264c:	4807      	ldr	r0, [pc, #28]	; (40266c <main_screen_play+0xe28>)
  40264e:	4798      	blx	r3
				glcd_putsf(" mm", 0);
  402650:	2100      	movs	r1, #0
  402652:	4814      	ldr	r0, [pc, #80]	; (4026a4 <main_screen_play+0xe60>)
  402654:	9b04      	ldr	r3, [sp, #16]
  402656:	4798      	blx	r3
  402658:	e57b      	b.n	402152 <main_screen_play+0x90e>
			if (fixedpt_abs(floor_err) >= FIXEDPT_ONE)
  40265a:	4246      	negs	r6, r0
  40265c:	eb61 0741 	sbc.w	r7, r1, r1, lsl #1
  402660:	e5bf      	b.n	4021e2 <main_screen_play+0x99e>
					putIt(1);
  402662:	9b02      	ldr	r3, [sp, #8]
  402664:	2001      	movs	r0, #1
  402666:	4798      	blx	r3
  402668:	e6e3      	b.n	402432 <main_screen_play+0xbee>
  40266a:	bf00      	nop
  40266c:	20400854 	.word	0x20400854
  402670:	00419a38 	.word	0x00419a38
  402674:	00419a0c 	.word	0x00419a0c
  402678:	0040cf51 	.word	0x0040cf51
  40267c:	004199fc 	.word	0x004199fc
  402680:	00419a04 	.word	0x00419a04
  402684:	0040de7d 	.word	0x0040de7d
  402688:	2040084c 	.word	0x2040084c
  40268c:	00419a24 	.word	0x00419a24
  402690:	00419a28 	.word	0x00419a28
  402694:	fffffeb8 	.word	0xfffffeb8
  402698:	00419a34 	.word	0x00419a34
  40269c:	00419a14 	.word	0x00419a14
  4026a0:	0040deb5 	.word	0x0040deb5
  4026a4:	00419a3c 	.word	0x00419a3c
		str[slen++] = '-';
  4026a8:	232d      	movs	r3, #45	; 0x2d
  4026aa:	9a00      	ldr	r2, [sp, #0]
  4026ac:	2600      	movs	r6, #0
  4026ae:	f8df 8070 	ldr.w	r8, [pc, #112]	; 402720 <main_screen_play+0xedc>
  4026b2:	f04f 39ff 	mov.w	r9, #4294967295
  4026b6:	f04f 0b01 	mov.w	fp, #1
  4026ba:	7013      	strb	r3, [r2, #0]
  4026bc:	e6c7      	b.n	40244e <main_screen_play+0xc0a>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  4026be:	2200      	movs	r2, #0
  4026c0:	9900      	ldr	r1, [sp, #0]
  4026c2:	54ca      	strb	r2, [r1, r3]
  4026c4:	e716      	b.n	4024f4 <main_screen_play+0xcb0>
					putIt(1);
  4026c6:	9b02      	ldr	r3, [sp, #8]
  4026c8:	2001      	movs	r0, #1
  4026ca:	4798      	blx	r3
  4026cc:	e756      	b.n	40257c <main_screen_play+0xd38>
					putIt(1);
  4026ce:	9b02      	ldr	r3, [sp, #8]
  4026d0:	2001      	movs	r0, #1
  4026d2:	4798      	blx	r3
  4026d4:	e5b0      	b.n	402238 <main_screen_play+0x9f4>
		str[slen++] = '-';
  4026d6:	232d      	movs	r3, #45	; 0x2d
  4026d8:	9a00      	ldr	r2, [sp, #0]
		A *= -1;
  4026da:	f1c8 0a00 	rsb	sl, r8, #0
		str[slen++] = '-';
  4026de:	f04f 0901 	mov.w	r9, #1
  4026e2:	7013      	strb	r3, [r2, #0]
  4026e4:	e75a      	b.n	40259c <main_screen_play+0xd58>
  4026e6:	232d      	movs	r3, #45	; 0x2d
  4026e8:	9a00      	ldr	r2, [sp, #0]
		A *= -1;
  4026ea:	f1c6 0a00 	rsb	sl, r6, #0
		str[slen++] = '-';
  4026ee:	f04f 0901 	mov.w	r9, #1
  4026f2:	7013      	strb	r3, [r2, #0]
  4026f4:	e5af      	b.n	402256 <main_screen_play+0xa12>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  4026f6:	2200      	movs	r2, #0
  4026f8:	9900      	ldr	r1, [sp, #0]
  4026fa:	54ca      	strb	r2, [r1, r3]
  4026fc:	e7a4      	b.n	402648 <main_screen_play+0xe04>
				floor_err = fixedpt_abs(floor_err);
  4026fe:	4276      	negs	r6, r6
  402700:	e59f      	b.n	402242 <main_screen_play+0x9fe>
  402702:	2200      	movs	r2, #0
  402704:	9900      	ldr	r1, [sp, #0]
  402706:	54ca      	strb	r2, [r1, r3]
  402708:	e636      	b.n	402378 <main_screen_play+0xb34>
				floor_err = fixedpt_abs(floor_err);
  40270a:	f1d8 0800 	rsbs	r8, r8, #0
  40270e:	e73b      	b.n	402588 <main_screen_play+0xd44>
					putIt(0);
  402710:	9b02      	ldr	r3, [sp, #8]
  402712:	2000      	movs	r0, #0
  402714:	4798      	blx	r3
  402716:	e731      	b.n	40257c <main_screen_play+0xd38>
  402718:	4620      	mov	r0, r4
	uint32_t hour, minute, seconds, PM = 0;
  40271a:	2400      	movs	r4, #0
  40271c:	f7ff b9d3 	b.w	401ac6 <main_screen_play+0x282>
  402720:	ffff0000 	.word	0xffff0000

00402724 <programming_screen_play>:

void programming_screen_play(void)
{
  402724:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if(menue_execute(get_enter_button(), get_esc_button(), get_up_button(), get_down_button(), get_left_button(), get_right_button())) active_screen = IDF_SCREEN_MAIN;	
  402728:	4b13      	ldr	r3, [pc, #76]	; (402778 <programming_screen_play+0x54>)
{
  40272a:	b083      	sub	sp, #12
	if(menue_execute(get_enter_button(), get_esc_button(), get_up_button(), get_down_button(), get_left_button(), get_right_button())) active_screen = IDF_SCREEN_MAIN;	
  40272c:	4798      	blx	r3
  40272e:	4b13      	ldr	r3, [pc, #76]	; (40277c <programming_screen_play+0x58>)
  402730:	4606      	mov	r6, r0
  402732:	4798      	blx	r3
  402734:	4b12      	ldr	r3, [pc, #72]	; (402780 <programming_screen_play+0x5c>)
  402736:	4607      	mov	r7, r0
  402738:	4798      	blx	r3
  40273a:	4b12      	ldr	r3, [pc, #72]	; (402784 <programming_screen_play+0x60>)
  40273c:	4680      	mov	r8, r0
  40273e:	4798      	blx	r3
  402740:	4b11      	ldr	r3, [pc, #68]	; (402788 <programming_screen_play+0x64>)
  402742:	4681      	mov	r9, r0
  402744:	4798      	blx	r3
  402746:	4604      	mov	r4, r0
  402748:	4b10      	ldr	r3, [pc, #64]	; (40278c <programming_screen_play+0x68>)
  40274a:	4798      	blx	r3
  40274c:	4d10      	ldr	r5, [pc, #64]	; (402790 <programming_screen_play+0x6c>)
  40274e:	b2c0      	uxtb	r0, r0
  402750:	b2e4      	uxtb	r4, r4
  402752:	9001      	str	r0, [sp, #4]
  402754:	fa5f f389 	uxtb.w	r3, r9
  402758:	9400      	str	r4, [sp, #0]
  40275a:	fa5f f288 	uxtb.w	r2, r8
  40275e:	b2f9      	uxtb	r1, r7
  402760:	b2f0      	uxtb	r0, r6
  402762:	47a8      	blx	r5
  402764:	b110      	cbz	r0, 40276c <programming_screen_play+0x48>
  402766:	4b0b      	ldr	r3, [pc, #44]	; (402794 <programming_screen_play+0x70>)
  402768:	2200      	movs	r2, #0
  40276a:	601a      	str	r2, [r3, #0]
	drop_all_buttons();
  40276c:	4b0a      	ldr	r3, [pc, #40]	; (402798 <programming_screen_play+0x74>)
}
  40276e:	b003      	add	sp, #12
  402770:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	drop_all_buttons();
  402774:	4718      	bx	r3
  402776:	bf00      	nop
  402778:	0040de29 	.word	0x0040de29
  40277c:	0040de45 	.word	0x0040de45
  402780:	0040de61 	.word	0x0040de61
  402784:	0040de7d 	.word	0x0040de7d
  402788:	0040de99 	.word	0x0040de99
  40278c:	0040deb5 	.word	0x0040deb5
  402790:	0040be99 	.word	0x0040be99
  402794:	2040084c 	.word	0x2040084c
  402798:	0040ded1 	.word	0x0040ded1

0040279c <monitor_screen_play>:

void monitor_screen_play(void)
{
  40279c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4027a0:	ed2d 8b02 	vpush	{d8}
  4027a4:	b089      	sub	sp, #36	; 0x24
	uint32_t *adc_reading;
	adc_reading = inverter_getADCcurrent();
  4027a6:	4bac      	ldr	r3, [pc, #688]	; (402a58 <monitor_screen_play+0x2bc>)
  4027a8:	4798      	blx	r3
	float ia,ib,ic;
	inverter_get_creadings(&ia, &ib, &ic);
  4027aa:	4bac      	ldr	r3, [pc, #688]	; (402a5c <monitor_screen_play+0x2c0>)
  4027ac:	aa04      	add	r2, sp, #16
  4027ae:	a903      	add	r1, sp, #12
  4027b0:	a802      	add	r0, sp, #8
	
	glcd_clear();
	glcd_gotoxy(0,0);

	glcd_putsf("I ",0);
	glcd_puts(fixedpt_cstr( fixedpt_rconst(sqrt(axt_get_current_avg())), 4),0);
  4027b2:	4fab      	ldr	r7, [pc, #684]	; (402a60 <monitor_screen_play+0x2c4>)
	inverter_get_creadings(&ia, &ib, &ic);
  4027b4:	4798      	blx	r3
	glcd_clear();
  4027b6:	4bab      	ldr	r3, [pc, #684]	; (402a64 <monitor_screen_play+0x2c8>)
  4027b8:	4798      	blx	r3
	glcd_gotoxy(0,0);
  4027ba:	2100      	movs	r1, #0
  4027bc:	4baa      	ldr	r3, [pc, #680]	; (402a68 <monitor_screen_play+0x2cc>)
	char tmp[12] = {0};
  4027be:	ae05      	add	r6, sp, #20
  4027c0:	4608      	mov	r0, r1
  4027c2:	4798      	blx	r3
	glcd_putsf("I ",0);
  4027c4:	2100      	movs	r1, #0
  4027c6:	4ba9      	ldr	r3, [pc, #676]	; (402a6c <monitor_screen_play+0x2d0>)
  4027c8:	48a9      	ldr	r0, [pc, #676]	; (402a70 <monitor_screen_play+0x2d4>)
  4027ca:	4798      	blx	r3
	glcd_puts(fixedpt_cstr( fixedpt_rconst(sqrt(axt_get_current_avg())), 4),0);
  4027cc:	47b8      	blx	r7
  4027ce:	4ba9      	ldr	r3, [pc, #676]	; (402a74 <monitor_screen_play+0x2d8>)
  4027d0:	4798      	blx	r3
  4027d2:	4ba9      	ldr	r3, [pc, #676]	; (402a78 <monitor_screen_play+0x2dc>)
  4027d4:	4798      	blx	r3
  4027d6:	4604      	mov	r4, r0
  4027d8:	460d      	mov	r5, r1
  4027da:	47b8      	blx	r7
  4027dc:	4620      	mov	r0, r4
  4027de:	2200      	movs	r2, #0
  4027e0:	4ba6      	ldr	r3, [pc, #664]	; (402a7c <monitor_screen_play+0x2e0>)
  4027e2:	4629      	mov	r1, r5
  4027e4:	4fa6      	ldr	r7, [pc, #664]	; (402a80 <monitor_screen_play+0x2e4>)
  4027e6:	47b8      	blx	r7
  4027e8:	4ca6      	ldr	r4, [pc, #664]	; (402a84 <monitor_screen_play+0x2e8>)
  4027ea:	2200      	movs	r2, #0
  4027ec:	4ba6      	ldr	r3, [pc, #664]	; (402a88 <monitor_screen_play+0x2ec>)
  4027ee:	47a0      	blx	r4
  4027f0:	4ba6      	ldr	r3, [pc, #664]	; (402a8c <monitor_screen_play+0x2f0>)
  4027f2:	4798      	blx	r3
  4027f4:	2300      	movs	r3, #0
	if (A < 0) {
  4027f6:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  4027f8:	6073      	str	r3, [r6, #4]
  4027fa:	9305      	str	r3, [sp, #20]
  4027fc:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  4027fe:	f2c0 83cd 	blt.w	402f9c <monitor_screen_play+0x800>
	int ndec = 0, slen = 0;
  402802:	469b      	mov	fp, r3
  402804:	4ba2      	ldr	r3, [pc, #648]	; (402a90 <monitor_screen_play+0x2f4>)
  402806:	9301      	str	r3, [sp, #4]
	ip = fixedpt_toint(A);
  402808:	ea4f 38e4 	mov.w	r8, r4, asr #15
  40280c:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  40280e:	2700      	movs	r7, #0
  402810:	4da0      	ldr	r5, [pc, #640]	; (402a94 <monitor_screen_play+0x2f8>)
	ip = fixedpt_toint(A);
  402812:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402816:	e000      	b.n	40281a <monitor_screen_play+0x7e>
		tmp[ndec++] = '0' + ip % 10;
  402818:	461f      	mov	r7, r3
  40281a:	4640      	mov	r0, r8
  40281c:	4649      	mov	r1, r9
  40281e:	220a      	movs	r2, #10
  402820:	2300      	movs	r3, #0
  402822:	47a8      	blx	r5
  402824:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402828:	4640      	mov	r0, r8
  40282a:	4649      	mov	r1, r9
  40282c:	220a      	movs	r2, #10
  40282e:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402830:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  402834:	47a8      	blx	r5
  402836:	4680      	mov	r8, r0
  402838:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  40283a:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  40283c:	ea58 0209 	orrs.w	r2, r8, r9
  402840:	d1ea      	bne.n	402818 <monitor_screen_play+0x7c>
  402842:	f10b 32ff 	add.w	r2, fp, #4294967295
  402846:	9901      	ldr	r1, [sp, #4]
  402848:	4433      	add	r3, r6
  40284a:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  40284c:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402850:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402852:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402856:	d1f9      	bne.n	40284c <monitor_screen_play+0xb0>
  402858:	eb07 0e0b 	add.w	lr, r7, fp
	str[slen++] = '.';
  40285c:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40285e:	0464      	lsls	r4, r4, #17
  402860:	f10b 0b01 	add.w	fp, fp, #1
  402864:	f10e 0c01 	add.w	ip, lr, #1
	str[slen++] = '.';
  402868:	4407      	add	r7, r0
  40286a:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40286c:	4622      	mov	r2, r4
	str[slen++] = '.';
  40286e:	f10e 0e02 	add.w	lr, lr, #2
  402872:	4484      	add	ip, r0
  402874:	f807 100b 	strb.w	r1, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402878:	2400      	movs	r4, #0
  40287a:	e001      	b.n	402880 <monitor_screen_play+0xe4>
	} while (fr != 0 && ndec < max_dec);
  40287c:	2c03      	cmp	r4, #3
  40287e:	dc12      	bgt.n	4028a6 <monitor_screen_play+0x10a>
		fr = (fr & mask) * 10;
  402880:	2300      	movs	r3, #0
  402882:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402884:	f10e 0e01 	add.w	lr, lr, #1
		ndec++;
  402888:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  40288a:	009f      	lsls	r7, r3, #2
  40288c:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  402890:	1812      	adds	r2, r2, r0
  402892:	414b      	adcs	r3, r1
  402894:	1892      	adds	r2, r2, r2
  402896:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402898:	f103 0130 	add.w	r1, r3, #48	; 0x30
  40289c:	f80c 1f01 	strb.w	r1, [ip, #1]!
	} while (fr != 0 && ndec < max_dec);
  4028a0:	ea52 0103 	orrs.w	r1, r2, r3
  4028a4:	d1ea      	bne.n	40287c <monitor_screen_play+0xe0>
	if (ndec > 1 && str[slen-1] == '0')
  4028a6:	2c01      	cmp	r4, #1
  4028a8:	d006      	beq.n	4028b8 <monitor_screen_play+0x11c>
  4028aa:	f10e 33ff 	add.w	r3, lr, #4294967295
  4028ae:	9a01      	ldr	r2, [sp, #4]
  4028b0:	5cd2      	ldrb	r2, [r2, r3]
  4028b2:	2a30      	cmp	r2, #48	; 0x30
  4028b4:	f000 83a8 	beq.w	403008 <monitor_screen_play+0x86c>
		str[slen] = '\0';
  4028b8:	2300      	movs	r3, #0
  4028ba:	9a01      	ldr	r2, [sp, #4]
  4028bc:	f802 300e 	strb.w	r3, [r2, lr]
  4028c0:	2100      	movs	r1, #0
  4028c2:	4873      	ldr	r0, [pc, #460]	; (402a90 <monitor_screen_play+0x2f4>)
  4028c4:	4b74      	ldr	r3, [pc, #464]	; (402a98 <monitor_screen_play+0x2fc>)
  4028c6:	4798      	blx	r3
	
	glcd_gotoxy(0, 45);
  4028c8:	212d      	movs	r1, #45	; 0x2d
  4028ca:	2000      	movs	r0, #0
  4028cc:	4b66      	ldr	r3, [pc, #408]	; (402a68 <monitor_screen_play+0x2cc>)
  4028ce:	4798      	blx	r3
	glcd_putsf("OL ",0);
  4028d0:	2100      	movs	r1, #0
  4028d2:	4872      	ldr	r0, [pc, #456]	; (402a9c <monitor_screen_play+0x300>)
  4028d4:	4b65      	ldr	r3, [pc, #404]	; (402a6c <monitor_screen_play+0x2d0>)
  4028d6:	4798      	blx	r3
	glcd_puts(itos(get_olval()),0);
  4028d8:	4b71      	ldr	r3, [pc, #452]	; (402aa0 <monitor_screen_play+0x304>)
  4028da:	4798      	blx	r3
  4028dc:	4b71      	ldr	r3, [pc, #452]	; (402aa4 <monitor_screen_play+0x308>)
  4028de:	4798      	blx	r3
  4028e0:	4b71      	ldr	r3, [pc, #452]	; (402aa8 <monitor_screen_play+0x30c>)
  4028e2:	4798      	blx	r3
  4028e4:	2100      	movs	r1, #0
  4028e6:	4b6c      	ldr	r3, [pc, #432]	; (402a98 <monitor_screen_play+0x2fc>)
  4028e8:	4798      	blx	r3
	
	glcd_gotoxy(0, 9);
  4028ea:	2109      	movs	r1, #9
  4028ec:	2000      	movs	r0, #0
  4028ee:	4b5e      	ldr	r3, [pc, #376]	; (402a68 <monitor_screen_play+0x2cc>)
  4028f0:	4798      	blx	r3
	glcd_putsf("Ia ",0);
  4028f2:	2100      	movs	r1, #0
  4028f4:	486d      	ldr	r0, [pc, #436]	; (402aac <monitor_screen_play+0x310>)
  4028f6:	4b5d      	ldr	r3, [pc, #372]	; (402a6c <monitor_screen_play+0x2d0>)
  4028f8:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(ia), 4),0);
  4028fa:	ed9d 8a02 	vldr	s16, [sp, #8]
  4028fe:	eddf 7a6c 	vldr	s15, [pc, #432]	; 402ab0 <monitor_screen_play+0x314>
  402902:	4b5c      	ldr	r3, [pc, #368]	; (402a74 <monitor_screen_play+0x2d8>)
  402904:	ee68 7a27 	vmul.f32	s15, s16, s15
  402908:	4c5e      	ldr	r4, [pc, #376]	; (402a84 <monitor_screen_play+0x2e8>)
  40290a:	ee17 0a90 	vmov	r0, s15
  40290e:	4798      	blx	r3
  402910:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  402914:	460b      	mov	r3, r1
  402916:	4602      	mov	r2, r0
  402918:	2000      	movs	r0, #0
  40291a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40291e:	bfac      	ite	ge
  402920:	4959      	ldrge	r1, [pc, #356]	; (402a88 <monitor_screen_play+0x2ec>)
  402922:	4964      	ldrlt	r1, [pc, #400]	; (402ab4 <monitor_screen_play+0x318>)
  402924:	47a0      	blx	r4
  402926:	4b59      	ldr	r3, [pc, #356]	; (402a8c <monitor_screen_play+0x2f0>)
  402928:	4798      	blx	r3
	char tmp[12] = {0};
  40292a:	2300      	movs	r3, #0
	if (A < 0) {
  40292c:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  402930:	9305      	str	r3, [sp, #20]
  402932:	6073      	str	r3, [r6, #4]
  402934:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  402936:	f2c0 835f 	blt.w	402ff8 <monitor_screen_play+0x85c>
	int ndec = 0, slen = 0;
  40293a:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  40293c:	ea4f 38eb 	mov.w	r8, fp, asr #15
  402940:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  402942:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  402944:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402948:	e000      	b.n	40294c <monitor_screen_play+0x1b0>
		tmp[ndec++] = '0' + ip % 10;
  40294a:	461c      	mov	r4, r3
  40294c:	4640      	mov	r0, r8
  40294e:	4649      	mov	r1, r9
  402950:	220a      	movs	r2, #10
  402952:	2300      	movs	r3, #0
  402954:	47a8      	blx	r5
  402956:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  40295a:	4640      	mov	r0, r8
  40295c:	4649      	mov	r1, r9
  40295e:	220a      	movs	r2, #10
  402960:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402962:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  402966:	47a8      	blx	r5
  402968:	4680      	mov	r8, r0
  40296a:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  40296c:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  40296e:	ea58 0209 	orrs.w	r2, r8, r9
  402972:	d1ea      	bne.n	40294a <monitor_screen_play+0x1ae>
  402974:	f10a 32ff 	add.w	r2, sl, #4294967295
  402978:	9901      	ldr	r1, [sp, #4]
  40297a:	4433      	add	r3, r6
  40297c:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  40297e:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402982:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402984:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402988:	d1f9      	bne.n	40297e <monitor_screen_play+0x1e2>
  40298a:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  40298e:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402990:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  402994:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  402998:	4404      	add	r4, r0
  40299a:	f107 0e01 	add.w	lr, r7, #1
  40299e:	212e      	movs	r1, #46	; 0x2e
  4029a0:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4029a2:	465a      	mov	r2, fp
  4029a4:	4486      	add	lr, r0
	str[slen++] = '.';
  4029a6:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4029aa:	2400      	movs	r4, #0
  4029ac:	e001      	b.n	4029b2 <monitor_screen_play+0x216>
	} while (fr != 0 && ndec < max_dec);
  4029ae:	2c03      	cmp	r4, #3
  4029b0:	dc12      	bgt.n	4029d8 <monitor_screen_play+0x23c>
		fr = (fr & mask) * 10;
  4029b2:	2300      	movs	r3, #0
  4029b4:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4029b6:	3701      	adds	r7, #1
		ndec++;
  4029b8:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  4029ba:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  4029be:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  4029c2:	1812      	adds	r2, r2, r0
  4029c4:	414b      	adcs	r3, r1
  4029c6:	1892      	adds	r2, r2, r2
  4029c8:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4029ca:	f103 0130 	add.w	r1, r3, #48	; 0x30
  4029ce:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  4029d2:	ea52 0103 	orrs.w	r1, r2, r3
  4029d6:	d1ea      	bne.n	4029ae <monitor_screen_play+0x212>
	if (ndec > 1 && str[slen-1] == '0')
  4029d8:	2c01      	cmp	r4, #1
  4029da:	d005      	beq.n	4029e8 <monitor_screen_play+0x24c>
  4029dc:	1e7b      	subs	r3, r7, #1
  4029de:	9a01      	ldr	r2, [sp, #4]
  4029e0:	5cd2      	ldrb	r2, [r2, r3]
  4029e2:	2a30      	cmp	r2, #48	; 0x30
  4029e4:	f000 8324 	beq.w	403030 <monitor_screen_play+0x894>
		str[slen] = '\0';
  4029e8:	2300      	movs	r3, #0
  4029ea:	9a01      	ldr	r2, [sp, #4]
  4029ec:	55d3      	strb	r3, [r2, r7]
  4029ee:	2100      	movs	r1, #0
  4029f0:	4827      	ldr	r0, [pc, #156]	; (402a90 <monitor_screen_play+0x2f4>)
  4029f2:	4b29      	ldr	r3, [pc, #164]	; (402a98 <monitor_screen_play+0x2fc>)
  4029f4:	4798      	blx	r3
	//glcd_puts(fixedpt_cstr((hoist_info.dirup0_decel), 4),0);
	//glcd_puts(sitos(get_olia()),0);
	
	glcd_gotoxy(0, 18);
  4029f6:	2112      	movs	r1, #18
  4029f8:	2000      	movs	r0, #0
  4029fa:	4b1b      	ldr	r3, [pc, #108]	; (402a68 <monitor_screen_play+0x2cc>)
  4029fc:	4798      	blx	r3
	glcd_putsf("Ib ",0);
  4029fe:	2100      	movs	r1, #0
  402a00:	482d      	ldr	r0, [pc, #180]	; (402ab8 <monitor_screen_play+0x31c>)
  402a02:	4b1a      	ldr	r3, [pc, #104]	; (402a6c <monitor_screen_play+0x2d0>)
  402a04:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(ib), 4),0);
  402a06:	ed9d 8a03 	vldr	s16, [sp, #12]
  402a0a:	eddf 7a29 	vldr	s15, [pc, #164]	; 402ab0 <monitor_screen_play+0x314>
  402a0e:	4b19      	ldr	r3, [pc, #100]	; (402a74 <monitor_screen_play+0x2d8>)
  402a10:	ee68 7a27 	vmul.f32	s15, s16, s15
  402a14:	4c1b      	ldr	r4, [pc, #108]	; (402a84 <monitor_screen_play+0x2e8>)
  402a16:	ee17 0a90 	vmov	r0, s15
  402a1a:	4798      	blx	r3
  402a1c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  402a20:	460b      	mov	r3, r1
  402a22:	4602      	mov	r2, r0
  402a24:	2000      	movs	r0, #0
  402a26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  402a2a:	bfac      	ite	ge
  402a2c:	4916      	ldrge	r1, [pc, #88]	; (402a88 <monitor_screen_play+0x2ec>)
  402a2e:	4921      	ldrlt	r1, [pc, #132]	; (402ab4 <monitor_screen_play+0x318>)
  402a30:	47a0      	blx	r4
  402a32:	4b16      	ldr	r3, [pc, #88]	; (402a8c <monitor_screen_play+0x2f0>)
  402a34:	4798      	blx	r3
	char tmp[12] = {0};
  402a36:	2300      	movs	r3, #0
	if (A < 0) {
  402a38:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  402a3c:	9305      	str	r3, [sp, #20]
  402a3e:	6073      	str	r3, [r6, #4]
  402a40:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  402a42:	f2c0 82d1 	blt.w	402fe8 <monitor_screen_play+0x84c>
	int ndec = 0, slen = 0;
  402a46:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  402a48:	ea4f 38eb 	mov.w	r8, fp, asr #15
  402a4c:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  402a4e:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  402a50:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402a54:	e033      	b.n	402abe <monitor_screen_play+0x322>
  402a56:	bf00      	nop
  402a58:	00414e35 	.word	0x00414e35
  402a5c:	004153c1 	.word	0x004153c1
  402a60:	0040e379 	.word	0x0040e379
  402a64:	0040c2e5 	.word	0x0040c2e5
  402a68:	0040c7a5 	.word	0x0040c7a5
  402a6c:	0040c7b9 	.word	0x0040c7b9
  402a70:	00419a40 	.word	0x00419a40
  402a74:	00418749 	.word	0x00418749
  402a78:	00418249 	.word	0x00418249
  402a7c:	40e00000 	.word	0x40e00000
  402a80:	004187f1 	.word	0x004187f1
  402a84:	0041848d 	.word	0x0041848d
  402a88:	3fe00000 	.word	0x3fe00000
  402a8c:	00418d51 	.word	0x00418d51
  402a90:	20400854 	.word	0x20400854
  402a94:	004190fd 	.word	0x004190fd
  402a98:	0040ca05 	.word	0x0040ca05
  402a9c:	00419a44 	.word	0x00419a44
  402aa0:	0041485d 	.word	0x0041485d
  402aa4:	00419155 	.word	0x00419155
  402aa8:	0040c205 	.word	0x0040c205
  402aac:	00419a48 	.word	0x00419a48
  402ab0:	47000000 	.word	0x47000000
  402ab4:	bfe00000 	.word	0xbfe00000
  402ab8:	00419a4c 	.word	0x00419a4c
		tmp[ndec++] = '0' + ip % 10;
  402abc:	461c      	mov	r4, r3
  402abe:	4640      	mov	r0, r8
  402ac0:	4649      	mov	r1, r9
  402ac2:	220a      	movs	r2, #10
  402ac4:	2300      	movs	r3, #0
  402ac6:	47a8      	blx	r5
  402ac8:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402acc:	4640      	mov	r0, r8
  402ace:	4649      	mov	r1, r9
  402ad0:	220a      	movs	r2, #10
  402ad2:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402ad4:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  402ad8:	47a8      	blx	r5
  402ada:	4680      	mov	r8, r0
  402adc:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  402ade:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  402ae0:	ea58 0209 	orrs.w	r2, r8, r9
  402ae4:	d1ea      	bne.n	402abc <monitor_screen_play+0x320>
  402ae6:	f10a 32ff 	add.w	r2, sl, #4294967295
  402aea:	9901      	ldr	r1, [sp, #4]
  402aec:	4433      	add	r3, r6
  402aee:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  402af0:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402af4:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402af6:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402afa:	d1f9      	bne.n	402af0 <monitor_screen_play+0x354>
  402afc:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  402b00:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402b02:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  402b06:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  402b0a:	4404      	add	r4, r0
  402b0c:	f107 0e01 	add.w	lr, r7, #1
  402b10:	212e      	movs	r1, #46	; 0x2e
  402b12:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402b14:	465a      	mov	r2, fp
  402b16:	4486      	add	lr, r0
	str[slen++] = '.';
  402b18:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402b1c:	2400      	movs	r4, #0
  402b1e:	e001      	b.n	402b24 <monitor_screen_play+0x388>
	} while (fr != 0 && ndec < max_dec);
  402b20:	2c03      	cmp	r4, #3
  402b22:	dc12      	bgt.n	402b4a <monitor_screen_play+0x3ae>
		fr = (fr & mask) * 10;
  402b24:	2300      	movs	r3, #0
  402b26:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402b28:	3701      	adds	r7, #1
		ndec++;
  402b2a:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  402b2c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  402b30:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  402b34:	1812      	adds	r2, r2, r0
  402b36:	414b      	adcs	r3, r1
  402b38:	1892      	adds	r2, r2, r2
  402b3a:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402b3c:	f103 0130 	add.w	r1, r3, #48	; 0x30
  402b40:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  402b44:	ea52 0103 	orrs.w	r1, r2, r3
  402b48:	d1ea      	bne.n	402b20 <monitor_screen_play+0x384>
	if (ndec > 1 && str[slen-1] == '0')
  402b4a:	2c01      	cmp	r4, #1
  402b4c:	d005      	beq.n	402b5a <monitor_screen_play+0x3be>
  402b4e:	1e7b      	subs	r3, r7, #1
  402b50:	9a01      	ldr	r2, [sp, #4]
  402b52:	5cd2      	ldrb	r2, [r2, r3]
  402b54:	2a30      	cmp	r2, #48	; 0x30
  402b56:	f000 826f 	beq.w	403038 <monitor_screen_play+0x89c>
		str[slen] = '\0';
  402b5a:	2300      	movs	r3, #0
  402b5c:	9a01      	ldr	r2, [sp, #4]
  402b5e:	55d3      	strb	r3, [r2, r7]
  402b60:	2100      	movs	r1, #0
  402b62:	48b1      	ldr	r0, [pc, #708]	; (402e28 <monitor_screen_play+0x68c>)
  402b64:	4bb1      	ldr	r3, [pc, #708]	; (402e2c <monitor_screen_play+0x690>)
  402b66:	4798      	blx	r3
	//glcd_puts(fixedpt_cstr((hoist_info.dirdwn0_decel), 4),0);
	//glcd_puts(sitos(get_olib()),0);

	glcd_gotoxy(0, 27);
  402b68:	211b      	movs	r1, #27
  402b6a:	2000      	movs	r0, #0
  402b6c:	4bb0      	ldr	r3, [pc, #704]	; (402e30 <monitor_screen_play+0x694>)
  402b6e:	4798      	blx	r3
	glcd_putsf("Ic ",0);
  402b70:	2100      	movs	r1, #0
  402b72:	48b0      	ldr	r0, [pc, #704]	; (402e34 <monitor_screen_play+0x698>)
  402b74:	4bb0      	ldr	r3, [pc, #704]	; (402e38 <monitor_screen_play+0x69c>)
  402b76:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(ic), 4),0);
  402b78:	ed9d 8a04 	vldr	s16, [sp, #16]
  402b7c:	eddf 7aaf 	vldr	s15, [pc, #700]	; 402e3c <monitor_screen_play+0x6a0>
  402b80:	4baf      	ldr	r3, [pc, #700]	; (402e40 <monitor_screen_play+0x6a4>)
  402b82:	ee68 7a27 	vmul.f32	s15, s16, s15
  402b86:	4caf      	ldr	r4, [pc, #700]	; (402e44 <monitor_screen_play+0x6a8>)
  402b88:	ee17 0a90 	vmov	r0, s15
  402b8c:	4798      	blx	r3
  402b8e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  402b92:	460b      	mov	r3, r1
  402b94:	4602      	mov	r2, r0
  402b96:	2000      	movs	r0, #0
  402b98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  402b9c:	bfac      	ite	ge
  402b9e:	49aa      	ldrge	r1, [pc, #680]	; (402e48 <monitor_screen_play+0x6ac>)
  402ba0:	49aa      	ldrlt	r1, [pc, #680]	; (402e4c <monitor_screen_play+0x6b0>)
  402ba2:	47a0      	blx	r4
  402ba4:	4baa      	ldr	r3, [pc, #680]	; (402e50 <monitor_screen_play+0x6b4>)
  402ba6:	4798      	blx	r3
	char tmp[12] = {0};
  402ba8:	2300      	movs	r3, #0
	if (A < 0) {
  402baa:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  402bae:	9305      	str	r3, [sp, #20]
  402bb0:	6073      	str	r3, [r6, #4]
  402bb2:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  402bb4:	f2c0 8210 	blt.w	402fd8 <monitor_screen_play+0x83c>
	int ndec = 0, slen = 0;
  402bb8:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  402bba:	ea4f 38eb 	mov.w	r8, fp, asr #15
  402bbe:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  402bc0:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  402bc2:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402bc6:	e000      	b.n	402bca <monitor_screen_play+0x42e>
		tmp[ndec++] = '0' + ip % 10;
  402bc8:	461c      	mov	r4, r3
  402bca:	4640      	mov	r0, r8
  402bcc:	4649      	mov	r1, r9
  402bce:	220a      	movs	r2, #10
  402bd0:	2300      	movs	r3, #0
  402bd2:	47a8      	blx	r5
  402bd4:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402bd8:	4640      	mov	r0, r8
  402bda:	4649      	mov	r1, r9
  402bdc:	220a      	movs	r2, #10
  402bde:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402be0:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  402be4:	47a8      	blx	r5
  402be6:	4680      	mov	r8, r0
  402be8:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  402bea:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  402bec:	ea58 0209 	orrs.w	r2, r8, r9
  402bf0:	d1ea      	bne.n	402bc8 <monitor_screen_play+0x42c>
  402bf2:	f10a 32ff 	add.w	r2, sl, #4294967295
  402bf6:	9901      	ldr	r1, [sp, #4]
  402bf8:	4433      	add	r3, r6
  402bfa:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  402bfc:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402c00:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402c02:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402c06:	d1f9      	bne.n	402bfc <monitor_screen_play+0x460>
  402c08:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  402c0c:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402c0e:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  402c12:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  402c16:	4404      	add	r4, r0
  402c18:	f107 0e01 	add.w	lr, r7, #1
  402c1c:	212e      	movs	r1, #46	; 0x2e
  402c1e:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402c20:	465a      	mov	r2, fp
  402c22:	4486      	add	lr, r0
	str[slen++] = '.';
  402c24:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402c28:	2400      	movs	r4, #0
  402c2a:	e001      	b.n	402c30 <monitor_screen_play+0x494>
	} while (fr != 0 && ndec < max_dec);
  402c2c:	2c03      	cmp	r4, #3
  402c2e:	dc12      	bgt.n	402c56 <monitor_screen_play+0x4ba>
		fr = (fr & mask) * 10;
  402c30:	2300      	movs	r3, #0
  402c32:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402c34:	3701      	adds	r7, #1
		ndec++;
  402c36:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  402c38:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  402c3c:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  402c40:	1812      	adds	r2, r2, r0
  402c42:	414b      	adcs	r3, r1
  402c44:	1892      	adds	r2, r2, r2
  402c46:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402c48:	f103 0130 	add.w	r1, r3, #48	; 0x30
  402c4c:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  402c50:	ea52 0103 	orrs.w	r1, r2, r3
  402c54:	d1ea      	bne.n	402c2c <monitor_screen_play+0x490>
	if (ndec > 1 && str[slen-1] == '0')
  402c56:	2c01      	cmp	r4, #1
  402c58:	d005      	beq.n	402c66 <monitor_screen_play+0x4ca>
  402c5a:	1e7b      	subs	r3, r7, #1
  402c5c:	9a01      	ldr	r2, [sp, #4]
  402c5e:	5cd2      	ldrb	r2, [r2, r3]
  402c60:	2a30      	cmp	r2, #48	; 0x30
  402c62:	f000 81d5 	beq.w	403010 <monitor_screen_play+0x874>
		str[slen] = '\0';
  402c66:	2300      	movs	r3, #0
  402c68:	9a01      	ldr	r2, [sp, #4]
  402c6a:	55d3      	strb	r3, [r2, r7]
  402c6c:	2100      	movs	r1, #0
  402c6e:	486e      	ldr	r0, [pc, #440]	; (402e28 <monitor_screen_play+0x68c>)
  402c70:	4b6e      	ldr	r3, [pc, #440]	; (402e2c <monitor_screen_play+0x690>)
  402c72:	4798      	blx	r3
	//glcd_puts(sitos(get_olic()),0);
	
	glcd_gotoxy(0, 36);
  402c74:	2124      	movs	r1, #36	; 0x24
  402c76:	2000      	movs	r0, #0
  402c78:	4b6d      	ldr	r3, [pc, #436]	; (402e30 <monitor_screen_play+0x694>)
  402c7a:	4798      	blx	r3
	glcd_putsf("Im ",0);
	glcd_puts(fixedpt_cstr(fixedpt_rconst(IM_param_tune1_getMdata()), 4),0);
  402c7c:	4c75      	ldr	r4, [pc, #468]	; (402e54 <monitor_screen_play+0x6b8>)
	glcd_putsf("Im ",0);
  402c7e:	2100      	movs	r1, #0
  402c80:	4b6d      	ldr	r3, [pc, #436]	; (402e38 <monitor_screen_play+0x69c>)
  402c82:	4875      	ldr	r0, [pc, #468]	; (402e58 <monitor_screen_play+0x6bc>)
  402c84:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(IM_param_tune1_getMdata()), 4),0);
  402c86:	47a0      	blx	r4
  402c88:	eddf 7a6c 	vldr	s15, [pc, #432]	; 402e3c <monitor_screen_play+0x6a0>
  402c8c:	ee07 0a10 	vmov	s14, r0
  402c90:	4b6b      	ldr	r3, [pc, #428]	; (402e40 <monitor_screen_play+0x6a4>)
  402c92:	ee67 7a27 	vmul.f32	s15, s14, s15
  402c96:	ee17 0a90 	vmov	r0, s15
  402c9a:	4798      	blx	r3
  402c9c:	4689      	mov	r9, r1
  402c9e:	4680      	mov	r8, r0
  402ca0:	47a0      	blx	r4
  402ca2:	ee07 0a90 	vmov	s15, r0
  402ca6:	464b      	mov	r3, r9
  402ca8:	4642      	mov	r2, r8
  402caa:	4c66      	ldr	r4, [pc, #408]	; (402e44 <monitor_screen_play+0x6a8>)
  402cac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  402cb0:	2000      	movs	r0, #0
  402cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  402cb6:	bfac      	ite	ge
  402cb8:	4963      	ldrge	r1, [pc, #396]	; (402e48 <monitor_screen_play+0x6ac>)
  402cba:	4964      	ldrlt	r1, [pc, #400]	; (402e4c <monitor_screen_play+0x6b0>)
  402cbc:	47a0      	blx	r4
  402cbe:	4b64      	ldr	r3, [pc, #400]	; (402e50 <monitor_screen_play+0x6b4>)
  402cc0:	4798      	blx	r3
	char tmp[12] = {0};
  402cc2:	2300      	movs	r3, #0
	if (A < 0) {
  402cc4:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  402cc6:	9305      	str	r3, [sp, #20]
  402cc8:	6073      	str	r3, [r6, #4]
  402cca:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  402ccc:	f2c0 817d 	blt.w	402fca <monitor_screen_play+0x82e>
	int ndec = 0, slen = 0;
  402cd0:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  402cd2:	ea4f 38e4 	mov.w	r8, r4, asr #15
  402cd6:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  402cd8:	2700      	movs	r7, #0
	ip = fixedpt_toint(A);
  402cda:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402cde:	e000      	b.n	402ce2 <monitor_screen_play+0x546>
		tmp[ndec++] = '0' + ip % 10;
  402ce0:	461f      	mov	r7, r3
  402ce2:	4640      	mov	r0, r8
  402ce4:	4649      	mov	r1, r9
  402ce6:	220a      	movs	r2, #10
  402ce8:	2300      	movs	r3, #0
  402cea:	47a8      	blx	r5
  402cec:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402cf0:	4640      	mov	r0, r8
  402cf2:	4649      	mov	r1, r9
  402cf4:	220a      	movs	r2, #10
  402cf6:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402cf8:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  402cfc:	47a8      	blx	r5
  402cfe:	4680      	mov	r8, r0
  402d00:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  402d02:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  402d04:	ea58 0209 	orrs.w	r2, r8, r9
  402d08:	d1ea      	bne.n	402ce0 <monitor_screen_play+0x544>
  402d0a:	f10b 32ff 	add.w	r2, fp, #4294967295
  402d0e:	9901      	ldr	r1, [sp, #4]
  402d10:	4433      	add	r3, r6
  402d12:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  402d14:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402d18:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402d1a:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402d1e:	d1f9      	bne.n	402d14 <monitor_screen_play+0x578>
  402d20:	eb07 0e0b 	add.w	lr, r7, fp
	str[slen++] = '.';
  402d24:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402d26:	0464      	lsls	r4, r4, #17
  402d28:	f10b 0b01 	add.w	fp, fp, #1
  402d2c:	f10e 0c01 	add.w	ip, lr, #1
	str[slen++] = '.';
  402d30:	4407      	add	r7, r0
  402d32:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402d34:	4622      	mov	r2, r4
	str[slen++] = '.';
  402d36:	f10e 0e02 	add.w	lr, lr, #2
  402d3a:	4484      	add	ip, r0
  402d3c:	f807 100b 	strb.w	r1, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402d40:	2400      	movs	r4, #0
  402d42:	e001      	b.n	402d48 <monitor_screen_play+0x5ac>
	} while (fr != 0 && ndec < max_dec);
  402d44:	2c03      	cmp	r4, #3
  402d46:	dc12      	bgt.n	402d6e <monitor_screen_play+0x5d2>
		fr = (fr & mask) * 10;
  402d48:	2300      	movs	r3, #0
  402d4a:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402d4c:	f10e 0e01 	add.w	lr, lr, #1
		ndec++;
  402d50:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  402d52:	009f      	lsls	r7, r3, #2
  402d54:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  402d58:	1812      	adds	r2, r2, r0
  402d5a:	414b      	adcs	r3, r1
  402d5c:	1892      	adds	r2, r2, r2
  402d5e:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402d60:	f103 0130 	add.w	r1, r3, #48	; 0x30
  402d64:	f80c 1f01 	strb.w	r1, [ip, #1]!
	} while (fr != 0 && ndec < max_dec);
  402d68:	ea52 0103 	orrs.w	r1, r2, r3
  402d6c:	d1ea      	bne.n	402d44 <monitor_screen_play+0x5a8>
	if (ndec > 1 && str[slen-1] == '0')
  402d6e:	2c01      	cmp	r4, #1
  402d70:	d006      	beq.n	402d80 <monitor_screen_play+0x5e4>
  402d72:	f10e 33ff 	add.w	r3, lr, #4294967295
  402d76:	9a01      	ldr	r2, [sp, #4]
  402d78:	5cd2      	ldrb	r2, [r2, r3]
  402d7a:	2a30      	cmp	r2, #48	; 0x30
  402d7c:	f000 814c 	beq.w	403018 <monitor_screen_play+0x87c>
		str[slen] = '\0';
  402d80:	2300      	movs	r3, #0
  402d82:	9a01      	ldr	r2, [sp, #4]
  402d84:	f802 300e 	strb.w	r3, [r2, lr]
  402d88:	2100      	movs	r1, #0
  402d8a:	4827      	ldr	r0, [pc, #156]	; (402e28 <monitor_screen_play+0x68c>)
  402d8c:	4b27      	ldr	r3, [pc, #156]	; (402e2c <monitor_screen_play+0x690>)
  402d8e:	4798      	blx	r3
	//glcd_puts(sitos(get_olim()),0);
	
	glcd_gotoxy(0, 45);
  402d90:	212d      	movs	r1, #45	; 0x2d
  402d92:	2000      	movs	r0, #0
  402d94:	4b26      	ldr	r3, [pc, #152]	; (402e30 <monitor_screen_play+0x694>)
  402d96:	4798      	blx	r3
	glcd_putsf("T ",0);
  402d98:	2100      	movs	r1, #0
  402d9a:	4830      	ldr	r0, [pc, #192]	; (402e5c <monitor_screen_play+0x6c0>)
  402d9c:	4b26      	ldr	r3, [pc, #152]	; (402e38 <monitor_screen_play+0x69c>)
  402d9e:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(iverter_get_igbt_temp(), 2), 0);
  402da0:	4b2f      	ldr	r3, [pc, #188]	; (402e60 <monitor_screen_play+0x6c4>)
  402da2:	4798      	blx	r3
	char tmp[12] = {0};
  402da4:	2300      	movs	r3, #0
	if (A < 0) {
  402da6:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  402da8:	9305      	str	r3, [sp, #20]
  402daa:	6073      	str	r3, [r6, #4]
  402dac:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  402dae:	f2c0 8105 	blt.w	402fbc <monitor_screen_play+0x820>
	int ndec = 0, slen = 0;
  402db2:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  402db4:	ea4f 38e4 	mov.w	r8, r4, asr #15
  402db8:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  402dba:	2700      	movs	r7, #0
	ip = fixedpt_toint(A);
  402dbc:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402dc0:	e000      	b.n	402dc4 <monitor_screen_play+0x628>
		tmp[ndec++] = '0' + ip % 10;
  402dc2:	461f      	mov	r7, r3
  402dc4:	4640      	mov	r0, r8
  402dc6:	4649      	mov	r1, r9
  402dc8:	220a      	movs	r2, #10
  402dca:	2300      	movs	r3, #0
  402dcc:	47a8      	blx	r5
  402dce:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402dd2:	4640      	mov	r0, r8
  402dd4:	4649      	mov	r1, r9
  402dd6:	220a      	movs	r2, #10
  402dd8:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402dda:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  402dde:	47a8      	blx	r5
  402de0:	4680      	mov	r8, r0
  402de2:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  402de4:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  402de6:	ea58 0209 	orrs.w	r2, r8, r9
  402dea:	d1ea      	bne.n	402dc2 <monitor_screen_play+0x626>
  402dec:	f10b 32ff 	add.w	r2, fp, #4294967295
  402df0:	9901      	ldr	r1, [sp, #4]
  402df2:	4433      	add	r3, r6
  402df4:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  402df6:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402dfa:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402dfc:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402e00:	d1f9      	bne.n	402df6 <monitor_screen_play+0x65a>
  402e02:	eb07 0e0b 	add.w	lr, r7, fp
	str[slen++] = '.';
  402e06:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402e08:	0464      	lsls	r4, r4, #17
  402e0a:	f10b 0b01 	add.w	fp, fp, #1
  402e0e:	f10e 0c01 	add.w	ip, lr, #1
	str[slen++] = '.';
  402e12:	4407      	add	r7, r0
  402e14:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402e16:	4622      	mov	r2, r4
	str[slen++] = '.';
  402e18:	f10e 0e02 	add.w	lr, lr, #2
  402e1c:	4484      	add	ip, r0
  402e1e:	f807 100b 	strb.w	r1, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402e22:	2400      	movs	r4, #0
  402e24:	e020      	b.n	402e68 <monitor_screen_play+0x6cc>
  402e26:	bf00      	nop
  402e28:	20400854 	.word	0x20400854
  402e2c:	0040ca05 	.word	0x0040ca05
  402e30:	0040c7a5 	.word	0x0040c7a5
  402e34:	00419a50 	.word	0x00419a50
  402e38:	0040c7b9 	.word	0x0040c7b9
  402e3c:	47000000 	.word	0x47000000
  402e40:	00418749 	.word	0x00418749
  402e44:	0041848d 	.word	0x0041848d
  402e48:	3fe00000 	.word	0x3fe00000
  402e4c:	bfe00000 	.word	0xbfe00000
  402e50:	00418d51 	.word	0x00418d51
  402e54:	00410555 	.word	0x00410555
  402e58:	00419a54 	.word	0x00419a54
  402e5c:	00419a58 	.word	0x00419a58
  402e60:	004156f1 	.word	0x004156f1
	} while (fr != 0 && ndec < max_dec);
  402e64:	2c01      	cmp	r4, #1
  402e66:	dc12      	bgt.n	402e8e <monitor_screen_play+0x6f2>
		fr = (fr & mask) * 10;
  402e68:	2300      	movs	r3, #0
  402e6a:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402e6c:	f10e 0e01 	add.w	lr, lr, #1
		ndec++;
  402e70:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  402e72:	009f      	lsls	r7, r3, #2
  402e74:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  402e78:	1812      	adds	r2, r2, r0
  402e7a:	414b      	adcs	r3, r1
  402e7c:	1892      	adds	r2, r2, r2
  402e7e:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402e80:	f103 0130 	add.w	r1, r3, #48	; 0x30
  402e84:	f80c 1f01 	strb.w	r1, [ip, #1]!
	} while (fr != 0 && ndec < max_dec);
  402e88:	ea52 0103 	orrs.w	r1, r2, r3
  402e8c:	d1ea      	bne.n	402e64 <monitor_screen_play+0x6c8>
	if (ndec > 1 && str[slen-1] == '0')
  402e8e:	2c02      	cmp	r4, #2
  402e90:	d106      	bne.n	402ea0 <monitor_screen_play+0x704>
  402e92:	f10e 33ff 	add.w	r3, lr, #4294967295
  402e96:	9a01      	ldr	r2, [sp, #4]
  402e98:	5cd2      	ldrb	r2, [r2, r3]
  402e9a:	2a30      	cmp	r2, #48	; 0x30
  402e9c:	f000 80c0 	beq.w	403020 <monitor_screen_play+0x884>
		str[slen] = '\0';
  402ea0:	2300      	movs	r3, #0
  402ea2:	9a01      	ldr	r2, [sp, #4]
  402ea4:	f802 300e 	strb.w	r3, [r2, lr]
  402ea8:	2100      	movs	r1, #0
  402eaa:	4865      	ldr	r0, [pc, #404]	; (403040 <monitor_screen_play+0x8a4>)
  402eac:	4b65      	ldr	r3, [pc, #404]	; (403044 <monitor_screen_play+0x8a8>)
  402eae:	4798      	blx	r3
	
	glcd_gotoxy(0, 54);
  402eb0:	2136      	movs	r1, #54	; 0x36
  402eb2:	2000      	movs	r0, #0
  402eb4:	4b64      	ldr	r3, [pc, #400]	; (403048 <monitor_screen_play+0x8ac>)
  402eb6:	4798      	blx	r3
	glcd_putsf("V ",0);
  402eb8:	2100      	movs	r1, #0
  402eba:	4864      	ldr	r0, [pc, #400]	; (40304c <monitor_screen_play+0x8b0>)
  402ebc:	4b64      	ldr	r3, [pc, #400]	; (403050 <monitor_screen_play+0x8b4>)
  402ebe:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(iverter_get_dc_v(), 2), 0);
  402ec0:	4b64      	ldr	r3, [pc, #400]	; (403054 <monitor_screen_play+0x8b8>)
  402ec2:	4798      	blx	r3
	char tmp[12] = {0};
  402ec4:	2300      	movs	r3, #0
	if (A < 0) {
  402ec6:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  402ec8:	9305      	str	r3, [sp, #20]
  402eca:	6073      	str	r3, [r6, #4]
  402ecc:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  402ece:	db6e      	blt.n	402fae <monitor_screen_play+0x812>
	int ndec = 0, slen = 0;
  402ed0:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  402ed2:	ea4f 38e4 	mov.w	r8, r4, asr #15
  402ed6:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  402ed8:	2700      	movs	r7, #0
	ip = fixedpt_toint(A);
  402eda:	ea4f 79e8 	mov.w	r9, r8, asr #31
  402ede:	e000      	b.n	402ee2 <monitor_screen_play+0x746>
		tmp[ndec++] = '0' + ip % 10;
  402ee0:	461f      	mov	r7, r3
  402ee2:	4640      	mov	r0, r8
  402ee4:	4649      	mov	r1, r9
  402ee6:	220a      	movs	r2, #10
  402ee8:	2300      	movs	r3, #0
  402eea:	47a8      	blx	r5
  402eec:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  402ef0:	4640      	mov	r0, r8
  402ef2:	4649      	mov	r1, r9
  402ef4:	220a      	movs	r2, #10
  402ef6:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  402ef8:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  402efc:	47a8      	blx	r5
  402efe:	4680      	mov	r8, r0
  402f00:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  402f02:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  402f04:	ea58 0209 	orrs.w	r2, r8, r9
  402f08:	d1ea      	bne.n	402ee0 <monitor_screen_play+0x744>
  402f0a:	f10b 32ff 	add.w	r2, fp, #4294967295
  402f0e:	9901      	ldr	r1, [sp, #4]
  402f10:	4433      	add	r3, r6
  402f12:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  402f14:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  402f18:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  402f1a:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  402f1e:	d1f9      	bne.n	402f14 <monitor_screen_play+0x778>
  402f20:	eb07 000b 	add.w	r0, r7, fp
	str[slen++] = '.';
  402f24:	9a01      	ldr	r2, [sp, #4]
  402f26:	f10b 0b01 	add.w	fp, fp, #1
  402f2a:	232e      	movs	r3, #46	; 0x2e
  402f2c:	1c46      	adds	r6, r0, #1
  402f2e:	4417      	add	r7, r2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402f30:	0464      	lsls	r4, r4, #17
	str[slen++] = '.';
  402f32:	3002      	adds	r0, #2
  402f34:	4416      	add	r6, r2
  402f36:	f807 300b 	strb.w	r3, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  402f3a:	2100      	movs	r1, #0
  402f3c:	e001      	b.n	402f42 <monitor_screen_play+0x7a6>
	} while (fr != 0 && ndec < max_dec);
  402f3e:	2901      	cmp	r1, #1
  402f40:	dc11      	bgt.n	402f66 <monitor_screen_play+0x7ca>
		fr = (fr & mask) * 10;
  402f42:	2500      	movs	r5, #0
  402f44:	00a2      	lsls	r2, r4, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402f46:	3001      	adds	r0, #1
		ndec++;
  402f48:	3101      	adds	r1, #1
		fr = (fr & mask) * 10;
  402f4a:	00af      	lsls	r7, r5, #2
  402f4c:	ea47 7394 	orr.w	r3, r7, r4, lsr #30
  402f50:	18a4      	adds	r4, r4, r2
  402f52:	415d      	adcs	r5, r3
  402f54:	1924      	adds	r4, r4, r4
  402f56:	416d      	adcs	r5, r5
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  402f58:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402f5c:	f806 3f01 	strb.w	r3, [r6, #1]!
	} while (fr != 0 && ndec < max_dec);
  402f60:	ea54 0305 	orrs.w	r3, r4, r5
  402f64:	d1eb      	bne.n	402f3e <monitor_screen_play+0x7a2>
	if (ndec > 1 && str[slen-1] == '0')
  402f66:	2902      	cmp	r1, #2
  402f68:	d104      	bne.n	402f74 <monitor_screen_play+0x7d8>
  402f6a:	1e43      	subs	r3, r0, #1
  402f6c:	9a01      	ldr	r2, [sp, #4]
  402f6e:	5cd2      	ldrb	r2, [r2, r3]
  402f70:	2a30      	cmp	r2, #48	; 0x30
  402f72:	d059      	beq.n	403028 <monitor_screen_play+0x88c>
		str[slen] = '\0';
  402f74:	2300      	movs	r3, #0
  402f76:	9a01      	ldr	r2, [sp, #4]
  402f78:	5413      	strb	r3, [r2, r0]
  402f7a:	4b32      	ldr	r3, [pc, #200]	; (403044 <monitor_screen_play+0x8a8>)
  402f7c:	2100      	movs	r1, #0
  402f7e:	4830      	ldr	r0, [pc, #192]	; (403040 <monitor_screen_play+0x8a4>)
  402f80:	4798      	blx	r3

	if(get_esc_button())
  402f82:	4b35      	ldr	r3, [pc, #212]	; (403058 <monitor_screen_play+0x8bc>)
  402f84:	4798      	blx	r3
  402f86:	b110      	cbz	r0, 402f8e <monitor_screen_play+0x7f2>
	{
		active_screen = IDF_SCREEN_MAIN;
  402f88:	4b34      	ldr	r3, [pc, #208]	; (40305c <monitor_screen_play+0x8c0>)
  402f8a:	2200      	movs	r2, #0
  402f8c:	601a      	str	r2, [r3, #0]
	}
	
	drop_all_buttons();
  402f8e:	4b34      	ldr	r3, [pc, #208]	; (403060 <monitor_screen_play+0x8c4>)
  402f90:	4798      	blx	r3
}
  402f92:	b009      	add	sp, #36	; 0x24
  402f94:	ecbd 8b02 	vpop	{d8}
  402f98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		str[slen++] = '-';
  402f9c:	4b28      	ldr	r3, [pc, #160]	; (403040 <monitor_screen_play+0x8a4>)
		A *= -1;
  402f9e:	4264      	negs	r4, r4
		str[slen++] = '-';
  402fa0:	f04f 0b01 	mov.w	fp, #1
  402fa4:	461a      	mov	r2, r3
  402fa6:	9301      	str	r3, [sp, #4]
  402fa8:	232d      	movs	r3, #45	; 0x2d
  402faa:	7013      	strb	r3, [r2, #0]
  402fac:	e42c      	b.n	402808 <monitor_screen_play+0x6c>
  402fae:	232d      	movs	r3, #45	; 0x2d
  402fb0:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  402fb2:	4264      	negs	r4, r4
		str[slen++] = '-';
  402fb4:	f04f 0b01 	mov.w	fp, #1
  402fb8:	7013      	strb	r3, [r2, #0]
  402fba:	e78a      	b.n	402ed2 <monitor_screen_play+0x736>
  402fbc:	232d      	movs	r3, #45	; 0x2d
  402fbe:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  402fc0:	4264      	negs	r4, r4
		str[slen++] = '-';
  402fc2:	f04f 0b01 	mov.w	fp, #1
  402fc6:	7013      	strb	r3, [r2, #0]
  402fc8:	e6f4      	b.n	402db4 <monitor_screen_play+0x618>
  402fca:	232d      	movs	r3, #45	; 0x2d
  402fcc:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  402fce:	4264      	negs	r4, r4
		str[slen++] = '-';
  402fd0:	f04f 0b01 	mov.w	fp, #1
  402fd4:	7013      	strb	r3, [r2, #0]
  402fd6:	e67c      	b.n	402cd2 <monitor_screen_play+0x536>
  402fd8:	232d      	movs	r3, #45	; 0x2d
  402fda:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  402fdc:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  402fe0:	f04f 0a01 	mov.w	sl, #1
  402fe4:	7013      	strb	r3, [r2, #0]
  402fe6:	e5e8      	b.n	402bba <monitor_screen_play+0x41e>
  402fe8:	232d      	movs	r3, #45	; 0x2d
  402fea:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  402fec:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  402ff0:	f04f 0a01 	mov.w	sl, #1
  402ff4:	7013      	strb	r3, [r2, #0]
  402ff6:	e527      	b.n	402a48 <monitor_screen_play+0x2ac>
  402ff8:	232d      	movs	r3, #45	; 0x2d
  402ffa:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  402ffc:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  403000:	f04f 0a01 	mov.w	sl, #1
  403004:	7013      	strb	r3, [r2, #0]
  403006:	e499      	b.n	40293c <monitor_screen_play+0x1a0>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  403008:	2200      	movs	r2, #0
  40300a:	9901      	ldr	r1, [sp, #4]
  40300c:	54ca      	strb	r2, [r1, r3]
  40300e:	e457      	b.n	4028c0 <monitor_screen_play+0x124>
  403010:	2200      	movs	r2, #0
  403012:	9901      	ldr	r1, [sp, #4]
  403014:	54ca      	strb	r2, [r1, r3]
  403016:	e629      	b.n	402c6c <monitor_screen_play+0x4d0>
  403018:	2200      	movs	r2, #0
  40301a:	9901      	ldr	r1, [sp, #4]
  40301c:	54ca      	strb	r2, [r1, r3]
  40301e:	e6b3      	b.n	402d88 <monitor_screen_play+0x5ec>
  403020:	2200      	movs	r2, #0
  403022:	9901      	ldr	r1, [sp, #4]
  403024:	54ca      	strb	r2, [r1, r3]
  403026:	e73f      	b.n	402ea8 <monitor_screen_play+0x70c>
  403028:	2200      	movs	r2, #0
  40302a:	9901      	ldr	r1, [sp, #4]
  40302c:	54ca      	strb	r2, [r1, r3]
  40302e:	e7a4      	b.n	402f7a <monitor_screen_play+0x7de>
  403030:	2200      	movs	r2, #0
  403032:	9901      	ldr	r1, [sp, #4]
  403034:	54ca      	strb	r2, [r1, r3]
  403036:	e4da      	b.n	4029ee <monitor_screen_play+0x252>
  403038:	2200      	movs	r2, #0
  40303a:	9901      	ldr	r1, [sp, #4]
  40303c:	54ca      	strb	r2, [r1, r3]
  40303e:	e58f      	b.n	402b60 <monitor_screen_play+0x3c4>
  403040:	20400854 	.word	0x20400854
  403044:	0040ca05 	.word	0x0040ca05
  403048:	0040c7a5 	.word	0x0040c7a5
  40304c:	00419a5c 	.word	0x00419a5c
  403050:	0040c7b9 	.word	0x0040c7b9
  403054:	0041570d 	.word	0x0041570d
  403058:	0040de45 	.word	0x0040de45
  40305c:	2040084c 	.word	0x2040084c
  403060:	0040ded1 	.word	0x0040ded1

00403064 <encoder_screen_play>:

void encoder_screen_play(void)
{
  403064:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	glcd_clear();
  403068:	4bb7      	ldr	r3, [pc, #732]	; (403348 <encoder_screen_play+0x2e4>)
	glcd_putsf("Encoder",0);
	
	glcd_gotoxy(0, 9);
	glcd_putsf("Inc ",0);
	int64_t tmp_theta = enc_get_lin_theta();
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  40306a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
{
  40306e:	ed2d 8b02 	vpush	{d8}
  403072:	b087      	sub	sp, #28
	glcd_clear();
  403074:	4798      	blx	r3
	glcd_gotoxy(0,0);
  403076:	2100      	movs	r1, #0
  403078:	4bb4      	ldr	r3, [pc, #720]	; (40334c <encoder_screen_play+0x2e8>)
  40307a:	4608      	mov	r0, r1
  40307c:	4798      	blx	r3
	glcd_putsf("Encoder",0);
  40307e:	2100      	movs	r1, #0
  403080:	48b3      	ldr	r0, [pc, #716]	; (403350 <encoder_screen_play+0x2ec>)
  403082:	4bb4      	ldr	r3, [pc, #720]	; (403354 <encoder_screen_play+0x2f0>)
  403084:	4798      	blx	r3
	glcd_gotoxy(0, 9);
  403086:	2109      	movs	r1, #9
  403088:	2000      	movs	r0, #0
  40308a:	4bb0      	ldr	r3, [pc, #704]	; (40334c <encoder_screen_play+0x2e8>)
  40308c:	4798      	blx	r3
	glcd_putsf("Inc ",0);
  40308e:	2100      	movs	r1, #0
  403090:	48b1      	ldr	r0, [pc, #708]	; (403358 <encoder_screen_play+0x2f4>)
  403092:	4bb0      	ldr	r3, [pc, #704]	; (403354 <encoder_screen_play+0x2f0>)
  403094:	4798      	blx	r3
	int64_t tmp_theta = enc_get_lin_theta();
  403096:	4bb1      	ldr	r3, [pc, #708]	; (40335c <encoder_screen_play+0x2f8>)
  403098:	4798      	blx	r3
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  40309a:	4bb1      	ldr	r3, [pc, #708]	; (403360 <encoder_screen_play+0x2fc>)
	int64_t tmp_theta = enc_get_lin_theta();
  40309c:	4606      	mov	r6, r0
  40309e:	460f      	mov	r7, r1
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  4030a0:	4798      	blx	r3
  4030a2:	fb04 f400 	mul.w	r4, r4, r0
  4030a6:	2c00      	cmp	r4, #0
  4030a8:	f2c0 8323 	blt.w	4036f2 <encoder_screen_play+0x68e>
	if (tmp_theta < 0)
  4030ac:	2e00      	cmp	r6, #0
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  4030ae:	ea4f 34e4 	mov.w	r4, r4, asr #15
	if (tmp_theta < 0)
  4030b2:	f177 0300 	sbcs.w	r3, r7, #0
  4030b6:	f2c0 82f1 	blt.w	40369c <encoder_screen_play+0x638>
  4030ba:	4daa      	ldr	r5, [pc, #680]	; (403364 <encoder_screen_play+0x300>)
	{
		tmp_theta += 1;
		if (tmp_theta == 0) putIt('-');
		tmp_phs = 1000 - tmp_phs;
	}
	glcd_puts(sitos(tmp_theta),0);
  4030bc:	4639      	mov	r1, r7
  4030be:	4baa      	ldr	r3, [pc, #680]	; (403368 <encoder_screen_play+0x304>)
  4030c0:	4630      	mov	r0, r6
  4030c2:	4798      	blx	r3
  4030c4:	2100      	movs	r1, #0
  4030c6:	4ba9      	ldr	r3, [pc, #676]	; (40336c <encoder_screen_play+0x308>)
  4030c8:	4798      	blx	r3
	
	putIt('.');
  4030ca:	202e      	movs	r0, #46	; 0x2e
  4030cc:	47a8      	blx	r5
	if(tmp_phs < 10) putIt('0');
  4030ce:	2c09      	cmp	r4, #9
  4030d0:	f240 82d8 	bls.w	403684 <encoder_screen_play+0x620>
	if(tmp_phs < 100) putIt('0');
  4030d4:	2c63      	cmp	r4, #99	; 0x63
  4030d6:	f240 82d7 	bls.w	403688 <encoder_screen_play+0x624>
	glcd_puts(itos(tmp_phs),0);
  4030da:	2500      	movs	r5, #0
  4030dc:	4620      	mov	r0, r4
  4030de:	4ba4      	ldr	r3, [pc, #656]	; (403370 <encoder_screen_play+0x30c>)
	char tmp[12] = {0};
  4030e0:	ae03      	add	r6, sp, #12
  4030e2:	4629      	mov	r1, r5
  4030e4:	4798      	blx	r3
  4030e6:	4629      	mov	r1, r5
  4030e8:	4ba0      	ldr	r3, [pc, #640]	; (40336c <encoder_screen_play+0x308>)
  4030ea:	4798      	blx	r3
	
// 	glcd_gotoxy(0, 18);
// 	glcd_putsf("ABS ",0);
// 	glcd_puts(fixedpt_cstr(fixedpt_rconst(encoder_getangle_abs()),4),0);

	glcd_gotoxy(0, 18);
  4030ec:	4628      	mov	r0, r5
  4030ee:	2112      	movs	r1, #18
  4030f0:	4b96      	ldr	r3, [pc, #600]	; (40334c <encoder_screen_play+0x2e8>)
  4030f2:	4798      	blx	r3
	glcd_putsf("Rev ",0);
  4030f4:	4629      	mov	r1, r5
  4030f6:	489f      	ldr	r0, [pc, #636]	; (403374 <encoder_screen_play+0x310>)
  4030f8:	4b96      	ldr	r3, [pc, #600]	; (403354 <encoder_screen_play+0x2f0>)
  4030fa:	4798      	blx	r3
//	glcd_puts(fixedpt_cstr(fixedpt_abs(enc_get_omega_shaft_rad_hat()) * FIXEDPT_ONE, 8),0);
	
	glcd_puts(fixedpt_cstr(enc_get_omega_hz_hat(MOTOR_POLEPAIR), 8),0);
  4030fc:	4a9e      	ldr	r2, [pc, #632]	; (403378 <encoder_screen_play+0x314>)
  4030fe:	4b9f      	ldr	r3, [pc, #636]	; (40337c <encoder_screen_play+0x318>)
  403100:	f892 003c 	ldrb.w	r0, [r2, #60]	; 0x3c
  403104:	4798      	blx	r3
	if (A < 0) {
  403106:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  403108:	9503      	str	r5, [sp, #12]
  40310a:	6075      	str	r5, [r6, #4]
  40310c:	60b5      	str	r5, [r6, #8]
	if (A < 0) {
  40310e:	f2c0 82cf 	blt.w	4036b0 <encoder_screen_play+0x64c>
  403112:	4b9b      	ldr	r3, [pc, #620]	; (403380 <encoder_screen_play+0x31c>)
	int ndec = 0, slen = 0;
  403114:	46ab      	mov	fp, r5
  403116:	9301      	str	r3, [sp, #4]
	ip = fixedpt_toint(A);
  403118:	ea4f 38e4 	mov.w	r8, r4, asr #15
  40311c:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  40311e:	2700      	movs	r7, #0
  403120:	4d98      	ldr	r5, [pc, #608]	; (403384 <encoder_screen_play+0x320>)
	ip = fixedpt_toint(A);
  403122:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403126:	e000      	b.n	40312a <encoder_screen_play+0xc6>
		tmp[ndec++] = '0' + ip % 10;
  403128:	461f      	mov	r7, r3
  40312a:	4640      	mov	r0, r8
  40312c:	4649      	mov	r1, r9
  40312e:	220a      	movs	r2, #10
  403130:	2300      	movs	r3, #0
  403132:	47a8      	blx	r5
  403134:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  403138:	4640      	mov	r0, r8
  40313a:	4649      	mov	r1, r9
  40313c:	220a      	movs	r2, #10
  40313e:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  403140:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  403144:	47a8      	blx	r5
  403146:	4680      	mov	r8, r0
  403148:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  40314a:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  40314c:	ea58 0209 	orrs.w	r2, r8, r9
  403150:	d1ea      	bne.n	403128 <encoder_screen_play+0xc4>
  403152:	f10b 32ff 	add.w	r2, fp, #4294967295
  403156:	9901      	ldr	r1, [sp, #4]
  403158:	4433      	add	r3, r6
  40315a:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  40315c:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  403160:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  403162:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403166:	d1f9      	bne.n	40315c <encoder_screen_play+0xf8>
  403168:	eb07 0e0b 	add.w	lr, r7, fp
	str[slen++] = '.';
  40316c:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40316e:	0464      	lsls	r4, r4, #17
  403170:	f10b 0b01 	add.w	fp, fp, #1
  403174:	f10e 0c01 	add.w	ip, lr, #1
	str[slen++] = '.';
  403178:	4407      	add	r7, r0
  40317a:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40317c:	4622      	mov	r2, r4
	str[slen++] = '.';
  40317e:	f10e 0e02 	add.w	lr, lr, #2
  403182:	4484      	add	ip, r0
  403184:	f807 100b 	strb.w	r1, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403188:	2400      	movs	r4, #0
  40318a:	e001      	b.n	403190 <encoder_screen_play+0x12c>
	} while (fr != 0 && ndec < max_dec);
  40318c:	2c07      	cmp	r4, #7
  40318e:	dc12      	bgt.n	4031b6 <encoder_screen_play+0x152>
		fr = (fr & mask) * 10;
  403190:	2300      	movs	r3, #0
  403192:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403194:	f10e 0e01 	add.w	lr, lr, #1
		ndec++;
  403198:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  40319a:	009f      	lsls	r7, r3, #2
  40319c:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  4031a0:	1812      	adds	r2, r2, r0
  4031a2:	414b      	adcs	r3, r1
  4031a4:	1892      	adds	r2, r2, r2
  4031a6:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4031a8:	f103 0130 	add.w	r1, r3, #48	; 0x30
  4031ac:	f80c 1f01 	strb.w	r1, [ip, #1]!
	} while (fr != 0 && ndec < max_dec);
  4031b0:	ea52 0103 	orrs.w	r1, r2, r3
  4031b4:	d1ea      	bne.n	40318c <encoder_screen_play+0x128>
	if (ndec > 1 && str[slen-1] == '0')
  4031b6:	2c01      	cmp	r4, #1
  4031b8:	d006      	beq.n	4031c8 <encoder_screen_play+0x164>
  4031ba:	f10e 33ff 	add.w	r3, lr, #4294967295
  4031be:	9a01      	ldr	r2, [sp, #4]
  4031c0:	5cd2      	ldrb	r2, [r2, r3]
  4031c2:	2a30      	cmp	r2, #48	; 0x30
  4031c4:	f000 829d 	beq.w	403702 <encoder_screen_play+0x69e>
		str[slen] = '\0';
  4031c8:	2300      	movs	r3, #0
  4031ca:	9a01      	ldr	r2, [sp, #4]
  4031cc:	f802 300e 	strb.w	r3, [r2, lr]
  4031d0:	2100      	movs	r1, #0
  4031d2:	486b      	ldr	r0, [pc, #428]	; (403380 <encoder_screen_play+0x31c>)
  4031d4:	4b65      	ldr	r3, [pc, #404]	; (40336c <encoder_screen_play+0x308>)
  4031d6:	4798      	blx	r3
	
//  glcd_gotoxy(0, 18);
//  glcd_putsf("phs ",0);
//  glcd_puts(fixedpt_cstr(enc_get_phase(), 4),0);	

	glcd_gotoxy(0, 27);
  4031d8:	211b      	movs	r1, #27
  4031da:	2000      	movs	r0, #0
  4031dc:	4b5b      	ldr	r3, [pc, #364]	; (40334c <encoder_screen_play+0x2e8>)
  4031de:	4798      	blx	r3
 	glcd_putsf("Vd ",0);
  4031e0:	2100      	movs	r1, #0
  4031e2:	4869      	ldr	r0, [pc, #420]	; (403388 <encoder_screen_play+0x324>)
  4031e4:	4b5b      	ldr	r3, [pc, #364]	; (403354 <encoder_screen_play+0x2f0>)
  4031e6:	4798      	blx	r3
 	glcd_puts(fixedpt_cstr(fixedpt_rconst(cvd), 4),0);
  4031e8:	4b68      	ldr	r3, [pc, #416]	; (40338c <encoder_screen_play+0x328>)
  4031ea:	eddf 7a69 	vldr	s15, [pc, #420]	; 403390 <encoder_screen_play+0x32c>
  4031ee:	ed93 8a00 	vldr	s16, [r3]
  4031f2:	4b68      	ldr	r3, [pc, #416]	; (403394 <encoder_screen_play+0x330>)
  4031f4:	ee68 7a27 	vmul.f32	s15, s16, s15
  4031f8:	4c67      	ldr	r4, [pc, #412]	; (403398 <encoder_screen_play+0x334>)
  4031fa:	ee17 0a90 	vmov	r0, s15
  4031fe:	4798      	blx	r3
  403200:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  403204:	460b      	mov	r3, r1
  403206:	4602      	mov	r2, r0
  403208:	2000      	movs	r0, #0
  40320a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40320e:	bfac      	ite	ge
  403210:	4962      	ldrge	r1, [pc, #392]	; (40339c <encoder_screen_play+0x338>)
  403212:	4963      	ldrlt	r1, [pc, #396]	; (4033a0 <encoder_screen_play+0x33c>)
  403214:	47a0      	blx	r4
  403216:	4b63      	ldr	r3, [pc, #396]	; (4033a4 <encoder_screen_play+0x340>)
  403218:	4798      	blx	r3
	char tmp[12] = {0};
  40321a:	2300      	movs	r3, #0
	if (A < 0) {
  40321c:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  403220:	9303      	str	r3, [sp, #12]
  403222:	6073      	str	r3, [r6, #4]
  403224:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  403226:	f2c0 824c 	blt.w	4036c2 <encoder_screen_play+0x65e>
	int ndec = 0, slen = 0;
  40322a:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  40322c:	ea4f 38eb 	mov.w	r8, fp, asr #15
  403230:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  403232:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  403234:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403238:	e000      	b.n	40323c <encoder_screen_play+0x1d8>
		tmp[ndec++] = '0' + ip % 10;
  40323a:	461c      	mov	r4, r3
  40323c:	4640      	mov	r0, r8
  40323e:	4649      	mov	r1, r9
  403240:	220a      	movs	r2, #10
  403242:	2300      	movs	r3, #0
  403244:	47a8      	blx	r5
  403246:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  40324a:	4640      	mov	r0, r8
  40324c:	4649      	mov	r1, r9
  40324e:	220a      	movs	r2, #10
  403250:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  403252:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  403256:	47a8      	blx	r5
  403258:	4680      	mov	r8, r0
  40325a:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  40325c:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  40325e:	ea58 0209 	orrs.w	r2, r8, r9
  403262:	d1ea      	bne.n	40323a <encoder_screen_play+0x1d6>
  403264:	f10a 32ff 	add.w	r2, sl, #4294967295
  403268:	9901      	ldr	r1, [sp, #4]
  40326a:	4433      	add	r3, r6
  40326c:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  40326e:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  403272:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  403274:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403278:	d1f9      	bne.n	40326e <encoder_screen_play+0x20a>
  40327a:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  40327e:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403280:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  403284:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  403288:	4404      	add	r4, r0
  40328a:	f107 0e01 	add.w	lr, r7, #1
  40328e:	212e      	movs	r1, #46	; 0x2e
  403290:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403292:	465a      	mov	r2, fp
  403294:	4486      	add	lr, r0
	str[slen++] = '.';
  403296:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40329a:	2400      	movs	r4, #0
  40329c:	e001      	b.n	4032a2 <encoder_screen_play+0x23e>
	} while (fr != 0 && ndec < max_dec);
  40329e:	2c03      	cmp	r4, #3
  4032a0:	dc12      	bgt.n	4032c8 <encoder_screen_play+0x264>
		fr = (fr & mask) * 10;
  4032a2:	2300      	movs	r3, #0
  4032a4:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4032a6:	3701      	adds	r7, #1
		ndec++;
  4032a8:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  4032aa:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  4032ae:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  4032b2:	1812      	adds	r2, r2, r0
  4032b4:	414b      	adcs	r3, r1
  4032b6:	1892      	adds	r2, r2, r2
  4032b8:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4032ba:	f103 0130 	add.w	r1, r3, #48	; 0x30
  4032be:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  4032c2:	ea52 0103 	orrs.w	r1, r2, r3
  4032c6:	d1ea      	bne.n	40329e <encoder_screen_play+0x23a>
	if (ndec > 1 && str[slen-1] == '0')
  4032c8:	2c01      	cmp	r4, #1
  4032ca:	d005      	beq.n	4032d8 <encoder_screen_play+0x274>
  4032cc:	1e7b      	subs	r3, r7, #1
  4032ce:	9a01      	ldr	r2, [sp, #4]
  4032d0:	5cd2      	ldrb	r2, [r2, r3]
  4032d2:	2a30      	cmp	r2, #48	; 0x30
  4032d4:	f000 821d 	beq.w	403712 <encoder_screen_play+0x6ae>
		str[slen] = '\0';
  4032d8:	2300      	movs	r3, #0
  4032da:	9a01      	ldr	r2, [sp, #4]
  4032dc:	55d3      	strb	r3, [r2, r7]
  4032de:	2100      	movs	r1, #0
  4032e0:	4827      	ldr	r0, [pc, #156]	; (403380 <encoder_screen_play+0x31c>)
  4032e2:	4b22      	ldr	r3, [pc, #136]	; (40336c <encoder_screen_play+0x308>)
  4032e4:	4798      	blx	r3
	//glcd_puts(fixedpt_cstr((vfd_get_desired_distance() / MOTOR_POLEPAIR), 4),0);
	
	
	glcd_gotoxy(0, 36);
  4032e6:	2124      	movs	r1, #36	; 0x24
  4032e8:	2000      	movs	r0, #0
  4032ea:	4b18      	ldr	r3, [pc, #96]	; (40334c <encoder_screen_play+0x2e8>)
  4032ec:	4798      	blx	r3
	glcd_putsf("Vq ",0);
  4032ee:	2100      	movs	r1, #0
  4032f0:	482d      	ldr	r0, [pc, #180]	; (4033a8 <encoder_screen_play+0x344>)
  4032f2:	4b18      	ldr	r3, [pc, #96]	; (403354 <encoder_screen_play+0x2f0>)
  4032f4:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(cvq), 4),0);
  4032f6:	4b2d      	ldr	r3, [pc, #180]	; (4033ac <encoder_screen_play+0x348>)
  4032f8:	eddf 7a25 	vldr	s15, [pc, #148]	; 403390 <encoder_screen_play+0x32c>
  4032fc:	ed93 8a00 	vldr	s16, [r3]
  403300:	4b24      	ldr	r3, [pc, #144]	; (403394 <encoder_screen_play+0x330>)
  403302:	ee68 7a27 	vmul.f32	s15, s16, s15
  403306:	4c24      	ldr	r4, [pc, #144]	; (403398 <encoder_screen_play+0x334>)
  403308:	ee17 0a90 	vmov	r0, s15
  40330c:	4798      	blx	r3
  40330e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  403312:	460b      	mov	r3, r1
  403314:	4602      	mov	r2, r0
  403316:	2000      	movs	r0, #0
  403318:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40331c:	bfac      	ite	ge
  40331e:	491f      	ldrge	r1, [pc, #124]	; (40339c <encoder_screen_play+0x338>)
  403320:	491f      	ldrlt	r1, [pc, #124]	; (4033a0 <encoder_screen_play+0x33c>)
  403322:	47a0      	blx	r4
  403324:	4b1f      	ldr	r3, [pc, #124]	; (4033a4 <encoder_screen_play+0x340>)
  403326:	4798      	blx	r3
	char tmp[12] = {0};
  403328:	2300      	movs	r3, #0
	if (A < 0) {
  40332a:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  40332e:	9303      	str	r3, [sp, #12]
  403330:	6073      	str	r3, [r6, #4]
  403332:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  403334:	f2c0 81d5 	blt.w	4036e2 <encoder_screen_play+0x67e>
	int ndec = 0, slen = 0;
  403338:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  40333a:	ea4f 38eb 	mov.w	r8, fp, asr #15
  40333e:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  403340:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  403342:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403346:	e034      	b.n	4033b2 <encoder_screen_play+0x34e>
  403348:	0040c2e5 	.word	0x0040c2e5
  40334c:	0040c7a5 	.word	0x0040c7a5
  403350:	004199a4 	.word	0x004199a4
  403354:	0040c7b9 	.word	0x0040c7b9
  403358:	004199ac 	.word	0x004199ac
  40335c:	00413b0d 	.word	0x00413b0d
  403360:	004138c9 	.word	0x004138c9
  403364:	0040c755 	.word	0x0040c755
  403368:	0040c259 	.word	0x0040c259
  40336c:	0040ca05 	.word	0x0040ca05
  403370:	0040c205 	.word	0x0040c205
  403374:	004199b4 	.word	0x004199b4
  403378:	20404ff0 	.word	0x20404ff0
  40337c:	00413d71 	.word	0x00413d71
  403380:	20400854 	.word	0x20400854
  403384:	004190fd 	.word	0x004190fd
  403388:	004199bc 	.word	0x004199bc
  40338c:	20406558 	.word	0x20406558
  403390:	47000000 	.word	0x47000000
  403394:	00418749 	.word	0x00418749
  403398:	0041848d 	.word	0x0041848d
  40339c:	3fe00000 	.word	0x3fe00000
  4033a0:	bfe00000 	.word	0xbfe00000
  4033a4:	00418d51 	.word	0x00418d51
  4033a8:	004199c0 	.word	0x004199c0
  4033ac:	20406550 	.word	0x20406550
		tmp[ndec++] = '0' + ip % 10;
  4033b0:	461c      	mov	r4, r3
  4033b2:	4640      	mov	r0, r8
  4033b4:	4649      	mov	r1, r9
  4033b6:	220a      	movs	r2, #10
  4033b8:	2300      	movs	r3, #0
  4033ba:	47a8      	blx	r5
  4033bc:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  4033c0:	4640      	mov	r0, r8
  4033c2:	4649      	mov	r1, r9
  4033c4:	220a      	movs	r2, #10
  4033c6:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  4033c8:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  4033cc:	47a8      	blx	r5
  4033ce:	4680      	mov	r8, r0
  4033d0:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  4033d2:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  4033d4:	ea58 0209 	orrs.w	r2, r8, r9
  4033d8:	d1ea      	bne.n	4033b0 <encoder_screen_play+0x34c>
  4033da:	f10a 32ff 	add.w	r2, sl, #4294967295
  4033de:	9901      	ldr	r1, [sp, #4]
  4033e0:	4433      	add	r3, r6
  4033e2:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  4033e4:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  4033e8:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  4033ea:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  4033ee:	d1f9      	bne.n	4033e4 <encoder_screen_play+0x380>
  4033f0:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  4033f4:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  4033f6:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  4033fa:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  4033fe:	4404      	add	r4, r0
  403400:	f107 0e01 	add.w	lr, r7, #1
  403404:	212e      	movs	r1, #46	; 0x2e
  403406:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403408:	465a      	mov	r2, fp
  40340a:	4486      	add	lr, r0
	str[slen++] = '.';
  40340c:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403410:	2400      	movs	r4, #0
  403412:	e001      	b.n	403418 <encoder_screen_play+0x3b4>
	} while (fr != 0 && ndec < max_dec);
  403414:	2c03      	cmp	r4, #3
  403416:	dc12      	bgt.n	40343e <encoder_screen_play+0x3da>
		fr = (fr & mask) * 10;
  403418:	2300      	movs	r3, #0
  40341a:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  40341c:	3701      	adds	r7, #1
		ndec++;
  40341e:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  403420:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  403424:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  403428:	1812      	adds	r2, r2, r0
  40342a:	414b      	adcs	r3, r1
  40342c:	1892      	adds	r2, r2, r2
  40342e:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403430:	f103 0130 	add.w	r1, r3, #48	; 0x30
  403434:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  403438:	ea52 0103 	orrs.w	r1, r2, r3
  40343c:	d1ea      	bne.n	403414 <encoder_screen_play+0x3b0>
	if (ndec > 1 && str[slen-1] == '0')
  40343e:	2c01      	cmp	r4, #1
  403440:	d005      	beq.n	40344e <encoder_screen_play+0x3ea>
  403442:	1e7b      	subs	r3, r7, #1
  403444:	9a01      	ldr	r2, [sp, #4]
  403446:	5cd2      	ldrb	r2, [r2, r3]
  403448:	2a30      	cmp	r2, #48	; 0x30
  40344a:	f000 8166 	beq.w	40371a <encoder_screen_play+0x6b6>
		str[slen] = '\0';
  40344e:	2300      	movs	r3, #0
  403450:	9a01      	ldr	r2, [sp, #4]
  403452:	55d3      	strb	r3, [r2, r7]
  403454:	2100      	movs	r1, #0
  403456:	48b5      	ldr	r0, [pc, #724]	; (40372c <encoder_screen_play+0x6c8>)
  403458:	4bb5      	ldr	r3, [pc, #724]	; (403730 <encoder_screen_play+0x6cc>)
  40345a:	4798      	blx	r3
	
	glcd_gotoxy(0, 45);
  40345c:	212d      	movs	r1, #45	; 0x2d
  40345e:	2000      	movs	r0, #0
  403460:	4bb4      	ldr	r3, [pc, #720]	; (403734 <encoder_screen_play+0x6d0>)
  403462:	4798      	blx	r3
	glcd_putsf("Id ",0);
  403464:	2100      	movs	r1, #0
  403466:	48b4      	ldr	r0, [pc, #720]	; (403738 <encoder_screen_play+0x6d4>)
  403468:	4bb4      	ldr	r3, [pc, #720]	; (40373c <encoder_screen_play+0x6d8>)
  40346a:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(cid), 4),0);
  40346c:	4bb4      	ldr	r3, [pc, #720]	; (403740 <encoder_screen_play+0x6dc>)
  40346e:	eddf 7ab5 	vldr	s15, [pc, #724]	; 403744 <encoder_screen_play+0x6e0>
  403472:	ed93 8a00 	vldr	s16, [r3]
  403476:	4bb4      	ldr	r3, [pc, #720]	; (403748 <encoder_screen_play+0x6e4>)
  403478:	ee68 7a27 	vmul.f32	s15, s16, s15
  40347c:	4cb3      	ldr	r4, [pc, #716]	; (40374c <encoder_screen_play+0x6e8>)
  40347e:	ee17 0a90 	vmov	r0, s15
  403482:	4798      	blx	r3
  403484:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  403488:	460b      	mov	r3, r1
  40348a:	4602      	mov	r2, r0
  40348c:	2000      	movs	r0, #0
  40348e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  403492:	bfac      	ite	ge
  403494:	49ae      	ldrge	r1, [pc, #696]	; (403750 <encoder_screen_play+0x6ec>)
  403496:	49af      	ldrlt	r1, [pc, #700]	; (403754 <encoder_screen_play+0x6f0>)
  403498:	47a0      	blx	r4
  40349a:	4baf      	ldr	r3, [pc, #700]	; (403758 <encoder_screen_play+0x6f4>)
  40349c:	4798      	blx	r3
	char tmp[12] = {0};
  40349e:	2300      	movs	r3, #0
	if (A < 0) {
  4034a0:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  4034a4:	9303      	str	r3, [sp, #12]
  4034a6:	6073      	str	r3, [r6, #4]
  4034a8:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  4034aa:	f2c0 8112 	blt.w	4036d2 <encoder_screen_play+0x66e>
	int ndec = 0, slen = 0;
  4034ae:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  4034b0:	ea4f 38eb 	mov.w	r8, fp, asr #15
  4034b4:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  4034b6:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  4034b8:	ea4f 79e8 	mov.w	r9, r8, asr #31
  4034bc:	e000      	b.n	4034c0 <encoder_screen_play+0x45c>
		tmp[ndec++] = '0' + ip % 10;
  4034be:	461c      	mov	r4, r3
  4034c0:	4640      	mov	r0, r8
  4034c2:	4649      	mov	r1, r9
  4034c4:	220a      	movs	r2, #10
  4034c6:	2300      	movs	r3, #0
  4034c8:	47a8      	blx	r5
  4034ca:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  4034ce:	4640      	mov	r0, r8
  4034d0:	4649      	mov	r1, r9
  4034d2:	220a      	movs	r2, #10
  4034d4:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  4034d6:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  4034da:	47a8      	blx	r5
  4034dc:	4680      	mov	r8, r0
  4034de:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  4034e0:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  4034e2:	ea58 0209 	orrs.w	r2, r8, r9
  4034e6:	d1ea      	bne.n	4034be <encoder_screen_play+0x45a>
  4034e8:	f10a 32ff 	add.w	r2, sl, #4294967295
  4034ec:	9901      	ldr	r1, [sp, #4]
  4034ee:	4433      	add	r3, r6
  4034f0:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  4034f2:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  4034f6:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  4034f8:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  4034fc:	d1f9      	bne.n	4034f2 <encoder_screen_play+0x48e>
  4034fe:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  403502:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403504:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  403508:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  40350c:	4404      	add	r4, r0
  40350e:	f107 0e01 	add.w	lr, r7, #1
  403512:	212e      	movs	r1, #46	; 0x2e
  403514:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403516:	465a      	mov	r2, fp
  403518:	4486      	add	lr, r0
	str[slen++] = '.';
  40351a:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40351e:	2400      	movs	r4, #0
  403520:	e001      	b.n	403526 <encoder_screen_play+0x4c2>
	} while (fr != 0 && ndec < max_dec);
  403522:	2c03      	cmp	r4, #3
  403524:	dc12      	bgt.n	40354c <encoder_screen_play+0x4e8>
		fr = (fr & mask) * 10;
  403526:	2300      	movs	r3, #0
  403528:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  40352a:	3701      	adds	r7, #1
		ndec++;
  40352c:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  40352e:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  403532:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  403536:	1812      	adds	r2, r2, r0
  403538:	414b      	adcs	r3, r1
  40353a:	1892      	adds	r2, r2, r2
  40353c:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  40353e:	f103 0130 	add.w	r1, r3, #48	; 0x30
  403542:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  403546:	ea52 0103 	orrs.w	r1, r2, r3
  40354a:	d1ea      	bne.n	403522 <encoder_screen_play+0x4be>
	if (ndec > 1 && str[slen-1] == '0')
  40354c:	2c01      	cmp	r4, #1
  40354e:	d005      	beq.n	40355c <encoder_screen_play+0x4f8>
  403550:	1e7b      	subs	r3, r7, #1
  403552:	9a01      	ldr	r2, [sp, #4]
  403554:	5cd2      	ldrb	r2, [r2, r3]
  403556:	2a30      	cmp	r2, #48	; 0x30
  403558:	f000 80d7 	beq.w	40370a <encoder_screen_play+0x6a6>
		str[slen] = '\0';
  40355c:	2300      	movs	r3, #0
  40355e:	9a01      	ldr	r2, [sp, #4]
  403560:	55d3      	strb	r3, [r2, r7]
  403562:	2100      	movs	r1, #0
  403564:	4871      	ldr	r0, [pc, #452]	; (40372c <encoder_screen_play+0x6c8>)
  403566:	4b72      	ldr	r3, [pc, #456]	; (403730 <encoder_screen_play+0x6cc>)
  403568:	4798      	blx	r3

	glcd_gotoxy(0, 54);
  40356a:	2136      	movs	r1, #54	; 0x36
  40356c:	2000      	movs	r0, #0
  40356e:	4b71      	ldr	r3, [pc, #452]	; (403734 <encoder_screen_play+0x6d0>)
  403570:	4798      	blx	r3
	glcd_putsf("Iq ",0);
  403572:	2100      	movs	r1, #0
  403574:	4879      	ldr	r0, [pc, #484]	; (40375c <encoder_screen_play+0x6f8>)
  403576:	4b71      	ldr	r3, [pc, #452]	; (40373c <encoder_screen_play+0x6d8>)
  403578:	4798      	blx	r3
	//glcd_puts(fixedpt_cstr(fixedpt_rconst(get_loadtorque()), 4),0);
	glcd_puts(fixedpt_cstr(fixedpt_rconst(ciq), 4),0);
  40357a:	4b79      	ldr	r3, [pc, #484]	; (403760 <encoder_screen_play+0x6fc>)
  40357c:	eddf 7a71 	vldr	s15, [pc, #452]	; 403744 <encoder_screen_play+0x6e0>
  403580:	ed93 8a00 	vldr	s16, [r3]
  403584:	4b70      	ldr	r3, [pc, #448]	; (403748 <encoder_screen_play+0x6e4>)
  403586:	ee68 7a27 	vmul.f32	s15, s16, s15
  40358a:	4c70      	ldr	r4, [pc, #448]	; (40374c <encoder_screen_play+0x6e8>)
  40358c:	ee17 0a90 	vmov	r0, s15
  403590:	4798      	blx	r3
  403592:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  403596:	460b      	mov	r3, r1
  403598:	4602      	mov	r2, r0
  40359a:	2000      	movs	r0, #0
  40359c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4035a0:	bfac      	ite	ge
  4035a2:	496b      	ldrge	r1, [pc, #428]	; (403750 <encoder_screen_play+0x6ec>)
  4035a4:	496b      	ldrlt	r1, [pc, #428]	; (403754 <encoder_screen_play+0x6f0>)
  4035a6:	47a0      	blx	r4
  4035a8:	4b6b      	ldr	r3, [pc, #428]	; (403758 <encoder_screen_play+0x6f4>)
  4035aa:	4798      	blx	r3
	char tmp[12] = {0};
  4035ac:	2300      	movs	r3, #0
	if (A < 0) {
  4035ae:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  4035b0:	9303      	str	r3, [sp, #12]
  4035b2:	6073      	str	r3, [r6, #4]
  4035b4:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  4035b6:	db6a      	blt.n	40368e <encoder_screen_play+0x62a>
	int ndec = 0, slen = 0;
  4035b8:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  4035ba:	ea4f 38e4 	mov.w	r8, r4, asr #15
  4035be:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  4035c0:	2700      	movs	r7, #0
	ip = fixedpt_toint(A);
  4035c2:	ea4f 79e8 	mov.w	r9, r8, asr #31
  4035c6:	e000      	b.n	4035ca <encoder_screen_play+0x566>
		tmp[ndec++] = '0' + ip % 10;
  4035c8:	461f      	mov	r7, r3
  4035ca:	4640      	mov	r0, r8
  4035cc:	4649      	mov	r1, r9
  4035ce:	220a      	movs	r2, #10
  4035d0:	2300      	movs	r3, #0
  4035d2:	47a8      	blx	r5
  4035d4:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  4035d8:	4640      	mov	r0, r8
  4035da:	4649      	mov	r1, r9
  4035dc:	220a      	movs	r2, #10
  4035de:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  4035e0:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  4035e4:	47a8      	blx	r5
  4035e6:	4680      	mov	r8, r0
  4035e8:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  4035ea:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  4035ec:	ea58 0209 	orrs.w	r2, r8, r9
  4035f0:	d1ea      	bne.n	4035c8 <encoder_screen_play+0x564>
  4035f2:	f10b 32ff 	add.w	r2, fp, #4294967295
  4035f6:	9901      	ldr	r1, [sp, #4]
  4035f8:	4433      	add	r3, r6
  4035fa:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  4035fc:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  403600:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  403602:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403606:	d1f9      	bne.n	4035fc <encoder_screen_play+0x598>
  403608:	eb07 000b 	add.w	r0, r7, fp
	str[slen++] = '.';
  40360c:	9a01      	ldr	r2, [sp, #4]
  40360e:	f10b 0b01 	add.w	fp, fp, #1
  403612:	232e      	movs	r3, #46	; 0x2e
  403614:	1c46      	adds	r6, r0, #1
  403616:	4417      	add	r7, r2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403618:	0464      	lsls	r4, r4, #17
	str[slen++] = '.';
  40361a:	3002      	adds	r0, #2
  40361c:	4416      	add	r6, r2
  40361e:	f807 300b 	strb.w	r3, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403622:	2100      	movs	r1, #0
  403624:	e001      	b.n	40362a <encoder_screen_play+0x5c6>
	} while (fr != 0 && ndec < max_dec);
  403626:	2903      	cmp	r1, #3
  403628:	dc11      	bgt.n	40364e <encoder_screen_play+0x5ea>
		fr = (fr & mask) * 10;
  40362a:	2500      	movs	r5, #0
  40362c:	00a2      	lsls	r2, r4, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  40362e:	3001      	adds	r0, #1
		ndec++;
  403630:	3101      	adds	r1, #1
		fr = (fr & mask) * 10;
  403632:	00af      	lsls	r7, r5, #2
  403634:	ea47 7394 	orr.w	r3, r7, r4, lsr #30
  403638:	18a4      	adds	r4, r4, r2
  40363a:	415d      	adcs	r5, r3
  40363c:	1924      	adds	r4, r4, r4
  40363e:	416d      	adcs	r5, r5
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403640:	f105 0330 	add.w	r3, r5, #48	; 0x30
  403644:	f806 3f01 	strb.w	r3, [r6, #1]!
	} while (fr != 0 && ndec < max_dec);
  403648:	ea54 0305 	orrs.w	r3, r4, r5
  40364c:	d1eb      	bne.n	403626 <encoder_screen_play+0x5c2>
	if (ndec > 1 && str[slen-1] == '0')
  40364e:	2901      	cmp	r1, #1
  403650:	d004      	beq.n	40365c <encoder_screen_play+0x5f8>
  403652:	1e43      	subs	r3, r0, #1
  403654:	9a01      	ldr	r2, [sp, #4]
  403656:	5cd2      	ldrb	r2, [r2, r3]
  403658:	2a30      	cmp	r2, #48	; 0x30
  40365a:	d062      	beq.n	403722 <encoder_screen_play+0x6be>
		str[slen] = '\0';
  40365c:	2300      	movs	r3, #0
  40365e:	9a01      	ldr	r2, [sp, #4]
  403660:	5413      	strb	r3, [r2, r0]
  403662:	4b33      	ldr	r3, [pc, #204]	; (403730 <encoder_screen_play+0x6cc>)
  403664:	2100      	movs	r1, #0
  403666:	4831      	ldr	r0, [pc, #196]	; (40372c <encoder_screen_play+0x6c8>)
  403668:	4798      	blx	r3
	
// 	glcd_gotoxy(0, 54);
// 	glcd_putsf("vec ",0);
// 	glcd_puts(itos(SPMstatic_getchosenvec()),0);
	
	if(get_esc_button())
  40366a:	4b3e      	ldr	r3, [pc, #248]	; (403764 <encoder_screen_play+0x700>)
  40366c:	4798      	blx	r3
  40366e:	b110      	cbz	r0, 403676 <encoder_screen_play+0x612>
	{
		active_screen = IDF_SCREEN_MAIN;
  403670:	4b3d      	ldr	r3, [pc, #244]	; (403768 <encoder_screen_play+0x704>)
  403672:	2200      	movs	r2, #0
  403674:	601a      	str	r2, [r3, #0]
	}
	
	drop_all_buttons();
  403676:	4b3d      	ldr	r3, [pc, #244]	; (40376c <encoder_screen_play+0x708>)
}
  403678:	b007      	add	sp, #28
  40367a:	ecbd 8b02 	vpop	{d8}
  40367e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	drop_all_buttons();
  403682:	4718      	bx	r3
	if(tmp_phs < 10) putIt('0');
  403684:	2030      	movs	r0, #48	; 0x30
  403686:	47a8      	blx	r5
	if(tmp_phs < 100) putIt('0');
  403688:	2030      	movs	r0, #48	; 0x30
  40368a:	47a8      	blx	r5
  40368c:	e525      	b.n	4030da <encoder_screen_play+0x76>
		str[slen++] = '-';
  40368e:	232d      	movs	r3, #45	; 0x2d
  403690:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  403692:	4264      	negs	r4, r4
		str[slen++] = '-';
  403694:	f04f 0b01 	mov.w	fp, #1
  403698:	7013      	strb	r3, [r2, #0]
  40369a:	e78e      	b.n	4035ba <encoder_screen_play+0x556>
		tmp_theta += 1;
  40369c:	3601      	adds	r6, #1
  40369e:	f147 0700 	adc.w	r7, r7, #0
		if (tmp_theta == 0) putIt('-');
  4036a2:	ea56 0307 	orrs.w	r3, r6, r7
  4036a6:	d028      	beq.n	4036fa <encoder_screen_play+0x696>
  4036a8:	4d31      	ldr	r5, [pc, #196]	; (403770 <encoder_screen_play+0x70c>)
		tmp_phs = 1000 - tmp_phs;
  4036aa:	f5c4 747a 	rsb	r4, r4, #1000	; 0x3e8
  4036ae:	e505      	b.n	4030bc <encoder_screen_play+0x58>
  4036b0:	4b1e      	ldr	r3, [pc, #120]	; (40372c <encoder_screen_play+0x6c8>)
		A *= -1;
  4036b2:	4264      	negs	r4, r4
		str[slen++] = '-';
  4036b4:	f04f 0b01 	mov.w	fp, #1
  4036b8:	461a      	mov	r2, r3
  4036ba:	9301      	str	r3, [sp, #4]
  4036bc:	232d      	movs	r3, #45	; 0x2d
  4036be:	7013      	strb	r3, [r2, #0]
  4036c0:	e52a      	b.n	403118 <encoder_screen_play+0xb4>
  4036c2:	232d      	movs	r3, #45	; 0x2d
  4036c4:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  4036c6:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  4036ca:	f04f 0a01 	mov.w	sl, #1
  4036ce:	7013      	strb	r3, [r2, #0]
  4036d0:	e5ac      	b.n	40322c <encoder_screen_play+0x1c8>
  4036d2:	232d      	movs	r3, #45	; 0x2d
  4036d4:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  4036d6:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  4036da:	f04f 0a01 	mov.w	sl, #1
  4036de:	7013      	strb	r3, [r2, #0]
  4036e0:	e6e6      	b.n	4034b0 <encoder_screen_play+0x44c>
  4036e2:	232d      	movs	r3, #45	; 0x2d
  4036e4:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  4036e6:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  4036ea:	f04f 0a01 	mov.w	sl, #1
  4036ee:	7013      	strb	r3, [r2, #0]
  4036f0:	e623      	b.n	40333a <encoder_screen_play+0x2d6>
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  4036f2:	f504 44ff 	add.w	r4, r4, #32640	; 0x7f80
  4036f6:	347f      	adds	r4, #127	; 0x7f
  4036f8:	e4d8      	b.n	4030ac <encoder_screen_play+0x48>
		if (tmp_theta == 0) putIt('-');
  4036fa:	4d1d      	ldr	r5, [pc, #116]	; (403770 <encoder_screen_play+0x70c>)
  4036fc:	202d      	movs	r0, #45	; 0x2d
  4036fe:	47a8      	blx	r5
  403700:	e7d3      	b.n	4036aa <encoder_screen_play+0x646>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  403702:	2200      	movs	r2, #0
  403704:	9901      	ldr	r1, [sp, #4]
  403706:	54ca      	strb	r2, [r1, r3]
  403708:	e562      	b.n	4031d0 <encoder_screen_play+0x16c>
  40370a:	2200      	movs	r2, #0
  40370c:	9901      	ldr	r1, [sp, #4]
  40370e:	54ca      	strb	r2, [r1, r3]
  403710:	e727      	b.n	403562 <encoder_screen_play+0x4fe>
  403712:	2200      	movs	r2, #0
  403714:	9901      	ldr	r1, [sp, #4]
  403716:	54ca      	strb	r2, [r1, r3]
  403718:	e5e1      	b.n	4032de <encoder_screen_play+0x27a>
  40371a:	2200      	movs	r2, #0
  40371c:	9901      	ldr	r1, [sp, #4]
  40371e:	54ca      	strb	r2, [r1, r3]
  403720:	e698      	b.n	403454 <encoder_screen_play+0x3f0>
  403722:	2200      	movs	r2, #0
  403724:	9901      	ldr	r1, [sp, #4]
  403726:	54ca      	strb	r2, [r1, r3]
  403728:	e79b      	b.n	403662 <encoder_screen_play+0x5fe>
  40372a:	bf00      	nop
  40372c:	20400854 	.word	0x20400854
  403730:	0040ca05 	.word	0x0040ca05
  403734:	0040c7a5 	.word	0x0040c7a5
  403738:	004199c4 	.word	0x004199c4
  40373c:	0040c7b9 	.word	0x0040c7b9
  403740:	2040655c 	.word	0x2040655c
  403744:	47000000 	.word	0x47000000
  403748:	00418749 	.word	0x00418749
  40374c:	0041848d 	.word	0x0041848d
  403750:	3fe00000 	.word	0x3fe00000
  403754:	bfe00000 	.word	0xbfe00000
  403758:	00418d51 	.word	0x00418d51
  40375c:	004199c8 	.word	0x004199c8
  403760:	20406554 	.word	0x20406554
  403764:	0040de45 	.word	0x0040de45
  403768:	2040084c 	.word	0x2040084c
  40376c:	0040ded1 	.word	0x0040ded1
  403770:	0040c755 	.word	0x0040c755

00403774 <torque_screen_play>:

void torque_screen_play(void)
{
  403774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	glcd_clear();
  403778:	4bb1      	ldr	r3, [pc, #708]	; (403a40 <torque_screen_play+0x2cc>)
{
  40377a:	b087      	sub	sp, #28
	glcd_clear();
  40377c:	4798      	blx	r3
	glcd_gotoxy(0,0);
  40377e:	2100      	movs	r1, #0
  403780:	4bb0      	ldr	r3, [pc, #704]	; (403a44 <torque_screen_play+0x2d0>)
	glcd_putsf("torques",0);
	
	glcd_gotoxy(0, 9);
	glcd_putsf("Inc ",0);
	int64_t tmp_theta = enc_get_lin_theta();
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  403782:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
	glcd_gotoxy(0,0);
  403786:	4608      	mov	r0, r1
  403788:	4798      	blx	r3
	glcd_putsf("torques",0);
  40378a:	2100      	movs	r1, #0
  40378c:	48ae      	ldr	r0, [pc, #696]	; (403a48 <torque_screen_play+0x2d4>)
  40378e:	4baf      	ldr	r3, [pc, #700]	; (403a4c <torque_screen_play+0x2d8>)
  403790:	4798      	blx	r3
	glcd_gotoxy(0, 9);
  403792:	2109      	movs	r1, #9
  403794:	2000      	movs	r0, #0
  403796:	4bab      	ldr	r3, [pc, #684]	; (403a44 <torque_screen_play+0x2d0>)
  403798:	4798      	blx	r3
	glcd_putsf("Inc ",0);
  40379a:	2100      	movs	r1, #0
  40379c:	48ac      	ldr	r0, [pc, #688]	; (403a50 <torque_screen_play+0x2dc>)
  40379e:	4bab      	ldr	r3, [pc, #684]	; (403a4c <torque_screen_play+0x2d8>)
  4037a0:	4798      	blx	r3
	int64_t tmp_theta = enc_get_lin_theta();
  4037a2:	4bac      	ldr	r3, [pc, #688]	; (403a54 <torque_screen_play+0x2e0>)
  4037a4:	4798      	blx	r3
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  4037a6:	4bac      	ldr	r3, [pc, #688]	; (403a58 <torque_screen_play+0x2e4>)
	int64_t tmp_theta = enc_get_lin_theta();
  4037a8:	4606      	mov	r6, r0
  4037aa:	460f      	mov	r7, r1
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  4037ac:	4798      	blx	r3
  4037ae:	fb04 f400 	mul.w	r4, r4, r0
  4037b2:	2c00      	cmp	r4, #0
  4037b4:	f2c0 8322 	blt.w	403dfc <torque_screen_play+0x688>
	if (tmp_theta < 0)
  4037b8:	2e00      	cmp	r6, #0
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  4037ba:	ea4f 34e4 	mov.w	r4, r4, asr #15
	if (tmp_theta < 0)
  4037be:	f177 0300 	sbcs.w	r3, r7, #0
  4037c2:	f2c0 82f1 	blt.w	403da8 <torque_screen_play+0x634>
  4037c6:	4da5      	ldr	r5, [pc, #660]	; (403a5c <torque_screen_play+0x2e8>)
	{
		tmp_theta += 1;
		if (tmp_theta == 0) putIt('-');
		tmp_phs = 1000 - tmp_phs;
	}
	glcd_puts(sitos(tmp_theta),0);
  4037c8:	4639      	mov	r1, r7
  4037ca:	4ba5      	ldr	r3, [pc, #660]	; (403a60 <torque_screen_play+0x2ec>)
  4037cc:	4630      	mov	r0, r6
  4037ce:	4798      	blx	r3
  4037d0:	2100      	movs	r1, #0
  4037d2:	4ba4      	ldr	r3, [pc, #656]	; (403a64 <torque_screen_play+0x2f0>)
  4037d4:	4798      	blx	r3
	
	putIt('.');
  4037d6:	202e      	movs	r0, #46	; 0x2e
  4037d8:	47a8      	blx	r5
	if(tmp_phs < 10) putIt('0');
  4037da:	2c09      	cmp	r4, #9
  4037dc:	f240 82d8 	bls.w	403d90 <torque_screen_play+0x61c>
	if(tmp_phs < 100) putIt('0');
  4037e0:	2c63      	cmp	r4, #99	; 0x63
  4037e2:	f240 82d7 	bls.w	403d94 <torque_screen_play+0x620>
	glcd_puts(itos(tmp_phs),0);
  4037e6:	2500      	movs	r5, #0
  4037e8:	4620      	mov	r0, r4
  4037ea:	4b9f      	ldr	r3, [pc, #636]	; (403a68 <torque_screen_play+0x2f4>)
	char tmp[12] = {0};
  4037ec:	ae03      	add	r6, sp, #12
  4037ee:	4629      	mov	r1, r5
  4037f0:	4798      	blx	r3
  4037f2:	4629      	mov	r1, r5
  4037f4:	4b9b      	ldr	r3, [pc, #620]	; (403a64 <torque_screen_play+0x2f0>)
  4037f6:	4798      	blx	r3
	

	glcd_gotoxy(0, 18);
  4037f8:	4628      	mov	r0, r5
  4037fa:	2112      	movs	r1, #18
  4037fc:	4b91      	ldr	r3, [pc, #580]	; (403a44 <torque_screen_play+0x2d0>)
  4037fe:	4798      	blx	r3
	glcd_putsf("Rev ",0);
  403800:	4629      	mov	r1, r5
  403802:	489a      	ldr	r0, [pc, #616]	; (403a6c <torque_screen_play+0x2f8>)
  403804:	4b91      	ldr	r3, [pc, #580]	; (403a4c <torque_screen_play+0x2d8>)
  403806:	4798      	blx	r3
	//	glcd_puts(fixedpt_cstr(fixedpt_abs(enc_get_omega_shaft_rad_hat()) * FIXEDPT_ONE, 8),0);
	
	glcd_puts(fixedpt_cstr(enc_get_omega_hz_hat(MOTOR_POLEPAIR), 8),0);
  403808:	4a99      	ldr	r2, [pc, #612]	; (403a70 <torque_screen_play+0x2fc>)
  40380a:	4b9a      	ldr	r3, [pc, #616]	; (403a74 <torque_screen_play+0x300>)
  40380c:	f892 003c 	ldrb.w	r0, [r2, #60]	; 0x3c
  403810:	4798      	blx	r3
	if (A < 0) {
  403812:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  403814:	9503      	str	r5, [sp, #12]
  403816:	6075      	str	r5, [r6, #4]
  403818:	60b5      	str	r5, [r6, #8]
	if (A < 0) {
  40381a:	f2c0 82cf 	blt.w	403dbc <torque_screen_play+0x648>
  40381e:	4b96      	ldr	r3, [pc, #600]	; (403a78 <torque_screen_play+0x304>)
	int ndec = 0, slen = 0;
  403820:	46ab      	mov	fp, r5
  403822:	9301      	str	r3, [sp, #4]
	ip = fixedpt_toint(A);
  403824:	ea4f 38e4 	mov.w	r8, r4, asr #15
  403828:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  40382a:	2700      	movs	r7, #0
  40382c:	4d93      	ldr	r5, [pc, #588]	; (403a7c <torque_screen_play+0x308>)
	ip = fixedpt_toint(A);
  40382e:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403832:	e000      	b.n	403836 <torque_screen_play+0xc2>
		tmp[ndec++] = '0' + ip % 10;
  403834:	461f      	mov	r7, r3
  403836:	4640      	mov	r0, r8
  403838:	4649      	mov	r1, r9
  40383a:	220a      	movs	r2, #10
  40383c:	2300      	movs	r3, #0
  40383e:	47a8      	blx	r5
  403840:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  403844:	4640      	mov	r0, r8
  403846:	4649      	mov	r1, r9
  403848:	220a      	movs	r2, #10
  40384a:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  40384c:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  403850:	47a8      	blx	r5
  403852:	4680      	mov	r8, r0
  403854:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  403856:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  403858:	ea58 0209 	orrs.w	r2, r8, r9
  40385c:	d1ea      	bne.n	403834 <torque_screen_play+0xc0>
  40385e:	f10b 32ff 	add.w	r2, fp, #4294967295
  403862:	9901      	ldr	r1, [sp, #4]
  403864:	4433      	add	r3, r6
  403866:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  403868:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  40386c:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  40386e:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403872:	d1f9      	bne.n	403868 <torque_screen_play+0xf4>
  403874:	eb07 0e0b 	add.w	lr, r7, fp
	str[slen++] = '.';
  403878:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  40387a:	0464      	lsls	r4, r4, #17
  40387c:	f10b 0b01 	add.w	fp, fp, #1
  403880:	f10e 0c01 	add.w	ip, lr, #1
	str[slen++] = '.';
  403884:	4407      	add	r7, r0
  403886:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403888:	4622      	mov	r2, r4
	str[slen++] = '.';
  40388a:	f10e 0e02 	add.w	lr, lr, #2
  40388e:	4484      	add	ip, r0
  403890:	f807 100b 	strb.w	r1, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403894:	2400      	movs	r4, #0
  403896:	e001      	b.n	40389c <torque_screen_play+0x128>
	} while (fr != 0 && ndec < max_dec);
  403898:	2c07      	cmp	r4, #7
  40389a:	dc12      	bgt.n	4038c2 <torque_screen_play+0x14e>
		fr = (fr & mask) * 10;
  40389c:	2300      	movs	r3, #0
  40389e:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4038a0:	f10e 0e01 	add.w	lr, lr, #1
		ndec++;
  4038a4:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  4038a6:	009f      	lsls	r7, r3, #2
  4038a8:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  4038ac:	1812      	adds	r2, r2, r0
  4038ae:	414b      	adcs	r3, r1
  4038b0:	1892      	adds	r2, r2, r2
  4038b2:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4038b4:	f103 0130 	add.w	r1, r3, #48	; 0x30
  4038b8:	f80c 1f01 	strb.w	r1, [ip, #1]!
	} while (fr != 0 && ndec < max_dec);
  4038bc:	ea52 0103 	orrs.w	r1, r2, r3
  4038c0:	d1ea      	bne.n	403898 <torque_screen_play+0x124>
	if (ndec > 1 && str[slen-1] == '0')
  4038c2:	2c01      	cmp	r4, #1
  4038c4:	d006      	beq.n	4038d4 <torque_screen_play+0x160>
  4038c6:	f10e 33ff 	add.w	r3, lr, #4294967295
  4038ca:	9a01      	ldr	r2, [sp, #4]
  4038cc:	5cd2      	ldrb	r2, [r2, r3]
  4038ce:	2a30      	cmp	r2, #48	; 0x30
  4038d0:	f000 829c 	beq.w	403e0c <torque_screen_play+0x698>
		str[slen] = '\0';
  4038d4:	2300      	movs	r3, #0
  4038d6:	9a01      	ldr	r2, [sp, #4]
  4038d8:	f802 300e 	strb.w	r3, [r2, lr]
  4038dc:	2100      	movs	r1, #0
  4038de:	4866      	ldr	r0, [pc, #408]	; (403a78 <torque_screen_play+0x304>)
  4038e0:	4b60      	ldr	r3, [pc, #384]	; (403a64 <torque_screen_play+0x2f0>)
  4038e2:	4798      	blx	r3

	glcd_gotoxy(0, 27);
  4038e4:	211b      	movs	r1, #27
  4038e6:	2000      	movs	r0, #0
  4038e8:	4b56      	ldr	r3, [pc, #344]	; (403a44 <torque_screen_play+0x2d0>)
  4038ea:	4798      	blx	r3
// 	glcd_putsf("SPT ",0);
// 	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_spt()), 4),0);
	
	glcd_putsf("Acc ",0);
  4038ec:	2100      	movs	r1, #0
  4038ee:	4864      	ldr	r0, [pc, #400]	; (403a80 <torque_screen_play+0x30c>)
  4038f0:	4b56      	ldr	r3, [pc, #344]	; (403a4c <torque_screen_play+0x2d8>)
  4038f2:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(enc_get_acc_shaft_rad_hat() * FIXEDPT_ONE, 4),0);
  4038f4:	4b63      	ldr	r3, [pc, #396]	; (403a84 <torque_screen_play+0x310>)
  4038f6:	4798      	blx	r3
  4038f8:	ee07 0a90 	vmov	s15, r0
	char tmp[12] = {0};
  4038fc:	2300      	movs	r3, #0
  4038fe:	eefe 7ae8 	vcvt.s32.f32	s15, s15, #15
  403902:	9303      	str	r3, [sp, #12]
  403904:	6073      	str	r3, [r6, #4]
  403906:	ee17 4a90 	vmov	r4, s15
  40390a:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  40390c:	429c      	cmp	r4, r3
  40390e:	f2c0 825e 	blt.w	403dce <torque_screen_play+0x65a>
	int ndec = 0, slen = 0;
  403912:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  403914:	ea4f 38e4 	mov.w	r8, r4, asr #15
  403918:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  40391a:	2700      	movs	r7, #0
	ip = fixedpt_toint(A);
  40391c:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403920:	e000      	b.n	403924 <torque_screen_play+0x1b0>
		tmp[ndec++] = '0' + ip % 10;
  403922:	461f      	mov	r7, r3
  403924:	4640      	mov	r0, r8
  403926:	4649      	mov	r1, r9
  403928:	220a      	movs	r2, #10
  40392a:	2300      	movs	r3, #0
  40392c:	47a8      	blx	r5
  40392e:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  403932:	4640      	mov	r0, r8
  403934:	4649      	mov	r1, r9
  403936:	220a      	movs	r2, #10
  403938:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  40393a:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  40393e:	47a8      	blx	r5
  403940:	4680      	mov	r8, r0
  403942:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  403944:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  403946:	ea58 0209 	orrs.w	r2, r8, r9
  40394a:	d1ea      	bne.n	403922 <torque_screen_play+0x1ae>
  40394c:	f10b 32ff 	add.w	r2, fp, #4294967295
  403950:	9901      	ldr	r1, [sp, #4]
  403952:	4433      	add	r3, r6
  403954:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  403956:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  40395a:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  40395c:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403960:	d1f9      	bne.n	403956 <torque_screen_play+0x1e2>
  403962:	eb07 0e0b 	add.w	lr, r7, fp
	str[slen++] = '.';
  403966:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403968:	0464      	lsls	r4, r4, #17
  40396a:	f10b 0b01 	add.w	fp, fp, #1
  40396e:	f10e 0c01 	add.w	ip, lr, #1
	str[slen++] = '.';
  403972:	4407      	add	r7, r0
  403974:	212e      	movs	r1, #46	; 0x2e
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403976:	4622      	mov	r2, r4
	str[slen++] = '.';
  403978:	f10e 0e02 	add.w	lr, lr, #2
  40397c:	4484      	add	ip, r0
  40397e:	f807 100b 	strb.w	r1, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403982:	2400      	movs	r4, #0
  403984:	e001      	b.n	40398a <torque_screen_play+0x216>
	} while (fr != 0 && ndec < max_dec);
  403986:	2c03      	cmp	r4, #3
  403988:	dc12      	bgt.n	4039b0 <torque_screen_play+0x23c>
		fr = (fr & mask) * 10;
  40398a:	2300      	movs	r3, #0
  40398c:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  40398e:	f10e 0e01 	add.w	lr, lr, #1
		ndec++;
  403992:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  403994:	009f      	lsls	r7, r3, #2
  403996:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  40399a:	1812      	adds	r2, r2, r0
  40399c:	414b      	adcs	r3, r1
  40399e:	1892      	adds	r2, r2, r2
  4039a0:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  4039a2:	f103 0130 	add.w	r1, r3, #48	; 0x30
  4039a6:	f80c 1f01 	strb.w	r1, [ip, #1]!
	} while (fr != 0 && ndec < max_dec);
  4039aa:	ea52 0103 	orrs.w	r1, r2, r3
  4039ae:	d1ea      	bne.n	403986 <torque_screen_play+0x212>
	if (ndec > 1 && str[slen-1] == '0')
  4039b0:	2c01      	cmp	r4, #1
  4039b2:	d006      	beq.n	4039c2 <torque_screen_play+0x24e>
  4039b4:	f10e 33ff 	add.w	r3, lr, #4294967295
  4039b8:	9a01      	ldr	r2, [sp, #4]
  4039ba:	5cd2      	ldrb	r2, [r2, r3]
  4039bc:	2a30      	cmp	r2, #48	; 0x30
  4039be:	f000 822d 	beq.w	403e1c <torque_screen_play+0x6a8>
		str[slen] = '\0';
  4039c2:	2300      	movs	r3, #0
  4039c4:	9a01      	ldr	r2, [sp, #4]
  4039c6:	f802 300e 	strb.w	r3, [r2, lr]
  4039ca:	2100      	movs	r1, #0
  4039cc:	482a      	ldr	r0, [pc, #168]	; (403a78 <torque_screen_play+0x304>)
  4039ce:	4b25      	ldr	r3, [pc, #148]	; (403a64 <torque_screen_play+0x2f0>)
  4039d0:	4798      	blx	r3

	
	glcd_gotoxy(0, 36);
  4039d2:	2124      	movs	r1, #36	; 0x24
  4039d4:	2000      	movs	r0, #0
  4039d6:	4b1b      	ldr	r3, [pc, #108]	; (403a44 <torque_screen_play+0x2d0>)
  4039d8:	4798      	blx	r3
	glcd_putsf("PZS ",0);
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_pzs()), 4),0);
  4039da:	4c2b      	ldr	r4, [pc, #172]	; (403a88 <torque_screen_play+0x314>)
	glcd_putsf("PZS ",0);
  4039dc:	2100      	movs	r1, #0
  4039de:	4b1b      	ldr	r3, [pc, #108]	; (403a4c <torque_screen_play+0x2d8>)
  4039e0:	482a      	ldr	r0, [pc, #168]	; (403a8c <torque_screen_play+0x318>)
  4039e2:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_pzs()), 4),0);
  4039e4:	47a0      	blx	r4
  4039e6:	eddf 7a2a 	vldr	s15, [pc, #168]	; 403a90 <torque_screen_play+0x31c>
  4039ea:	ee07 0a10 	vmov	s14, r0
  4039ee:	4b29      	ldr	r3, [pc, #164]	; (403a94 <torque_screen_play+0x320>)
  4039f0:	ee67 7a27 	vmul.f32	s15, s14, s15
  4039f4:	ee17 0a90 	vmov	r0, s15
  4039f8:	4798      	blx	r3
  4039fa:	4689      	mov	r9, r1
  4039fc:	4680      	mov	r8, r0
  4039fe:	47a0      	blx	r4
  403a00:	ee07 0a90 	vmov	s15, r0
  403a04:	464b      	mov	r3, r9
  403a06:	4642      	mov	r2, r8
  403a08:	2000      	movs	r0, #0
  403a0a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  403a0e:	4c22      	ldr	r4, [pc, #136]	; (403a98 <torque_screen_play+0x324>)
  403a10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  403a14:	bfac      	ite	ge
  403a16:	4921      	ldrge	r1, [pc, #132]	; (403a9c <torque_screen_play+0x328>)
  403a18:	4921      	ldrlt	r1, [pc, #132]	; (403aa0 <torque_screen_play+0x32c>)
  403a1a:	47a0      	blx	r4
  403a1c:	4b21      	ldr	r3, [pc, #132]	; (403aa4 <torque_screen_play+0x330>)
  403a1e:	4798      	blx	r3
	char tmp[12] = {0};
  403a20:	2300      	movs	r3, #0
	if (A < 0) {
  403a22:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  403a26:	9303      	str	r3, [sp, #12]
  403a28:	6073      	str	r3, [r6, #4]
  403a2a:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  403a2c:	f2c0 81de 	blt.w	403dec <torque_screen_play+0x678>
	int ndec = 0, slen = 0;
  403a30:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  403a32:	ea4f 38eb 	mov.w	r8, fp, asr #15
  403a36:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  403a38:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  403a3a:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403a3e:	e034      	b.n	403aaa <torque_screen_play+0x336>
  403a40:	0040c2e5 	.word	0x0040c2e5
  403a44:	0040c7a5 	.word	0x0040c7a5
  403a48:	00419a60 	.word	0x00419a60
  403a4c:	0040c7b9 	.word	0x0040c7b9
  403a50:	004199ac 	.word	0x004199ac
  403a54:	00413b0d 	.word	0x00413b0d
  403a58:	004138c9 	.word	0x004138c9
  403a5c:	0040c755 	.word	0x0040c755
  403a60:	0040c259 	.word	0x0040c259
  403a64:	0040ca05 	.word	0x0040ca05
  403a68:	0040c205 	.word	0x0040c205
  403a6c:	004199b4 	.word	0x004199b4
  403a70:	20404ff0 	.word	0x20404ff0
  403a74:	00413d71 	.word	0x00413d71
  403a78:	20400854 	.word	0x20400854
  403a7c:	004190fd 	.word	0x004190fd
  403a80:	00419a68 	.word	0x00419a68
  403a84:	00413d09 	.word	0x00413d09
  403a88:	0040f72d 	.word	0x0040f72d
  403a8c:	00419a70 	.word	0x00419a70
  403a90:	47000000 	.word	0x47000000
  403a94:	00418749 	.word	0x00418749
  403a98:	0041848d 	.word	0x0041848d
  403a9c:	3fe00000 	.word	0x3fe00000
  403aa0:	bfe00000 	.word	0xbfe00000
  403aa4:	00418d51 	.word	0x00418d51
		tmp[ndec++] = '0' + ip % 10;
  403aa8:	461c      	mov	r4, r3
  403aaa:	4640      	mov	r0, r8
  403aac:	4649      	mov	r1, r9
  403aae:	220a      	movs	r2, #10
  403ab0:	2300      	movs	r3, #0
  403ab2:	47a8      	blx	r5
  403ab4:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  403ab8:	4640      	mov	r0, r8
  403aba:	4649      	mov	r1, r9
  403abc:	220a      	movs	r2, #10
  403abe:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  403ac0:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  403ac4:	47a8      	blx	r5
  403ac6:	4680      	mov	r8, r0
  403ac8:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  403aca:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  403acc:	ea58 0209 	orrs.w	r2, r8, r9
  403ad0:	d1ea      	bne.n	403aa8 <torque_screen_play+0x334>
  403ad2:	f10a 32ff 	add.w	r2, sl, #4294967295
  403ad6:	9901      	ldr	r1, [sp, #4]
  403ad8:	4433      	add	r3, r6
  403ada:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  403adc:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  403ae0:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  403ae2:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403ae6:	d1f9      	bne.n	403adc <torque_screen_play+0x368>
  403ae8:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  403aec:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403aee:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  403af2:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  403af6:	4404      	add	r4, r0
  403af8:	f107 0e01 	add.w	lr, r7, #1
  403afc:	212e      	movs	r1, #46	; 0x2e
  403afe:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403b00:	465a      	mov	r2, fp
  403b02:	4486      	add	lr, r0
	str[slen++] = '.';
  403b04:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403b08:	2400      	movs	r4, #0
  403b0a:	e001      	b.n	403b10 <torque_screen_play+0x39c>
	} while (fr != 0 && ndec < max_dec);
  403b0c:	2c03      	cmp	r4, #3
  403b0e:	dc12      	bgt.n	403b36 <torque_screen_play+0x3c2>
		fr = (fr & mask) * 10;
  403b10:	2300      	movs	r3, #0
  403b12:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403b14:	3701      	adds	r7, #1
		ndec++;
  403b16:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  403b18:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  403b1c:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  403b20:	1812      	adds	r2, r2, r0
  403b22:	414b      	adcs	r3, r1
  403b24:	1892      	adds	r2, r2, r2
  403b26:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403b28:	f103 0130 	add.w	r1, r3, #48	; 0x30
  403b2c:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  403b30:	ea52 0103 	orrs.w	r1, r2, r3
  403b34:	d1ea      	bne.n	403b0c <torque_screen_play+0x398>
	if (ndec > 1 && str[slen-1] == '0')
  403b36:	2c01      	cmp	r4, #1
  403b38:	d005      	beq.n	403b46 <torque_screen_play+0x3d2>
  403b3a:	1e7b      	subs	r3, r7, #1
  403b3c:	9a01      	ldr	r2, [sp, #4]
  403b3e:	5cd2      	ldrb	r2, [r2, r3]
  403b40:	2a30      	cmp	r2, #48	; 0x30
  403b42:	f000 816f 	beq.w	403e24 <torque_screen_play+0x6b0>
		str[slen] = '\0';
  403b46:	2300      	movs	r3, #0
  403b48:	9a01      	ldr	r2, [sp, #4]
  403b4a:	55d3      	strb	r3, [r2, r7]
  403b4c:	2100      	movs	r1, #0
  403b4e:	48b9      	ldr	r0, [pc, #740]	; (403e34 <torque_screen_play+0x6c0>)
  403b50:	4bb9      	ldr	r3, [pc, #740]	; (403e38 <torque_screen_play+0x6c4>)
  403b52:	4798      	blx	r3
	
	glcd_gotoxy(0, 45);
  403b54:	212d      	movs	r1, #45	; 0x2d
  403b56:	2000      	movs	r0, #0
  403b58:	4bb8      	ldr	r3, [pc, #736]	; (403e3c <torque_screen_play+0x6c8>)
  403b5a:	4798      	blx	r3
	glcd_putsf("LT ",0);
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_loadtorque()), 4),0);
  403b5c:	4cb8      	ldr	r4, [pc, #736]	; (403e40 <torque_screen_play+0x6cc>)
	glcd_putsf("LT ",0);
  403b5e:	2100      	movs	r1, #0
  403b60:	4bb8      	ldr	r3, [pc, #736]	; (403e44 <torque_screen_play+0x6d0>)
  403b62:	48b9      	ldr	r0, [pc, #740]	; (403e48 <torque_screen_play+0x6d4>)
  403b64:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_loadtorque()), 4),0);
  403b66:	47a0      	blx	r4
  403b68:	eddf 7ab8 	vldr	s15, [pc, #736]	; 403e4c <torque_screen_play+0x6d8>
  403b6c:	ee07 0a10 	vmov	s14, r0
  403b70:	4bb7      	ldr	r3, [pc, #732]	; (403e50 <torque_screen_play+0x6dc>)
  403b72:	ee67 7a27 	vmul.f32	s15, s14, s15
  403b76:	ee17 0a90 	vmov	r0, s15
  403b7a:	4798      	blx	r3
  403b7c:	4689      	mov	r9, r1
  403b7e:	4680      	mov	r8, r0
  403b80:	47a0      	blx	r4
  403b82:	ee07 0a90 	vmov	s15, r0
  403b86:	464b      	mov	r3, r9
  403b88:	4642      	mov	r2, r8
  403b8a:	2000      	movs	r0, #0
  403b8c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  403b90:	4cb0      	ldr	r4, [pc, #704]	; (403e54 <torque_screen_play+0x6e0>)
  403b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  403b96:	bfac      	ite	ge
  403b98:	49af      	ldrge	r1, [pc, #700]	; (403e58 <torque_screen_play+0x6e4>)
  403b9a:	49b0      	ldrlt	r1, [pc, #704]	; (403e5c <torque_screen_play+0x6e8>)
  403b9c:	47a0      	blx	r4
  403b9e:	4bb0      	ldr	r3, [pc, #704]	; (403e60 <torque_screen_play+0x6ec>)
  403ba0:	4798      	blx	r3
	char tmp[12] = {0};
  403ba2:	2300      	movs	r3, #0
	if (A < 0) {
  403ba4:	f1b0 0b00 	subs.w	fp, r0, #0
	char tmp[12] = {0};
  403ba8:	9303      	str	r3, [sp, #12]
  403baa:	6073      	str	r3, [r6, #4]
  403bac:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  403bae:	f2c0 8115 	blt.w	403ddc <torque_screen_play+0x668>
	int ndec = 0, slen = 0;
  403bb2:	469a      	mov	sl, r3
	ip = fixedpt_toint(A);
  403bb4:	ea4f 38eb 	mov.w	r8, fp, asr #15
  403bb8:	4637      	mov	r7, r6
	int ndec = 0, slen = 0;
  403bba:	2400      	movs	r4, #0
	ip = fixedpt_toint(A);
  403bbc:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403bc0:	e000      	b.n	403bc4 <torque_screen_play+0x450>
		tmp[ndec++] = '0' + ip % 10;
  403bc2:	461c      	mov	r4, r3
  403bc4:	4640      	mov	r0, r8
  403bc6:	4649      	mov	r1, r9
  403bc8:	220a      	movs	r2, #10
  403bca:	2300      	movs	r3, #0
  403bcc:	47a8      	blx	r5
  403bce:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  403bd2:	4640      	mov	r0, r8
  403bd4:	4649      	mov	r1, r9
  403bd6:	220a      	movs	r2, #10
  403bd8:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  403bda:	f807 eb01 	strb.w	lr, [r7], #1
		ip /= 10;
  403bde:	47a8      	blx	r5
  403be0:	4680      	mov	r8, r0
  403be2:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  403be4:	1c63      	adds	r3, r4, #1
	} while (ip != 0);
  403be6:	ea58 0209 	orrs.w	r2, r8, r9
  403bea:	d1ea      	bne.n	403bc2 <torque_screen_play+0x44e>
  403bec:	f10a 32ff 	add.w	r2, sl, #4294967295
  403bf0:	9901      	ldr	r1, [sp, #4]
  403bf2:	4433      	add	r3, r6
  403bf4:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  403bf6:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  403bfa:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  403bfc:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403c00:	d1f9      	bne.n	403bf6 <torque_screen_play+0x482>
  403c02:	eb04 070a 	add.w	r7, r4, sl
	str[slen++] = '.';
  403c06:	9801      	ldr	r0, [sp, #4]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403c08:	ea4f 4b4b 	mov.w	fp, fp, lsl #17
  403c0c:	f10a 0a01 	add.w	sl, sl, #1
	str[slen++] = '.';
  403c10:	4404      	add	r4, r0
  403c12:	f107 0e01 	add.w	lr, r7, #1
  403c16:	212e      	movs	r1, #46	; 0x2e
  403c18:	3702      	adds	r7, #2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403c1a:	465a      	mov	r2, fp
  403c1c:	4486      	add	lr, r0
	str[slen++] = '.';
  403c1e:	f804 100a 	strb.w	r1, [r4, sl]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403c22:	2400      	movs	r4, #0
  403c24:	e001      	b.n	403c2a <torque_screen_play+0x4b6>
	} while (fr != 0 && ndec < max_dec);
  403c26:	2c03      	cmp	r4, #3
  403c28:	dc12      	bgt.n	403c50 <torque_screen_play+0x4dc>
		fr = (fr & mask) * 10;
  403c2a:	2300      	movs	r3, #0
  403c2c:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403c2e:	3701      	adds	r7, #1
		ndec++;
  403c30:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  403c32:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  403c36:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  403c3a:	1812      	adds	r2, r2, r0
  403c3c:	414b      	adcs	r3, r1
  403c3e:	1892      	adds	r2, r2, r2
  403c40:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403c42:	f103 0130 	add.w	r1, r3, #48	; 0x30
  403c46:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  403c4a:	ea52 0103 	orrs.w	r1, r2, r3
  403c4e:	d1ea      	bne.n	403c26 <torque_screen_play+0x4b2>
	if (ndec > 1 && str[slen-1] == '0')
  403c50:	2c01      	cmp	r4, #1
  403c52:	d005      	beq.n	403c60 <torque_screen_play+0x4ec>
  403c54:	1e7b      	subs	r3, r7, #1
  403c56:	9a01      	ldr	r2, [sp, #4]
  403c58:	5cd2      	ldrb	r2, [r2, r3]
  403c5a:	2a30      	cmp	r2, #48	; 0x30
  403c5c:	f000 80da 	beq.w	403e14 <torque_screen_play+0x6a0>
		str[slen] = '\0';
  403c60:	2300      	movs	r3, #0
  403c62:	9a01      	ldr	r2, [sp, #4]
  403c64:	55d3      	strb	r3, [r2, r7]
  403c66:	2100      	movs	r1, #0
  403c68:	4872      	ldr	r0, [pc, #456]	; (403e34 <torque_screen_play+0x6c0>)
  403c6a:	4b73      	ldr	r3, [pc, #460]	; (403e38 <torque_screen_play+0x6c4>)
  403c6c:	4798      	blx	r3

	glcd_gotoxy(0, 54);
  403c6e:	2136      	movs	r1, #54	; 0x36
  403c70:	2000      	movs	r0, #0
  403c72:	4b72      	ldr	r3, [pc, #456]	; (403e3c <torque_screen_play+0x6c8>)
  403c74:	4798      	blx	r3
	glcd_putsf("PIT ",0);
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_pit()), 4),0);
  403c76:	4c7b      	ldr	r4, [pc, #492]	; (403e64 <torque_screen_play+0x6f0>)
	glcd_putsf("PIT ",0);
  403c78:	2100      	movs	r1, #0
  403c7a:	4b72      	ldr	r3, [pc, #456]	; (403e44 <torque_screen_play+0x6d0>)
  403c7c:	487a      	ldr	r0, [pc, #488]	; (403e68 <torque_screen_play+0x6f4>)
  403c7e:	4798      	blx	r3
	glcd_puts(fixedpt_cstr(fixedpt_rconst(get_pit()), 4),0);
  403c80:	47a0      	blx	r4
  403c82:	eddf 7a72 	vldr	s15, [pc, #456]	; 403e4c <torque_screen_play+0x6d8>
  403c86:	ee07 0a10 	vmov	s14, r0
  403c8a:	4b71      	ldr	r3, [pc, #452]	; (403e50 <torque_screen_play+0x6dc>)
  403c8c:	ee67 7a27 	vmul.f32	s15, s14, s15
  403c90:	ee17 0a90 	vmov	r0, s15
  403c94:	4798      	blx	r3
  403c96:	4689      	mov	r9, r1
  403c98:	4680      	mov	r8, r0
  403c9a:	47a0      	blx	r4
  403c9c:	ee07 0a90 	vmov	s15, r0
  403ca0:	464b      	mov	r3, r9
  403ca2:	4642      	mov	r2, r8
  403ca4:	4c6b      	ldr	r4, [pc, #428]	; (403e54 <torque_screen_play+0x6e0>)
  403ca6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  403caa:	2000      	movs	r0, #0
  403cac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  403cb0:	bfac      	ite	ge
  403cb2:	4969      	ldrge	r1, [pc, #420]	; (403e58 <torque_screen_play+0x6e4>)
  403cb4:	4969      	ldrlt	r1, [pc, #420]	; (403e5c <torque_screen_play+0x6e8>)
  403cb6:	47a0      	blx	r4
  403cb8:	4b69      	ldr	r3, [pc, #420]	; (403e60 <torque_screen_play+0x6ec>)
  403cba:	4798      	blx	r3
	char tmp[12] = {0};
  403cbc:	2300      	movs	r3, #0
	if (A < 0) {
  403cbe:	1e04      	subs	r4, r0, #0
	char tmp[12] = {0};
  403cc0:	9303      	str	r3, [sp, #12]
  403cc2:	6073      	str	r3, [r6, #4]
  403cc4:	60b3      	str	r3, [r6, #8]
	if (A < 0) {
  403cc6:	db68      	blt.n	403d9a <torque_screen_play+0x626>
	int ndec = 0, slen = 0;
  403cc8:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  403cca:	ea4f 38e4 	mov.w	r8, r4, asr #15
  403cce:	46b2      	mov	sl, r6
	int ndec = 0, slen = 0;
  403cd0:	2700      	movs	r7, #0
	ip = fixedpt_toint(A);
  403cd2:	ea4f 79e8 	mov.w	r9, r8, asr #31
  403cd6:	e000      	b.n	403cda <torque_screen_play+0x566>
		tmp[ndec++] = '0' + ip % 10;
  403cd8:	461f      	mov	r7, r3
  403cda:	4640      	mov	r0, r8
  403cdc:	4649      	mov	r1, r9
  403cde:	220a      	movs	r2, #10
  403ce0:	2300      	movs	r3, #0
  403ce2:	47a8      	blx	r5
  403ce4:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  403ce8:	4640      	mov	r0, r8
  403cea:	4649      	mov	r1, r9
  403cec:	220a      	movs	r2, #10
  403cee:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  403cf0:	f80a eb01 	strb.w	lr, [sl], #1
		ip /= 10;
  403cf4:	47a8      	blx	r5
  403cf6:	4680      	mov	r8, r0
  403cf8:	4689      	mov	r9, r1
		tmp[ndec++] = '0' + ip % 10;
  403cfa:	1c7b      	adds	r3, r7, #1
	} while (ip != 0);
  403cfc:	ea58 0209 	orrs.w	r2, r8, r9
  403d00:	d1ea      	bne.n	403cd8 <torque_screen_play+0x564>
  403d02:	f10b 32ff 	add.w	r2, fp, #4294967295
  403d06:	9901      	ldr	r1, [sp, #4]
  403d08:	4433      	add	r3, r6
  403d0a:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  403d0c:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  403d10:	429e      	cmp	r6, r3
		str[slen++] = tmp[--ndec];
  403d12:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  403d16:	d1f9      	bne.n	403d0c <torque_screen_play+0x598>
  403d18:	eb07 000b 	add.w	r0, r7, fp
	str[slen++] = '.';
  403d1c:	9a01      	ldr	r2, [sp, #4]
  403d1e:	f10b 0b01 	add.w	fp, fp, #1
  403d22:	232e      	movs	r3, #46	; 0x2e
  403d24:	1c46      	adds	r6, r0, #1
  403d26:	4417      	add	r7, r2
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403d28:	0464      	lsls	r4, r4, #17
	str[slen++] = '.';
  403d2a:	3002      	adds	r0, #2
  403d2c:	4416      	add	r6, r2
  403d2e:	f807 300b 	strb.w	r3, [r7, fp]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  403d32:	2100      	movs	r1, #0
  403d34:	e001      	b.n	403d3a <torque_screen_play+0x5c6>
	} while (fr != 0 && ndec < max_dec);
  403d36:	2903      	cmp	r1, #3
  403d38:	dc11      	bgt.n	403d5e <torque_screen_play+0x5ea>
		fr = (fr & mask) * 10;
  403d3a:	2500      	movs	r5, #0
  403d3c:	00a2      	lsls	r2, r4, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403d3e:	3001      	adds	r0, #1
		ndec++;
  403d40:	3101      	adds	r1, #1
		fr = (fr & mask) * 10;
  403d42:	00af      	lsls	r7, r5, #2
  403d44:	ea47 7394 	orr.w	r3, r7, r4, lsr #30
  403d48:	18a4      	adds	r4, r4, r2
  403d4a:	415d      	adcs	r5, r3
  403d4c:	1924      	adds	r4, r4, r4
  403d4e:	416d      	adcs	r5, r5
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  403d50:	f105 0330 	add.w	r3, r5, #48	; 0x30
  403d54:	f806 3f01 	strb.w	r3, [r6, #1]!
	} while (fr != 0 && ndec < max_dec);
  403d58:	ea54 0305 	orrs.w	r3, r4, r5
  403d5c:	d1eb      	bne.n	403d36 <torque_screen_play+0x5c2>
	if (ndec > 1 && str[slen-1] == '0')
  403d5e:	2901      	cmp	r1, #1
  403d60:	d004      	beq.n	403d6c <torque_screen_play+0x5f8>
  403d62:	1e43      	subs	r3, r0, #1
  403d64:	9a01      	ldr	r2, [sp, #4]
  403d66:	5cd2      	ldrb	r2, [r2, r3]
  403d68:	2a30      	cmp	r2, #48	; 0x30
  403d6a:	d05f      	beq.n	403e2c <torque_screen_play+0x6b8>
		str[slen] = '\0';
  403d6c:	2300      	movs	r3, #0
  403d6e:	9a01      	ldr	r2, [sp, #4]
  403d70:	5413      	strb	r3, [r2, r0]
  403d72:	4b31      	ldr	r3, [pc, #196]	; (403e38 <torque_screen_play+0x6c4>)
  403d74:	2100      	movs	r1, #0
  403d76:	482f      	ldr	r0, [pc, #188]	; (403e34 <torque_screen_play+0x6c0>)
  403d78:	4798      	blx	r3

	
	if(get_esc_button())
  403d7a:	4b3c      	ldr	r3, [pc, #240]	; (403e6c <torque_screen_play+0x6f8>)
  403d7c:	4798      	blx	r3
  403d7e:	b110      	cbz	r0, 403d86 <torque_screen_play+0x612>
	{
		active_screen = IDF_SCREEN_MAIN;
  403d80:	4b3b      	ldr	r3, [pc, #236]	; (403e70 <torque_screen_play+0x6fc>)
  403d82:	2200      	movs	r2, #0
  403d84:	601a      	str	r2, [r3, #0]
	}
	
	drop_all_buttons();
  403d86:	4b3b      	ldr	r3, [pc, #236]	; (403e74 <torque_screen_play+0x700>)
  403d88:	b007      	add	sp, #28
  403d8a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	drop_all_buttons();
  403d8e:	4718      	bx	r3
	if(tmp_phs < 10) putIt('0');
  403d90:	2030      	movs	r0, #48	; 0x30
  403d92:	47a8      	blx	r5
	if(tmp_phs < 100) putIt('0');
  403d94:	2030      	movs	r0, #48	; 0x30
  403d96:	47a8      	blx	r5
  403d98:	e525      	b.n	4037e6 <torque_screen_play+0x72>
		str[slen++] = '-';
  403d9a:	232d      	movs	r3, #45	; 0x2d
  403d9c:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  403d9e:	4264      	negs	r4, r4
		str[slen++] = '-';
  403da0:	f04f 0b01 	mov.w	fp, #1
  403da4:	7013      	strb	r3, [r2, #0]
  403da6:	e790      	b.n	403cca <torque_screen_play+0x556>
		tmp_theta += 1;
  403da8:	3601      	adds	r6, #1
  403daa:	f147 0700 	adc.w	r7, r7, #0
		if (tmp_theta == 0) putIt('-');
  403dae:	ea56 0307 	orrs.w	r3, r6, r7
  403db2:	d027      	beq.n	403e04 <torque_screen_play+0x690>
  403db4:	4d30      	ldr	r5, [pc, #192]	; (403e78 <torque_screen_play+0x704>)
		tmp_phs = 1000 - tmp_phs;
  403db6:	f5c4 747a 	rsb	r4, r4, #1000	; 0x3e8
  403dba:	e505      	b.n	4037c8 <torque_screen_play+0x54>
  403dbc:	4b1d      	ldr	r3, [pc, #116]	; (403e34 <torque_screen_play+0x6c0>)
		A *= -1;
  403dbe:	4264      	negs	r4, r4
		str[slen++] = '-';
  403dc0:	f04f 0b01 	mov.w	fp, #1
  403dc4:	461a      	mov	r2, r3
  403dc6:	9301      	str	r3, [sp, #4]
  403dc8:	232d      	movs	r3, #45	; 0x2d
  403dca:	7013      	strb	r3, [r2, #0]
  403dcc:	e52a      	b.n	403824 <torque_screen_play+0xb0>
  403dce:	232d      	movs	r3, #45	; 0x2d
  403dd0:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  403dd2:	4264      	negs	r4, r4
		str[slen++] = '-';
  403dd4:	f04f 0b01 	mov.w	fp, #1
  403dd8:	7013      	strb	r3, [r2, #0]
  403dda:	e59b      	b.n	403914 <torque_screen_play+0x1a0>
  403ddc:	232d      	movs	r3, #45	; 0x2d
  403dde:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  403de0:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  403de4:	f04f 0a01 	mov.w	sl, #1
  403de8:	7013      	strb	r3, [r2, #0]
  403dea:	e6e3      	b.n	403bb4 <torque_screen_play+0x440>
  403dec:	232d      	movs	r3, #45	; 0x2d
  403dee:	9a01      	ldr	r2, [sp, #4]
		A *= -1;
  403df0:	f1cb 0b00 	rsb	fp, fp, #0
		str[slen++] = '-';
  403df4:	f04f 0a01 	mov.w	sl, #1
  403df8:	7013      	strb	r3, [r2, #0]
  403dfa:	e61a      	b.n	403a32 <torque_screen_play+0x2be>
	uint32_t tmp_phs = (enc_get_phase() * 1000) / FIXEDPT_ONE;
  403dfc:	f504 44ff 	add.w	r4, r4, #32640	; 0x7f80
  403e00:	347f      	adds	r4, #127	; 0x7f
  403e02:	e4d9      	b.n	4037b8 <torque_screen_play+0x44>
		if (tmp_theta == 0) putIt('-');
  403e04:	4d1c      	ldr	r5, [pc, #112]	; (403e78 <torque_screen_play+0x704>)
  403e06:	202d      	movs	r0, #45	; 0x2d
  403e08:	47a8      	blx	r5
  403e0a:	e7d4      	b.n	403db6 <torque_screen_play+0x642>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  403e0c:	2200      	movs	r2, #0
  403e0e:	9901      	ldr	r1, [sp, #4]
  403e10:	54ca      	strb	r2, [r1, r3]
  403e12:	e563      	b.n	4038dc <torque_screen_play+0x168>
  403e14:	2200      	movs	r2, #0
  403e16:	9901      	ldr	r1, [sp, #4]
  403e18:	54ca      	strb	r2, [r1, r3]
  403e1a:	e724      	b.n	403c66 <torque_screen_play+0x4f2>
  403e1c:	2200      	movs	r2, #0
  403e1e:	9901      	ldr	r1, [sp, #4]
  403e20:	54ca      	strb	r2, [r1, r3]
  403e22:	e5d2      	b.n	4039ca <torque_screen_play+0x256>
  403e24:	2200      	movs	r2, #0
  403e26:	9901      	ldr	r1, [sp, #4]
  403e28:	54ca      	strb	r2, [r1, r3]
  403e2a:	e68f      	b.n	403b4c <torque_screen_play+0x3d8>
  403e2c:	2200      	movs	r2, #0
  403e2e:	9901      	ldr	r1, [sp, #4]
  403e30:	54ca      	strb	r2, [r1, r3]
  403e32:	e79e      	b.n	403d72 <torque_screen_play+0x5fe>
  403e34:	20400854 	.word	0x20400854
  403e38:	0040ca05 	.word	0x0040ca05
  403e3c:	0040c7a5 	.word	0x0040c7a5
  403e40:	0040f739 	.word	0x0040f739
  403e44:	0040c7b9 	.word	0x0040c7b9
  403e48:	00419a78 	.word	0x00419a78
  403e4c:	47000000 	.word	0x47000000
  403e50:	00418749 	.word	0x00418749
  403e54:	0041848d 	.word	0x0041848d
  403e58:	3fe00000 	.word	0x3fe00000
  403e5c:	bfe00000 	.word	0xbfe00000
  403e60:	00418d51 	.word	0x00418d51
  403e64:	0040f745 	.word	0x0040f745
  403e68:	00419a7c 	.word	0x00419a7c
  403e6c:	0040de45 	.word	0x0040de45
  403e70:	2040084c 	.word	0x2040084c
  403e74:	0040ded1 	.word	0x0040ded1
  403e78:	0040c755 	.word	0x0040c755

00403e7c <controller_lcd_manager_handler>:
{
  403e7c:	b510      	push	{r4, lr}
	if (pop_ups_showMessage()) 
  403e7e:	4b12      	ldr	r3, [pc, #72]	; (403ec8 <controller_lcd_manager_handler+0x4c>)
  403e80:	4798      	blx	r3
  403e82:	b950      	cbnz	r0, 403e9a <controller_lcd_manager_handler+0x1e>
	if (active_screen == IDF_SCREEN_MAIN)
  403e84:	4b11      	ldr	r3, [pc, #68]	; (403ecc <controller_lcd_manager_handler+0x50>)
  403e86:	681b      	ldr	r3, [r3, #0]
  403e88:	b15b      	cbz	r3, 403ea2 <controller_lcd_manager_handler+0x26>
	else if (active_screen == IDF_SCREEN_PROGRAMMING)
  403e8a:	2b01      	cmp	r3, #1
  403e8c:	d00f      	beq.n	403eae <controller_lcd_manager_handler+0x32>
	else if (active_screen == IDF_SCREEN_MONITOR)
  403e8e:	2b02      	cmp	r3, #2
  403e90:	d010      	beq.n	403eb4 <controller_lcd_manager_handler+0x38>
	else if (active_screen == IDF_SCREEN_ENCODER)
  403e92:	2b03      	cmp	r3, #3
  403e94:	d011      	beq.n	403eba <controller_lcd_manager_handler+0x3e>
	else if (active_screen == IDF_SCREEN_TORQUE)
  403e96:	2b04      	cmp	r3, #4
  403e98:	d012      	beq.n	403ec0 <controller_lcd_manager_handler+0x44>
		lcd_update();
  403e9a:	4b0d      	ldr	r3, [pc, #52]	; (403ed0 <controller_lcd_manager_handler+0x54>)
}
  403e9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		lcd_update();
  403ea0:	4718      	bx	r3
		main_screen_play();
  403ea2:	4b0c      	ldr	r3, [pc, #48]	; (403ed4 <controller_lcd_manager_handler+0x58>)
  403ea4:	4798      	blx	r3
		lcd_update();
  403ea6:	4b0a      	ldr	r3, [pc, #40]	; (403ed0 <controller_lcd_manager_handler+0x54>)
}
  403ea8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		lcd_update();
  403eac:	4718      	bx	r3
		programming_screen_play();
  403eae:	4b0a      	ldr	r3, [pc, #40]	; (403ed8 <controller_lcd_manager_handler+0x5c>)
  403eb0:	4798      	blx	r3
  403eb2:	e7f2      	b.n	403e9a <controller_lcd_manager_handler+0x1e>
		monitor_screen_play();
  403eb4:	4b09      	ldr	r3, [pc, #36]	; (403edc <controller_lcd_manager_handler+0x60>)
  403eb6:	4798      	blx	r3
  403eb8:	e7ef      	b.n	403e9a <controller_lcd_manager_handler+0x1e>
		encoder_screen_play();
  403eba:	4b09      	ldr	r3, [pc, #36]	; (403ee0 <controller_lcd_manager_handler+0x64>)
  403ebc:	4798      	blx	r3
  403ebe:	e7ec      	b.n	403e9a <controller_lcd_manager_handler+0x1e>
		torque_screen_play();
  403ec0:	4b08      	ldr	r3, [pc, #32]	; (403ee4 <controller_lcd_manager_handler+0x68>)
  403ec2:	4798      	blx	r3
  403ec4:	e7e9      	b.n	403e9a <controller_lcd_manager_handler+0x1e>
  403ec6:	bf00      	nop
  403ec8:	0040c02d 	.word	0x0040c02d
  403ecc:	2040084c 	.word	0x2040084c
  403ed0:	0040c35d 	.word	0x0040c35d
  403ed4:	00401845 	.word	0x00401845
  403ed8:	00402725 	.word	0x00402725
  403edc:	0040279d 	.word	0x0040279d
  403ee0:	00403065 	.word	0x00403065
  403ee4:	00403775 	.word	0x00403775

00403ee8 <elevator_init>:
}

uByte_t heart_beat_flasher_index;
#define  LIFT_INIT_DELAY 4800
void elevator_init(void)
{
  403ee8:	b510      	push	{r4, lr}
// 	dtwi_init();
// 	
 	sch_add_task_ms(&scan_buttons_handler,75 + LIFT_INIT_DELAY,1);
  403eea:	2301      	movs	r3, #1
  403eec:	4c2b      	ldr	r4, [pc, #172]	; (403f9c <elevator_init+0xb4>)
  403eee:	220a      	movs	r2, #10
  403ef0:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403ef4:	482a      	ldr	r0, [pc, #168]	; (403fa0 <elevator_init+0xb8>)
  403ef6:	47a0      	blx	r4
 	sch_add_task_ms(&auto_update, 20 + LIFT_INIT_DELAY, AUTO_STATE_PERIOD_MS);
  403ef8:	2301      	movs	r3, #1
  403efa:	f44f 72c8 	mov.w	r2, #400	; 0x190
  403efe:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403f02:	4828      	ldr	r0, [pc, #160]	; (403fa4 <elevator_init+0xbc>)
  403f04:	47a0      	blx	r4
 	sch_add_task_ms(&controller_lcd_manager_handler,50 + LIFT_INIT_DELAY,160);
  403f06:	2301      	movs	r3, #1
  403f08:	f44f 62c8 	mov.w	r2, #1600	; 0x640
  403f0c:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403f10:	4825      	ldr	r0, [pc, #148]	; (403fa8 <elevator_init+0xc0>)
  403f12:	47a0      	blx	r4
 	sch_add_task_ms(&timer_count_handler,5 + LIFT_INIT_DELAY, TIMER_DELAY_MS);
  403f14:	2301      	movs	r3, #1
  403f16:	2264      	movs	r2, #100	; 0x64
  403f18:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403f1c:	4823      	ldr	r0, [pc, #140]	; (403fac <elevator_init+0xc4>)
  403f1e:	47a0      	blx	r4
	sch_add_task_ms(&req_io_mb_scan_handler,5 + LIFT_INIT_DELAY, 80);
  403f20:	2301      	movs	r3, #1
  403f22:	f44f 7248 	mov.w	r2, #800	; 0x320
  403f26:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403f2a:	4821      	ldr	r0, [pc, #132]	; (403fb0 <elevator_init+0xc8>)
  403f2c:	47a0      	blx	r4
	sch_add_task_ms(&req_scan, 5 + LIFT_INIT_DELAY, 40);
  403f2e:	2301      	movs	r3, #1
  403f30:	f44f 72c8 	mov.w	r2, #400	; 0x190
  403f34:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403f38:	481e      	ldr	r0, [pc, #120]	; (403fb4 <elevator_init+0xcc>)
  403f3a:	47a0      	blx	r4
 	sch_add_task_ms(&dir_limit_startup, (LIFT_INIT_DELAY - 148), 0);
  403f3c:	2301      	movs	r3, #1
  403f3e:	2200      	movs	r2, #0
  403f40:	f24b 51b8 	movw	r1, #46520	; 0xb5b8
  403f44:	481c      	ldr	r0, [pc, #112]	; (403fb8 <elevator_init+0xd0>)
  403f46:	47a0      	blx	r4
	heart_beat_flasher_index = sch_add_task_ms(&ST2_LED,0 + LIFT_INIT_DELAY,1000); //heart beat flash
  403f48:	2301      	movs	r3, #1
  403f4a:	f242 7210 	movw	r2, #10000	; 0x2710
  403f4e:	f64b 3180 	movw	r1, #48000	; 0xbb80
  403f52:	481a      	ldr	r0, [pc, #104]	; (403fbc <elevator_init+0xd4>)
  403f54:	47a0      	blx	r4
  403f56:	491a      	ldr	r1, [pc, #104]	; (403fc0 <elevator_init+0xd8>)
	sch_add_task_ms(&init_menues, (LIFT_INIT_DELAY - 720), 0);
  403f58:	2200      	movs	r2, #0
  403f5a:	2301      	movs	r3, #1
	heart_beat_flasher_index = sch_add_task_ms(&ST2_LED,0 + LIFT_INIT_DELAY,1000); //heart beat flash
  403f5c:	6008      	str	r0, [r1, #0]
	sch_add_task_ms(&init_menues, (LIFT_INIT_DELAY - 720), 0);
  403f5e:	f649 7160 	movw	r1, #40800	; 0x9f60
  403f62:	4818      	ldr	r0, [pc, #96]	; (403fc4 <elevator_init+0xdc>)
  403f64:	47a0      	blx	r4
	idle_camt_init(TIMER_TICK_DELAY_PER_SEC / 2);
  403f66:	2032      	movs	r0, #50	; 0x32
  403f68:	4b17      	ldr	r3, [pc, #92]	; (403fc8 <elevator_init+0xe0>)
  403f6a:	4798      	blx	r3
	//init_requests(LIFT_INIT_DELAY + 1343); 

 	init_elevator_values();
	e_faults_inti();
  403f6c:	4b17      	ldr	r3, [pc, #92]	; (403fcc <elevator_init+0xe4>)
  403f6e:	4798      	blx	r3
	
	init_glcd();
  403f70:	4b17      	ldr	r3, [pc, #92]	; (403fd0 <elevator_init+0xe8>)
  403f72:	4798      	blx	r3
	glcd_clear();
  403f74:	4b17      	ldr	r3, [pc, #92]	; (403fd4 <elevator_init+0xec>)
  403f76:	4798      	blx	r3
 	out_image(20, 0, intro_logo);
  403f78:	4a17      	ldr	r2, [pc, #92]	; (403fd8 <elevator_init+0xf0>)
  403f7a:	2100      	movs	r1, #0
  403f7c:	2014      	movs	r0, #20
  403f7e:	4b17      	ldr	r3, [pc, #92]	; (403fdc <elevator_init+0xf4>)
  403f80:	4798      	blx	r3
	lcd_update();
  403f82:	4b17      	ldr	r3, [pc, #92]	; (403fe0 <elevator_init+0xf8>)
  403f84:	4798      	blx	r3
	
	sch_add_task_ms(&auto_stop_enter, (LIFT_INIT_DELAY - 200), 0);
  403f86:	2301      	movs	r3, #1
  403f88:	2200      	movs	r2, #0
  403f8a:	f24b 31b0 	movw	r1, #46000	; 0xb3b0
  403f8e:	4815      	ldr	r0, [pc, #84]	; (403fe4 <elevator_init+0xfc>)
  403f90:	47a0      	blx	r4
	timers_init();	
  403f92:	4b15      	ldr	r3, [pc, #84]	; (403fe8 <elevator_init+0x100>)
}
  403f94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	timers_init();	
  403f98:	4718      	bx	r3
  403f9a:	bf00      	nop
  403f9c:	00417301 	.word	0x00417301
  403fa0:	0040da79 	.word	0x0040da79
  403fa4:	004096ad 	.word	0x004096ad
  403fa8:	00403e7d 	.word	0x00403e7d
  403fac:	004017d5 	.word	0x004017d5
  403fb0:	0040e18d 	.word	0x0040e18d
  403fb4:	00401129 	.word	0x00401129
  403fb8:	00400f25 	.word	0x00400f25
  403fbc:	00416179 	.word	0x00416179
  403fc0:	20400c74 	.word	0x20400c74
  403fc4:	00404d1d 	.word	0x00404d1d
  403fc8:	004017dd 	.word	0x004017dd
  403fcc:	004009f1 	.word	0x004009f1
  403fd0:	0040d20d 	.word	0x0040d20d
  403fd4:	0040c2e5 	.word	0x0040c2e5
  403fd8:	0041a02c 	.word	0x0041a02c
  403fdc:	0040c4a5 	.word	0x0040c4a5
  403fe0:	0040c35d 	.word	0x0040c35d
  403fe4:	004082b5 	.word	0x004082b5
  403fe8:	00401709 	.word	0x00401709

00403fec <EMCM_get_travel_speed_sign>:
	return DECEL_DISP;
}

int8_t EMCM_get_travel_speed_sign(void)
{
	return speed_sign;
  403fec:	4b01      	ldr	r3, [pc, #4]	; (403ff4 <EMCM_get_travel_speed_sign+0x8>)
}
  403fee:	f993 0000 	ldrsb.w	r0, [r3]
  403ff2:	4770      	bx	lr
  403ff4:	20400018 	.word	0x20400018

00403ff8 <exit_hspd>:

int32_t decel_point = 0, decel_point2 = 0;
uint8_t allowedToExit_hspd = 0, allowedToExit_lspd = 0, dir_lmt0_posDev_corrected = 0, correct_at_stop = 0, stop_after_correction = 0;
uint32_t exit_hspd(void)
{
	return allowedToExit_hspd;
  403ff8:	4b01      	ldr	r3, [pc, #4]	; (404000 <exit_hspd+0x8>)
}
  403ffa:	7818      	ldrb	r0, [r3, #0]
  403ffc:	4770      	bx	lr
  403ffe:	bf00      	nop
  404000:	2040086d 	.word	0x2040086d

00404004 <change_dest_floor>:
{
	return allowedToExit_lspd;
}
int8_t temp_vfd_const = 1;
void change_dest_floor(void)
{
  404004:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
	int32_t temp_dest_floor = get_scheduled_floor();
  404008:	4b2f      	ldr	r3, [pc, #188]	; (4040c8 <change_dest_floor+0xc4>)
  40400a:	4798      	blx	r3
	if (temp_dest_floor < 0 ) return;
  40400c:	1e04      	subs	r4, r0, #0
  40400e:	db05      	blt.n	40401c <change_dest_floor+0x18>
	if ((allowedToExit_hspd) || (allowedToExit_lspd)) return;
  404010:	4b2e      	ldr	r3, [pc, #184]	; (4040cc <change_dest_floor+0xc8>)
  404012:	781b      	ldrb	r3, [r3, #0]
  404014:	b913      	cbnz	r3, 40401c <change_dest_floor+0x18>
  404016:	4b2e      	ldr	r3, [pc, #184]	; (4040d0 <change_dest_floor+0xcc>)
  404018:	781b      	ldrb	r3, [r3, #0]
  40401a:	b10b      	cbz	r3, 404020 <change_dest_floor+0x1c>
  40401c:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
	if (vfd_is_constant_speed())
  404020:	4b2c      	ldr	r3, [pc, #176]	; (4040d4 <change_dest_floor+0xd0>)
  404022:	4798      	blx	r3
  404024:	2800      	cmp	r0, #0
  404026:	d040      	beq.n	4040aa <change_dest_floor+0xa6>
	{
		temp_vfd_const = 1;
		if (temp_dest_floor != dest_floor)
  404028:	4d2b      	ldr	r5, [pc, #172]	; (4040d8 <change_dest_floor+0xd4>)
		temp_vfd_const = 1;
  40402a:	2201      	movs	r2, #1
  40402c:	4b2b      	ldr	r3, [pc, #172]	; (4040dc <change_dest_floor+0xd8>)
		if (temp_dest_floor != dest_floor)
  40402e:	6828      	ldr	r0, [r5, #0]
		temp_vfd_const = 1;
  404030:	701a      	strb	r2, [r3, #0]
		if (temp_dest_floor != dest_floor)
  404032:	4284      	cmp	r4, r0
  404034:	d0f2      	beq.n	40401c <change_dest_floor+0x18>
		{
			//destination floor has changed
			if(fixedpt_abs(hoistinfo_getfloor_pos(dest_floor) - enc_get_theta()) /*available_displacement*/ > (fixedpt_abs(decel_displacement) + hoist_info.enc_count_per_meter/2))
  404036:	4e2a      	ldr	r6, [pc, #168]	; (4040e0 <change_dest_floor+0xdc>)
  404038:	47b0      	blx	r6
  40403a:	4680      	mov	r8, r0
  40403c:	4f29      	ldr	r7, [pc, #164]	; (4040e4 <change_dest_floor+0xe0>)
  40403e:	47b8      	blx	r7
  404040:	ebb8 0200 	subs.w	r2, r8, r0
  404044:	ea4f 79e8 	mov.w	r9, r8, asr #31
  404048:	eb69 0301 	sbc.w	r3, r9, r1
  40404c:	2a00      	cmp	r2, #0
  40404e:	f173 0300 	sbcs.w	r3, r3, #0
  404052:	db2d      	blt.n	4040b0 <change_dest_floor+0xac>
  404054:	6828      	ldr	r0, [r5, #0]
  404056:	47b0      	blx	r6
  404058:	4680      	mov	r8, r0
  40405a:	47b8      	blx	r7
  40405c:	ea4f 79e8 	mov.w	r9, r8, asr #31
  404060:	ebb8 0800 	subs.w	r8, r8, r0
  404064:	eb69 0901 	sbc.w	r9, r9, r1
  404068:	46c3      	mov	fp, r8
  40406a:	46cc      	mov	ip, r9
  40406c:	4a1e      	ldr	r2, [pc, #120]	; (4040e8 <change_dest_floor+0xe4>)
  40406e:	4f1f      	ldr	r7, [pc, #124]	; (4040ec <change_dest_floor+0xe8>)
  404070:	f8d2 319c 	ldr.w	r3, [r2, #412]	; 0x19c
  404074:	683a      	ldr	r2, [r7, #0]
  404076:	2a00      	cmp	r2, #0
  404078:	bfb8      	it	lt
  40407a:	4252      	neglt	r2, r2
  40407c:	eb02 0253 	add.w	r2, r2, r3, lsr #1
  404080:	2300      	movs	r3, #0
  404082:	455a      	cmp	r2, fp
  404084:	eb73 030c 	sbcs.w	r3, r3, ip
  404088:	dac8      	bge.n	40401c <change_dest_floor+0x18>
			{
				//there is a room for inserting new floor level
				dest_floor = temp_dest_floor;
				decel_point = hoistinfo_getfloor_pos(dest_floor) - decel_displacement;
  40408a:	4620      	mov	r0, r4
				dest_floor = temp_dest_floor;
  40408c:	602c      	str	r4, [r5, #0]
				decel_point = hoistinfo_getfloor_pos(dest_floor) - decel_displacement;
  40408e:	47b0      	blx	r6
  404090:	683b      	ldr	r3, [r7, #0]
  404092:	4a17      	ldr	r2, [pc, #92]	; (4040f0 <change_dest_floor+0xec>)
  404094:	1ac3      	subs	r3, r0, r3
				decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  404096:	6828      	ldr	r0, [r5, #0]
				decel_point = hoistinfo_getfloor_pos(dest_floor) - decel_displacement;
  404098:	6013      	str	r3, [r2, #0]
				decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  40409a:	47b0      	blx	r6
  40409c:	4b15      	ldr	r3, [pc, #84]	; (4040f4 <change_dest_floor+0xf0>)
  40409e:	4a16      	ldr	r2, [pc, #88]	; (4040f8 <change_dest_floor+0xf4>)
  4040a0:	681b      	ldr	r3, [r3, #0]
  4040a2:	1ac0      	subs	r0, r0, r3
  4040a4:	6010      	str	r0, [r2, #0]
  4040a6:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
			}
		}	
	}
	else temp_vfd_const = 0;
  4040aa:	4b0c      	ldr	r3, [pc, #48]	; (4040dc <change_dest_floor+0xd8>)
  4040ac:	7018      	strb	r0, [r3, #0]
  4040ae:	e7b5      	b.n	40401c <change_dest_floor+0x18>
			if(fixedpt_abs(hoistinfo_getfloor_pos(dest_floor) - enc_get_theta()) /*available_displacement*/ > (fixedpt_abs(decel_displacement) + hoist_info.enc_count_per_meter/2))
  4040b0:	47b8      	blx	r7
  4040b2:	4680      	mov	r8, r0
  4040b4:	6828      	ldr	r0, [r5, #0]
  4040b6:	4689      	mov	r9, r1
  4040b8:	47b0      	blx	r6
  4040ba:	ebb8 0200 	subs.w	r2, r8, r0
  4040be:	eb69 73e0 	sbc.w	r3, r9, r0, asr #31
  4040c2:	4693      	mov	fp, r2
  4040c4:	469c      	mov	ip, r3
  4040c6:	e7d1      	b.n	40406c <change_dest_floor+0x68>
  4040c8:	00401625 	.word	0x00401625
  4040cc:	2040086d 	.word	0x2040086d
  4040d0:	2040086e 	.word	0x2040086e
  4040d4:	004169ad 	.word	0x004169ad
  4040d8:	20400884 	.word	0x20400884
  4040dc:	20400019 	.word	0x20400019
  4040e0:	00404645 	.word	0x00404645
  4040e4:	00413aed 	.word	0x00413aed
  4040e8:	20400c80 	.word	0x20400c80
  4040ec:	20400874 	.word	0x20400874
  4040f0:	2040087c 	.word	0x2040087c
  4040f4:	20400878 	.word	0x20400878
  4040f8:	20400880 	.word	0x20400880

004040fc <set_Stop_afterCorrection>:
}

void set_Stop_afterCorrection(void)
{
	stop_after_correction = 1;
  4040fc:	4b01      	ldr	r3, [pc, #4]	; (404104 <set_Stop_afterCorrection+0x8>)
  4040fe:	2201      	movs	r2, #1
  404100:	701a      	strb	r2, [r3, #0]
  404102:	4770      	bx	lr
  404104:	20400890 	.word	0x20400890

00404108 <set_correct_atStop>:
}

void set_correct_atStop(void)
{
	correct_at_stop = 1;
  404108:	4b01      	ldr	r3, [pc, #4]	; (404110 <set_correct_atStop+0x8>)
  40410a:	2201      	movs	r2, #1
  40410c:	701a      	strb	r2, [r3, #0]
  40410e:	4770      	bx	lr
  404110:	2040086f 	.word	0x2040086f

00404114 <set_Hspeed_profile>:
}

uint32_t set_Hspeed_profile(void)
{
  404114:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	distance_regulator_disable();
  404118:	4b2d      	ldr	r3, [pc, #180]	; (4041d0 <set_Hspeed_profile+0xbc>)
{
  40411a:	b083      	sub	sp, #12
	distance_regulator_disable();
  40411c:	4798      	blx	r3
	dest_floor = get_scheduled_floor();
  40411e:	4b2d      	ldr	r3, [pc, #180]	; (4041d4 <set_Hspeed_profile+0xc0>)
  404120:	4798      	blx	r3
	fixedpt ref_speed;
	
	if (hoist_info.Lrn)
  404122:	4a2d      	ldr	r2, [pc, #180]	; (4041d8 <set_Hspeed_profile+0xc4>)
	dest_floor = get_scheduled_floor();
  404124:	4e2d      	ldr	r6, [pc, #180]	; (4041dc <set_Hspeed_profile+0xc8>)
	if (hoist_info.Lrn)
  404126:	7815      	ldrb	r5, [r2, #0]
	dest_floor = get_scheduled_floor();
  404128:	6030      	str	r0, [r6, #0]
	if (hoist_info.Lrn)
  40412a:	2d00      	cmp	r5, #0
  40412c:	d13e      	bne.n	4041ac <set_Hspeed_profile+0x98>
	{
		LRN_req_err_set;
		drop_all_req();
		return 0;
	}
	if(dest_floor >= 0)
  40412e:	2800      	cmp	r0, #0
  404130:	db38      	blt.n	4041a4 <set_Hspeed_profile+0x90>
	{
		//vfd_set_ref_speed(speed_sign * HIGH_SPEED);
		decel_displacement = vfd_get_Max_possible_speed(hoistinfo_getfloor_pos(dest_floor) - enc_pos, &ref_speed, &decel_displacement2);
  404132:	4f2b      	ldr	r7, [pc, #172]	; (4041e0 <set_Hspeed_profile+0xcc>)
  404134:	47b8      	blx	r7
  404136:	4b2b      	ldr	r3, [pc, #172]	; (4041e4 <set_Hspeed_profile+0xd0>)
  404138:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 40421c <set_Hspeed_profile+0x108>
  40413c:	aa01      	add	r2, sp, #4
  40413e:	6819      	ldr	r1, [r3, #0]
  404140:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 404220 <set_Hspeed_profile+0x10c>
  404144:	4643      	mov	r3, r8
  404146:	1a40      	subs	r0, r0, r1
  404148:	4c27      	ldr	r4, [pc, #156]	; (4041e8 <set_Hspeed_profile+0xd4>)
  40414a:	17c1      	asrs	r1, r0, #31
  40414c:	47a0      	blx	r4
  40414e:	4604      	mov	r4, r0
  404150:	f8c9 0000 	str.w	r0, [r9]
		if(decel_displacement == 0) 
  404154:	2800      	cmp	r0, #0
  404156:	d033      	beq.n	4041c0 <set_Hspeed_profile+0xac>
		{
			drop_req(dest_floor);
			return 0;
		}
		
		decel_point = hoistinfo_getfloor_pos(dest_floor) - decel_displacement;
  404158:	6830      	ldr	r0, [r6, #0]
  40415a:	47b8      	blx	r7
  40415c:	f8d9 3000 	ldr.w	r3, [r9]
  404160:	4a22      	ldr	r2, [pc, #136]	; (4041ec <set_Hspeed_profile+0xd8>)
  404162:	1ac3      	subs	r3, r0, r3
		decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  404164:	6830      	ldr	r0, [r6, #0]
  404166:	4e22      	ldr	r6, [pc, #136]	; (4041f0 <set_Hspeed_profile+0xdc>)
		decel_point = hoistinfo_getfloor_pos(dest_floor) - decel_displacement;
  404168:	6013      	str	r3, [r2, #0]
		decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  40416a:	47b8      	blx	r7
		speed_sign = sign(ref_speed);
  40416c:	9a01      	ldr	r2, [sp, #4]
		decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  40416e:	f8d8 3000 	ldr.w	r3, [r8]
		speed_sign = sign(ref_speed);
  404172:	2a00      	cmp	r2, #0
  404174:	491f      	ldr	r1, [pc, #124]	; (4041f4 <set_Hspeed_profile+0xe0>)
		decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  404176:	eba0 0303 	sub.w	r3, r0, r3
		
		vfd_set_accel_profile(ref_speed);
  40417a:	4610      	mov	r0, r2
		speed_sign = sign(ref_speed);
  40417c:	bfb4      	ite	lt
  40417e:	f04f 34ff 	movlt.w	r4, #4294967295
  404182:	2401      	movge	r4, #1
		vfd_set_accel_profile(ref_speed);
  404184:	4a1c      	ldr	r2, [pc, #112]	; (4041f8 <set_Hspeed_profile+0xe4>)
		decel_point2 = hoistinfo_getfloor_pos(dest_floor) - decel_displacement2;
  404186:	6033      	str	r3, [r6, #0]
		speed_sign = sign(ref_speed);
  404188:	700c      	strb	r4, [r1, #0]
		vfd_set_accel_profile(ref_speed);
  40418a:	4790      	blx	r2
		allowedToExit_hspd = 0;
  40418c:	4c1b      	ldr	r4, [pc, #108]	; (4041fc <set_Hspeed_profile+0xe8>)
	{
		//no destination floor
		return 0;
	}
	allowedToExit_hspd = 0;
	return 1;
  40418e:	2001      	movs	r0, #1
		allowedToExit_lspd = 0;
  404190:	491b      	ldr	r1, [pc, #108]	; (404200 <set_Hspeed_profile+0xec>)
		dir_lmt0_posDev_corrected = 0;
  404192:	4a1c      	ldr	r2, [pc, #112]	; (404204 <set_Hspeed_profile+0xf0>)
		correct_at_stop = 0;
  404194:	4b1c      	ldr	r3, [pc, #112]	; (404208 <set_Hspeed_profile+0xf4>)
		allowedToExit_hspd = 0;
  404196:	7025      	strb	r5, [r4, #0]
		allowedToExit_lspd = 0;
  404198:	700d      	strb	r5, [r1, #0]
		dir_lmt0_posDev_corrected = 0;
  40419a:	7015      	strb	r5, [r2, #0]
		correct_at_stop = 0;
  40419c:	701d      	strb	r5, [r3, #0]
	
}
  40419e:	b003      	add	sp, #12
  4041a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return 0;
  4041a4:	4628      	mov	r0, r5
}
  4041a6:	b003      	add	sp, #12
  4041a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LRN_req_err_set;
  4041ac:	4a17      	ldr	r2, [pc, #92]	; (40420c <set_Hspeed_profile+0xf8>)
  4041ae:	4b18      	ldr	r3, [pc, #96]	; (404210 <set_Hspeed_profile+0xfc>)
  4041b0:	7810      	ldrb	r0, [r2, #0]
  4041b2:	4798      	blx	r3
		drop_all_req();
  4041b4:	4b17      	ldr	r3, [pc, #92]	; (404214 <set_Hspeed_profile+0x100>)
  4041b6:	4798      	blx	r3
		return 0;
  4041b8:	2000      	movs	r0, #0
}
  4041ba:	b003      	add	sp, #12
  4041bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			drop_req(dest_floor);
  4041c0:	7830      	ldrb	r0, [r6, #0]
  4041c2:	4b15      	ldr	r3, [pc, #84]	; (404218 <set_Hspeed_profile+0x104>)
  4041c4:	4798      	blx	r3
			return 0;
  4041c6:	4620      	mov	r0, r4
}
  4041c8:	b003      	add	sp, #12
  4041ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4041ce:	bf00      	nop
  4041d0:	0040f0e1 	.word	0x0040f0e1
  4041d4:	00401625 	.word	0x00401625
  4041d8:	20400c80 	.word	0x20400c80
  4041dc:	20400884 	.word	0x20400884
  4041e0:	00404645 	.word	0x00404645
  4041e4:	20400c78 	.word	0x20400c78
  4041e8:	00417015 	.word	0x00417015
  4041ec:	2040087c 	.word	0x2040087c
  4041f0:	20400880 	.word	0x20400880
  4041f4:	20400018 	.word	0x20400018
  4041f8:	00416f65 	.word	0x00416f65
  4041fc:	2040086d 	.word	0x2040086d
  404200:	2040086e 	.word	0x2040086e
  404204:	20400888 	.word	0x20400888
  404208:	2040086f 	.word	0x2040086f
  40420c:	20400c4f 	.word	0x20400c4f
  404210:	0041282d 	.word	0x0041282d
  404214:	00401079 	.word	0x00401079
  404218:	00401095 	.word	0x00401095
  40421c:	20400878 	.word	0x20400878
  404220:	20400874 	.word	0x20400874

00404224 <decelToStop>:
		}
	}
}

void decelToStop(void)
{
  404224:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if(!allowedToExit_hspd)
  404228:	4c41      	ldr	r4, [pc, #260]	; (404330 <decelToStop+0x10c>)
  40422a:	7823      	ldrb	r3, [r4, #0]
  40422c:	b96b      	cbnz	r3, 40424a <decelToStop+0x26>
	{
		if (speed_sign < 0)
  40422e:	4d41      	ldr	r5, [pc, #260]	; (404334 <decelToStop+0x110>)
  404230:	f995 3000 	ldrsb.w	r3, [r5]
  404234:	2b00      	cmp	r3, #0
  404236:	db36      	blt.n	4042a6 <decelToStop+0x82>
				
				vfd_set_ref_speed(speed_sign * CREEP_SPEED);
				allowedToExit_hspd = 1;
			}
		}
		else if (speed_sign > 0)
  404238:	d005      	beq.n	404246 <decelToStop+0x22>
		{
			//positive speed
			if (enc_pos >= decel_point)
  40423a:	4a3f      	ldr	r2, [pc, #252]	; (404338 <decelToStop+0x114>)
  40423c:	4b3f      	ldr	r3, [pc, #252]	; (40433c <decelToStop+0x118>)
  40423e:	6812      	ldr	r2, [r2, #0]
  404240:	681b      	ldr	r3, [r3, #0]
  404242:	429a      	cmp	r2, r3
  404244:	da35      	bge.n	4042b2 <decelToStop+0x8e>
  404246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				allowedToExit_hspd = 1;
			}
		}
		
	}
	else if(!allowedToExit_lspd)
  40424a:	4c3d      	ldr	r4, [pc, #244]	; (404340 <decelToStop+0x11c>)
  40424c:	7823      	ldrb	r3, [r4, #0]
  40424e:	2b00      	cmp	r3, #0
  404250:	d1f9      	bne.n	404246 <decelToStop+0x22>
	{
		if (speed_sign < 0)
  404252:	4b38      	ldr	r3, [pc, #224]	; (404334 <decelToStop+0x110>)
  404254:	f993 3000 	ldrsb.w	r3, [r3]
  404258:	2b00      	cmp	r3, #0
  40425a:	db62      	blt.n	404322 <decelToStop+0xfe>
				vfd_set_ref_speed(0);
				allowedToExit_lspd = 1;
				distance_regulator_enable();
			}
		}
		else if (speed_sign > 0)
  40425c:	d0f3      	beq.n	404246 <decelToStop+0x22>
		{
			//positive speed
			if (enc_pos >= decel_point2)
  40425e:	4a36      	ldr	r2, [pc, #216]	; (404338 <decelToStop+0x114>)
  404260:	4b38      	ldr	r3, [pc, #224]	; (404344 <decelToStop+0x120>)
  404262:	6812      	ldr	r2, [r2, #0]
  404264:	681b      	ldr	r3, [r3, #0]
  404266:	429a      	cmp	r2, r3
  404268:	dbed      	blt.n	404246 <decelToStop+0x22>
				vfd_set_motion_acc(menue_lift_data_applied.m_dec);
  40426a:	4e37      	ldr	r6, [pc, #220]	; (404348 <decelToStop+0x124>)
  40426c:	4b37      	ldr	r3, [pc, #220]	; (40434c <decelToStop+0x128>)
  40426e:	6cb0      	ldr	r0, [r6, #72]	; 0x48
  404270:	4798      	blx	r3
				vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  404272:	4d37      	ldr	r5, [pc, #220]	; (404350 <decelToStop+0x12c>)
  404274:	6db3      	ldr	r3, [r6, #88]	; 0x58
  404276:	4a37      	ldr	r2, [pc, #220]	; (404354 <decelToStop+0x130>)
  404278:	fb85 1003 	smull	r1, r0, r5, r3
  40427c:	17db      	asrs	r3, r3, #31
  40427e:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  404282:	4790      	blx	r2
				vfd_set_motion_j2(menue_lift_data_applied.m_corner3/100);
  404284:	6e33      	ldr	r3, [r6, #96]	; 0x60
  404286:	4a34      	ldr	r2, [pc, #208]	; (404358 <decelToStop+0x134>)
  404288:	fb85 1003 	smull	r1, r0, r5, r3
  40428c:	17db      	asrs	r3, r3, #31
  40428e:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  404292:	4790      	blx	r2
				vfd_set_ref_speed(0);
  404294:	4b31      	ldr	r3, [pc, #196]	; (40435c <decelToStop+0x138>)
  404296:	2000      	movs	r0, #0
  404298:	4798      	blx	r3
				allowedToExit_lspd = 1;
  40429a:	2201      	movs	r2, #1
				distance_regulator_enable();
  40429c:	4b30      	ldr	r3, [pc, #192]	; (404360 <decelToStop+0x13c>)
				allowedToExit_lspd = 1;
  40429e:	7022      	strb	r2, [r4, #0]
				allowedToExit_lspd = 1;
				distance_regulator_enable();
			}
		}
	}
}
  4042a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				distance_regulator_enable();
  4042a4:	4718      	bx	r3
			if (enc_pos <= decel_point)
  4042a6:	4a24      	ldr	r2, [pc, #144]	; (404338 <decelToStop+0x114>)
  4042a8:	4b24      	ldr	r3, [pc, #144]	; (40433c <decelToStop+0x118>)
  4042aa:	6812      	ldr	r2, [r2, #0]
  4042ac:	681b      	ldr	r3, [r3, #0]
  4042ae:	429a      	cmp	r2, r3
  4042b0:	dcc9      	bgt.n	404246 <decelToStop+0x22>
				vfd_set_motion_acc(menue_lift_data_applied.m_dec);
  4042b2:	4f25      	ldr	r7, [pc, #148]	; (404348 <decelToStop+0x124>)
  4042b4:	4b25      	ldr	r3, [pc, #148]	; (40434c <decelToStop+0x128>)
  4042b6:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  4042b8:	4798      	blx	r3
				vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  4042ba:	f8df 8094 	ldr.w	r8, [pc, #148]	; 404350 <decelToStop+0x12c>
  4042be:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  4042c0:	4a24      	ldr	r2, [pc, #144]	; (404354 <decelToStop+0x130>)
  4042c2:	fb88 1003 	smull	r1, r0, r8, r3
  4042c6:	17db      	asrs	r3, r3, #31
  4042c8:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  4042cc:	4790      	blx	r2
				vfd_set_motion_j2(menue_lift_data_applied.m_corner2/100);
  4042ce:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  4042d0:	4a21      	ldr	r2, [pc, #132]	; (404358 <decelToStop+0x134>)
  4042d2:	fb88 1003 	smull	r1, r0, r8, r3
  4042d6:	17db      	asrs	r3, r3, #31
  4042d8:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  4042dc:	4790      	blx	r2
				vfd_set_ref_speed(speed_sign * CREEP_SPEED);
  4042de:	4a21      	ldr	r2, [pc, #132]	; (404364 <decelToStop+0x140>)
  4042e0:	4b21      	ldr	r3, [pc, #132]	; (404368 <decelToStop+0x144>)
  4042e2:	f892 603c 	ldrb.w	r6, [r2, #60]	; 0x3c
  4042e6:	68d1      	ldr	r1, [r2, #12]
  4042e8:	f995 0000 	ldrsb.w	r0, [r5]
  4042ec:	fb01 f106 	mul.w	r1, r1, r6
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4042f0:	6b3f      	ldr	r7, [r7, #48]	; 0x30
  4042f2:	4a1a      	ldr	r2, [pc, #104]	; (40435c <decelToStop+0x138>)
  4042f4:	fb83 5301 	smull	r5, r3, r3, r1
  4042f8:	17ce      	asrs	r6, r1, #31
  4042fa:	440b      	add	r3, r1
  4042fc:	ebc6 1663 	rsb	r6, r6, r3, asr #5
  404300:	fb86 6707 	smull	r6, r7, r6, r7
  404304:	0bf3      	lsrs	r3, r6, #15
  404306:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  40430a:	fb88 1803 	smull	r1, r8, r8, r3
  40430e:	17db      	asrs	r3, r3, #31
  404310:	ebc3 1368 	rsb	r3, r3, r8, asr #5
  404314:	fb00 f003 	mul.w	r0, r0, r3
  404318:	4790      	blx	r2
				allowedToExit_hspd = 1;
  40431a:	2301      	movs	r3, #1
  40431c:	7023      	strb	r3, [r4, #0]
  40431e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (enc_pos <= decel_point2)
  404322:	4a05      	ldr	r2, [pc, #20]	; (404338 <decelToStop+0x114>)
  404324:	4b07      	ldr	r3, [pc, #28]	; (404344 <decelToStop+0x120>)
  404326:	6812      	ldr	r2, [r2, #0]
  404328:	681b      	ldr	r3, [r3, #0]
  40432a:	429a      	cmp	r2, r3
  40432c:	dc8b      	bgt.n	404246 <decelToStop+0x22>
  40432e:	e79c      	b.n	40426a <decelToStop+0x46>
  404330:	2040086d 	.word	0x2040086d
  404334:	20400018 	.word	0x20400018
  404338:	20400c78 	.word	0x20400c78
  40433c:	2040087c 	.word	0x2040087c
  404340:	2040086e 	.word	0x2040086e
  404344:	20400880 	.word	0x20400880
  404348:	204052b4 	.word	0x204052b4
  40434c:	00416f41 	.word	0x00416f41
  404350:	51eb851f 	.word	0x51eb851f
  404354:	00416f4d 	.word	0x00416f4d
  404358:	00416f59 	.word	0x00416f59
  40435c:	00416f8d 	.word	0x00416f8d
  404360:	0040f0a5 	.word	0x0040f0a5
  404364:	20404ff0 	.word	0x20404ff0
  404368:	88888889 	.word	0x88888889

0040436c <virsual_selector_conrol>:

uint8_t current_floor = 0;
void virsual_selector_conrol(void)
{
  40436c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int32_t floor_middle;
	int32_t upSgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  404370:	4d6e      	ldr	r5, [pc, #440]	; (40452c <virsual_selector_conrol+0x1c0>)
	
	
	if (selfLearn_isLearning()) return; //don't rely on enocder counts during self learning
  404372:	4a6f      	ldr	r2, [pc, #444]	; (404530 <virsual_selector_conrol+0x1c4>)
	int32_t upSgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  404374:	6eab      	ldr	r3, [r5, #104]	; 0x68
  404376:	6e69      	ldr	r1, [r5, #100]	; 0x64
  404378:	1a5b      	subs	r3, r3, r1
  40437a:	2b00      	cmp	r3, #0
  40437c:	bfac      	ite	ge
  40437e:	2401      	movge	r4, #1
  404380:	f04f 34ff 	movlt.w	r4, #4294967295
	if (selfLearn_isLearning()) return; //don't rely on enocder counts during self learning
  404384:	4790      	blx	r2
  404386:	bb98      	cbnz	r0, 4043f0 <virsual_selector_conrol+0x84>
	
	//search for the floor
	if (current_floor > MAX_F_NUM) current_floor = MAX_F_NUM;
  404388:	4e6a      	ldr	r6, [pc, #424]	; (404534 <virsual_selector_conrol+0x1c8>)
  40438a:	7830      	ldrb	r0, [r6, #0]
  40438c:	2817      	cmp	r0, #23
  40438e:	d82a      	bhi.n	4043e6 <virsual_selector_conrol+0x7a>
  404390:	4603      	mov	r3, r0
	
	if (upSgn < 0)
	{
		//encoder decrement in up direction
		if (enc_pos <= hoist_info.level_position[current_floor])
  404392:	eb05 0283 	add.w	r2, r5, r3, lsl #2
  404396:	4968      	ldr	r1, [pc, #416]	; (404538 <virsual_selector_conrol+0x1cc>)
	if (upSgn < 0)
  404398:	3401      	adds	r4, #1
		if (enc_pos <= hoist_info.level_position[current_floor])
  40439a:	f8d2 e064 	ldr.w	lr, [r2, #100]	; 0x64
  40439e:	6809      	ldr	r1, [r1, #0]
	if (upSgn < 0)
  4043a0:	d04c      	beq.n	40443c <virsual_selector_conrol+0xd0>
		}
	} 
	else
	{
		//encoder increment in up direction
		if (enc_pos >= hoist_info.level_position[current_floor])
  4043a2:	458e      	cmp	lr, r1
  4043a4:	dd26      	ble.n	4043f4 <virsual_selector_conrol+0x88>
			}
		}
		else
		{
			// elevator moved down
			while (current_floor > 0)
  4043a6:	b1b8      	cbz	r0, 4043d8 <virsual_selector_conrol+0x6c>
			{
				if (enc_pos < hoist_info.level_position[current_floor - 1])
  4043a8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  4043ac:	6e1c      	ldr	r4, [r3, #96]	; 0x60
  4043ae:	42a1      	cmp	r1, r4
  4043b0:	da65      	bge.n	40447e <virsual_selector_conrol+0x112>
  4043b2:	3801      	subs	r0, #1
  4043b4:	f8df e18c 	ldr.w	lr, [pc, #396]	; 404544 <virsual_selector_conrol+0x1d8>
  4043b8:	b2c3      	uxtb	r3, r0
  4043ba:	eb05 0283 	add.w	r2, r5, r3, lsl #2
  4043be:	3264      	adds	r2, #100	; 0x64
  4043c0:	e003      	b.n	4043ca <virsual_selector_conrol+0x5e>
  4043c2:	f852 4d04 	ldr.w	r4, [r2, #-4]!
  4043c6:	42a1      	cmp	r1, r4
  4043c8:	da54      	bge.n	404474 <virsual_selector_conrol+0x108>
			while (current_floor > 0)
  4043ca:	4572      	cmp	r2, lr
				{
					// go to the upper next floor
					current_floor--;
  4043cc:	b2d8      	uxtb	r0, r3
				if (enc_pos < hoist_info.level_position[current_floor - 1])
  4043ce:	461f      	mov	r7, r3
  4043d0:	f103 33ff 	add.w	r3, r3, #4294967295
			while (current_floor > 0)
  4043d4:	d1f5      	bne.n	4043c2 <virsual_selector_conrol+0x56>
				}
			}
		}
	}
	
	if (current_floor > f_max) current_floor = f_max;
  4043d6:	7030      	strb	r0, [r6, #0]
	sel_set(current_floor<<1);
  4043d8:	0040      	lsls	r0, r0, #1
  4043da:	4b58      	ldr	r3, [pc, #352]	; (40453c <virsual_selector_conrol+0x1d0>)
  4043dc:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
}
  4043e0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	sel_set(current_floor<<1);
  4043e4:	4718      	bx	r3
	if (current_floor > MAX_F_NUM) current_floor = MAX_F_NUM;
  4043e6:	2217      	movs	r2, #23
  4043e8:	4613      	mov	r3, r2
  4043ea:	7032      	strb	r2, [r6, #0]
  4043ec:	4610      	mov	r0, r2
  4043ee:	e7d0      	b.n	404392 <virsual_selector_conrol+0x26>
  4043f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			while (current_floor < MAX_F_NUM)
  4043f4:	2817      	cmp	r0, #23
  4043f6:	f000 8093 	beq.w	404520 <virsual_selector_conrol+0x1b4>
				if (enc_pos > hoist_info.level_position[current_floor + 1])
  4043fa:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  4043fe:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  404400:	4291      	cmp	r1, r2
  404402:	f340 808f 	ble.w	404524 <virsual_selector_conrol+0x1b8>
  404406:	1c43      	adds	r3, r0, #1
  404408:	f1c0 0016 	rsb	r0, r0, #22
  40440c:	b2db      	uxtb	r3, r3
  40440e:	eb05 0483 	add.w	r4, r5, r3, lsl #2
  404412:	fa53 f080 	uxtab	r0, r3, r0
  404416:	3464      	adds	r4, #100	; 0x64
  404418:	e003      	b.n	404422 <virsual_selector_conrol+0xb6>
  40441a:	f854 2f04 	ldr.w	r2, [r4, #4]!
  40441e:	4291      	cmp	r1, r2
  404420:	dd45      	ble.n	4044ae <virsual_selector_conrol+0x142>
			while (current_floor < MAX_F_NUM)
  404422:	4283      	cmp	r3, r0
					current_floor++;
  404424:	b2df      	uxtb	r7, r3
				if (enc_pos > hoist_info.level_position[current_floor + 1])
  404426:	469e      	mov	lr, r3
  404428:	f103 0301 	add.w	r3, r3, #1
			while (current_floor < MAX_F_NUM)
  40442c:	d1f5      	bne.n	40441a <virsual_selector_conrol+0xae>
					if (enc_pos < floor_middle) current_floor--;
  40442e:	7037      	strb	r7, [r6, #0]
	if (current_floor > f_max) current_floor = f_max;
  404430:	4b43      	ldr	r3, [pc, #268]	; (404540 <virsual_selector_conrol+0x1d4>)
  404432:	7a98      	ldrb	r0, [r3, #10]
  404434:	42b8      	cmp	r0, r7
  404436:	d3ce      	bcc.n	4043d6 <virsual_selector_conrol+0x6a>
  404438:	4638      	mov	r0, r7
  40443a:	e7cd      	b.n	4043d8 <virsual_selector_conrol+0x6c>
		if (enc_pos <= hoist_info.level_position[current_floor])
  40443c:	458e      	cmp	lr, r1
  40443e:	da46      	bge.n	4044ce <virsual_selector_conrol+0x162>
			while (current_floor > 0)
  404440:	2800      	cmp	r0, #0
  404442:	d0c9      	beq.n	4043d8 <virsual_selector_conrol+0x6c>
				if (enc_pos > hoist_info.level_position[current_floor - 1])
  404444:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  404448:	6e1c      	ldr	r4, [r3, #96]	; 0x60
  40444a:	42a1      	cmp	r1, r4
  40444c:	dd60      	ble.n	404510 <virsual_selector_conrol+0x1a4>
  40444e:	3801      	subs	r0, #1
  404450:	f8df e0f0 	ldr.w	lr, [pc, #240]	; 404544 <virsual_selector_conrol+0x1d8>
  404454:	b2c3      	uxtb	r3, r0
  404456:	eb05 0283 	add.w	r2, r5, r3, lsl #2
  40445a:	3264      	adds	r2, #100	; 0x64
  40445c:	e003      	b.n	404466 <virsual_selector_conrol+0xfa>
  40445e:	f852 4d04 	ldr.w	r4, [r2, #-4]!
  404462:	42a1      	cmp	r1, r4
  404464:	dd4f      	ble.n	404506 <virsual_selector_conrol+0x19a>
			while (current_floor > 0)
  404466:	4572      	cmp	r2, lr
					current_floor--;
  404468:	b2d8      	uxtb	r0, r3
				if (enc_pos > hoist_info.level_position[current_floor - 1])
  40446a:	461f      	mov	r7, r3
  40446c:	f103 33ff 	add.w	r3, r3, #4294967295
			while (current_floor > 0)
  404470:	d1f5      	bne.n	40445e <virsual_selector_conrol+0xf2>
  404472:	e7b0      	b.n	4043d6 <virsual_selector_conrol+0x6a>
  404474:	eb05 0587 	add.w	r5, r5, r7, lsl #2
  404478:	7030      	strb	r0, [r6, #0]
  40447a:	f8d5 e064 	ldr.w	lr, [r5, #100]	; 0x64
					floor_middle = 	(hoist_info.level_position[current_floor] +
  40447e:	eb1e 0404 	adds.w	r4, lr, r4
  404482:	bf48      	it	mi
  404484:	3401      	addmi	r4, #1
					if (enc_pos < floor_middle) current_floor--;
  404486:	ebb1 0f64 	cmp.w	r1, r4, asr #1
  40448a:	da0e      	bge.n	4044aa <virsual_selector_conrol+0x13e>
  40448c:	3801      	subs	r0, #1
  40448e:	b2c7      	uxtb	r7, r0
  404490:	e7cd      	b.n	40442e <virsual_selector_conrol+0xc2>
  404492:	eb05 058e 	add.w	r5, r5, lr, lsl #2
  404496:	7037      	strb	r7, [r6, #0]
  404498:	f8d5 e064 	ldr.w	lr, [r5, #100]	; 0x64
					floor_middle = 	(hoist_info.level_position[current_floor] +
  40449c:	eb12 020e 	adds.w	r2, r2, lr
  4044a0:	bf48      	it	mi
  4044a2:	3201      	addmi	r2, #1
					if (enc_pos < floor_middle) current_floor++;
  4044a4:	ebb1 0f62 	cmp.w	r1, r2, asr #1
  4044a8:	db0d      	blt.n	4044c6 <virsual_selector_conrol+0x15a>
  4044aa:	7837      	ldrb	r7, [r6, #0]
  4044ac:	e7c0      	b.n	404430 <virsual_selector_conrol+0xc4>
  4044ae:	eb05 058e 	add.w	r5, r5, lr, lsl #2
  4044b2:	7037      	strb	r7, [r6, #0]
  4044b4:	f8d5 e064 	ldr.w	lr, [r5, #100]	; 0x64
					floor_middle = 	(hoist_info.level_position[current_floor] +
  4044b8:	eb1e 0202 	adds.w	r2, lr, r2
  4044bc:	bf48      	it	mi
  4044be:	3201      	addmi	r2, #1
					if (enc_pos > floor_middle) current_floor++;
  4044c0:	ebb1 0f62 	cmp.w	r1, r2, asr #1
  4044c4:	ddf1      	ble.n	4044aa <virsual_selector_conrol+0x13e>
  4044c6:	3701      	adds	r7, #1
  4044c8:	b2ff      	uxtb	r7, r7
  4044ca:	7037      	strb	r7, [r6, #0]
  4044cc:	e7b0      	b.n	404430 <virsual_selector_conrol+0xc4>
			while (current_floor < MAX_F_NUM)
  4044ce:	2817      	cmp	r0, #23
  4044d0:	d026      	beq.n	404520 <virsual_selector_conrol+0x1b4>
				if (enc_pos < hoist_info.level_position[current_floor + 1])
  4044d2:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  4044d6:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  4044d8:	4291      	cmp	r1, r2
  4044da:	da25      	bge.n	404528 <virsual_selector_conrol+0x1bc>
  4044dc:	1c43      	adds	r3, r0, #1
  4044de:	f1c0 0016 	rsb	r0, r0, #22
  4044e2:	b2db      	uxtb	r3, r3
  4044e4:	eb05 0483 	add.w	r4, r5, r3, lsl #2
  4044e8:	fa53 f080 	uxtab	r0, r3, r0
  4044ec:	3464      	adds	r4, #100	; 0x64
  4044ee:	e003      	b.n	4044f8 <virsual_selector_conrol+0x18c>
  4044f0:	f854 2f04 	ldr.w	r2, [r4, #4]!
  4044f4:	4291      	cmp	r1, r2
  4044f6:	dacc      	bge.n	404492 <virsual_selector_conrol+0x126>
			while (current_floor < MAX_F_NUM)
  4044f8:	4283      	cmp	r3, r0
					current_floor++;
  4044fa:	b2df      	uxtb	r7, r3
				if (enc_pos < hoist_info.level_position[current_floor + 1])
  4044fc:	469e      	mov	lr, r3
  4044fe:	f103 0301 	add.w	r3, r3, #1
			while (current_floor < MAX_F_NUM)
  404502:	d1f5      	bne.n	4044f0 <virsual_selector_conrol+0x184>
  404504:	e793      	b.n	40442e <virsual_selector_conrol+0xc2>
  404506:	eb05 0587 	add.w	r5, r5, r7, lsl #2
  40450a:	7030      	strb	r0, [r6, #0]
  40450c:	f8d5 e064 	ldr.w	lr, [r5, #100]	; 0x64
					floor_middle = 	(hoist_info.level_position[current_floor] +
  404510:	eb14 040e 	adds.w	r4, r4, lr
  404514:	bf48      	it	mi
  404516:	3401      	addmi	r4, #1
					if (enc_pos > floor_middle) current_floor--;
  404518:	ebb1 0f64 	cmp.w	r1, r4, asr #1
  40451c:	dcb6      	bgt.n	40448c <virsual_selector_conrol+0x120>
  40451e:	e7c4      	b.n	4044aa <virsual_selector_conrol+0x13e>
			while (current_floor < MAX_F_NUM)
  404520:	4607      	mov	r7, r0
  404522:	e785      	b.n	404430 <virsual_selector_conrol+0xc4>
				if (enc_pos > hoist_info.level_position[current_floor + 1])
  404524:	4607      	mov	r7, r0
  404526:	e7c7      	b.n	4044b8 <virsual_selector_conrol+0x14c>
				if (enc_pos < hoist_info.level_position[current_floor + 1])
  404528:	4607      	mov	r7, r0
  40452a:	e7b7      	b.n	40449c <virsual_selector_conrol+0x130>
  40452c:	20400c80 	.word	0x20400c80
  404530:	00404705 	.word	0x00404705
  404534:	20400870 	.word	0x20400870
  404538:	20400c78 	.word	0x20400c78
  40453c:	00400e31 	.word	0x00400e31
  404540:	204052b4 	.word	0x204052b4
  404544:	20400ce4 	.word	0x20400ce4

00404548 <EMCM_handler>:


void EMCM_handler(void)
{
	if (DIRECT_STOP)
  404548:	4b05      	ldr	r3, [pc, #20]	; (404560 <EMCM_handler+0x18>)
  40454a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  40454e:	b903      	cbnz	r3, 404552 <EMCM_handler+0xa>
  404550:	4770      	bx	lr
{
  404552:	b510      	push	{r4, lr}
	{
		//direct stop mode
		//EMCM_decel_point_watch();
		virsual_selector_conrol();
  404554:	4b03      	ldr	r3, [pc, #12]	; (404564 <EMCM_handler+0x1c>)
  404556:	4798      	blx	r3
		change_dest_floor();
  404558:	4b03      	ldr	r3, [pc, #12]	; (404568 <EMCM_handler+0x20>)
	}
}
  40455a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		change_dest_floor();
  40455e:	4718      	bx	r3
  404560:	204052b4 	.word	0x204052b4
  404564:	0040436d 	.word	0x0040436d
  404568:	00404005 	.word	0x00404005

0040456c <EMCM_get_floorErr>:

int32_t EMCM_get_floorErr(void)
{
	//return allowedToExit_lspd;
	//return decel_point2;
	return enc_pos - hoistinfo_getfloor_pos(get_current_floor());
  40456c:	4a04      	ldr	r2, [pc, #16]	; (404580 <EMCM_get_floorErr+0x14>)
  40456e:	4b05      	ldr	r3, [pc, #20]	; (404584 <EMCM_get_floorErr+0x18>)
{
  404570:	b510      	push	{r4, lr}
	return enc_pos - hoistinfo_getfloor_pos(get_current_floor());
  404572:	6814      	ldr	r4, [r2, #0]
  404574:	4798      	blx	r3
  404576:	4b04      	ldr	r3, [pc, #16]	; (404588 <EMCM_get_floorErr+0x1c>)
  404578:	4798      	blx	r3
}
  40457a:	1a20      	subs	r0, r4, r0
  40457c:	bd10      	pop	{r4, pc}
  40457e:	bf00      	nop
  404580:	20400c78 	.word	0x20400c78
  404584:	00400e15 	.word	0x00400e15
  404588:	00404645 	.word	0x00404645

0040458c <EMCM_decel_point_watch>:

void EMCM_decel_point_watch(void)
{
	self_learn_handler();
  40458c:	4b0c      	ldr	r3, [pc, #48]	; (4045c0 <EMCM_decel_point_watch+0x34>)
{
  40458e:	b570      	push	{r4, r5, r6, lr}
	self_learn_handler();
  404590:	4798      	blx	r3
	if (DIRECT_STOP)
  404592:	4b0c      	ldr	r3, [pc, #48]	; (4045c4 <EMCM_decel_point_watch+0x38>)
  404594:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  404598:	b903      	cbnz	r3, 40459c <EMCM_decel_point_watch+0x10>
  40459a:	bd70      	pop	{r4, r5, r6, pc}
	{
		//direct stop mode
		enc_pos = enc_get_theta();
  40459c:	4b0a      	ldr	r3, [pc, #40]	; (4045c8 <EMCM_decel_point_watch+0x3c>)
  40459e:	4798      	blx	r3
		enc_flashing = enc_pos - prev_enc_val;
  4045a0:	4a0a      	ldr	r2, [pc, #40]	; (4045cc <EMCM_decel_point_watch+0x40>)
		enc_pos = enc_get_theta();
  4045a2:	4d0b      	ldr	r5, [pc, #44]	; (4045d0 <EMCM_decel_point_watch+0x44>)
		enc_flashing = enc_pos - prev_enc_val;
  4045a4:	6813      	ldr	r3, [r2, #0]
  4045a6:	4c0b      	ldr	r4, [pc, #44]	; (4045d4 <EMCM_decel_point_watch+0x48>)
  4045a8:	1ac3      	subs	r3, r0, r3
		prev_enc_val = enc_pos;
		decelToStop();
  4045aa:	490b      	ldr	r1, [pc, #44]	; (4045d8 <EMCM_decel_point_watch+0x4c>)
		enc_pos = enc_get_theta();
  4045ac:	6028      	str	r0, [r5, #0]
		enc_flashing = enc_pos - prev_enc_val;
  4045ae:	6023      	str	r3, [r4, #0]
		prev_enc_val = enc_pos;
  4045b0:	6010      	str	r0, [r2, #0]
		decelToStop();
  4045b2:	4788      	blx	r1
		if(auto_instate(auto_lspd))
  4045b4:	2002      	movs	r0, #2
  4045b6:	4b09      	ldr	r3, [pc, #36]	; (4045dc <EMCM_decel_point_watch+0x50>)
				auto_set_mstp_met();
				mstp_met();
			}
		}
	}
  4045b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if(auto_instate(auto_lspd))
  4045bc:	4718      	bx	r3
  4045be:	bf00      	nop
  4045c0:	00404a09 	.word	0x00404a09
  4045c4:	204052b4 	.word	0x204052b4
  4045c8:	00413aed 	.word	0x00413aed
  4045cc:	2040088c 	.word	0x2040088c
  4045d0:	20400c78 	.word	0x20400c78
  4045d4:	20400c7c 	.word	0x20400c7c
  4045d8:	00404225 	.word	0x00404225
  4045dc:	004081c5 	.word	0x004081c5

004045e0 <Hoist_init>:

hoist_info_t hoist_info;

#define FLOOR_ENC_COUNT (32563)
void Hoist_init(void)
{
  4045e0:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t i;
	hoist_info.Lrn = 1;
  4045e2:	2200      	movs	r2, #0
  4045e4:	4e13      	ldr	r6, [pc, #76]	; (404634 <Hoist_init+0x54>)
  4045e6:	2701      	movs	r7, #1
  4045e8:	4d13      	ldr	r5, [pc, #76]	; (404638 <Hoist_init+0x58>)
  4045ea:	4633      	mov	r3, r6
  4045ec:	f506 7190 	add.w	r1, r6, #288	; 0x120
  4045f0:	f106 04c0 	add.w	r4, r6, #192	; 0xc0
	for (i=0; i<MAX_POSSIBLE_FLOOR_COUNT; i++)
	{
		hoist_info.level_position[i] = -1 * (i-0) * FLOOR_ENC_COUNT;
		hoist_info.level_position_correction[i] = 0;
  4045f4:	4610      	mov	r0, r2
	hoist_info.Lrn = 1;
  4045f6:	f803 7b60 	strb.w	r7, [r3], #96
		hoist_info.level_position[i] = -1 * (i-0) * FLOOR_ENC_COUNT;
  4045fa:	f843 2f04 	str.w	r2, [r3, #4]!
	for (i=0; i<MAX_POSSIBLE_FLOOR_COUNT; i++)
  4045fe:	42a3      	cmp	r3, r4
  404600:	442a      	add	r2, r5
		hoist_info.level_position_correction[i] = 0;
  404602:	f841 0f04 	str.w	r0, [r1, #4]!
	for (i=0; i<MAX_POSSIBLE_FLOOR_COUNT; i++)
  404606:	d1f8      	bne.n	4045fa <Hoist_init+0x1a>
	}
	hoist_info.dirDnlimit0 = -FLOOR_ENC_COUNT/3;
  404608:	4c0c      	ldr	r4, [pc, #48]	; (40463c <Hoist_init+0x5c>)
	hoist_info.dirUplimit0 = (-7 * FLOOR_ENC_COUNT) + FLOOR_ENC_COUNT/3;
	hoist_info.dirup0_decel = fixedpt_rconst(1);
  40460a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
	hoist_info.dirUplimit0 = (-7 * FLOOR_ENC_COUNT) + FLOOR_ENC_COUNT/3;
  40460e:	480c      	ldr	r0, [pc, #48]	; (404640 <Hoist_init+0x60>)
	hoist_info.dirdwn0_decel = fixedpt_rconst(1);
	hoist_info.forced_decel_error_trig = 2170; //enc count
  404610:	f640 017a 	movw	r1, #2170	; 0x87a
	hoist_info.mstp_plate_length = 1085; //enc_count
  404614:	f240 423d 	movw	r2, #1085	; 0x43d
	hoist_info.dirDnlimit0 = -FLOOR_ENC_COUNT/3;
  404618:	f8c6 4188 	str.w	r4, [r6, #392]	; 0x188
	hoist_info.dirUplimit0 = (-7 * FLOOR_ENC_COUNT) + FLOOR_ENC_COUNT/3;
  40461c:	f8c6 0184 	str.w	r0, [r6, #388]	; 0x184
	hoist_info.dirup0_decel = fixedpt_rconst(1);
  404620:	f8c6 318c 	str.w	r3, [r6, #396]	; 0x18c
	hoist_info.dirdwn0_decel = fixedpt_rconst(1);
  404624:	f8c6 3190 	str.w	r3, [r6, #400]	; 0x190
	hoist_info.forced_decel_error_trig = 2170; //enc count
  404628:	f8c6 1194 	str.w	r1, [r6, #404]	; 0x194
	hoist_info.mstp_plate_length = 1085; //enc_count
  40462c:	f8c6 2198 	str.w	r2, [r6, #408]	; 0x198
	//enc_set_theta(hoist_info.level_position[5]);
	//enc_set_theta(hoist_info.dirUplimit0);
}
  404630:	bcf0      	pop	{r4, r5, r6, r7}
  404632:	4770      	bx	lr
  404634:	20400c80 	.word	0x20400c80
  404638:	ffff80cd 	.word	0xffff80cd
  40463c:	ffffd59a 	.word	0xffffd59a
  404640:	fffcb001 	.word	0xfffcb001

00404644 <hoistinfo_getfloor_pos>:

int32_t hoistinfo_getfloor_pos(uint32_t floor)
{
  404644:	2817      	cmp	r0, #23
  404646:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404648:	bf28      	it	cs
  40464a:	2017      	movcs	r0, #23
	int32_t up_sgn;
	/*volatile*/ int64_t tmp;
	if (floor > MAX_F_NUM) floor = MAX_F_NUM;
	
	up_sgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  40464c:	4c11      	ldr	r4, [pc, #68]	; (404694 <hoistinfo_getfloor_pos+0x50>)
	//tmp = fixedpt_toint(hoist_info.level_position_correction[floor]) ;
	tmp = hoist_info.enc_count_per_meter;
	tmp *= up_sgn * (fixedpt_toint(hoist_info.level_position_correction[floor]));
	tmp /= 1000;
  40464e:	4e12      	ldr	r6, [pc, #72]	; (404698 <hoistinfo_getfloor_pos+0x54>)
  404650:	4605      	mov	r5, r0
	up_sgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  404652:	6e62      	ldr	r2, [r4, #100]	; 0x64
  404654:	6ea0      	ldr	r0, [r4, #104]	; 0x68
	tmp *= up_sgn * (fixedpt_toint(hoist_info.level_position_correction[floor]));
  404656:	eb04 0185 	add.w	r1, r4, r5, lsl #2
	tmp = hoist_info.enc_count_per_meter;
  40465a:	f8d4 719c 	ldr.w	r7, [r4, #412]	; 0x19c
	up_sgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  40465e:	1a82      	subs	r2, r0, r2
	tmp *= up_sgn * (fixedpt_toint(hoist_info.level_position_correction[floor]));
  404660:	f8d1 3124 	ldr.w	r3, [r1, #292]	; 0x124
	up_sgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  404664:	2a00      	cmp	r2, #0
	tmp /= 1000;
  404666:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	tmp *= up_sgn * (fixedpt_toint(hoist_info.level_position_correction[floor]));
  40466a:	ea4f 33e3 	mov.w	r3, r3, asr #15
	up_sgn = sign(hoist_info.level_position[1] - hoist_info.level_position[0]);
  40466e:	bfb4      	ite	lt
  404670:	f04f 30ff 	movlt.w	r0, #4294967295
  404674:	2001      	movge	r0, #1
	tmp *= up_sgn * (fixedpt_toint(hoist_info.level_position_correction[floor]));
  404676:	fb00 f003 	mul.w	r0, r0, r3
  40467a:	17c3      	asrs	r3, r0, #31
  40467c:	fba0 0107 	umull	r0, r1, r0, r7
  404680:	fb07 1103 	mla	r1, r7, r3, r1
	tmp /= 1000;
  404684:	2300      	movs	r3, #0
  404686:	47b0      	blx	r6
	tmp += hoist_info.level_position[floor];
  404688:	eb04 0385 	add.w	r3, r4, r5, lsl #2
  40468c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
	return tmp;
	
  40468e:	4418      	add	r0, r3
  404690:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404692:	bf00      	nop
  404694:	20400c80 	.word	0x20400c80
  404698:	0041905d 	.word	0x0041905d

0040469c <enter_Hlearn>:
	
	return 1;
}

uint32_t enter_Hlearn(int32_t up_dir)
{
  40469c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if(HW_LRN == 0)
  40469e:	4c0f      	ldr	r4, [pc, #60]	; (4046dc <enter_Hlearn+0x40>)
  4046a0:	7823      	ldrb	r3, [r4, #0]
  4046a2:	b103      	cbz	r3, 4046a6 <enter_Hlearn+0xa>
	{
		hw_learning = 0;
		return 0;
	}
	if (up_dir == 0)
  4046a4:	b920      	cbnz	r0, 4046b0 <enter_Hlearn+0x14>
		hw_learning = 0;
  4046a6:	4b0e      	ldr	r3, [pc, #56]	; (4046e0 <enter_Hlearn+0x44>)
  4046a8:	2200      	movs	r2, #0
	enc_set_theta(0);
	sel_set(0);
	lrn_stage = 0;
	lrn_active = 1;
	return 1;
}
  4046aa:	2000      	movs	r0, #0
		hw_learning = 0;
  4046ac:	701a      	strb	r2, [r3, #0]
}
  4046ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	prev_mstp = 0;
  4046b0:	2500      	movs	r5, #0
  4046b2:	4b0c      	ldr	r3, [pc, #48]	; (4046e4 <enter_Hlearn+0x48>)
		LRN_err_set;
  4046b4:	480c      	ldr	r0, [pc, #48]	; (4046e8 <enter_Hlearn+0x4c>)
	prev_upfdl0 = 1;
  4046b6:	2101      	movs	r1, #1
  4046b8:	4a0c      	ldr	r2, [pc, #48]	; (4046ec <enter_Hlearn+0x50>)
	prev_dnfdl0 = 0;
  4046ba:	4f0d      	ldr	r7, [pc, #52]	; (4046f0 <enter_Hlearn+0x54>)
	lrn_floor_counter = 0;
  4046bc:	4e0d      	ldr	r6, [pc, #52]	; (4046f4 <enter_Hlearn+0x58>)
	prev_mstp = 0;
  4046be:	701d      	strb	r5, [r3, #0]
		LRN_err_set;
  4046c0:	7800      	ldrb	r0, [r0, #0]
  4046c2:	4b0d      	ldr	r3, [pc, #52]	; (4046f8 <enter_Hlearn+0x5c>)
	prev_upfdl0 = 1;
  4046c4:	7011      	strb	r1, [r2, #0]
	prev_dnfdl0 = 0;
  4046c6:	703d      	strb	r5, [r7, #0]
	lrn_floor_counter = 0;
  4046c8:	7035      	strb	r5, [r6, #0]
		LRN_err_set;
  4046ca:	4798      	blx	r3
		pop_ups_add("Learn failed", 800);
  4046cc:	f44f 7148 	mov.w	r1, #800	; 0x320
  4046d0:	480a      	ldr	r0, [pc, #40]	; (4046fc <enter_Hlearn+0x60>)
  4046d2:	4b0b      	ldr	r3, [pc, #44]	; (404700 <enter_Hlearn+0x64>)
  4046d4:	4798      	blx	r3
		HW_LRN = 0;
  4046d6:	7025      	strb	r5, [r4, #0]
}
  4046d8:	2000      	movs	r0, #0
  4046da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4046dc:	204008eb 	.word	0x204008eb
  4046e0:	20400891 	.word	0x20400891
  4046e4:	20400e27 	.word	0x20400e27
  4046e8:	20400c4e 	.word	0x20400c4e
  4046ec:	20400e25 	.word	0x20400e25
  4046f0:	20400e24 	.word	0x20400e24
  4046f4:	20400893 	.word	0x20400893
  4046f8:	0041282d 	.word	0x0041282d
  4046fc:	00419a84 	.word	0x00419a84
  404700:	0040c065 	.word	0x0040c065

00404704 <selfLearn_isLearning>:

uint32_t selfLearn_isLearning(void)
{
	if ((HW_LRN) && (hw_learning)) return 1;
  404704:	4b04      	ldr	r3, [pc, #16]	; (404718 <selfLearn_isLearning+0x14>)
  404706:	7818      	ldrb	r0, [r3, #0]
  404708:	b120      	cbz	r0, 404714 <selfLearn_isLearning+0x10>
  40470a:	4b04      	ldr	r3, [pc, #16]	; (40471c <selfLearn_isLearning+0x18>)
  40470c:	7818      	ldrb	r0, [r3, #0]
  40470e:	3000      	adds	r0, #0
  404710:	bf18      	it	ne
  404712:	2001      	movne	r0, #1
	return 0;
}
  404714:	4770      	bx	lr
  404716:	bf00      	nop
  404718:	204008eb 	.word	0x204008eb
  40471c:	20400891 	.word	0x20400891

00404720 <selfLearn_terminateLearning>:

void selfLearn_terminateLearning(void)
{
  404720:	b510      	push	{r4, lr}
	if (hw_learning == 1)
  404722:	4c0b      	ldr	r4, [pc, #44]	; (404750 <selfLearn_terminateLearning+0x30>)
  404724:	7823      	ldrb	r3, [r4, #0]
  404726:	2b01      	cmp	r3, #1
  404728:	d002      	beq.n	404730 <selfLearn_terminateLearning+0x10>
		//todo lrn error
		LRN_err_set;
		pop_ups_add("Learn failed", 800);
		HW_LRN = 0;
	}
	hw_learning = 0;
  40472a:	2300      	movs	r3, #0
  40472c:	7023      	strb	r3, [r4, #0]
  40472e:	bd10      	pop	{r4, pc}
		LRN_err_set;
  404730:	4a08      	ldr	r2, [pc, #32]	; (404754 <selfLearn_terminateLearning+0x34>)
  404732:	4b09      	ldr	r3, [pc, #36]	; (404758 <selfLearn_terminateLearning+0x38>)
  404734:	7810      	ldrb	r0, [r2, #0]
  404736:	4798      	blx	r3
		pop_ups_add("Learn failed", 800);
  404738:	4b08      	ldr	r3, [pc, #32]	; (40475c <selfLearn_terminateLearning+0x3c>)
  40473a:	f44f 7148 	mov.w	r1, #800	; 0x320
  40473e:	4808      	ldr	r0, [pc, #32]	; (404760 <selfLearn_terminateLearning+0x40>)
  404740:	4798      	blx	r3
		HW_LRN = 0;
  404742:	4b08      	ldr	r3, [pc, #32]	; (404764 <selfLearn_terminateLearning+0x44>)
  404744:	2200      	movs	r2, #0
  404746:	701a      	strb	r2, [r3, #0]
	hw_learning = 0;
  404748:	2300      	movs	r3, #0
  40474a:	7023      	strb	r3, [r4, #0]
  40474c:	bd10      	pop	{r4, pc}
  40474e:	bf00      	nop
  404750:	20400891 	.word	0x20400891
  404754:	20400c4e 	.word	0x20400c4e
  404758:	0041282d 	.word	0x0041282d
  40475c:	0040c065 	.word	0x0040c065
  404760:	00419a84 	.word	0x00419a84
  404764:	204008eb 	.word	0x204008eb

00404768 <selfLearn_stage0_exe>:
}

uint32_t selfLearn_stage0_exe()
{
  404768:	b570      	push	{r4, r5, r6, lr}
	if (mstop == 1)
	{
		if (prev_mstp == 0)
  40476a:	4c14      	ldr	r4, [pc, #80]	; (4047bc <selfLearn_stage0_exe+0x54>)
  40476c:	7823      	ldrb	r3, [r4, #0]
  40476e:	b14b      	cbz	r3, 404784 <selfLearn_stage0_exe+0x1c>
		if (mstop == 0) 
		{
			LRN_err_set;
			pop_ups_add("Learn failed", 800);
		}
		if (prev_dnfdl0 == 0)
  404770:	4d13      	ldr	r5, [pc, #76]	; (4047c0 <selfLearn_stage0_exe+0x58>)
		prev_mstp = mstop;
  404772:	2001      	movs	r0, #1
		if (prev_dnfdl0 == 0)
  404774:	782b      	ldrb	r3, [r5, #0]
		prev_mstp = mstop;
  404776:	7020      	strb	r0, [r4, #0]
		if (prev_dnfdl0 == 0)
  404778:	b183      	cbz	r3, 40479c <selfLearn_stage0_exe+0x34>
  40477a:	4603      	mov	r3, r0
		{
			hoist_info.dirDnlimit0 = enc_get_theta();
		}
		prev_dnfdl0 = dnfdl0;
  40477c:	2201      	movs	r2, #1
		LRN_err_set;
		pop_ups_add("Learn failed", 800);
	}
	if ((prev_mstp == 1) && (prev_dnfdl0 == 1)) return 1;
	return 0;
}
  40477e:	4618      	mov	r0, r3
		prev_dnfdl0 = dnfdl0;
  404780:	702a      	strb	r2, [r5, #0]
}
  404782:	bd70      	pop	{r4, r5, r6, pc}
			hoist_info.level_position_up[0] = enc_get_theta();
  404784:	4d0f      	ldr	r5, [pc, #60]	; (4047c4 <selfLearn_stage0_exe+0x5c>)
  404786:	4e10      	ldr	r6, [pc, #64]	; (4047c8 <selfLearn_stage0_exe+0x60>)
  404788:	47b0      	blx	r6
  40478a:	6068      	str	r0, [r5, #4]
			hoist_info.level_position[0] = enc_get_theta();
  40478c:	47b0      	blx	r6
  40478e:	6668      	str	r0, [r5, #100]	; 0x64
		if (prev_dnfdl0 == 0)
  404790:	4d0b      	ldr	r5, [pc, #44]	; (4047c0 <selfLearn_stage0_exe+0x58>)
		prev_mstp = mstop;
  404792:	2001      	movs	r0, #1
		if (prev_dnfdl0 == 0)
  404794:	782b      	ldrb	r3, [r5, #0]
		prev_mstp = mstop;
  404796:	7020      	strb	r0, [r4, #0]
		if (prev_dnfdl0 == 0)
  404798:	2b00      	cmp	r3, #0
  40479a:	d1ee      	bne.n	40477a <selfLearn_stage0_exe+0x12>
			hoist_info.dirDnlimit0 = enc_get_theta();
  40479c:	4b0a      	ldr	r3, [pc, #40]	; (4047c8 <selfLearn_stage0_exe+0x60>)
  40479e:	4798      	blx	r3
  4047a0:	7823      	ldrb	r3, [r4, #0]
  4047a2:	4a08      	ldr	r2, [pc, #32]	; (4047c4 <selfLearn_stage0_exe+0x5c>)
  4047a4:	f1a3 0301 	sub.w	r3, r3, #1
  4047a8:	f8c2 0188 	str.w	r0, [r2, #392]	; 0x188
		prev_dnfdl0 = dnfdl0;
  4047ac:	2201      	movs	r2, #1
  4047ae:	fab3 f383 	clz	r3, r3
  4047b2:	702a      	strb	r2, [r5, #0]
  4047b4:	095b      	lsrs	r3, r3, #5
}
  4047b6:	4618      	mov	r0, r3
  4047b8:	bd70      	pop	{r4, r5, r6, pc}
  4047ba:	bf00      	nop
  4047bc:	20400e27 	.word	0x20400e27
  4047c0:	20400e24 	.word	0x20400e24
  4047c4:	20400c80 	.word	0x20400c80
  4047c8:	00413aed 	.word	0x00413aed

004047cc <selfLearn_stage1_exe>:

uint32_t selfLearn_stage1_exe()
{
	if ((f_max < 2) || (((f_max - lrn_floor_counter) == 1) && (prev_mstp == 1))) return 1;
  4047cc:	4b1e      	ldr	r3, [pc, #120]	; (404848 <selfLearn_stage1_exe+0x7c>)
  4047ce:	7a9b      	ldrb	r3, [r3, #10]
  4047d0:	2b01      	cmp	r3, #1
  4047d2:	d932      	bls.n	40483a <selfLearn_stage1_exe+0x6e>
{
  4047d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((f_max < 2) || (((f_max - lrn_floor_counter) == 1) && (prev_mstp == 1))) return 1;
  4047d8:	4e1c      	ldr	r6, [pc, #112]	; (40484c <selfLearn_stage1_exe+0x80>)
  4047da:	4c1d      	ldr	r4, [pc, #116]	; (404850 <selfLearn_stage1_exe+0x84>)
  4047dc:	7835      	ldrb	r5, [r6, #0]
  4047de:	7820      	ldrb	r0, [r4, #0]
  4047e0:	1b5b      	subs	r3, r3, r5
  4047e2:	2b01      	cmp	r3, #1
  4047e4:	d005      	beq.n	4047f2 <selfLearn_stage1_exe+0x26>
		}
		prev_mstp = mstop;
	}
	else if (mstop == 1)
	{
		if (prev_mstp == 0)
  4047e6:	b140      	cbz	r0, 4047fa <selfLearn_stage1_exe+0x2e>
				hoist_info.mstp_plate_length += enc_get_theta();
			}
			
			
		}
		prev_mstp = mstop;
  4047e8:	2301      	movs	r3, #1
	if (upfdl0 == 0)
	{
		LRN_err_set;
		pop_ups_add("Learn failed", 800);
	}
	return 0;
  4047ea:	2000      	movs	r0, #0
		prev_mstp = mstop;
  4047ec:	7023      	strb	r3, [r4, #0]
	return 0;
  4047ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((f_max < 2) || (((f_max - lrn_floor_counter) == 1) && (prev_mstp == 1))) return 1;
  4047f2:	2801      	cmp	r0, #1
  4047f4:	d1f7      	bne.n	4047e6 <selfLearn_stage1_exe+0x1a>
}
  4047f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			hoist_info.level_position_up[lrn_floor_counter] = enc_get_theta();
  4047fa:	4f16      	ldr	r7, [pc, #88]	; (404854 <selfLearn_stage1_exe+0x88>)
  4047fc:	f8df 8058 	ldr.w	r8, [pc, #88]	; 404858 <selfLearn_stage1_exe+0x8c>
  404800:	eb07 0585 	add.w	r5, r7, r5, lsl #2
  404804:	47c0      	blx	r8
  404806:	6068      	str	r0, [r5, #4]
			hoist_info.level_position[lrn_floor_counter] += enc_get_theta()/2;
  404808:	47c0      	blx	r8
  40480a:	7835      	ldrb	r5, [r6, #0]
  40480c:	2800      	cmp	r0, #0
  40480e:	f105 0318 	add.w	r3, r5, #24
  404812:	f171 0200 	sbcs.w	r2, r1, #0
  404816:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  40481a:	db10      	blt.n	40483e <selfLearn_stage1_exe+0x72>
  40481c:	1049      	asrs	r1, r1, #1
  40481e:	ea4f 0030 	mov.w	r0, r0, rrx
  404822:	685a      	ldr	r2, [r3, #4]
			if (lrn_floor_counter == 1)
  404824:	2d01      	cmp	r5, #1
			hoist_info.level_position[lrn_floor_counter] += enc_get_theta()/2;
  404826:	4410      	add	r0, r2
  404828:	6058      	str	r0, [r3, #4]
			if (lrn_floor_counter == 1)
  40482a:	d1dd      	bne.n	4047e8 <selfLearn_stage1_exe+0x1c>
				hoist_info.mstp_plate_length += enc_get_theta();
  40482c:	47c0      	blx	r8
  40482e:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
  404832:	4418      	add	r0, r3
  404834:	f8c7 0198 	str.w	r0, [r7, #408]	; 0x198
  404838:	e7d6      	b.n	4047e8 <selfLearn_stage1_exe+0x1c>
	if ((f_max < 2) || (((f_max - lrn_floor_counter) == 1) && (prev_mstp == 1))) return 1;
  40483a:	2001      	movs	r0, #1
  40483c:	4770      	bx	lr
			hoist_info.level_position[lrn_floor_counter] += enc_get_theta()/2;
  40483e:	3001      	adds	r0, #1
  404840:	f141 0100 	adc.w	r1, r1, #0
  404844:	e7ea      	b.n	40481c <selfLearn_stage1_exe+0x50>
  404846:	bf00      	nop
  404848:	204052b4 	.word	0x204052b4
  40484c:	20400893 	.word	0x20400893
  404850:	20400e27 	.word	0x20400e27
  404854:	20400c80 	.word	0x20400c80
  404858:	00413aed 	.word	0x00413aed

0040485c <selfLearn_finalize_calculations>:
	if ((prev_mstp == 0) && (prev_upfdl0 == 0)) return 1;
	return 0;
}

uint32_t selfLearn_finalize_calculations()
{
  40485c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	{
		//level lenght isn't measured so estimate it
	} 

	
	hoist_info.level_position[0] -= hoist_info.mstp_plate_length/2;
  404860:	4c5c      	ldr	r4, [pc, #368]	; (4049d4 <selfLearn_finalize_calculations+0x178>)
{
  404862:	b085      	sub	sp, #20
	if ((f_max < 2))
  404864:	4f5c      	ldr	r7, [pc, #368]	; (4049d8 <selfLearn_finalize_calculations+0x17c>)
	hoist_info.level_position[0] -= hoist_info.mstp_plate_length/2;
  404866:	f8d4 6198 	ldr.w	r6, [r4, #408]	; 0x198
  40486a:	6e62      	ldr	r2, [r4, #100]	; 0x64
  40486c:	2e00      	cmp	r6, #0
	hoist_info.level_position_dn[0] = hoist_info.level_position_up[0] - hoist_info.mstp_plate_length;
  40486e:	6863      	ldr	r3, [r4, #4]
	if ((f_max < 2))
  404870:	7ab9      	ldrb	r1, [r7, #10]
	hoist_info.level_position[0] -= hoist_info.mstp_plate_length/2;
  404872:	bfb4      	ite	lt
  404874:	1c75      	addlt	r5, r6, #1
  404876:	4635      	movge	r5, r6
	hoist_info.level_position_dn[0] = hoist_info.level_position_up[0] - hoist_info.mstp_plate_length;
  404878:	1b9b      	subs	r3, r3, r6
	
	hoist_info.level_position[f_max] += hoist_info.mstp_plate_length/2;
  40487a:	f101 0018 	add.w	r0, r1, #24
	hoist_info.level_position[0] -= hoist_info.mstp_plate_length/2;
  40487e:	eba2 0265 	sub.w	r2, r2, r5, asr #1
	hoist_info.level_position_up[f_max] = hoist_info.level_position_dn[f_max] + hoist_info.mstp_plate_length;
	
	hoist_info.mstp_plate_length = fixedpt_abs(hoist_info.mstp_plate_length);
	 
	ENCODER_COUNT_METER = (hoist_info.mstp_plate_length * 1000) / PLATE_LENGTH_MM;
  404882:	f897 e078 	ldrb.w	lr, [r7, #120]	; 0x78
	hoist_info.level_position_dn[0] = hoist_info.level_position_up[0] - hoist_info.mstp_plate_length;
  404886:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	ENCODER_COUNT_METER = (hoist_info.mstp_plate_length * 1000) / PLATE_LENGTH_MM;
  40488a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
	hoist_info.level_position[0] -= hoist_info.mstp_plate_length/2;
  40488e:	6662      	str	r2, [r4, #100]	; 0x64
	hoist_info.mstp_plate_length = fixedpt_abs(hoist_info.mstp_plate_length);
  404890:	ea86 72e6 	eor.w	r2, r6, r6, asr #31
	hoist_info.level_position[f_max] += hoist_info.mstp_plate_length/2;
  404894:	2e00      	cmp	r6, #0
  404896:	eb04 0c80 	add.w	ip, r4, r0, lsl #2
	hoist_info.mstp_plate_length = fixedpt_abs(hoist_info.mstp_plate_length);
  40489a:	eba2 72e6 	sub.w	r2, r2, r6, asr #31
	hoist_info.level_position[f_max] += hoist_info.mstp_plate_length/2;
  40489e:	4635      	mov	r5, r6
  4048a0:	eb04 0780 	add.w	r7, r4, r0, lsl #2
  4048a4:	bfb8      	it	lt
  4048a6:	1c75      	addlt	r5, r6, #1
	ENCODER_COUNT_METER = (hoist_info.mstp_plate_length * 1000) / PLATE_LENGTH_MM;
  4048a8:	fb03 f302 	mul.w	r3, r3, r2
	hoist_info.level_position[f_max] += hoist_info.mstp_plate_length/2;
  4048ac:	f8dc 0004 	ldr.w	r0, [ip, #4]
	hoist_info.level_position_up[f_max] = hoist_info.level_position_dn[f_max] + hoist_info.mstp_plate_length;
  4048b0:	eb04 0c81 	add.w	ip, r4, r1, lsl #2
	hoist_info.mstp_plate_length = fixedpt_abs(hoist_info.mstp_plate_length);
  4048b4:	f8c4 2198 	str.w	r2, [r4, #408]	; 0x198
	hoist_info.level_position[f_max] += hoist_info.mstp_plate_length/2;
  4048b8:	eb00 0565 	add.w	r5, r0, r5, asr #1
	hoist_info.enc_count_per_meter = ENCODER_COUNT_METER;
	
	hoist_info.forced_decel_error_trig = ENCODER_COUNT_METER / 13; //(7.5 CM)
  4048bc:	4847      	ldr	r0, [pc, #284]	; (4049dc <selfLearn_finalize_calculations+0x180>)
	hoist_info.level_position_up[f_max] = hoist_info.level_position_dn[f_max] + hoist_info.mstp_plate_length;
  4048be:	f8dc 10c4 	ldr.w	r1, [ip, #196]	; 0xc4
	hoist_info.level_position[f_max] += hoist_info.mstp_plate_length/2;
  4048c2:	607d      	str	r5, [r7, #4]
	hoist_info.level_position_up[f_max] = hoist_info.level_position_dn[f_max] + hoist_info.mstp_plate_length;
  4048c4:	4431      	add	r1, r6
	
	hoist_info.dirup0_decel = fixedpt_rconst(hoist_info.level_position[f_max] - hoist_info.dirUplimit0) / (ENCODER_COUNTREV / MOTOR_POLEPAIR); 
  4048c6:	f8d4 6184 	ldr.w	r6, [r4, #388]	; 0x184
	ENCODER_COUNT_METER = (hoist_info.mstp_plate_length * 1000) / PLATE_LENGTH_MM;
  4048ca:	4f45      	ldr	r7, [pc, #276]	; (4049e0 <selfLearn_finalize_calculations+0x184>)
	hoist_info.dirup0_decel = fixedpt_rconst(hoist_info.level_position[f_max] - hoist_info.dirUplimit0) / (ENCODER_COUNTREV / MOTOR_POLEPAIR); 
  4048cc:	1bad      	subs	r5, r5, r6
  4048ce:	4e45      	ldr	r6, [pc, #276]	; (4049e4 <selfLearn_finalize_calculations+0x188>)
	hoist_info.level_position_up[f_max] = hoist_info.level_position_dn[f_max] + hoist_info.mstp_plate_length;
  4048d0:	f8cc 1004 	str.w	r1, [ip, #4]
	hoist_info.dirup0_decel = fixedpt_rconst(hoist_info.level_position[f_max] - hoist_info.dirUplimit0) / (ENCODER_COUNTREV / MOTOR_POLEPAIR); 
  4048d4:	f8df b120 	ldr.w	fp, [pc, #288]	; 4049f8 <selfLearn_finalize_calculations+0x19c>
  4048d8:	f8df a120 	ldr.w	sl, [pc, #288]	; 4049fc <selfLearn_finalize_calculations+0x1a0>
  4048dc:	f8df 9120 	ldr.w	r9, [pc, #288]	; 404a00 <selfLearn_finalize_calculations+0x1a4>
	ENCODER_COUNT_METER = (hoist_info.mstp_plate_length * 1000) / PLATE_LENGTH_MM;
  4048e0:	fb93 f3fe 	sdiv	r3, r3, lr
	hoist_info.forced_decel_error_trig = ENCODER_COUNT_METER / 13; //(7.5 CM)
  4048e4:	fb80 2003 	smull	r2, r0, r0, r3
  4048e8:	17da      	asrs	r2, r3, #31
	ENCODER_COUNT_METER = (hoist_info.mstp_plate_length * 1000) / PLATE_LENGTH_MM;
  4048ea:	603b      	str	r3, [r7, #0]
	hoist_info.forced_decel_error_trig = ENCODER_COUNT_METER / 13; //(7.5 CM)
  4048ec:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
	hoist_info.enc_count_per_meter = ENCODER_COUNT_METER;
  4048f0:	f8c4 319c 	str.w	r3, [r4, #412]	; 0x19c
	hoist_info.dirup0_decel = fixedpt_rconst(hoist_info.level_position[f_max] - hoist_info.dirUplimit0) / (ENCODER_COUNTREV / MOTOR_POLEPAIR); 
  4048f4:	03e8      	lsls	r0, r5, #15
	hoist_info.forced_decel_error_trig = ENCODER_COUNT_METER / 13; //(7.5 CM)
  4048f6:	f8c4 2194 	str.w	r2, [r4, #404]	; 0x194
	hoist_info.dirup0_decel = fixedpt_rconst(hoist_info.level_position[f_max] - hoist_info.dirUplimit0) / (ENCODER_COUNTREV / MOTOR_POLEPAIR); 
  4048fa:	47d8      	blx	fp
  4048fc:	2d00      	cmp	r5, #0
  4048fe:	f8b6 50ae 	ldrh.w	r5, [r6, #174]	; 0xae
  404902:	460b      	mov	r3, r1
  404904:	f896 e03c 	ldrb.w	lr, [r6, #60]	; 0x3c
  404908:	4602      	mov	r2, r0
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40490a:	68b6      	ldr	r6, [r6, #8]
  40490c:	ea4f 0545 	mov.w	r5, r5, lsl #1
  404910:	bfb8      	it	lt
  404912:	4935      	ldrlt	r1, [pc, #212]	; (4049e8 <selfLearn_finalize_calculations+0x18c>)
  404914:	f04f 0000 	mov.w	r0, #0
  404918:	ea4f 78e6 	mov.w	r8, r6, asr #31
  40491c:	bfa8      	it	ge
  40491e:	4933      	ldrge	r1, [pc, #204]	; (4049ec <selfLearn_finalize_calculations+0x190>)
  404920:	fb95 f5fe 	sdiv	r5, r5, lr
  404924:	4647      	mov	r7, r8
  404926:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 404a04 <selfLearn_finalize_calculations+0x1a8>
  40492a:	e9cd 6700 	strd	r6, r7, [sp]
  40492e:	47d0      	blx	sl
  404930:	47c8      	blx	r9
  404932:	463b      	mov	r3, r7
  404934:	4632      	mov	r2, r6
  404936:	fb90 f1f5 	sdiv	r1, r0, r5
  40493a:	17cf      	asrs	r7, r1, #31
  40493c:	03c8      	lsls	r0, r1, #15
  40493e:	ea4f 3ec7 	mov.w	lr, r7, lsl #15
  404942:	ea4e 4151 	orr.w	r1, lr, r1, lsr #17
  404946:	47c0      	blx	r8
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  404948:	f246 33d7 	movw	r3, #25559	; 0x63d7
	hoist_info.dirup0_decel = fixedpt_div(hoist_info.dirup0_decel, fbase)<<1;
  40494c:	0040      	lsls	r0, r0, #1
	hoist_info.dirup0_decel = fixedpt_mul(hoist_info.dirup0_decel, fixedpt_rconst(0.78));
	hoist_info.dirup0_decel = fixedpt_abs(hoist_info.dirup0_decel);
	
	hoist_info.dirdwn0_decel = fixedpt_rconst(hoist_info.dirDnlimit0 - hoist_info.level_position[0]) / (ENCODER_COUNTREV / MOTOR_POLEPAIR);
  40494e:	f8d4 2188 	ldr.w	r2, [r4, #392]	; 0x188
  404952:	fb80 0103 	smull	r0, r1, r0, r3
  404956:	6e63      	ldr	r3, [r4, #100]	; 0x64
  404958:	ea4f 3ed0 	mov.w	lr, r0, lsr #15
  40495c:	1ad3      	subs	r3, r2, r3
  40495e:	ea4e 4e41 	orr.w	lr, lr, r1, lsl #17
  404962:	9303      	str	r3, [sp, #12]
  404964:	03d8      	lsls	r0, r3, #15
	hoist_info.dirup0_decel = fixedpt_abs(hoist_info.dirup0_decel);
  404966:	ea8e 72ee 	eor.w	r2, lr, lr, asr #31
  40496a:	eba2 72ee 	sub.w	r2, r2, lr, asr #31
  40496e:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
	hoist_info.dirdwn0_decel = fixedpt_rconst(hoist_info.dirDnlimit0 - hoist_info.level_position[0]) / (ENCODER_COUNTREV / MOTOR_POLEPAIR);
  404972:	47d8      	blx	fp
  404974:	9b03      	ldr	r3, [sp, #12]
  404976:	f04f 0b00 	mov.w	fp, #0
  40497a:	4602      	mov	r2, r0
  40497c:	2b00      	cmp	r3, #0
  40497e:	460b      	mov	r3, r1
  404980:	4658      	mov	r0, fp
  404982:	bfb4      	ite	lt
  404984:	f8df c060 	ldrlt.w	ip, [pc, #96]	; 4049e8 <selfLearn_finalize_calculations+0x18c>
  404988:	f8df c060 	ldrge.w	ip, [pc, #96]	; 4049ec <selfLearn_finalize_calculations+0x190>
  40498c:	4661      	mov	r1, ip
  40498e:	47d0      	blx	sl
  404990:	47c8      	blx	r9
  404992:	fb90 f5f5 	sdiv	r5, r0, r5
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  404996:	17ef      	asrs	r7, r5, #31
  404998:	03e8      	lsls	r0, r5, #15
  40499a:	03f9      	lsls	r1, r7, #15
  40499c:	e9dd 2300 	ldrd	r2, r3, [sp]
  4049a0:	ea41 4155 	orr.w	r1, r1, r5, lsr #17
  4049a4:	47c0      	blx	r8
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4049a6:	f246 32d7 	movw	r2, #25559	; 0x63d7
	hoist_info.dirdwn0_decel = fixedpt_div(hoist_info.dirdwn0_decel, fbase)<<1;
  4049aa:	0046      	lsls	r6, r0, #1
	hoist_info.dirdwn0_decel = fixedpt_mul(hoist_info.dirdwn0_decel, fixedpt_rconst(0.78));
	hoist_info.dirdwn0_decel = fixedpt_abs(hoist_info.dirdwn0_decel);
	
	hoist_info.Lrn = 0;
  4049ac:	2300      	movs	r3, #0
	//tmptst = hoist_info.dirDnlimit0;
	pop_ups_add("Learn Successful", 1500);
  4049ae:	4810      	ldr	r0, [pc, #64]	; (4049f0 <selfLearn_finalize_calculations+0x194>)
  4049b0:	f240 51dc 	movw	r1, #1500	; 0x5dc
  4049b4:	fb86 6702 	smull	r6, r7, r6, r2
  4049b8:	4a0e      	ldr	r2, [pc, #56]	; (4049f4 <selfLearn_finalize_calculations+0x198>)
	hoist_info.Lrn = 0;
  4049ba:	7023      	strb	r3, [r4, #0]
  4049bc:	0bf3      	lsrs	r3, r6, #15
  4049be:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
	hoist_info.dirdwn0_decel = fixedpt_abs(hoist_info.dirdwn0_decel);
  4049c2:	2b00      	cmp	r3, #0
  4049c4:	bfb8      	it	lt
  4049c6:	425b      	neglt	r3, r3
  4049c8:	f8c4 3190 	str.w	r3, [r4, #400]	; 0x190
	pop_ups_add("Learn Successful", 1500);
  4049cc:	4790      	blx	r2
}
  4049ce:	b005      	add	sp, #20
  4049d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4049d4:	20400c80 	.word	0x20400c80
  4049d8:	204052b4 	.word	0x204052b4
  4049dc:	4ec4ec4f 	.word	0x4ec4ec4f
  4049e0:	20400e20 	.word	0x20400e20
  4049e4:	20404ff0 	.word	0x20404ff0
  4049e8:	bfe00000 	.word	0xbfe00000
  4049ec:	3fe00000 	.word	0x3fe00000
  4049f0:	00419a94 	.word	0x00419a94
  4049f4:	0040c065 	.word	0x0040c065
  4049f8:	00418725 	.word	0x00418725
  4049fc:	0041848d 	.word	0x0041848d
  404a00:	00418d51 	.word	0x00418d51
  404a04:	0041905d 	.word	0x0041905d

00404a08 <self_learn_handler>:

void self_learn_handler(void)
{
  404a08:	b570      	push	{r4, r5, r6, lr}
	if (hw_learning == 0) return;
  404a0a:	4c16      	ldr	r4, [pc, #88]	; (404a64 <self_learn_handler+0x5c>)
  404a0c:	7823      	ldrb	r3, [r4, #0]
  404a0e:	b1d3      	cbz	r3, 404a46 <self_learn_handler+0x3e>
	if (lrn_stage == 0)
  404a10:	4d15      	ldr	r5, [pc, #84]	; (404a68 <self_learn_handler+0x60>)
  404a12:	782b      	ldrb	r3, [r5, #0]
  404a14:	b1c3      	cbz	r3, 404a48 <self_learn_handler+0x40>
		if (selfLearn_stage0_exe())
		{
			lrn_stage++;
		}
	}
	else if (lrn_stage == 1)
  404a16:	2b01      	cmp	r3, #1
  404a18:	d01e      	beq.n	404a58 <self_learn_handler+0x50>
		if (selfLearn_stage1_exe())
		{
			lrn_stage++;
		}
	}
	else if (lrn_stage == 2)
  404a1a:	2b02      	cmp	r3, #2
  404a1c:	d003      	beq.n	404a26 <self_learn_handler+0x1e>
			HW_LRN = 0;
			lrn_stage++;
			lrn_active = 0;
		}
	}
	else lrn_active = 0;
  404a1e:	4b13      	ldr	r3, [pc, #76]	; (404a6c <self_learn_handler+0x64>)
  404a20:	2200      	movs	r2, #0
  404a22:	701a      	strb	r2, [r3, #0]
  404a24:	bd70      	pop	{r4, r5, r6, pc}
	if ((prev_mstp == 0) && (prev_upfdl0 == 0)) return 1;
  404a26:	4b12      	ldr	r3, [pc, #72]	; (404a70 <self_learn_handler+0x68>)
  404a28:	781b      	ldrb	r3, [r3, #0]
  404a2a:	b963      	cbnz	r3, 404a46 <self_learn_handler+0x3e>
  404a2c:	4b11      	ldr	r3, [pc, #68]	; (404a74 <self_learn_handler+0x6c>)
  404a2e:	781e      	ldrb	r6, [r3, #0]
  404a30:	b9be      	cbnz	r6, 404a62 <self_learn_handler+0x5a>
			selfLearn_finalize_calculations();
  404a32:	4b11      	ldr	r3, [pc, #68]	; (404a78 <self_learn_handler+0x70>)
  404a34:	4798      	blx	r3
			lrn_stage++;
  404a36:	782b      	ldrb	r3, [r5, #0]
			HW_LRN = 0;
  404a38:	4910      	ldr	r1, [pc, #64]	; (404a7c <self_learn_handler+0x74>)
			lrn_stage++;
  404a3a:	3301      	adds	r3, #1
			lrn_active = 0;
  404a3c:	4a0b      	ldr	r2, [pc, #44]	; (404a6c <self_learn_handler+0x64>)
			hw_learning = 0;
  404a3e:	7026      	strb	r6, [r4, #0]
			lrn_stage++;
  404a40:	702b      	strb	r3, [r5, #0]
			HW_LRN = 0;
  404a42:	700e      	strb	r6, [r1, #0]
			lrn_active = 0;
  404a44:	7016      	strb	r6, [r2, #0]
  404a46:	bd70      	pop	{r4, r5, r6, pc}
		if (selfLearn_stage0_exe())
  404a48:	4b0d      	ldr	r3, [pc, #52]	; (404a80 <self_learn_handler+0x78>)
  404a4a:	4798      	blx	r3
  404a4c:	2800      	cmp	r0, #0
  404a4e:	d0fa      	beq.n	404a46 <self_learn_handler+0x3e>
			lrn_stage++;
  404a50:	782b      	ldrb	r3, [r5, #0]
  404a52:	3301      	adds	r3, #1
  404a54:	702b      	strb	r3, [r5, #0]
  404a56:	bd70      	pop	{r4, r5, r6, pc}
		if (selfLearn_stage1_exe())
  404a58:	4b0a      	ldr	r3, [pc, #40]	; (404a84 <self_learn_handler+0x7c>)
  404a5a:	4798      	blx	r3
  404a5c:	2800      	cmp	r0, #0
  404a5e:	d0f2      	beq.n	404a46 <self_learn_handler+0x3e>
  404a60:	e7f6      	b.n	404a50 <self_learn_handler+0x48>
  404a62:	bd70      	pop	{r4, r5, r6, pc}
  404a64:	20400891 	.word	0x20400891
  404a68:	20400e26 	.word	0x20400e26
  404a6c:	20400892 	.word	0x20400892
  404a70:	20400e27 	.word	0x20400e27
  404a74:	20400e25 	.word	0x20400e25
  404a78:	0040485d 	.word	0x0040485d
  404a7c:	204008eb 	.word	0x204008eb
  404a80:	00404769 	.word	0x00404769
  404a84:	004047cd 	.word	0x004047cd

00404a88 <selfLearn_exe>:
}

uint32_t selfLearn_exe(void)
{
	if (hw_learning == 0) return 0;
  404a88:	4b03      	ldr	r3, [pc, #12]	; (404a98 <selfLearn_exe+0x10>)
  404a8a:	7818      	ldrb	r0, [r3, #0]
  404a8c:	b110      	cbz	r0, 404a94 <selfLearn_exe+0xc>
	return lrn_active;
  404a8e:	4b03      	ldr	r3, [pc, #12]	; (404a9c <selfLearn_exe+0x14>)
  404a90:	f993 0000 	ldrsb.w	r0, [r3]
}
  404a94:	4770      	bx	lr
  404a96:	bf00      	nop
  404a98:	20400891 	.word	0x20400891
  404a9c:	20400892 	.word	0x20400892

00404aa0 <floor_level_floorLevel_enter>:
#define direct_stop_inactive			  (opt_direct_stop_activation[0])
#define direct_stop_active				  (opt_direct_stop_activation[1])

void floor_level_floorLevel_enter(void)
{
	floor_level_option_val.val = &hoist_info.level_position_correction[floor_number];
  404aa0:	4a04      	ldr	r2, [pc, #16]	; (404ab4 <floor_level_floorLevel_enter+0x14>)
  404aa2:	4b05      	ldr	r3, [pc, #20]	; (404ab8 <floor_level_floorLevel_enter+0x18>)
  404aa4:	7812      	ldrb	r2, [r2, #0]
  404aa6:	4905      	ldr	r1, [pc, #20]	; (404abc <floor_level_floorLevel_enter+0x1c>)
  404aa8:	3249      	adds	r2, #73	; 0x49
  404aaa:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  404aae:	61cb      	str	r3, [r1, #28]
  404ab0:	4770      	bx	lr
  404ab2:	bf00      	nop
  404ab4:	20400894 	.word	0x20400894
  404ab8:	20400c80 	.word	0x20400c80
  404abc:	20400ee4 	.word	0x20400ee4

00404ac0 <menue_direct_stop_init>:
	lift_speed_option_val.max_value			=  8;
	lift_speed_option_val.min_value			=  0.1;
	lift_speed_option_val.unit				= "M/s";
	//lift_speed_option_val.text = "Enter your building number of doors";
	
	lift_speed_option_val.val				= &menue_lift_data_setup.m_lift_speed;
  404ac0:	486f      	ldr	r0, [pc, #444]	; (404c80 <menue_direct_stop_init+0x1c0>)
	opt_plate_length.text = "Stop plate length";
	plate_length_option_val.data_types = uint8_dt;
	plate_length_option_val.mantissa_count	=  0;
	plate_length_option_val.real_count		=  3;
	plate_length_option_val.max_value			=  500;
	plate_length_option_val.min_value			=  10;
  404ac2:	4b70      	ldr	r3, [pc, #448]	; (404c84 <menue_direct_stop_init+0x1c4>)
	creep_distance_option_val.max_value			=  24;
	creep_distance_option_val.min_value			=  0.01;
	//creep_distance_option_val.unit				= "d";
	//creep_distance_option_val.text = "Enter your building number of doors";
	
	creep_distance_option_val.val				= &menue_lift_data_setup.m_creep_distance;
  404ac4:	f100 0208 	add.w	r2, r0, #8
	plate_length_option_val.max_value			=  500;
  404ac8:	496f      	ldr	r1, [pc, #444]	; (404c88 <menue_direct_stop_init+0x1c8>)
	creep_distance_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
	opt_creep_distance.option_save_val = &creep_distance_option_val;
//__________________________________________________
	opt_direct_stop.text = "DirectStop Act";
	direct_stop_inactive.text = "Inactive";
  404aca:	f8df c1f8 	ldr.w	ip, [pc, #504]	; 404cc4 <menue_direct_stop_init+0x204>
{
  404ace:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	plate_length_option_val.data_types = uint8_dt;
  404ad2:	4e6e      	ldr	r6, [pc, #440]	; (404c8c <menue_direct_stop_init+0x1cc>)
	plate_length_option_val.val				= &menue_lift_data_setup.m_stop_plate_length;
  404ad4:	f100 0e04 	add.w	lr, r0, #4
	creep_distance_option_val.data_types = fixedpt_dt;
  404ad8:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 404cc8 <menue_direct_stop_init+0x208>
	lift_speed_option_val.mantissa_count	=  1;
  404adc:	2401      	movs	r4, #1
	lift_speed_option_val.max_value			=  8;
  404ade:	f04f 4982 	mov.w	r9, #1090519040	; 0x41000000
	lift_speed_option_val.data_types = fixedpt_dt;
  404ae2:	f04f 0b02 	mov.w	fp, #2
	plate_length_option_val.real_count		=  3;
  404ae6:	2703      	movs	r7, #3
	plate_length_option_val.data_types = uint8_dt;
  404ae8:	2500      	movs	r5, #0
	direct_stop_active.text = "Active";
	
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404aea:	f100 0a0c 	add.w	sl, r0, #12
{
  404aee:	ed2d 8b02 	vpush	{d8}
	plate_length_option_val.val				= &menue_lift_data_setup.m_stop_plate_length;
  404af2:	f8c6 e01c 	str.w	lr, [r6, #28]
	creep_distance_option_val.max_value			=  24;
  404af6:	eeb3 8a08 	vmov.f32	s16, #56	; 0x41c00000  24.0
	creep_distance_option_val.min_value			=  0.01;
  404afa:	f8df e1d0 	ldr.w	lr, [pc, #464]	; 404ccc <menue_direct_stop_init+0x20c>
{
  404afe:	b083      	sub	sp, #12
	creep_distance_option_val.val				= &menue_lift_data_setup.m_creep_distance;
  404b00:	f8c8 201c 	str.w	r2, [r8, #28]
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404b04:	465a      	mov	r2, fp
	creep_distance_option_val.min_value			=  0.01;
  404b06:	f8c8 e018 	str.w	lr, [r8, #24]
	lift_speed_option_val.data_types = fixedpt_dt;
  404b0a:	f8df e1c4 	ldr.w	lr, [pc, #452]	; 404cd0 <menue_direct_stop_init+0x210>
	creep_distance_option_val.data_types = fixedpt_dt;
  404b0e:	f888 b000 	strb.w	fp, [r8]
	lift_speed_option_val.max_value			=  8;
  404b12:	f8ce 9014 	str.w	r9, [lr, #20]
	lift_speed_option_val.mantissa_count	=  1;
  404b16:	f8ce 4008 	str.w	r4, [lr, #8]
	lift_speed_option_val.real_count		=  1;
  404b1a:	f8ce 4004 	str.w	r4, [lr, #4]
	lift_speed_option_val.min_value			=  0.1;
  404b1e:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 404cd4 <menue_direct_stop_init+0x214>
	lift_speed_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
  404b22:	4c5b      	ldr	r4, [pc, #364]	; (404c90 <menue_direct_stop_init+0x1d0>)
	lift_speed_option_val.min_value			=  0.1;
  404b24:	f8ce 9018 	str.w	r9, [lr, #24]
	lift_speed_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
  404b28:	f8ce 4020 	str.w	r4, [lr, #32]
	plate_length_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
  404b2c:	6234      	str	r4, [r6, #32]
	creep_distance_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
  404b2e:	f8c8 4020 	str.w	r4, [r8, #32]
	lift_speed_option_val.unit				= "M/s";
  404b32:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 404cd8 <menue_direct_stop_init+0x218>
	opt_lift_speed.text = "Lift speed";
  404b36:	4c57      	ldr	r4, [pc, #348]	; (404c94 <menue_direct_stop_init+0x1d4>)
	lift_speed_option_val.val				= &menue_lift_data_setup.m_lift_speed;
  404b38:	f8ce 001c 	str.w	r0, [lr, #28]
	lift_speed_option_val.data_types = fixedpt_dt;
  404b3c:	f88e b000 	strb.w	fp, [lr]
	lift_speed_option_val.unit				= "M/s";
  404b40:	f8ce 900c 	str.w	r9, [lr, #12]
	opt_lift_speed.option_save_val = &lift_speed_option_val;
  404b44:	f8c4 e04c 	str.w	lr, [r4, #76]	; 0x4c
	opt_plate_length.text = "Stop plate length";
  404b48:	f8df e190 	ldr.w	lr, [pc, #400]	; 404cdc <menue_direct_stop_init+0x21c>
	creep_distance_option_val.mantissa_count	=  2;
  404b4c:	f8c8 b008 	str.w	fp, [r8, #8]
	creep_distance_option_val.real_count		=  2;
  404b50:	f8c8 b004 	str.w	fp, [r8, #4]
	creep_distance_option_val.max_value			=  24;
  404b54:	ed88 8a05 	vstr	s16, [r8, #20]
	opt_creep_distance.option_save_val = &creep_distance_option_val;
  404b58:	f8c4 809c 	str.w	r8, [r4, #156]	; 0x9c
	opt_plate_length.text = "Stop plate length";
  404b5c:	f8c4 e050 	str.w	lr, [r4, #80]	; 0x50
	plate_length_option_val.real_count		=  3;
  404b60:	6077      	str	r7, [r6, #4]
	opt_lift_speed.text = "Lift speed";
  404b62:	f8df 817c 	ldr.w	r8, [pc, #380]	; 404ce0 <menue_direct_stop_init+0x220>
	opt_direct_stop.text = "DirectStop Act";
  404b66:	f8df e17c 	ldr.w	lr, [pc, #380]	; 404ce4 <menue_direct_stop_init+0x224>
	plate_length_option_val.unit				= "mm";
  404b6a:	4f4b      	ldr	r7, [pc, #300]	; (404c98 <menue_direct_stop_init+0x1d8>)
	plate_length_option_val.max_value			=  500;
  404b6c:	6171      	str	r1, [r6, #20]
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404b6e:	4661      	mov	r1, ip
	plate_length_option_val.min_value			=  10;
  404b70:	61b3      	str	r3, [r6, #24]
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404b72:	462b      	mov	r3, r5
	plate_length_option_val.data_types = uint8_dt;
  404b74:	7035      	strb	r5, [r6, #0]
	plate_length_option_val.mantissa_count	=  0;
  404b76:	60b5      	str	r5, [r6, #8]
	opt_plate_length.option_save_val = &plate_length_option_val;
  404b78:	6766      	str	r6, [r4, #116]	; 0x74
	opt_lift_speed.text = "Lift speed";
  404b7a:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
	opt_direct_stop.text = "DirectStop Act";
  404b7e:	f8c4 e000 	str.w	lr, [r4]
	plate_length_option_val.unit				= "mm";
  404b82:	60f7      	str	r7, [r6, #12]
	direct_stop_inactive.text = "Inactive";
  404b84:	f8df e160 	ldr.w	lr, [pc, #352]	; 404ce8 <menue_direct_stop_init+0x228>
	opt_creep_distance.text = "stopping distance";
  404b88:	f8df 8160 	ldr.w	r8, [pc, #352]	; 404cec <menue_direct_stop_init+0x22c>
	direct_stop_active.text = "Active";
  404b8c:	4e43      	ldr	r6, [pc, #268]	; (404c9c <menue_direct_stop_init+0x1dc>)
	
	//Set the child to enter
	opt_direct_stop.child = &menue_direct_stop_activation;
  404b8e:	4f44      	ldr	r7, [pc, #272]	; (404ca0 <menue_direct_stop_init+0x1e0>)
	opt_creep_distance.text = "stopping distance";
  404b90:	f8c4 8078 	str.w	r8, [r4, #120]	; 0x78
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404b94:	4842      	ldr	r0, [pc, #264]	; (404ca0 <menue_direct_stop_init+0x1e0>)
	direct_stop_inactive.text = "Inactive";
  404b96:	f8cc e000 	str.w	lr, [ip]
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404b9a:	f8df 8154 	ldr.w	r8, [pc, #340]	; 404cf0 <menue_direct_stop_init+0x230>
	direct_stop_active.text = "Active";
  404b9e:	f8cc 6028 	str.w	r6, [ip, #40]	; 0x28
	fill_menue_list(&menue_direct_stop_activation, opt_direct_stop_activation, OPT_DIRECT_STOP_ACTIVATION_MAX, 0, &menue_lift_data_setup.m_direct_stop);
  404ba2:	f8cd a000 	str.w	sl, [sp]
  404ba6:	47c0      	blx	r8
	opt_direct_stop.child = &menue_direct_stop_activation;
  404ba8:	6227      	str	r7, [r4, #32]
//__________________________________________________
	opt_self_learn.text = "HoistWay learn";
	self_learn_on.text = "On";
	self_learn_off.text = "Off";
	
	fill_menue_list(&menue_direct_stop_self_learn, opt_direct_stop_self_learn, OPT_DIRECT_STOP_SELF_LEARN_MAX, 0, &menue_lift_data_startSelfLrn);
  404baa:	493e      	ldr	r1, [pc, #248]	; (404ca4 <menue_direct_stop_init+0x1e4>)
  404bac:	462b      	mov	r3, r5
	opt_self_learn.text = "HoistWay learn";
  404bae:	4f3e      	ldr	r7, [pc, #248]	; (404ca8 <menue_direct_stop_init+0x1e8>)
	fill_menue_list(&menue_direct_stop_self_learn, opt_direct_stop_self_learn, OPT_DIRECT_STOP_SELF_LEARN_MAX, 0, &menue_lift_data_startSelfLrn);
  404bb0:	465a      	mov	r2, fp
  404bb2:	9100      	str	r1, [sp, #0]
	self_learn_on.text = "On";
  404bb4:	f8df e13c 	ldr.w	lr, [pc, #316]	; 404cf4 <menue_direct_stop_init+0x234>
	fill_menue_list(&menue_direct_stop_self_learn, opt_direct_stop_self_learn, OPT_DIRECT_STOP_SELF_LEARN_MAX, 0, &menue_lift_data_startSelfLrn);
  404bb8:	4e3c      	ldr	r6, [pc, #240]	; (404cac <menue_direct_stop_init+0x1ec>)
	opt_self_learn.text = "HoistWay learn";
  404bba:	f8c4 70a0 	str.w	r7, [r4, #160]	; 0xa0
	fill_menue_list(&menue_direct_stop_self_learn, opt_direct_stop_self_learn, OPT_DIRECT_STOP_SELF_LEARN_MAX, 0, &menue_lift_data_startSelfLrn);
  404bbe:	4671      	mov	r1, lr
	self_learn_on.text = "On";
  404bc0:	f8df c134 	ldr.w	ip, [pc, #308]	; 404cf8 <menue_direct_stop_init+0x238>
	fill_menue_list(&menue_direct_stop_self_learn, opt_direct_stop_self_learn, OPT_DIRECT_STOP_SELF_LEARN_MAX, 0, &menue_lift_data_startSelfLrn);
  404bc4:	4630      	mov	r0, r6
	self_learn_off.text = "Off";
  404bc6:	4f3a      	ldr	r7, [pc, #232]	; (404cb0 <menue_direct_stop_init+0x1f0>)
	self_learn_on.text = "On";
  404bc8:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	self_learn_off.text = "Off";
  404bcc:	f8ce 7000 	str.w	r7, [lr]
	floor_level_floorLevel.text = "Floor Level";
	//floor_level_floorLevel.exe = &floor_dislplay_menue_exe;
	//floor_level_floorLevel.enter = &floor_dislplay_menue_enter;
	floor_level_option_val.data_types			=	fixedpt_dt;
	floor_level_option_val.mantissa_count		=	2;
	floor_level_option_val.real_count			=	3;
  404bd0:	2703      	movs	r7, #3
	fill_menue_list(&menue_direct_stop_self_learn, opt_direct_stop_self_learn, OPT_DIRECT_STOP_SELF_LEARN_MAX, 0, &menue_lift_data_startSelfLrn);
  404bd2:	47c0      	blx	r8
	floor_number_option_val.val	= &floor_number;
  404bd4:	4837      	ldr	r0, [pc, #220]	; (404cb4 <menue_direct_stop_init+0x1f4>)
	floor_level_option_val.data_types			=	fixedpt_dt;
  404bd6:	f8df 9124 	ldr.w	r9, [pc, #292]	; 404cfc <menue_direct_stop_init+0x23c>
	floor_number_option_val.min_value			=  0;
  404bda:	f04f 0c00 	mov.w	ip, #0
	floor_level_option_val.max_value			=	fixedpt_rconst(200);
	floor_level_option_val.min_value			=	-fixedpt_rconst(200);
	floor_level_option_val.unit					=	"mm";
	floor_level_option_val.val					=	&hoist_info.level_position_correction[floor_number];
  404bde:	f890 e000 	ldrb.w	lr, [r0]

	floor_level_floorLevel.option_save_val = &floor_level_option_val;
	floor_level_floorLevel.enter = &floor_level_floorLevel_enter;
	
	fill_menue_list(&menue_direct_stop_floor_leves, &opt_direct_stop_floor_levels, OPT_DIRECT_STOP_FLOOR_LEVEL_MAX, 0, 0);
  404be2:	465a      	mov	r2, fp
  404be4:	9500      	str	r5, [sp, #0]
  404be6:	462b      	mov	r3, r5
	opt_self_learn.child = &menue_direct_stop_self_learn;
  404be8:	f8c4 60c0 	str.w	r6, [r4, #192]	; 0xc0
	floor_level_option_val.val					=	&hoist_info.level_position_correction[floor_number];
  404bec:	f10e 0e49 	add.w	lr, lr, #73	; 0x49
	floor_number_option_val.data_types = uint8_dt;
  404bf0:	4e31      	ldr	r6, [pc, #196]	; (404cb8 <menue_direct_stop_init+0x1f8>)
	floor_level_option_val.val					=	&hoist_info.level_position_correction[floor_number];
  404bf2:	4932      	ldr	r1, [pc, #200]	; (404cbc <menue_direct_stop_init+0x1fc>)
	floor_number_option_val.real_count		=  2;
  404bf4:	f8c6 b004 	str.w	fp, [r6, #4]
	floor_level_option_val.val					=	&hoist_info.level_position_correction[floor_number];
  404bf8:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
	floor_number_option_val.min_value			=  0;
  404bfc:	f8c6 c018 	str.w	ip, [r6, #24]
	floor_level_option_val.data_types			=	fixedpt_dt;
  404c00:	f889 b000 	strb.w	fp, [r9]
	floor_level_option_val.mantissa_count		=	2;
  404c04:	f8c9 b008 	str.w	fp, [r9, #8]
	floor_level_option_val.max_value			=	fixedpt_rconst(200);
  404c08:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 404d00 <menue_direct_stop_init+0x240>
	floor_level_option_val.min_value			=	-fixedpt_rconst(200);
  404c0c:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 404d04 <menue_direct_stop_init+0x244>
	fill_menue_list(&menue_direct_stop_floor_leves, &opt_direct_stop_floor_levels, OPT_DIRECT_STOP_FLOOR_LEVEL_MAX, 0, 0);
  404c10:	492b      	ldr	r1, [pc, #172]	; (404cc0 <menue_direct_stop_init+0x200>)
	floor_level_option_val.real_count			=	3;
  404c12:	f8c9 7004 	str.w	r7, [r9, #4]
	floor_level_option_val.unit					=	"mm";
  404c16:	4f20      	ldr	r7, [pc, #128]	; (404c98 <menue_direct_stop_init+0x1d8>)
	fill_menue_list(&menue_direct_stop_floor_leves, &opt_direct_stop_floor_levels, OPT_DIRECT_STOP_FLOOR_LEVEL_MAX, 0, 0);
  404c18:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 404d08 <menue_direct_stop_init+0x248>
	floor_level_option_val.max_value			=	fixedpt_rconst(200);
  404c1c:	f8c9 c014 	str.w	ip, [r9, #20]
	floor_level_option_val.min_value			=	-fixedpt_rconst(200);
  404c20:	f8c9 b018 	str.w	fp, [r9, #24]
	floor_level_floorNumber.text = "Enter floor number";
  404c24:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 404d0c <menue_direct_stop_init+0x24c>
	floor_level_option_val.val					=	&hoist_info.level_position_correction[floor_number];
  404c28:	f8c9 e01c 	str.w	lr, [r9, #28]
	floor_level_floorLevel.enter = &floor_level_floorLevel_enter;
  404c2c:	f8df b0e0 	ldr.w	fp, [pc, #224]	; 404d10 <menue_direct_stop_init+0x250>
	opt_floor_level.text = "Floor Level";
  404c30:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 404d14 <menue_direct_stop_init+0x254>
	floor_level_option_val.unit					=	"mm";
  404c34:	f8c9 700c 	str.w	r7, [r9, #12]
	floor_level_floorLevel.option_save_val = &floor_level_option_val;
  404c38:	f8c1 904c 	str.w	r9, [r1, #76]	; 0x4c

	// set the 'option display_type' child to be menue_basic1_floor display
	opt_floor_level.child = &menue_direct_stop_floor_leves;	

//__________________________________________________
	fill_menue_list(&menue_direct_stop, optl_direct_stop, OPT_DIRECT_STOP_MAX, 0, 0);
  404c3c:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 404d18 <menue_direct_stop_init+0x258>
	floor_level_floorNumber.text = "Enter floor number";
  404c40:	f8c1 c000 	str.w	ip, [r1]
	floor_level_floorLevel.text = "Floor Level";
  404c44:	f8c1 e028 	str.w	lr, [r1, #40]	; 0x28
	floor_number_option_val.val	= &floor_number;
  404c48:	61f0      	str	r0, [r6, #28]
	fill_menue_list(&menue_direct_stop_floor_leves, &opt_direct_stop_floor_levels, OPT_DIRECT_STOP_FLOOR_LEVEL_MAX, 0, 0);
  404c4a:	4650      	mov	r0, sl
	floor_level_floorNumber.option_save_val = &floor_number_option_val;
  404c4c:	624e      	str	r6, [r1, #36]	; 0x24
	floor_number_option_val.text = "Enter floor number";
  404c4e:	f8c6 c010 	str.w	ip, [r6, #16]
	floor_level_floorLevel.enter = &floor_level_floorLevel_enter;
  404c52:	f8c1 b03c 	str.w	fp, [r1, #60]	; 0x3c
	opt_floor_level.text = "Floor Level";
  404c56:	f8c4 e0c8 	str.w	lr, [r4, #200]	; 0xc8
	floor_number_option_val.max_value			=  24;
  404c5a:	ed86 8a05 	vstr	s16, [r6, #20]
	floor_number_option_val.data_types = uint8_dt;
  404c5e:	7035      	strb	r5, [r6, #0]
	floor_number_option_val.mantissa_count	=  0;
  404c60:	60b5      	str	r5, [r6, #8]
	fill_menue_list(&menue_direct_stop_floor_leves, &opt_direct_stop_floor_levels, OPT_DIRECT_STOP_FLOOR_LEVEL_MAX, 0, 0);
  404c62:	47c0      	blx	r8
	fill_menue_list(&menue_direct_stop, optl_direct_stop, OPT_DIRECT_STOP_MAX, 0, 0);
  404c64:	9500      	str	r5, [sp, #0]
  404c66:	4648      	mov	r0, r9
  404c68:	462b      	mov	r3, r5
  404c6a:	4621      	mov	r1, r4
  404c6c:	2206      	movs	r2, #6
	opt_floor_level.child = &menue_direct_stop_floor_leves;	
  404c6e:	f8c4 a0e8 	str.w	sl, [r4, #232]	; 0xe8
	fill_menue_list(&menue_direct_stop, optl_direct_stop, OPT_DIRECT_STOP_MAX, 0, 0);
  404c72:	47c0      	blx	r8

	return &menue_direct_stop;
  404c74:	4648      	mov	r0, r9
  404c76:	b003      	add	sp, #12
  404c78:	ecbd 8b02 	vpop	{d8}
  404c7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404c80:	20405254 	.word	0x20405254
  404c84:	41200000 	.word	0x41200000
  404c88:	43fa0000 	.word	0x43fa0000
  404c8c:	20400f88 	.word	0x20400f88
  404c90:	204008ea 	.word	0x204008ea
  404c94:	20400fd0 	.word	0x20400fd0
  404c98:	0041a5ec 	.word	0x0041a5ec
  404c9c:	0041a620 	.word	0x0041a620
  404ca0:	20400f48 	.word	0x20400f48
  404ca4:	204008eb 	.word	0x204008eb
  404ca8:	0041a628 	.word	0x0041a628
  404cac:	20401110 	.word	0x20401110
  404cb0:	0041a63c 	.word	0x0041a63c
  404cb4:	20400894 	.word	0x20400894
  404cb8:	20400fac 	.word	0x20400fac
  404cbc:	20400c80 	.word	0x20400c80
  404cc0:	204010c0 	.word	0x204010c0
  404cc4:	20400e78 	.word	0x20400e78
  404cc8:	20400f64 	.word	0x20400f64
  404ccc:	3c23d70a 	.word	0x3c23d70a
  404cd0:	20400f08 	.word	0x20400f08
  404cd4:	3dcccccd 	.word	0x3dcccccd
  404cd8:	004199cc 	.word	0x004199cc
  404cdc:	0041a5d8 	.word	0x0041a5d8
  404ce0:	0041a5cc 	.word	0x0041a5cc
  404ce4:	0041a604 	.word	0x0041a604
  404ce8:	0041a614 	.word	0x0041a614
  404cec:	0041a5f0 	.word	0x0041a5f0
  404cf0:	0040b0ad 	.word	0x0040b0ad
  404cf4:	20400e28 	.word	0x20400e28
  404cf8:	0041a638 	.word	0x0041a638
  404cfc:	20400ee4 	.word	0x20400ee4
  404d00:	4ac80000 	.word	0x4ac80000
  404d04:	cac80000 	.word	0xcac80000
  404d08:	20400ec8 	.word	0x20400ec8
  404d0c:	0041a64c 	.word	0x0041a64c
  404d10:	00404aa1 	.word	0x00404aa1
  404d14:	0041a640 	.word	0x0041a640
  404d18:	20400f2c 	.word	0x20400f2c

00404d1c <init_menues>:
//access control graphical
menue_design_image_t menue_util_graphical;


void init_menues(void)
{
  404d1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	connect_graphical_menues(&menue_lift_graphical, &menue_driver_graphical);
  404d20:	4c11      	ldr	r4, [pc, #68]	; (404d68 <init_menues+0x4c>)
  404d22:	f8df 8068 	ldr.w	r8, [pc, #104]	; 404d8c <init_menues+0x70>
	connect_graphical_menues(&menue_driver_graphical, &menue_util_graphical);
  404d26:	4f11      	ldr	r7, [pc, #68]	; (404d6c <init_menues+0x50>)
	connect_graphical_menues(&menue_lift_graphical, &menue_driver_graphical);
  404d28:	4620      	mov	r0, r4
  404d2a:	4d11      	ldr	r5, [pc, #68]	; (404d70 <init_menues+0x54>)
  404d2c:	4641      	mov	r1, r8
	connect_graphical_menues(&menue_util_graphical, &menue_faults_graphical);
  404d2e:	4e11      	ldr	r6, [pc, #68]	; (404d74 <init_menues+0x58>)
	connect_graphical_menues(&menue_lift_graphical, &menue_driver_graphical);
  404d30:	47a8      	blx	r5
	connect_graphical_menues(&menue_driver_graphical, &menue_util_graphical);
  404d32:	4640      	mov	r0, r8
  404d34:	4639      	mov	r1, r7
  404d36:	47a8      	blx	r5
	connect_graphical_menues(&menue_util_graphical, &menue_faults_graphical);
  404d38:	4638      	mov	r0, r7
  404d3a:	4631      	mov	r1, r6
  404d3c:	47a8      	blx	r5
	connect_graphical_menues(&menue_faults_graphical, &menue_lift_graphical);
  404d3e:	4621      	mov	r1, r4
  404d40:	4630      	mov	r0, r6
  404d42:	47a8      	blx	r5
	
	menue_lift_init(&menue_lift_graphical);	//init the menue images and other sub_lists
  404d44:	4620      	mov	r0, r4
  404d46:	4b0c      	ldr	r3, [pc, #48]	; (404d78 <init_menues+0x5c>)
  404d48:	4798      	blx	r3
	menue_drive_init(&menue_driver_graphical); //init the driver menue images and other sub_lists
  404d4a:	4640      	mov	r0, r8
  404d4c:	4b0b      	ldr	r3, [pc, #44]	; (404d7c <init_menues+0x60>)
  404d4e:	4798      	blx	r3
	menue_util_init(&menue_util_graphical);
  404d50:	4638      	mov	r0, r7
  404d52:	4b0b      	ldr	r3, [pc, #44]	; (404d80 <init_menues+0x64>)
  404d54:	4798      	blx	r3
	menue_faults_init(&menue_faults_graphical);
  404d56:	4630      	mov	r0, r6
  404d58:	4b0a      	ldr	r3, [pc, #40]	; (404d84 <init_menues+0x68>)
  404d5a:	4798      	blx	r3
	
	set_current_list(&menue_lift_graphical); //set the default active menue	
  404d5c:	4620      	mov	r0, r4
  404d5e:	4b0a      	ldr	r3, [pc, #40]	; (404d88 <init_menues+0x6c>)
}
  404d60:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	set_current_list(&menue_lift_graphical); //set the default active menue	
  404d64:	4718      	bx	r3
  404d66:	bf00      	nop
  404d68:	2040112c 	.word	0x2040112c
  404d6c:	2040118c 	.word	0x2040118c
  404d70:	0040c015 	.word	0x0040c015
  404d74:	2040114c 	.word	0x2040114c
  404d78:	00407355 	.word	0x00407355
  404d7c:	00405769 	.word	0x00405769
  404d80:	00407835 	.word	0x00407835
  404d84:	004070f9 	.word	0x004070f9
  404d88:	0040bbe1 	.word	0x0040bbe1
  404d8c:	204011ac 	.word	0x204011ac

00404d90 <req_dis_off>:
option_t opt_date_time[OPT_DATE_TIME_MAX];

#define ddate	          (opt_date_time[0])
#define dtime	          (opt_date_time[1])
void req_dis_off(void)
{
  404d90:	b4f0      	push	{r4, r5, r6, r7}
	ladvanced_controller_dis_val.text = "off";
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404d92:	4b0e      	ldr	r3, [pc, #56]	; (404dcc <req_dis_off+0x3c>)
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
	oval_ladvanced_controller_dis_val.real_count = 3;
	oval_ladvanced_controller_dis_val.max_value = 999;
	oval_ladvanced_controller_dis_val.min_value = 1;
  404d94:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
	oval_ladvanced_controller_dis_val.real_count = 3;
  404d98:	2403      	movs	r4, #3
	oval_ladvanced_controller_dis_val.max_value = 999;
  404d9a:	4f0d      	ldr	r7, [pc, #52]	; (404dd0 <req_dis_off+0x40>)
	oval_ladvanced_controller_dis_val.new_val_flag = &menue_lift_data_newdata_flag;
  404d9c:	4e0d      	ldr	r6, [pc, #52]	; (404dd4 <req_dis_off+0x44>)
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404d9e:	2001      	movs	r0, #1
	//oval_ladvanced_controller_dis_val.unit = "Sec";
	//oval_ladvanced_controller_dis_val.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.m_unit_out;
  404da0:	4d0d      	ldr	r5, [pc, #52]	; (404dd8 <req_dis_off+0x48>)
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
  404da2:	2100      	movs	r1, #0
	oval_ladvanced_controller_dis_val.min_value = 1;
  404da4:	619a      	str	r2, [r3, #24]
	oval_ladvanced_controller_dis_val.real_count = 3;
  404da6:	605c      	str	r4, [r3, #4]
	ladvanced_controller_dis_val.text = "off";
  404da8:	4a0c      	ldr	r2, [pc, #48]	; (404ddc <req_dis_off+0x4c>)
  404daa:	4c0d      	ldr	r4, [pc, #52]	; (404de0 <req_dis_off+0x50>)
	oval_ladvanced_controller_dis_val.max_value = 999;
  404dac:	615f      	str	r7, [r3, #20]
	oval_ladvanced_controller_dis_val.new_val_flag = &menue_lift_data_newdata_flag;
  404dae:	621e      	str	r6, [r3, #32]
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.m_unit_out;
  404db0:	61dd      	str	r5, [r3, #28]
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404db2:	7018      	strb	r0, [r3, #0]
	ladvanced_controller_dis_val.option_save_val = &oval_ladvanced_controller_dis_val;
	ladvanced_controller_dis_val.option_characteristics = OPTION_HIDDEN;
  404db4:	f882 00b0 	strb.w	r0, [r2, #176]	; 0xb0
	ladvanced_controller_dis_val.option_save_val = &oval_ladvanced_controller_dis_val;
  404db8:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
	ladvanced_controller_dis_val.text = "off";
  404dbc:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
  404dc0:	6099      	str	r1, [r3, #8]
	ladvanced_controller_dis_val.child = 0;
  404dc2:	f8c2 10c0 	str.w	r1, [r2, #192]	; 0xc0
}
  404dc6:	bcf0      	pop	{r4, r5, r6, r7}
  404dc8:	4770      	bx	lr
  404dca:	bf00      	nop
  404dcc:	204012b0 	.word	0x204012b0
  404dd0:	4479c000 	.word	0x4479c000
  404dd4:	204008ea 	.word	0x204008ea
  404dd8:	204051ee 	.word	0x204051ee
  404ddc:	204011e8 	.word	0x204011e8
  404de0:	0041a700 	.word	0x0041a700

00404de4 <req_dis_servicess>:

void req_dis_servicess(void)
{
	ladvanced_controller_dis_val.text = "Servicess count";
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404de4:	4b0e      	ldr	r3, [pc, #56]	; (404e20 <req_dis_servicess+0x3c>)
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
	oval_ladvanced_controller_dis_val.real_count = 4;
	oval_ladvanced_controller_dis_val.max_value = 9999;
	oval_ladvanced_controller_dis_val.min_value = 1;
  404de6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404dea:	2001      	movs	r0, #1
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
  404dec:	2100      	movs	r1, #0
{
  404dee:	b4f0      	push	{r4, r5, r6, r7}
	oval_ladvanced_controller_dis_val.real_count = 4;
  404df0:	2704      	movs	r7, #4
	oval_ladvanced_controller_dis_val.max_value = 9999;
  404df2:	4e0c      	ldr	r6, [pc, #48]	; (404e24 <req_dis_servicess+0x40>)
	oval_ladvanced_controller_dis_val.new_val_flag = &menue_lift_data_newdata_flag;
  404df4:	4d0c      	ldr	r5, [pc, #48]	; (404e28 <req_dis_servicess+0x44>)
	//oval_ladvanced_controller_dis_val.unit = "Sec";
	//oval_ladvanced_controller_dis_val.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.services;
  404df6:	4c0d      	ldr	r4, [pc, #52]	; (404e2c <req_dis_servicess+0x48>)
	oval_ladvanced_controller_dis_val.min_value = 1;
  404df8:	619a      	str	r2, [r3, #24]
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404dfa:	7018      	strb	r0, [r3, #0]
	ladvanced_controller_dis_val.text = "Servicess count";
  404dfc:	4a0c      	ldr	r2, [pc, #48]	; (404e30 <req_dis_servicess+0x4c>)
  404dfe:	480d      	ldr	r0, [pc, #52]	; (404e34 <req_dis_servicess+0x50>)
	oval_ladvanced_controller_dis_val.real_count = 4;
  404e00:	605f      	str	r7, [r3, #4]
	oval_ladvanced_controller_dis_val.max_value = 9999;
  404e02:	615e      	str	r6, [r3, #20]
	oval_ladvanced_controller_dis_val.new_val_flag = &menue_lift_data_newdata_flag;
  404e04:	621d      	str	r5, [r3, #32]
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.services;
  404e06:	61dc      	str	r4, [r3, #28]
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
  404e08:	6099      	str	r1, [r3, #8]
	ladvanced_controller_dis_val.option_save_val = &oval_ladvanced_controller_dis_val;
  404e0a:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
	ladvanced_controller_dis_val.option_characteristics = 0;
  404e0e:	f882 10b0 	strb.w	r1, [r2, #176]	; 0xb0
	ladvanced_controller_dis_val.child = 0;
  404e12:	f8c2 10c0 	str.w	r1, [r2, #192]	; 0xc0
	ladvanced_controller_dis_val.text = "Servicess count";
  404e16:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
}
  404e1a:	bcf0      	pop	{r4, r5, r6, r7}
  404e1c:	4770      	bx	lr
  404e1e:	bf00      	nop
  404e20:	204012b0 	.word	0x204012b0
  404e24:	461c3c00 	.word	0x461c3c00
  404e28:	204008ea 	.word	0x204008ea
  404e2c:	204052ac 	.word	0x204052ac
  404e30:	204011e8 	.word	0x204011e8
  404e34:	0041a704 	.word	0x0041a704

00404e38 <req_dis_time>:
void req_dis_time(void)
{
  404e38:	b5f0      	push	{r4, r5, r6, r7, lr}
	ladvanced_controller_dis_val.text = "Date/Time";
  404e3a:	4d11      	ldr	r5, [pc, #68]	; (404e80 <req_dis_time+0x48>)
	ladvanced_controller_dis_val.option_save_val = 0;
  404e3c:	2200      	movs	r2, #0
	ladvanced_controller_dis_val.text = "Date/Time";
  404e3e:	4f11      	ldr	r7, [pc, #68]	; (404e84 <req_dis_time+0x4c>)
{
  404e40:	b083      	sub	sp, #12
	ladvanced_controller_dis_val.option_characteristics = 0;
	
	ddate.text = "Set date";
  404e42:	4c11      	ldr	r4, [pc, #68]	; (404e88 <req_dis_time+0x50>)
	ddate.option_save_val = 3; //set date option
  404e44:	f04f 0c03 	mov.w	ip, #3
	ladvanced_controller_dis_val.text = "Date/Time";
  404e48:	f8c5 70a0 	str.w	r7, [r5, #160]	; 0xa0
	//////////////////////////////////////////////////////////////////////////
	
	dtime.text = "Set time";
	dtime.option_save_val = 4; //set time option
  404e4c:	f04f 0e04 	mov.w	lr, #4
	ddate.text = "Set date";
  404e50:	4f0e      	ldr	r7, [pc, #56]	; (404e8c <req_dis_time+0x54>)
	//////////////////////////////////////////////////////////////////////////

	fill_menue_list(&menue_date_time, opt_date_time, OPT_DATE_TIME_MAX, 0, 0);
  404e52:	4613      	mov	r3, r2
  404e54:	9200      	str	r2, [sp, #0]
  404e56:	4621      	mov	r1, r4
  404e58:	4e0d      	ldr	r6, [pc, #52]	; (404e90 <req_dis_time+0x58>)
	ddate.text = "Set date";
  404e5a:	6027      	str	r7, [r4, #0]
	dtime.text = "Set time";
  404e5c:	4f0d      	ldr	r7, [pc, #52]	; (404e94 <req_dis_time+0x5c>)
	fill_menue_list(&menue_date_time, opt_date_time, OPT_DATE_TIME_MAX, 0, 0);
  404e5e:	4630      	mov	r0, r6
	ladvanced_controller_dis_val.option_save_val = 0;
  404e60:	f8c5 20c4 	str.w	r2, [r5, #196]	; 0xc4
	ladvanced_controller_dis_val.option_characteristics = 0;
  404e64:	f885 20b0 	strb.w	r2, [r5, #176]	; 0xb0
	fill_menue_list(&menue_date_time, opt_date_time, OPT_DATE_TIME_MAX, 0, 0);
  404e68:	2202      	movs	r2, #2
	ddate.option_save_val = 3; //set date option
  404e6a:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
	dtime.option_save_val = 4; //set time option
  404e6e:	f8c4 e04c 	str.w	lr, [r4, #76]	; 0x4c
	dtime.text = "Set time";
  404e72:	62a7      	str	r7, [r4, #40]	; 0x28
	fill_menue_list(&menue_date_time, opt_date_time, OPT_DATE_TIME_MAX, 0, 0);
  404e74:	4c08      	ldr	r4, [pc, #32]	; (404e98 <req_dis_time+0x60>)
  404e76:	47a0      	blx	r4

	ladvanced_controller_dis_val.child = &menue_date_time;
  404e78:	f8c5 60c0 	str.w	r6, [r5, #192]	; 0xc0
}
  404e7c:	b003      	add	sp, #12
  404e7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  404e80:	204011e8 	.word	0x204011e8
  404e84:	0041a714 	.word	0x0041a714
  404e88:	20401368 	.word	0x20401368
  404e8c:	0041a720 	.word	0x0041a720
  404e90:	20401470 	.word	0x20401470
  404e94:	0041a72c 	.word	0x0041a72c
  404e98:	0040b0ad 	.word	0x0040b0ad

00404e9c <menue_advanced_init>:
menue_design_t *menue_advanced_init(void)
{
  404e9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	oval_ladvanced_cam_trials.max_value = 9;
	oval_ladvanced_cam_trials.min_value = 1;
	oval_ladvanced_cam_trials.new_val_flag = &menue_lift_data_newdata_flag;
	//oval_ladvanced_cam_trials.unit = "Sec";
	//oval_ladvanced_cam_trials.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_ladvanced_cam_trials.val = &menue_lift_data_setup.m_cam_trials;
  404ea0:	4d60      	ldr	r5, [pc, #384]	; (405024 <menue_advanced_init+0x188>)
	ladvanced_parking_floor.text = "Parking floor";
	oval_ladvanced_parking_floor.data_types = uint8_dt;
	oval_ladvanced_parking_floor.mantissa_count = 0;
	oval_ladvanced_parking_floor.real_count = 2;
	oval_ladvanced_parking_floor.max_value = 23;
	oval_ladvanced_parking_floor.min_value = 0;
  404ea2:	f04f 0800 	mov.w	r8, #0
	oval_ladvanced_parking_floor.data_types = uint8_dt;
  404ea6:	4f60      	ldr	r7, [pc, #384]	; (405028 <menue_advanced_init+0x18c>)
	oval_ladvanced_cam_trials.data_types = uint8_dt;
  404ea8:	2600      	movs	r6, #0
	req_pin_3inputs.text = "3 req buttons";
	req_pin_2inputs.text = "2 req buttons";
	req_pin_1inputs.text = "2 shared req buttons";


	fill_menue_list(&menue_advanced_req_pins, &opt_advanced_req_pins, OPT_ADVANCED_REQ_PINS_MAX, 0, &menue_lift_data_setup.m_req_pin_config);
  404eaa:	1c69      	adds	r1, r5, #1
	oval_ladvanced_parking_floor.max_value = 23;
  404eac:	f8df e1a8 	ldr.w	lr, [pc, #424]	; 405058 <menue_advanced_init+0x1bc>
	oval_ladvanced_cam_trials.max_value = 9;
  404eb0:	4c5e      	ldr	r4, [pc, #376]	; (40502c <menue_advanced_init+0x190>)
	oval_ladvanced_cam_trials.real_count = 1;
  404eb2:	f04f 0901 	mov.w	r9, #1
	oval_ladvanced_parking_floor.val = &menue_lift_data_setup.m_parking_floor;
  404eb6:	1d28      	adds	r0, r5, #4
	oval_ladvanced_parking_floor.real_count = 2;
  404eb8:	2202      	movs	r2, #2
	req_pin_3inputs.text = "3 req buttons";
  404eba:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 40505c <menue_advanced_init+0x1c0>
	fill_menue_list(&menue_advanced_req_pins, &opt_advanced_req_pins, OPT_ADVANCED_REQ_PINS_MAX, 0, &menue_lift_data_setup.m_req_pin_config);
  404ebe:	4633      	mov	r3, r6
  404ec0:	f8df b19c 	ldr.w	fp, [pc, #412]	; 405060 <menue_advanced_init+0x1c4>
	ladvanced_cam_trials.text = "CAM trials";
  404ec4:	f8df a19c 	ldr.w	sl, [pc, #412]	; 405064 <menue_advanced_init+0x1c8>
{
  404ec8:	ed2d 8b02 	vpush	{d8}
  404ecc:	b083      	sub	sp, #12
	oval_ladvanced_cam_trials.min_value = 1;
  404ece:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
	fill_menue_list(&menue_advanced_req_pins, &opt_advanced_req_pins, OPT_ADVANCED_REQ_PINS_MAX, 0, &menue_lift_data_setup.m_req_pin_config);
  404ed2:	9100      	str	r1, [sp, #0]
  404ed4:	4661      	mov	r1, ip
	oval_ladvanced_parking_floor.max_value = 23;
  404ed6:	f8c7 e014 	str.w	lr, [r7, #20]
	oval_ladvanced_cam_trials.data_types = uint8_dt;
  404eda:	f8df e18c 	ldr.w	lr, [pc, #396]	; 405068 <menue_advanced_init+0x1cc>
	oval_ladvanced_parking_floor.min_value = 0;
  404ede:	f8c7 8018 	str.w	r8, [r7, #24]
	oval_ladvanced_cam_trials.max_value = 9;
  404ee2:	f8ce 4014 	str.w	r4, [lr, #20]
	oval_ladvanced_cam_trials.new_val_flag = &menue_lift_data_newdata_flag;
  404ee6:	f8df 8184 	ldr.w	r8, [pc, #388]	; 40506c <menue_advanced_init+0x1d0>
	ladvanced_cam_trials.text = "CAM trials";
  404eea:	4c51      	ldr	r4, [pc, #324]	; (405030 <menue_advanced_init+0x194>)
	oval_ladvanced_cam_trials.val = &menue_lift_data_setup.m_cam_trials;
  404eec:	f8ce 501c 	str.w	r5, [lr, #28]
	oval_ladvanced_cam_trials.data_types = uint8_dt;
  404ef0:	f88e 6000 	strb.w	r6, [lr]
	oval_ladvanced_cam_trials.mantissa_count = 0;
  404ef4:	f8ce 6008 	str.w	r6, [lr, #8]
	oval_ladvanced_cam_trials.real_count = 1;
  404ef8:	f8ce 9004 	str.w	r9, [lr, #4]
	oval_ladvanced_cam_trials.min_value = 1;
  404efc:	ed8e 8a06 	vstr	s16, [lr, #24]
	oval_ladvanced_cam_trials.new_val_flag = &menue_lift_data_newdata_flag;
  404f00:	f8ce 8020 	str.w	r8, [lr, #32]
	ladvanced_cam_trials.option_save_val = &oval_ladvanced_cam_trials;
  404f04:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
	ladvanced_parking_floor.text = "Parking floor";
  404f08:	f8df e164 	ldr.w	lr, [pc, #356]	; 405070 <menue_advanced_init+0x1d4>
	oval_ladvanced_parking_floor.val = &menue_lift_data_setup.m_parking_floor;
  404f0c:	61f8      	str	r0, [r7, #28]
	fill_menue_list(&menue_advanced_req_pins, &opt_advanced_req_pins, OPT_ADVANCED_REQ_PINS_MAX, 0, &menue_lift_data_setup.m_req_pin_config);
  404f0e:	4658      	mov	r0, fp
	oval_ladvanced_parking_floor.real_count = 2;
  404f10:	607a      	str	r2, [r7, #4]
	fill_menue_list(&menue_advanced_req_pins, &opt_advanced_req_pins, OPT_ADVANCED_REQ_PINS_MAX, 0, &menue_lift_data_setup.m_req_pin_config);
  404f12:	2203      	movs	r2, #3
	oval_ladvanced_parking_floor.data_types = uint8_dt;
  404f14:	703e      	strb	r6, [r7, #0]
	oval_ladvanced_parking_floor.mantissa_count = 0;
  404f16:	60be      	str	r6, [r7, #8]
	oval_ladvanced_parking_floor.new_val_flag = &menue_lift_data_newdata_flag;
  404f18:	f8c7 8020 	str.w	r8, [r7, #32]
	ladvanced_parking_floor.option_save_val = &oval_ladvanced_parking_floor;
  404f1c:	64e7      	str	r7, [r4, #76]	; 0x4c
	ladvanced_parking_floor.text = "Parking floor";
  404f1e:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
	ladvanced_req_pins.text = "Request Pins config";
  404f22:	4f44      	ldr	r7, [pc, #272]	; (405034 <menue_advanced_init+0x198>)
	req_pin_3inputs.text = "3 req buttons";
  404f24:	f8df e14c 	ldr.w	lr, [pc, #332]	; 405074 <menue_advanced_init+0x1d8>
	ladvanced_req_pins.text = "Request Pins config";
  404f28:	6527      	str	r7, [r4, #80]	; 0x50
	req_pin_3inputs.text = "3 req buttons";
  404f2a:	f8cc e000 	str.w	lr, [ip]
	req_pin_2inputs.text = "2 req buttons";
  404f2e:	4f42      	ldr	r7, [pc, #264]	; (405038 <menue_advanced_init+0x19c>)
	req_pin_1inputs.text = "2 shared req buttons";
  404f30:	f8df e144 	ldr.w	lr, [pc, #324]	; 405078 <menue_advanced_init+0x1dc>
	req_pin_2inputs.text = "2 req buttons";
  404f34:	f8cc 7028 	str.w	r7, [ip, #40]	; 0x28
	req_pin_1inputs.text = "2 shared req buttons";
  404f38:	f8cc e050 	str.w	lr, [ip, #80]	; 0x50
	ladvanced_cam_trials.text = "CAM trials";
  404f3c:	f8c4 a000 	str.w	sl, [r4]
	fill_menue_list(&menue_advanced_req_pins, &opt_advanced_req_pins, OPT_ADVANCED_REQ_PINS_MAX, 0, &menue_lift_data_setup.m_req_pin_config);
  404f40:	4f3e      	ldr	r7, [pc, #248]	; (40503c <menue_advanced_init+0x1a0>)
  404f42:	47b8      	blx	r7
	contr_dis_timeout.enter = &req_dis_time;
	contr_dis_services.text = "Services disable";
	contr_dis_services.enter = &req_dis_servicess;


	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f44:	f105 02ba 	add.w	r2, r5, #186	; 0xba
	ladvanced_controller_dis_tech.text = "Req disable tech";
  404f48:	f8df c130 	ldr.w	ip, [pc, #304]	; 40507c <menue_advanced_init+0x1e0>

	// set the 'option ladvanced_req_pins' child

	ladvanced_controller_dis_tech.child = &menue_advanced_controller_dis_tech;
//__________________________________________________
	if(menue_lift_data_setup.m_cont_dis_technique == 1) req_dis_servicess();
  404f4c:	3d08      	subs	r5, #8
	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f4e:	9200      	str	r2, [sp, #0]
  404f50:	4633      	mov	r3, r6
	contr_dis_off.text = "Off";
  404f52:	f8df e12c 	ldr.w	lr, [pc, #300]	; 405080 <menue_advanced_init+0x1e4>
	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f56:	2203      	movs	r2, #3
	ladvanced_req_pins.child = &menue_advanced_req_pins;
  404f58:	f8c4 b070 	str.w	fp, [r4, #112]	; 0x70
	ladvanced_controller_dis_tech.text = "Req disable tech";
  404f5c:	f8c4 c078 	str.w	ip, [r4, #120]	; 0x78
	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f60:	4671      	mov	r1, lr
	contr_dis_off.text = "Off";
  404f62:	f8df b120 	ldr.w	fp, [pc, #288]	; 405084 <menue_advanced_init+0x1e8>
	contr_dis_off.enter = &req_dis_off;
  404f66:	f8df c120 	ldr.w	ip, [pc, #288]	; 405088 <menue_advanced_init+0x1ec>
	contr_dis_off.text = "Off";
  404f6a:	f8ce b000 	str.w	fp, [lr]
	contr_dis_off.enter = &req_dis_off;
  404f6e:	f8ce c014 	str.w	ip, [lr, #20]
	contr_dis_timeout.text = "Time disable";
  404f72:	f8df b118 	ldr.w	fp, [pc, #280]	; 40508c <menue_advanced_init+0x1f0>
	contr_dis_services.text = "Services disable";
  404f76:	f8df c118 	ldr.w	ip, [pc, #280]	; 405090 <menue_advanced_init+0x1f4>
	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f7a:	f8df a118 	ldr.w	sl, [pc, #280]	; 405094 <menue_advanced_init+0x1f8>
	contr_dis_timeout.text = "Time disable";
  404f7e:	f8ce b050 	str.w	fp, [lr, #80]	; 0x50
	contr_dis_services.text = "Services disable";
  404f82:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f86:	4650      	mov	r0, sl
	contr_dis_services.enter = &req_dis_servicess;
  404f88:	f8df c10c 	ldr.w	ip, [pc, #268]	; 405098 <menue_advanced_init+0x1fc>
	contr_dis_timeout.enter = &req_dis_time;
  404f8c:	f8df b10c 	ldr.w	fp, [pc, #268]	; 40509c <menue_advanced_init+0x200>
	contr_dis_services.enter = &req_dis_servicess;
  404f90:	f8ce c03c 	str.w	ip, [lr, #60]	; 0x3c
	contr_dis_timeout.enter = &req_dis_time;
  404f94:	f8ce b064 	str.w	fp, [lr, #100]	; 0x64
	fill_menue_list(&menue_advanced_controller_dis_tech, &opt_advanced_controller_dis_tech, OPT_ADVANCED_CONTROLLER_DIS_TECH_MAX, 0, &menue_lift_data_setup.m_cont_dis_technique);
  404f98:	47b8      	blx	r7
	if(menue_lift_data_setup.m_cont_dis_technique == 1) req_dis_servicess();
  404f9a:	f895 30c2 	ldrb.w	r3, [r5, #194]	; 0xc2
	ladvanced_controller_dis_tech.child = &menue_advanced_controller_dis_tech;
  404f9e:	f8c4 a098 	str.w	sl, [r4, #152]	; 0x98
	if(menue_lift_data_setup.m_cont_dis_technique == 1) req_dis_servicess();
  404fa2:	454b      	cmp	r3, r9
  404fa4:	d024      	beq.n	404ff0 <menue_advanced_init+0x154>
	else if(menue_lift_data_setup.m_cont_dis_technique == 2) req_dis_time();
  404fa6:	2b02      	cmp	r3, #2
  404fa8:	d039      	beq.n	40501e <menue_advanced_init+0x182>
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404faa:	4b25      	ldr	r3, [pc, #148]	; (405040 <menue_advanced_init+0x1a4>)
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.m_unit_out;
  404fac:	350e      	adds	r5, #14
	oval_ladvanced_controller_dis_val.real_count = 3;
  404fae:	2003      	movs	r0, #3
	oval_ladvanced_controller_dis_val.max_value = 999;
  404fb0:	4924      	ldr	r1, [pc, #144]	; (405044 <menue_advanced_init+0x1a8>)
	ladvanced_controller_dis_val.text = "off";
  404fb2:	4a25      	ldr	r2, [pc, #148]	; (405048 <menue_advanced_init+0x1ac>)
	ladvanced_controller_dis_val.option_characteristics = OPTION_HIDDEN;
  404fb4:	f884 90b0 	strb.w	r9, [r4, #176]	; 0xb0
	ladvanced_controller_dis_val.child = 0;
  404fb8:	f8c4 60c0 	str.w	r6, [r4, #192]	; 0xc0
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.m_unit_out;
  404fbc:	61dd      	str	r5, [r3, #28]
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404fbe:	f883 9000 	strb.w	r9, [r3]
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
  404fc2:	609e      	str	r6, [r3, #8]
	oval_ladvanced_controller_dis_val.min_value = 1;
  404fc4:	ed83 8a06 	vstr	s16, [r3, #24]
	oval_ladvanced_controller_dis_val.new_val_flag = &menue_lift_data_newdata_flag;
  404fc8:	f8c3 8020 	str.w	r8, [r3, #32]
	ladvanced_controller_dis_val.option_save_val = &oval_ladvanced_controller_dis_val;
  404fcc:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	oval_ladvanced_controller_dis_val.real_count = 3;
  404fd0:	6058      	str	r0, [r3, #4]
	oval_ladvanced_controller_dis_val.max_value = 999;
  404fd2:	6159      	str	r1, [r3, #20]
	ladvanced_controller_dis_val.text = "off";
  404fd4:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	else req_dis_off();
//__________________________________________________
	
	
	fill_menue_list(&menue_advanced, opt_advanced, OPT_ADVANCED_MAX, 0, 0);
  404fd8:	2300      	movs	r3, #0
  404fda:	2205      	movs	r2, #5
  404fdc:	4914      	ldr	r1, [pc, #80]	; (405030 <menue_advanced_init+0x194>)
  404fde:	9300      	str	r3, [sp, #0]
  404fe0:	481a      	ldr	r0, [pc, #104]	; (40504c <menue_advanced_init+0x1b0>)
  404fe2:	47b8      	blx	r7
	return &menue_advanced;
  404fe4:	4819      	ldr	r0, [pc, #100]	; (40504c <menue_advanced_init+0x1b0>)
  404fe6:	b003      	add	sp, #12
  404fe8:	ecbd 8b02 	vpop	{d8}
  404fec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404ff0:	4a13      	ldr	r2, [pc, #76]	; (405040 <menue_advanced_init+0x1a4>)
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.services;
  404ff2:	35cc      	adds	r5, #204	; 0xcc
	oval_ladvanced_controller_dis_val.real_count = 4;
  404ff4:	2004      	movs	r0, #4
	oval_ladvanced_controller_dis_val.max_value = 9999;
  404ff6:	4916      	ldr	r1, [pc, #88]	; (405050 <menue_advanced_init+0x1b4>)
	oval_ladvanced_controller_dis_val.data_types = uint16_dt;
  404ff8:	7013      	strb	r3, [r2, #0]
	ladvanced_controller_dis_val.text = "Servicess count";
  404ffa:	4b16      	ldr	r3, [pc, #88]	; (405054 <menue_advanced_init+0x1b8>)
	ladvanced_controller_dis_val.option_characteristics = 0;
  404ffc:	f884 60b0 	strb.w	r6, [r4, #176]	; 0xb0
	ladvanced_controller_dis_val.child = 0;
  405000:	f8c4 60c0 	str.w	r6, [r4, #192]	; 0xc0
	oval_ladvanced_controller_dis_val.val = &menue_lift_data_setup.services;
  405004:	61d5      	str	r5, [r2, #28]
	oval_ladvanced_controller_dis_val.mantissa_count = 0;
  405006:	6096      	str	r6, [r2, #8]
	oval_ladvanced_controller_dis_val.min_value = 1;
  405008:	ed82 8a06 	vstr	s16, [r2, #24]
	oval_ladvanced_controller_dis_val.new_val_flag = &menue_lift_data_newdata_flag;
  40500c:	f8c2 8020 	str.w	r8, [r2, #32]
	ladvanced_controller_dis_val.option_save_val = &oval_ladvanced_controller_dis_val;
  405010:	f8c4 20c4 	str.w	r2, [r4, #196]	; 0xc4
	oval_ladvanced_controller_dis_val.real_count = 4;
  405014:	6050      	str	r0, [r2, #4]
	oval_ladvanced_controller_dis_val.max_value = 9999;
  405016:	6151      	str	r1, [r2, #20]
	ladvanced_controller_dis_val.text = "Servicess count";
  405018:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
  40501c:	e7dc      	b.n	404fd8 <menue_advanced_init+0x13c>
	else if(menue_lift_data_setup.m_cont_dis_technique == 2) req_dis_time();
  40501e:	47d8      	blx	fp
  405020:	e7da      	b.n	404fd8 <menue_advanced_init+0x13c>
  405022:	bf00      	nop
  405024:	204051e8 	.word	0x204051e8
  405028:	204013b8 	.word	0x204013b8
  40502c:	41100000 	.word	0x41100000
  405030:	204011e8 	.word	0x204011e8
  405034:	0041a67c 	.word	0x0041a67c
  405038:	0041a6a0 	.word	0x0041a6a0
  40503c:	0040b0ad 	.word	0x0040b0ad
  405040:	204012b0 	.word	0x204012b0
  405044:	4479c000 	.word	0x4479c000
  405048:	0041a700 	.word	0x0041a700
  40504c:	204011cc 	.word	0x204011cc
  405050:	461c3c00 	.word	0x461c3c00
  405054:	0041a704 	.word	0x0041a704
  405058:	41b80000 	.word	0x41b80000
  40505c:	204013dc 	.word	0x204013dc
  405060:	204012d4 	.word	0x204012d4
  405064:	0041a660 	.word	0x0041a660
  405068:	2040148c 	.word	0x2040148c
  40506c:	204008ea 	.word	0x204008ea
  405070:	0041a66c 	.word	0x0041a66c
  405074:	0041a690 	.word	0x0041a690
  405078:	0041a6b0 	.word	0x0041a6b0
  40507c:	0041a6c8 	.word	0x0041a6c8
  405080:	204012f0 	.word	0x204012f0
  405084:	0041a63c 	.word	0x0041a63c
  405088:	00404d91 	.word	0x00404d91
  40508c:	0041a6dc 	.word	0x0041a6dc
  405090:	0041a6ec 	.word	0x0041a6ec
  405094:	20401454 	.word	0x20401454
  405098:	00404de5 	.word	0x00404de5
  40509c:	00404e39 	.word	0x00404e39

004050a0 <menue_basic_init>:
	return 1;
}
//struct menue_design test_list;

menue_design_t *menue_basic_init(void)
{
  4050a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	door_count_option_val.max_value			=  23;
	door_count_option_val.min_value			=  1;
	//door_count_option_val.unit				= "d";
	door_count_option_val.text = "Enter your building number of doors";
	
	door_count_option_val.val				= &menue_lift_data_setup.m_floor_count;
  4050a4:	4f66      	ldr	r7, [pc, #408]	; (405240 <menue_basic_init+0x1a0>)
{
  4050a6:	b083      	sub	sp, #12
	door_count_option_val.data_types = uint8_dt;
  4050a8:	4e66      	ldr	r6, [pc, #408]	; (405244 <menue_basic_init+0x1a4>)
	door_count_option_val.min_value			=  1;
  4050aa:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
	display_type_7seg.text = "7 Segments";
	display_type_binary.text = "Binary";
	display_type_binarypos.text = "Binary Pos";
	display_type_decoder.text = "Decoder";

	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  4050ae:	f1a7 010a 	sub.w	r1, r7, #10
	door_count_option_val.text = "Enter your building number of doors";
  4050b2:	4c65      	ldr	r4, [pc, #404]	; (405248 <menue_basic_init+0x1a8>)
	door_count_option_val.data_types = uint8_dt;
  4050b4:	2500      	movs	r5, #0
	door_count_option_val.real_count		=  2;
  4050b6:	f04f 0902 	mov.w	r9, #2
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  4050ba:	9100      	str	r1, [sp, #0]
	door_count_option_val.max_value			=  23;
  4050bc:	4a63      	ldr	r2, [pc, #396]	; (40524c <menue_basic_init+0x1ac>)
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  4050be:	462b      	mov	r3, r5
	door_count_option_val.min_value			=  1;
  4050c0:	f8c6 c018 	str.w	ip, [r6, #24]
	door_count_option_val.text = "Enter your building number of doors";
  4050c4:	6134      	str	r4, [r6, #16]
	door_count_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
  4050c6:	f8df c1c0 	ldr.w	ip, [pc, #448]	; 405288 <menue_basic_init+0x1e8>
	door_count.text = "Floors count";
  4050ca:	4c61      	ldr	r4, [pc, #388]	; (405250 <menue_basic_init+0x1b0>)
	display_type_7seg.text = "7 Segments";
  4050cc:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 40528c <menue_basic_init+0x1ec>
	door_count_option_val.val				= &menue_lift_data_setup.m_floor_count;
  4050d0:	61f7      	str	r7, [r6, #28]
	door_count_option_val.max_value			=  23;
  4050d2:	6172      	str	r2, [r6, #20]
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  4050d4:	4671      	mov	r1, lr
	door_count_option_val.new_val_flag		= &menue_lift_data_newdata_flag;
  4050d6:	f8c6 c020 	str.w	ip, [r6, #32]
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  4050da:	2204      	movs	r2, #4
	door_count_option_val.data_types = uint8_dt;
  4050dc:	7035      	strb	r5, [r6, #0]
	door_count_option_val.mantissa_count	=  0;
  4050de:	60b5      	str	r5, [r6, #8]
	door_count_option_val.real_count		=  2;
  4050e0:	f8c6 9004 	str.w	r9, [r6, #4]
	door_count.option_save_val = &door_count_option_val;
  4050e4:	6266      	str	r6, [r4, #36]	; 0x24
	door_count.text = "Floors count";
  4050e6:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 405290 <menue_basic_init+0x1f0>
	display_type_7seg.text = "7 Segments";
  4050ea:	4e5a      	ldr	r6, [pc, #360]	; (405254 <menue_basic_init+0x1b4>)
	door_count.text = "Floors count";
  4050ec:	f8c4 c000 	str.w	ip, [r4]
	display_type_7seg.text = "7 Segments";
  4050f0:	f8ce 6000 	str.w	r6, [lr]
	display_type.text = "Display type";
  4050f4:	f8df c19c 	ldr.w	ip, [pc, #412]	; 405294 <menue_basic_init+0x1f4>
	display_type_binarypos.text = "Binary Pos";
  4050f8:	4e57      	ldr	r6, [pc, #348]	; (405258 <menue_basic_init+0x1b8>)
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  4050fa:	f8df b19c 	ldr.w	fp, [pc, #412]	; 405298 <menue_basic_init+0x1f8>
	display_type.text = "Display type";
  4050fe:	f8c4 c028 	str.w	ip, [r4, #40]	; 0x28
	display_type_binarypos.text = "Binary Pos";
  405102:	f8ce 6078 	str.w	r6, [lr, #120]	; 0x78
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  405106:	4658      	mov	r0, fp
	display_type_binary.text = "Binary";
  405108:	f8df c190 	ldr.w	ip, [pc, #400]	; 40529c <menue_basic_init+0x1fc>
	display_type_decoder.text = "Decoder";
  40510c:	4e53      	ldr	r6, [pc, #332]	; (40525c <menue_basic_init+0x1bc>)
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  40510e:	f8df 8190 	ldr.w	r8, [pc, #400]	; 4052a0 <menue_basic_init+0x200>
	display_type_binary.text = "Binary";
  405112:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	display_type_decoder.text = "Decoder";
  405116:	f8ce 6050 	str.w	r6, [lr, #80]	; 0x50
	fill_menue_list(&menue_basic1_display_types, &opt_basic1_display_types, OPT_BASIC_DISPLAY_TYPES_MAX, 0, &menue_lift_data_setup.m_display_type);
  40511a:	47c0      	blx	r8
	
	floor_disp.text = "Floor display";
	
	floor_disp_floorNumber.text = "Enter floor number";
	
	floor_disp_option_val.data_types = uint8_dt;
  40511c:	4e50      	ldr	r6, [pc, #320]	; (405260 <menue_basic_init+0x1c0>)
	floor_disp_option_val.mantissa_count	=  0;
	floor_disp_option_val.real_count		=  2;
	floor_disp_option_val.max_value			=  24;
  40511e:	f8df c184 	ldr.w	ip, [pc, #388]	; 4052a4 <menue_basic_init+0x204>
	
	floor_disp_floorDisp.text = "Floor Display";
	floor_disp_floorDisp.exe = &floor_dislplay_menue_exe;
	floor_disp_floorDisp.enter = &floor_dislplay_menue_enter;
	
	fill_menue_list(&menue_basic1_floor_disp, &opt_basic1_floor_disp, OPT_BASIC_FLOOR_DISP_MAX, 0, 0);
  405122:	462b      	mov	r3, r5
  405124:	9500      	str	r5, [sp, #0]
  405126:	464a      	mov	r2, r9
	floor_disp_option_val.max_value			=  24;
  405128:	f8c6 c014 	str.w	ip, [r6, #20]
	floor_disp_option_val.min_value			=  0;
  40512c:	f04f 0c00 	mov.w	ip, #0
	floor_disp_floorNumber.text = "Enter floor number";
  405130:	f8df e174 	ldr.w	lr, [pc, #372]	; 4052a8 <menue_basic_init+0x208>
	floor_disp_option_val.min_value			=  0;
  405134:	f8c6 c018 	str.w	ip, [r6, #24]
	floor_disp_option_val.val				= &start_floor_floor_display;
  405138:	f8df c170 	ldr.w	ip, [pc, #368]	; 4052ac <menue_basic_init+0x20c>
	fill_menue_list(&menue_basic1_floor_disp, &opt_basic1_floor_disp, OPT_BASIC_FLOOR_DISP_MAX, 0, 0);
  40513c:	4671      	mov	r1, lr
	floor_disp_option_val.data_types = uint8_dt;
  40513e:	7035      	strb	r5, [r6, #0]
	floor_disp_option_val.val				= &start_floor_floor_display;
  405140:	f8c6 c01c 	str.w	ip, [r6, #28]
	floor_disp_floorNumber.text = "Enter floor number";
  405144:	f8df c168 	ldr.w	ip, [pc, #360]	; 4052b0 <menue_basic_init+0x210>
	floor_disp_option_val.mantissa_count	=  0;
  405148:	60b5      	str	r5, [r6, #8]
	floor_disp_option_val.real_count		=  2;
  40514a:	f8c6 9004 	str.w	r9, [r6, #4]
	floor_disp_floorNumber.option_save_val = &floor_disp_option_val;
  40514e:	f8ce 6024 	str.w	r6, [lr, #36]	; 0x24
	floor_disp_option_val.text = "Enter floor number";
  405152:	f8c6 c010 	str.w	ip, [r6, #16]
	floor_disp_floorDisp.exe = &floor_dislplay_menue_exe;
  405156:	4e43      	ldr	r6, [pc, #268]	; (405264 <menue_basic_init+0x1c4>)
	fill_menue_list(&menue_basic1_floor_disp, &opt_basic1_floor_disp, OPT_BASIC_FLOOR_DISP_MAX, 0, 0);
  405158:	f8df a158 	ldr.w	sl, [pc, #344]	; 4052b4 <menue_basic_init+0x214>
	floor_disp_floorNumber.text = "Enter floor number";
  40515c:	f8ce c000 	str.w	ip, [lr]
	floor_disp_floorDisp.exe = &floor_dislplay_menue_exe;
  405160:	f8ce 6030 	str.w	r6, [lr, #48]	; 0x30
	floor_disp_floorDisp.text = "Floor Display";
  405164:	f8df c150 	ldr.w	ip, [pc, #336]	; 4052b8 <menue_basic_init+0x218>
	floor_disp.text = "Floor display";
  405168:	483f      	ldr	r0, [pc, #252]	; (405268 <menue_basic_init+0x1c8>)
	floor_disp_floorDisp.enter = &floor_dislplay_menue_enter;
  40516a:	4e40      	ldr	r6, [pc, #256]	; (40526c <menue_basic_init+0x1cc>)
	display_type.child = &menue_basic1_display_types;
  40516c:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	floor_disp.text = "Floor display";
  405170:	6520      	str	r0, [r4, #80]	; 0x50
	fill_menue_list(&menue_basic1_floor_disp, &opt_basic1_floor_disp, OPT_BASIC_FLOOR_DISP_MAX, 0, 0);
  405172:	4650      	mov	r0, sl
	floor_disp_floorDisp.text = "Floor Display";
  405174:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	floor_disp_floorDisp.enter = &floor_dislplay_menue_enter;
  405178:	f8ce 603c 	str.w	r6, [lr, #60]	; 0x3c
	fill_menue_list(&menue_basic1_floor_disp, &opt_basic1_floor_disp, OPT_BASIC_FLOOR_DISP_MAX, 0, 0);
  40517c:	47c0      	blx	r8

//__________________________________________________

	door_type.text = "door type";
	//fill menue door options
	door_type_manual.text = "Manual";
  40517e:	4e3c      	ldr	r6, [pc, #240]	; (405270 <menue_basic_init+0x1d0>)
	door_type_internal_auto.text = "Internal automatic";
	door_type_auto_closed.text = "Automatic N closed";
	door_type_auto_open.text = "Automatic N open";
	
	fill_menue_list(&menue_basic1_door_types, opt_basic1_door_types, OPT_BASIC_DOOR_TYPES_MAX, 0, &menue_lift_data_setup.m_door_type);
  405180:	f1a7 0109 	sub.w	r1, r7, #9
	door_type_manual.text = "Manual";
  405184:	f8df c134 	ldr.w	ip, [pc, #308]	; 4052bc <menue_basic_init+0x21c>
	door_type_internal_auto.text = "Internal automatic";
  405188:	f8df e134 	ldr.w	lr, [pc, #308]	; 4052c0 <menue_basic_init+0x220>
	fill_menue_list(&menue_basic1_door_types, opt_basic1_door_types, OPT_BASIC_DOOR_TYPES_MAX, 0, &menue_lift_data_setup.m_door_type);
  40518c:	462b      	mov	r3, r5
  40518e:	9100      	str	r1, [sp, #0]
  405190:	4631      	mov	r1, r6
  405192:	f8df b130 	ldr.w	fp, [pc, #304]	; 4052c4 <menue_basic_init+0x224>
	door_type_manual.text = "Manual";
  405196:	f8c6 c000 	str.w	ip, [r6]
	door_type_internal_auto.text = "Internal automatic";
  40519a:	f8c6 e028 	str.w	lr, [r6, #40]	; 0x28
	fill_menue_list(&menue_basic1_door_types, opt_basic1_door_types, OPT_BASIC_DOOR_TYPES_MAX, 0, &menue_lift_data_setup.m_door_type);
  40519e:	4658      	mov	r0, fp
	door_type_auto_closed.text = "Automatic N closed";
  4051a0:	f8df c124 	ldr.w	ip, [pc, #292]	; 4052c8 <menue_basic_init+0x228>
	door_type_auto_open.text = "Automatic N open";
  4051a4:	f8df e124 	ldr.w	lr, [pc, #292]	; 4052cc <menue_basic_init+0x22c>
	door_type.text = "door type";
  4051a8:	4a32      	ldr	r2, [pc, #200]	; (405274 <menue_basic_init+0x1d4>)
	floor_disp.child = &menue_basic1_floor_disp;	
  4051aa:	f8c4 a070 	str.w	sl, [r4, #112]	; 0x70
	door_type.text = "door type";
  4051ae:	67a2      	str	r2, [r4, #120]	; 0x78
	fill_menue_list(&menue_basic1_door_types, opt_basic1_door_types, OPT_BASIC_DOOR_TYPES_MAX, 0, &menue_lift_data_setup.m_door_type);
  4051b0:	2204      	movs	r2, #4
	door_type_auto_closed.text = "Automatic N closed";
  4051b2:	f8c6 c050 	str.w	ip, [r6, #80]	; 0x50
	door_type_auto_open.text = "Automatic N open";
  4051b6:	f8c6 e078 	str.w	lr, [r6, #120]	; 0x78
	fill_menue_list(&menue_basic1_door_types, opt_basic1_door_types, OPT_BASIC_DOOR_TYPES_MAX, 0, &menue_lift_data_setup.m_door_type);
  4051ba:	47c0      	blx	r8
	// set the 'option door_type' child to be menue_basic1_door_types
	//this way when you click door_type menue_basic1_door_types' items will appear!
	door_type.child = &menue_basic1_door_types;
//__________________________________________________	
	collective.text = "Registering system";
	collective_type_down24.text = "Down collect 24";
  4051bc:	f8df e110 	ldr.w	lr, [pc, #272]	; 4052d0 <menue_basic_init+0x230>
	collective_type_down.text = "Down collect";
	collective_type_updown.text = "Up down collect";
	
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051c0:	f1a7 0108 	sub.w	r1, r7, #8
	collective_type_down.text = "Down collect";
  4051c4:	f8df c10c 	ldr.w	ip, [pc, #268]	; 4052d4 <menue_basic_init+0x234>
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051c8:	4e2b      	ldr	r6, [pc, #172]	; (405278 <menue_basic_init+0x1d8>)
//__________________________________________________
	lift_direction.text = "Lift up direction";
	lift_direction_fwd.text = "Forward";
	lift_direction_rev.text = "Reverse";
	
	fill_menue_list(&menue_basic1_lift_directions, opt_basic1_lift_directions, OPT_BASIC_LIFT_DIRECTIONS_MAX, 0, &menue_lift_data_setup.m_up_dir);
  4051ca:	3701      	adds	r7, #1
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051cc:	9100      	str	r1, [sp, #0]
  4051ce:	462b      	mov	r3, r5
	collective_type_down.text = "Down collect";
  4051d0:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051d4:	4671      	mov	r1, lr
	collective_type_updown.text = "Up down collect";
  4051d6:	f8df c100 	ldr.w	ip, [pc, #256]	; 4052d8 <menue_basic_init+0x238>
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051da:	4630      	mov	r0, r6
	collective.text = "Registering system";
  4051dc:	4a27      	ldr	r2, [pc, #156]	; (40527c <menue_basic_init+0x1dc>)
	collective_type_down24.text = "Down collect 24";
  4051de:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 4052dc <menue_basic_init+0x23c>
	collective.text = "Registering system";
  4051e2:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051e6:	2203      	movs	r2, #3
	collective_type_down24.text = "Down collect 24";
  4051e8:	f8ce a000 	str.w	sl, [lr]
	collective_type_updown.text = "Up down collect";
  4051ec:	f8ce c050 	str.w	ip, [lr, #80]	; 0x50
	door_type.child = &menue_basic1_door_types;
  4051f0:	f8c4 b098 	str.w	fp, [r4, #152]	; 0x98
	fill_menue_list(&menue_basic1_collective_types, opt_basic1_collective_types, OPT_BASIC_COLLECTIVE_TYPES_MAX, 0, &menue_lift_data_setup.m_collection);
  4051f4:	47c0      	blx	r8
	fill_menue_list(&menue_basic1_lift_directions, opt_basic1_lift_directions, OPT_BASIC_LIFT_DIRECTIONS_MAX, 0, &menue_lift_data_setup.m_up_dir);
  4051f6:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 4052e0 <menue_basic_init+0x240>
  4051fa:	9700      	str	r7, [sp, #0]
  4051fc:	464a      	mov	r2, r9
	lift_direction_fwd.text = "Forward";
  4051fe:	f8df e0e4 	ldr.w	lr, [pc, #228]	; 4052e4 <menue_basic_init+0x244>
	fill_menue_list(&menue_basic1_lift_directions, opt_basic1_lift_directions, OPT_BASIC_LIFT_DIRECTIONS_MAX, 0, &menue_lift_data_setup.m_up_dir);
  405202:	462b      	mov	r3, r5
	lift_direction_fwd.text = "Forward";
  405204:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 4052e8 <menue_basic_init+0x248>
	fill_menue_list(&menue_basic1_lift_directions, opt_basic1_lift_directions, OPT_BASIC_LIFT_DIRECTIONS_MAX, 0, &menue_lift_data_setup.m_up_dir);
  405208:	4650      	mov	r0, sl
	lift_direction.text = "Lift up direction";
  40520a:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 4052ec <menue_basic_init+0x24c>
	fill_menue_list(&menue_basic1_lift_directions, opt_basic1_lift_directions, OPT_BASIC_LIFT_DIRECTIONS_MAX, 0, &menue_lift_data_setup.m_up_dir);
  40520e:	4671      	mov	r1, lr
	lift_direction_rev.text = "Reverse";
  405210:	4f1b      	ldr	r7, [pc, #108]	; (405280 <menue_basic_init+0x1e0>)
	collective.child = &menue_basic1_collective_types;
  405212:	f8c4 60c0 	str.w	r6, [r4, #192]	; 0xc0
	
	//Set the child to enter
	lift_direction.child = &menue_basic1_lift_directions;
//__________________________________________________
	fill_menue_list(&menue_basic1, opt_basic1, OPT_BASIC_MAX, 0, 0);
  405216:	4e1b      	ldr	r6, [pc, #108]	; (405284 <menue_basic_init+0x1e4>)
	lift_direction_fwd.text = "Forward";
  405218:	f8ce c000 	str.w	ip, [lr]
	lift_direction_rev.text = "Reverse";
  40521c:	f8ce 7028 	str.w	r7, [lr, #40]	; 0x28
	lift_direction.text = "Lift up direction";
  405220:	f8c4 90c8 	str.w	r9, [r4, #200]	; 0xc8
	fill_menue_list(&menue_basic1_lift_directions, opt_basic1_lift_directions, OPT_BASIC_LIFT_DIRECTIONS_MAX, 0, &menue_lift_data_setup.m_up_dir);
  405224:	47c0      	blx	r8
	fill_menue_list(&menue_basic1, opt_basic1, OPT_BASIC_MAX, 0, 0);
  405226:	9500      	str	r5, [sp, #0]
  405228:	4630      	mov	r0, r6
  40522a:	462b      	mov	r3, r5
  40522c:	4621      	mov	r1, r4
  40522e:	2206      	movs	r2, #6
	lift_direction.child = &menue_basic1_lift_directions;
  405230:	f8c4 a0e8 	str.w	sl, [r4, #232]	; 0xe8
	fill_menue_list(&menue_basic1, opt_basic1, OPT_BASIC_MAX, 0, 0);
  405234:	47c0      	blx	r8

	return &menue_basic1;
  405236:	4630      	mov	r0, r6
  405238:	b003      	add	sp, #12
  40523a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40523e:	bf00      	nop
  405240:	204051ea 	.word	0x204051ea
  405244:	2040179c 	.word	0x2040179c
  405248:	0041a748 	.word	0x0041a748
  40524c:	41b80000 	.word	0x41b80000
  405250:	204014b0 	.word	0x204014b0
  405254:	0041a77c 	.word	0x0041a77c
  405258:	0041a790 	.word	0x0041a790
  40525c:	0041a79c 	.word	0x0041a79c
  405260:	2040166c 	.word	0x2040166c
  405264:	00400c69 	.word	0x00400c69
  405268:	0041a7a4 	.word	0x0041a7a4
  40526c:	00400c09 	.word	0x00400c09
  405270:	20401690 	.word	0x20401690
  405274:	0041a7c4 	.word	0x0041a7c4
  405278:	204018cc 	.word	0x204018cc
  40527c:	0041a814 	.word	0x0041a814
  405280:	0041a874 	.word	0x0041a874
  405284:	20401730 	.word	0x20401730
  405288:	204008ea 	.word	0x204008ea
  40528c:	204017c0 	.word	0x204017c0
  405290:	0041a738 	.word	0x0041a738
  405294:	0041a76c 	.word	0x0041a76c
  405298:	204018b0 	.word	0x204018b0
  40529c:	0041a788 	.word	0x0041a788
  4052a0:	0040b0ad 	.word	0x0040b0ad
  4052a4:	41c00000 	.word	0x41c00000
  4052a8:	2040174c 	.word	0x2040174c
  4052ac:	2040082d 	.word	0x2040082d
  4052b0:	0041a64c 	.word	0x0041a64c
  4052b4:	20401618 	.word	0x20401618
  4052b8:	0041a7b4 	.word	0x0041a7b4
  4052bc:	0041a7d0 	.word	0x0041a7d0
  4052c0:	0041a7d8 	.word	0x0041a7d8
  4052c4:	20401650 	.word	0x20401650
  4052c8:	0041a7ec 	.word	0x0041a7ec
  4052cc:	0041a800 	.word	0x0041a800
  4052d0:	204015a0 	.word	0x204015a0
  4052d4:	0041a838 	.word	0x0041a838
  4052d8:	0041a848 	.word	0x0041a848
  4052dc:	0041a828 	.word	0x0041a828
  4052e0:	20401634 	.word	0x20401634
  4052e4:	20401860 	.word	0x20401860
  4052e8:	0041a86c 	.word	0x0041a86c
  4052ec:	0041a858 	.word	0x0041a858

004052f0 <menue_curves_init>:
option_val_t oval_ARDspeed;
option_val_t oval_ARDaccdec;
option_val_t oval_ARDjerk;

menue_design_t *menue_curves_init(void)
{
  4052f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	oval_high_speed.max_value = 100.0;
	oval_high_speed.min_value = 1;
	oval_high_speed.new_val_flag = &menue_lift_data_newdata_flag;
	oval_high_speed.unit = "%";
	//oval_high_speed.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_high_speed.val = &menue_lift_data_setup.m_high_speed;
  4052f4:	4ed5      	ldr	r6, [pc, #852]	; (40564c <menue_curves_init+0x35c>)
	oval_high_speed.min_value = 1;
  4052f6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	lcurves_high_speed.option_save_val = &oval_high_speed;
	//__________________________________________________

	lcurves_medium_speed.text = "Medium speed";
	oval_medium_speed.data_types = fixedpt_dt;
  4052fa:	4ad5      	ldr	r2, [pc, #852]	; (405650 <menue_curves_init+0x360>)
	oval_high_speed.data_types = fixedpt_dt;
  4052fc:	2402      	movs	r4, #2
	//oval_medium_speed.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_medium_speed.val = &menue_lift_data_setup.m_medium_speed;
	lcurves_medium_speed.option_save_val = &oval_medium_speed;
	//__________________________________________________
	lcurves_creep_speed.text = "Creep speed";
	oval_creep_speed.data_types = fixedpt_dt;
  4052fe:	4bd5      	ldr	r3, [pc, #852]	; (405654 <menue_curves_init+0x364>)
	oval_medium_speed.val = &menue_lift_data_setup.m_medium_speed;
  405300:	1d35      	adds	r5, r6, #4
	oval_creep_speed.max_value = 100;
	oval_creep_speed.min_value = 0;
	oval_creep_speed.new_val_flag = &menue_lift_data_newdata_flag;
	oval_creep_speed.unit = "%";
	//oval_creep_speed.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_creep_speed.val = &menue_lift_data_setup.m_creep_speed;
  405302:	f106 0008 	add.w	r0, r6, #8
	oval_high_speed.new_val_flag = &menue_lift_data_newdata_flag;
  405306:	4fd4      	ldr	r7, [pc, #848]	; (405658 <menue_curves_init+0x368>)
	oval_high_speed.unit = "%";
  405308:	f8df 83c0 	ldr.w	r8, [pc, #960]	; 4056cc <menue_curves_init+0x3dc>
	oval_high_speed.real_count = 3;
  40530c:	f04f 0903 	mov.w	r9, #3
	oval_high_speed.data_types = fixedpt_dt;
  405310:	49d2      	ldr	r1, [pc, #840]	; (40565c <menue_curves_init+0x36c>)
	oval_relevel_speed.max_value = 100;
	oval_relevel_speed.min_value = 0;
	oval_relevel_speed.new_val_flag = &menue_lift_data_newdata_flag;
	oval_relevel_speed.unit = "%";
	//oval_relevel_speed.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_relevel_speed.val = &menue_lift_data_setup.m_relevel_speed;
  405312:	f106 0a0c 	add.w	sl, r6, #12
	oval_high_speed.max_value = 100.0;
  405316:	ed9f 7ad2 	vldr	s14, [pc, #840]	; 405660 <menue_curves_init+0x370>
	oval_ins_speed.max_value = 100;
	oval_ins_speed.min_value = 0;
	oval_ins_speed.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ins_speed.unit = "%";
	//oval_ins_speed.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ins_speed.val = &menue_lift_data_setup.m_ins_speed;
  40531a:	f106 0c10 	add.w	ip, r6, #16
	oval_acc.max_value = 20.99;
	oval_acc.min_value = 0.1;
	oval_acc.new_val_flag = &menue_lift_data_newdata_flag;
	oval_acc.unit = "Sec";
	//oval_acc.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_acc.val = &menue_lift_data_setup.m_acc;
  40531e:	f106 0e1c 	add.w	lr, r6, #28

	lcurves_ins_acc.text = "Ins Aceleration";
	oval_ins_acc.data_types = fixedpt_dt;
	oval_ins_acc.mantissa_count = 2;
	oval_ins_acc.real_count = 2;
	oval_ins_acc.max_value = 20.0;
  405322:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
	oval_corner1.max_value = 99.99;
	oval_corner1.min_value = 1;
	oval_corner1.new_val_flag = &menue_lift_data_newdata_flag;
	oval_corner1.unit = "%";
	//oval_corner1.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_corner1.val = &menue_lift_data_setup.m_corner1;
  405326:	f106 0b30 	add.w	fp, r6, #48	; 0x30
{
  40532a:	ed2d 8b02 	vpush	{d8}
	oval_medium_speed.val = &menue_lift_data_setup.m_medium_speed;
  40532e:	61d5      	str	r5, [r2, #28]
{
  405330:	b083      	sub	sp, #12
	lcurves_high_speed.text = "High speed";
  405332:	4dcc      	ldr	r5, [pc, #816]	; (405664 <menue_curves_init+0x374>)
	oval_creep_speed.val = &menue_lift_data_setup.m_creep_speed;
  405334:	61d8      	str	r0, [r3, #28]
	oval_high_speed.mantissa_count = 1;
  405336:	2001      	movs	r0, #1
	oval_creep_speed.min_value = 0;
  405338:	eddf 8acb 	vldr	s17, [pc, #812]	; 405668 <menue_curves_init+0x378>
	oval_high_speed.max_value = 100.0;
  40533c:	ed81 7a05 	vstr	s14, [r1, #20]
	oval_medium_speed.max_value = 100;
  405340:	ed82 7a05 	vstr	s14, [r2, #20]
	oval_high_speed.min_value = 1;
  405344:	edc1 7a06 	vstr	s15, [r1, #24]
	oval_medium_speed.min_value = 1;
  405348:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_high_speed.val = &menue_lift_data_setup.m_high_speed;
  40534c:	61ce      	str	r6, [r1, #28]
	oval_high_speed.data_types = fixedpt_dt;
  40534e:	700c      	strb	r4, [r1, #0]
	oval_medium_speed.data_types = fixedpt_dt;
  405350:	7014      	strb	r4, [r2, #0]
	oval_high_speed.mantissa_count = 1;
  405352:	6088      	str	r0, [r1, #8]
	oval_medium_speed.mantissa_count = 1;
  405354:	6090      	str	r0, [r2, #8]
	oval_high_speed.real_count = 3;
  405356:	f8c1 9004 	str.w	r9, [r1, #4]
	oval_medium_speed.real_count = 3;
  40535a:	f8c2 9004 	str.w	r9, [r2, #4]
	oval_high_speed.new_val_flag = &menue_lift_data_newdata_flag;
  40535e:	620f      	str	r7, [r1, #32]
	oval_medium_speed.new_val_flag = &menue_lift_data_newdata_flag;
  405360:	6217      	str	r7, [r2, #32]
	oval_high_speed.unit = "%";
  405362:	f8c1 800c 	str.w	r8, [r1, #12]
	oval_medium_speed.unit = "%";
  405366:	f8c2 800c 	str.w	r8, [r2, #12]
	lcurves_high_speed.option_save_val = &oval_high_speed;
  40536a:	6269      	str	r1, [r5, #36]	; 0x24
	lcurves_medium_speed.option_save_val = &oval_medium_speed;
  40536c:	64ea      	str	r2, [r5, #76]	; 0x4c
	lcurves_high_speed.text = "High speed";
  40536e:	49bf      	ldr	r1, [pc, #764]	; (40566c <menue_curves_init+0x37c>)
	lcurves_medium_speed.text = "Medium speed";
  405370:	4abf      	ldr	r2, [pc, #764]	; (405670 <menue_curves_init+0x380>)
	oval_creep_speed.max_value = 100;
  405372:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_creep_speed.data_types = fixedpt_dt;
  405376:	701c      	strb	r4, [r3, #0]
	oval_creep_speed.mantissa_count = 1;
  405378:	6098      	str	r0, [r3, #8]
	oval_creep_speed.real_count = 3;
  40537a:	f8c3 9004 	str.w	r9, [r3, #4]
	oval_creep_speed.new_val_flag = &menue_lift_data_newdata_flag;
  40537e:	621f      	str	r7, [r3, #32]
	oval_creep_speed.unit = "%";
  405380:	f8c3 800c 	str.w	r8, [r3, #12]
	lcurves_creep_speed.option_save_val = &oval_creep_speed;
  405384:	676b      	str	r3, [r5, #116]	; 0x74
	lcurves_high_speed.text = "High speed";
  405386:	6029      	str	r1, [r5, #0]
	lcurves_medium_speed.text = "Medium speed";
  405388:	62aa      	str	r2, [r5, #40]	; 0x28
	oval_creep_speed.min_value = 0;
  40538a:	edc3 8a06 	vstr	s17, [r3, #24]
	lcurves_creep_speed.text = "Creep speed";
  40538e:	49b9      	ldr	r1, [pc, #740]	; (405674 <menue_curves_init+0x384>)
	oval_relevel_speed.data_types = fixedpt_dt;
  405390:	4bb9      	ldr	r3, [pc, #740]	; (405678 <menue_curves_init+0x388>)
	lcurves_relevel_speed.text = "Relevel speed";
  405392:	4aba      	ldr	r2, [pc, #744]	; (40567c <menue_curves_init+0x38c>)
	lcurves_creep_speed.text = "Creep speed";
  405394:	6529      	str	r1, [r5, #80]	; 0x50
	oval_ins_corner.val = &menue_lift_data_setup.m_ins_corner;
  405396:	f106 012c 	add.w	r1, r6, #44	; 0x2c
	lcurves_relevel_speed.text = "Relevel speed";
  40539a:	67aa      	str	r2, [r5, #120]	; 0x78
	oval_relevel_speed.max_value = 100;
  40539c:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_relevel_speed.data_types = fixedpt_dt;
  4053a0:	701c      	strb	r4, [r3, #0]
	oval_relevel_speed.mantissa_count = 1;
  4053a2:	6098      	str	r0, [r3, #8]
	oval_relevel_speed.real_count = 3;
  4053a4:	f8c3 9004 	str.w	r9, [r3, #4]
	oval_relevel_speed.min_value = 0;
  4053a8:	edc3 8a06 	vstr	s17, [r3, #24]
	oval_relevel_speed.new_val_flag = &menue_lift_data_newdata_flag;
  4053ac:	621f      	str	r7, [r3, #32]
	oval_relevel_speed.unit = "%";
  4053ae:	f8c3 800c 	str.w	r8, [r3, #12]
	oval_relevel_speed.val = &menue_lift_data_setup.m_relevel_speed;
  4053b2:	f8c3 a01c 	str.w	sl, [r3, #28]
	oval_corner3.max_value = 99.99;
	oval_corner3.min_value = 1;
	oval_corner3.new_val_flag = &menue_lift_data_newdata_flag;
	oval_corner3.unit = "%";
	//oval_corner3.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_corner3.val = &menue_lift_data_setup.m_corner3;
  4053b6:	f106 0a38 	add.w	sl, r6, #56	; 0x38
	lcurves_relevel_speed.option_save_val = &oval_relevel_speed;
  4053ba:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
	oval_ins_speed.data_types = fixedpt_dt;
  4053be:	4bb0      	ldr	r3, [pc, #704]	; (405680 <menue_curves_init+0x390>)
	lcurves_ins_speed.text = "Ins speed";
  4053c0:	4ab0      	ldr	r2, [pc, #704]	; (405684 <menue_curves_init+0x394>)
	oval_ins_speed.max_value = 100;
  4053c2:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_ins_speed.real_count = 3;
  4053c6:	f8c3 9004 	str.w	r9, [r3, #4]
	oval_ins_speed.data_types = fixedpt_dt;
  4053ca:	701c      	strb	r4, [r3, #0]
	oval_ins_speed.mantissa_count = 1;
  4053cc:	6098      	str	r0, [r3, #8]

	lcurves_ins_stopping_mode.text = "Ins stop mode";
	ins_stopping_abrupt.text = "Abrupt";
	ins_stopping_decelerate.text = "Decelerate";

	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  4053ce:	f106 003c 	add.w	r0, r6, #60	; 0x3c
	oval_ins_speed.min_value = 0;
  4053d2:	edc3 8a06 	vstr	s17, [r3, #24]
	oval_ins_speed.new_val_flag = &menue_lift_data_newdata_flag;
  4053d6:	621f      	str	r7, [r3, #32]
	oval_ins_speed.unit = "%";
  4053d8:	f8c3 800c 	str.w	r8, [r3, #12]
	lcurves_ins_speed.option_save_val = &oval_ins_speed;
  4053dc:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	oval_ins_speed.val = &menue_lift_data_setup.m_ins_speed;
  4053e0:	f8c3 c01c 	str.w	ip, [r3, #28]
	oval_corner2.val = &menue_lift_data_setup.m_corner2;
  4053e4:	f106 0c34 	add.w	ip, r6, #52	; 0x34
	lcurves_acc.text = "Acceleration";
  4053e8:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 4056d0 <menue_curves_init+0x3e0>
	lcurves_dec.text = "Deceleration";
  4053ec:	4ba6      	ldr	r3, [pc, #664]	; (405688 <menue_curves_init+0x398>)
	lcurves_ins_speed.text = "Ins speed";
  4053ee:	f8c5 20a0 	str.w	r2, [r5, #160]	; 0xa0
	lcurves_acc.text = "Acceleration";
  4053f2:	f8c5 90c8 	str.w	r9, [r5, #200]	; 0xc8
	oval_acc.data_types = fixedpt_dt;
  4053f6:	4aa5      	ldr	r2, [pc, #660]	; (40568c <menue_curves_init+0x39c>)
	oval_acc.max_value = 20.99;
  4053f8:	f8df 92d8 	ldr.w	r9, [pc, #728]	; 4056d4 <menue_curves_init+0x3e4>
	lcurves_dec.text = "Deceleration";
  4053fc:	f8c5 30f0 	str.w	r3, [r5, #240]	; 0xf0
	oval_dec.data_types = fixedpt_dt;
  405400:	4ba3      	ldr	r3, [pc, #652]	; (405690 <menue_curves_init+0x3a0>)
	oval_acc.val = &menue_lift_data_setup.m_acc;
  405402:	f8c2 e01c 	str.w	lr, [r2, #28]
	oval_acc.max_value = 20.99;
  405406:	f8c2 9014 	str.w	r9, [r2, #20]
	oval_acc.min_value = 0.1;
  40540a:	f8df e2cc 	ldr.w	lr, [pc, #716]	; 4056d8 <menue_curves_init+0x3e8>
	oval_dec.max_value = 20.99;
  40540e:	f8c3 9014 	str.w	r9, [r3, #20]
	oval_acc.unit = "Sec";
  405412:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 4056dc <menue_curves_init+0x3ec>
	oval_acc.data_types = fixedpt_dt;
  405416:	7014      	strb	r4, [r2, #0]
	oval_acc.mantissa_count = 2;
  405418:	6094      	str	r4, [r2, #8]
	oval_acc.real_count = 2;
  40541a:	6054      	str	r4, [r2, #4]
	oval_acc.new_val_flag = &menue_lift_data_newdata_flag;
  40541c:	6217      	str	r7, [r2, #32]
	lcurves_acc.option_save_val = &oval_acc;
  40541e:	f8c5 20ec 	str.w	r2, [r5, #236]	; 0xec
	oval_dec.data_types = fixedpt_dt;
  405422:	701c      	strb	r4, [r3, #0]
	oval_dec.mantissa_count = 2;
  405424:	609c      	str	r4, [r3, #8]
	oval_dec.real_count = 2;
  405426:	605c      	str	r4, [r3, #4]
	oval_acc.min_value = 0.1;
  405428:	f8c2 e018 	str.w	lr, [r2, #24]
	oval_acc.unit = "Sec";
  40542c:	f8c2 900c 	str.w	r9, [r2, #12]
	lcurves_ins_acc.text = "Ins Aceleration";
  405430:	4a98      	ldr	r2, [pc, #608]	; (405694 <menue_curves_init+0x3a4>)
	oval_dec.min_value = 0.1;
  405432:	f8c3 e018 	str.w	lr, [r3, #24]
	lcurves_ins_acc.text = "Ins Aceleration";
  405436:	f8c5 2118 	str.w	r2, [r5, #280]	; 0x118
	oval_dec.val = &menue_lift_data_setup.m_dec;
  40543a:	f106 0220 	add.w	r2, r6, #32
	oval_dec.new_val_flag = &menue_lift_data_newdata_flag;
  40543e:	621f      	str	r7, [r3, #32]
	oval_dec.unit = "Sec";
  405440:	f8c3 900c 	str.w	r9, [r3, #12]
	oval_dec.val = &menue_lift_data_setup.m_dec;
  405444:	61da      	str	r2, [r3, #28]
	oval_ins_acc.val = &menue_lift_data_setup.m_ins_acc;
  405446:	f106 0224 	add.w	r2, r6, #36	; 0x24
	lcurves_dec.option_save_val = &oval_dec;
  40544a:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
	lcurves_ins_dec.text = "Ins Deceleration";
  40544e:	4b92      	ldr	r3, [pc, #584]	; (405698 <menue_curves_init+0x3a8>)
	oval_ins_corner.max_value = 99.99;
  405450:	ed9f 8a92 	vldr	s16, [pc, #584]	; 40569c <menue_curves_init+0x3ac>
	lcurves_ins_dec.text = "Ins Deceleration";
  405454:	f8c5 3140 	str.w	r3, [r5, #320]	; 0x140
	lcurves_ins_corner.text = "Ins corner";
  405458:	4b91      	ldr	r3, [pc, #580]	; (4056a0 <menue_curves_init+0x3b0>)
  40545a:	f8c5 3168 	str.w	r3, [r5, #360]	; 0x168
	oval_ins_acc.data_types = fixedpt_dt;
  40545e:	4b91      	ldr	r3, [pc, #580]	; (4056a4 <menue_curves_init+0x3b4>)
	oval_ins_acc.max_value = 20.0;
  405460:	edc3 6a05 	vstr	s13, [r3, #20]
	oval_ins_acc.data_types = fixedpt_dt;
  405464:	701c      	strb	r4, [r3, #0]
	oval_ins_acc.mantissa_count = 2;
  405466:	609c      	str	r4, [r3, #8]
	oval_ins_acc.real_count = 2;
  405468:	605c      	str	r4, [r3, #4]
	oval_ins_acc.min_value = 0.1;
  40546a:	f8c3 e018 	str.w	lr, [r3, #24]
	oval_ins_acc.new_val_flag = &menue_lift_data_newdata_flag;
  40546e:	621f      	str	r7, [r3, #32]
	oval_ins_acc.val = &menue_lift_data_setup.m_ins_acc;
  405470:	61da      	str	r2, [r3, #28]
	oval_ins_dec.val = &menue_lift_data_setup.m_ins_dec;
  405472:	3204      	adds	r2, #4
	oval_ins_acc.unit = "Sec";
  405474:	f8c3 900c 	str.w	r9, [r3, #12]
	lcurves_ins_acc.option_save_val = &oval_ins_acc;
  405478:	f8c5 313c 	str.w	r3, [r5, #316]	; 0x13c
	oval_ins_dec.data_types = fixedpt_dt;
  40547c:	4b8a      	ldr	r3, [pc, #552]	; (4056a8 <menue_curves_init+0x3b8>)
	oval_ins_dec.max_value = 20.0;
  40547e:	edc3 6a05 	vstr	s13, [r3, #20]
	oval_ins_dec.data_types = fixedpt_dt;
  405482:	701c      	strb	r4, [r3, #0]
	oval_ins_dec.mantissa_count = 2;
  405484:	609c      	str	r4, [r3, #8]
	oval_ins_dec.real_count = 2;
  405486:	605c      	str	r4, [r3, #4]
	oval_ins_dec.min_value = 0.1;
  405488:	f8c3 e018 	str.w	lr, [r3, #24]
	oval_ins_dec.new_val_flag = &menue_lift_data_newdata_flag;
  40548c:	621f      	str	r7, [r3, #32]
	oval_ins_dec.unit = "Sec";
  40548e:	f8c3 900c 	str.w	r9, [r3, #12]
	lcurves_ins_dec.option_save_val = &oval_ins_dec;	
  405492:	f8c5 3164 	str.w	r3, [r5, #356]	; 0x164
	oval_ins_dec.val = &menue_lift_data_setup.m_ins_dec;
  405496:	61da      	str	r2, [r3, #28]
	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  405498:	4622      	mov	r2, r4
	oval_ins_corner.data_types = fixedpt_dt;
  40549a:	4b84      	ldr	r3, [pc, #528]	; (4056ac <menue_curves_init+0x3bc>)
	lcurves_corner1.text = "Corner 1";
  40549c:	f8df e240 	ldr.w	lr, [pc, #576]	; 4056e0 <menue_curves_init+0x3f0>
	oval_ins_corner.min_value = 1;
  4054a0:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_ins_corner.data_types = fixedpt_dt;
  4054a4:	701c      	strb	r4, [r3, #0]
	oval_ins_corner.mantissa_count = 2;
  4054a6:	609c      	str	r4, [r3, #8]
	oval_ins_corner.real_count = 2;
  4054a8:	605c      	str	r4, [r3, #4]
	oval_ins_corner.new_val_flag = &menue_lift_data_newdata_flag;
  4054aa:	621f      	str	r7, [r3, #32]
	oval_ins_corner.unit = "%";
  4054ac:	f8c3 800c 	str.w	r8, [r3, #12]
	oval_ins_corner.val = &menue_lift_data_setup.m_ins_corner;
  4054b0:	61d9      	str	r1, [r3, #28]
	lcurves_corner2.text = "Corner 2";
  4054b2:	497f      	ldr	r1, [pc, #508]	; (4056b0 <menue_curves_init+0x3c0>)
	lcurves_corner1.text = "Corner 1";
  4054b4:	f8c5 e190 	str.w	lr, [r5, #400]	; 0x190
	lcurves_corner2.text = "Corner 2";
  4054b8:	f8c5 11b8 	str.w	r1, [r5, #440]	; 0x1b8
	lcurves_ins_stopping_mode.text = "Ins stop mode";
  4054bc:	497d      	ldr	r1, [pc, #500]	; (4056b4 <menue_curves_init+0x3c4>)
	lcurves_corner3.text = "Corner 3";
  4054be:	f8df e224 	ldr.w	lr, [pc, #548]	; 4056e4 <menue_curves_init+0x3f4>
	lcurves_ins_stopping_mode.text = "Ins stop mode";
  4054c2:	f8c5 1258 	str.w	r1, [r5, #600]	; 0x258
	oval_corner2.data_types = fixedpt_dt;
  4054c6:	497c      	ldr	r1, [pc, #496]	; (4056b8 <menue_curves_init+0x3c8>)
	lcurves_corner3.text = "Corner 3";
  4054c8:	f8c5 e1e0 	str.w	lr, [r5, #480]	; 0x1e0
	oval_corner2.val = &menue_lift_data_setup.m_corner2;
  4054cc:	f8c1 c01c 	str.w	ip, [r1, #28]
	oval_corner1.data_types = fixedpt_dt;
  4054d0:	f8df e214 	ldr.w	lr, [pc, #532]	; 4056e8 <menue_curves_init+0x3f8>
	oval_corner3.data_types = fixedpt_dt;
  4054d4:	f8df c214 	ldr.w	ip, [pc, #532]	; 4056ec <menue_curves_init+0x3fc>
	oval_corner1.min_value = 1;
  4054d8:	edce 7a06 	vstr	s15, [lr, #24]
	oval_corner2.min_value = 1;
  4054dc:	edc1 7a06 	vstr	s15, [r1, #24]
	oval_corner3.min_value = 1;
  4054e0:	edcc 7a06 	vstr	s15, [ip, #24]
	oval_ins_corner.max_value = 99.99;
  4054e4:	ed83 8a05 	vstr	s16, [r3, #20]
	lcurves_ins_corner.option_save_val = &oval_ins_corner;
  4054e8:	f8c5 318c 	str.w	r3, [r5, #396]	; 0x18c
	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  4054ec:	2300      	movs	r3, #0
	oval_corner1.val = &menue_lift_data_setup.m_corner1;
  4054ee:	f8ce b01c 	str.w	fp, [lr, #28]
	oval_corner1.data_types = fixedpt_dt;
  4054f2:	f88e 4000 	strb.w	r4, [lr]
	oval_corner1.mantissa_count = 2;
  4054f6:	f8ce 4008 	str.w	r4, [lr, #8]
	oval_corner1.real_count = 2;
  4054fa:	f8ce 4004 	str.w	r4, [lr, #4]
	oval_corner1.max_value = 99.99;
  4054fe:	ed8e 8a05 	vstr	s16, [lr, #20]
	oval_corner1.new_val_flag = &menue_lift_data_newdata_flag;
  405502:	f8ce 7020 	str.w	r7, [lr, #32]
	oval_corner1.unit = "%";
  405506:	f8ce 800c 	str.w	r8, [lr, #12]
	lcurves_corner1.option_save_val = &oval_corner1;
  40550a:	f8c5 e1b4 	str.w	lr, [r5, #436]	; 0x1b4
	oval_corner2.data_types = fixedpt_dt;
  40550e:	700c      	strb	r4, [r1, #0]
	ins_stopping_abrupt.text = "Abrupt";
  405510:	f8df e1dc 	ldr.w	lr, [pc, #476]	; 4056f0 <menue_curves_init+0x400>
	oval_corner2.mantissa_count = 2;
  405514:	608c      	str	r4, [r1, #8]
	oval_corner2.real_count = 2;
  405516:	604c      	str	r4, [r1, #4]
	oval_corner2.max_value = 99.99;
  405518:	ed81 8a05 	vstr	s16, [r1, #20]
	oval_corner2.new_val_flag = &menue_lift_data_newdata_flag;
  40551c:	620f      	str	r7, [r1, #32]
	oval_corner2.unit = "%";
  40551e:	f8c1 800c 	str.w	r8, [r1, #12]
	lcurves_corner2.option_save_val = &oval_corner2;
  405522:	f8c5 11dc 	str.w	r1, [r5, #476]	; 0x1dc
	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  405526:	4671      	mov	r1, lr
	oval_corner3.data_types = fixedpt_dt;
  405528:	f88c 4000 	strb.w	r4, [ip]
	oval_corner3.mantissa_count = 2;
  40552c:	f8cc 4008 	str.w	r4, [ip, #8]
	oval_corner3.real_count = 2;
  405530:	f8cc 4004 	str.w	r4, [ip, #4]
	oval_corner3.max_value = 99.99;
  405534:	ed8c 8a05 	vstr	s16, [ip, #20]
	oval_corner3.new_val_flag = &menue_lift_data_newdata_flag;
  405538:	f8cc 7020 	str.w	r7, [ip, #32]
	oval_corner3.unit = "%";
  40553c:	f8cc 800c 	str.w	r8, [ip, #12]
	lcurves_corner3.option_save_val = &oval_corner3;
  405540:	f8c5 c204 	str.w	ip, [r5, #516]	; 0x204
	oval_corner3.val = &menue_lift_data_setup.m_corner3;
  405544:	f8cc a01c 	str.w	sl, [ip, #28]
	ins_stopping_abrupt.text = "Abrupt";
  405548:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 4056f4 <menue_curves_init+0x404>
	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  40554c:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 4056f8 <menue_curves_init+0x408>
	ins_stopping_abrupt.text = "Abrupt";
  405550:	f8ce c000 	str.w	ip, [lr]
	ins_stopping_decelerate.text = "Decelerate";
  405554:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 4056fc <menue_curves_init+0x40c>
	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  405558:	9000      	str	r0, [sp, #0]
  40555a:	4658      	mov	r0, fp
	ins_stopping_decelerate.text = "Decelerate";
  40555c:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	fill_menue_list(&menue_curves_ins_stopping, opt_curves_ins_stopping, OPT_CURVES_INS_STOPPING_MAX, 0, &menue_lift_data_setup.m_ins_stopping_mode);
  405560:	f8df a19c 	ldr.w	sl, [pc, #412]	; 405700 <menue_curves_init+0x410>
  405564:	47d0      	blx	sl

	//Set the child to enter
	lcurves_ins_stopping_mode.child = &menue_curves_ins_stopping;
  405566:	f8c5 b278 	str.w	fp, [r5, #632]	; 0x278
	//__________________________________________________
	
	lcurves_ARDspeed.text = "ARD speed";
  40556a:	f8df b198 	ldr.w	fp, [pc, #408]	; 405704 <menue_curves_init+0x414>
	oval_ARDaccdec.max_value = 99.99;
	oval_ARDaccdec.min_value = 0.5;
	oval_ARDaccdec.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ARDaccdec.unit = "Sec";
	//oval_ARDaccdec.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ARDaccdec.val = &menue_lift_data_setup.m_ARDAccDec;
  40556e:	f106 0c44 	add.w	ip, r6, #68	; 0x44
	oval_ARDaccdec.data_types = fixedpt_dt;
  405572:	4952      	ldr	r1, [pc, #328]	; (4056bc <menue_curves_init+0x3cc>)
	oval_ARDjerk.max_value = 99.99;
	oval_ARDjerk.min_value = 0;
	oval_ARDjerk.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ARDjerk.unit = "%";
	//oval_ARDjerk.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ARDjerk.val = &menue_lift_data_setup.m_ARDJerk;
  405574:	f106 0048 	add.w	r0, r6, #72	; 0x48
	lcurves_ARDspeed.text = "ARD speed";
  405578:	f8c5 b280 	str.w	fp, [r5, #640]	; 0x280
	oval_ARDspeed.min_value = 0.5;
  40557c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	lcurves_ARDAccDec.text = "ARD Acc/Dec";
  405580:	f8df b184 	ldr.w	fp, [pc, #388]	; 405708 <menue_curves_init+0x418>
	oval_pre_spd.val = &menue_lift_data_setup.m_pre_speed;
	lcurves_prespeed.option_save_val = &oval_pre_spd;	
	//__________________________________________________
	lcurves_prespd_time.text = "Soft speed time";
	oval_pre_spd_time.data_types = uint16_dt;
	oval_pre_spd_time.mantissa_count = 0;
  405584:	f04f 0e00 	mov.w	lr, #0
	oval_ARDspeed.data_types = fixedpt_dt;
  405588:	4a4d      	ldr	r2, [pc, #308]	; (4056c0 <menue_curves_init+0x3d0>)
	oval_ARDspeed.val = &menue_lift_data_setup.m_ARDspeed;
  40558a:	f106 0340 	add.w	r3, r6, #64	; 0x40
	lcurves_ARDAccDec.text = "ARD Acc/Dec";
  40558e:	f8c5 b2a8 	str.w	fp, [r5, #680]	; 0x2a8
	lcurves_ARDjerk.text = "ARD Corner";
  405592:	f8df b178 	ldr.w	fp, [pc, #376]	; 40570c <menue_curves_init+0x41c>
	oval_ARDaccdec.val = &menue_lift_data_setup.m_ARDAccDec;
  405596:	f8c1 c01c 	str.w	ip, [r1, #28]
	lcurves_ARDjerk.text = "ARD Corner";
  40559a:	f8c5 b2d0 	str.w	fp, [r5, #720]	; 0x2d0
	oval_ARDjerk.data_types = fixedpt_dt;
  40559e:	f8df b170 	ldr.w	fp, [pc, #368]	; 405710 <menue_curves_init+0x420>
	oval_ARDspeed.unit = "Hz";
  4055a2:	f8df c170 	ldr.w	ip, [pc, #368]	; 405714 <menue_curves_init+0x424>
	oval_ARDjerk.unit = "%";
  4055a6:	f8cb 800c 	str.w	r8, [fp, #12]
	oval_ARDjerk.data_types = fixedpt_dt;
  4055aa:	f88b 4000 	strb.w	r4, [fp]
	oval_ARDjerk.mantissa_count = 2;
  4055ae:	f8cb 4008 	str.w	r4, [fp, #8]
	oval_ARDjerk.real_count = 2;
  4055b2:	f8cb 4004 	str.w	r4, [fp, #4]
	oval_ARDjerk.max_value = 99.99;
  4055b6:	ed8b 8a05 	vstr	s16, [fp, #20]
	oval_ARDjerk.min_value = 0;
  4055ba:	edcb 8a06 	vstr	s17, [fp, #24]
	oval_ARDjerk.new_val_flag = &menue_lift_data_newdata_flag;
  4055be:	f8cb 7020 	str.w	r7, [fp, #32]
	lcurves_ARDjerk.option_save_val = &oval_ARDjerk;
  4055c2:	f8c5 b2f4 	str.w	fp, [r5, #756]	; 0x2f4
	oval_ARDjerk.val = &menue_lift_data_setup.m_ARDJerk;
  4055c6:	f8cb 001c 	str.w	r0, [fp, #28]
	oval_pre_spd.data_types = fixedpt_dt;
  4055ca:	f8df b14c 	ldr.w	fp, [pc, #332]	; 405718 <menue_curves_init+0x428>
	lcurves_prespeed.text = "Soft start speed";
  4055ce:	483d      	ldr	r0, [pc, #244]	; (4056c4 <menue_curves_init+0x3d4>)
	oval_ARDaccdec.min_value = 0.5;
  4055d0:	edc1 7a06 	vstr	s15, [r1, #24]
	oval_ARDspeed.min_value = 0.5;
  4055d4:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_ARDaccdec.unit = "Sec";
  4055d8:	f8c1 900c 	str.w	r9, [r1, #12]
	oval_pre_spd.val = &menue_lift_data_setup.m_pre_speed;
  4055dc:	f106 0914 	add.w	r9, r6, #20
	oval_ARDaccdec.max_value = 99.99;
  4055e0:	ed81 8a05 	vstr	s16, [r1, #20]
	oval_pre_spd_time.max_value = 5000;
	oval_pre_spd_time.min_value = 0;
	oval_pre_spd_time.new_val_flag = &menue_lift_data_newdata_flag;
	oval_pre_spd_time.unit = "ms";
	//oval_pre_spd_time.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_pre_spd_time.val = &menue_lift_data_setup.m_pre_spd_time;
  4055e4:	3618      	adds	r6, #24
	lcurves_ARDAccDec.option_save_val = &oval_ARDaccdec;
  4055e6:	f8c5 12cc 	str.w	r1, [r5, #716]	; 0x2cc
	oval_ARDaccdec.new_val_flag = &menue_lift_data_newdata_flag;
  4055ea:	620f      	str	r7, [r1, #32]
	oval_ARDaccdec.data_types = fixedpt_dt;
  4055ec:	700c      	strb	r4, [r1, #0]
	oval_ARDaccdec.mantissa_count = 2;
  4055ee:	608c      	str	r4, [r1, #8]
	oval_ARDaccdec.real_count = 2;
  4055f0:	604c      	str	r4, [r1, #4]
	lcurves_prespd_time.option_save_val = &oval_pre_spd_time;
	//__________________________________________________
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  4055f2:	4629      	mov	r1, r5
	oval_ARDspeed.max_value = 99.99;
  4055f4:	ed82 8a05 	vstr	s16, [r2, #20]
	lcurves_ARDspeed.option_save_val = &oval_ARDspeed;
  4055f8:	f8c5 22a4 	str.w	r2, [r5, #676]	; 0x2a4
	oval_ARDspeed.new_val_flag = &menue_lift_data_newdata_flag;
  4055fc:	6217      	str	r7, [r2, #32]
	oval_ARDspeed.data_types = fixedpt_dt;
  4055fe:	7014      	strb	r4, [r2, #0]
	oval_ARDspeed.mantissa_count = 2;
  405600:	6094      	str	r4, [r2, #8]
	oval_ARDspeed.real_count = 2;
  405602:	6054      	str	r4, [r2, #4]
	oval_ARDspeed.val = &menue_lift_data_setup.m_ARDspeed;
  405604:	61d3      	str	r3, [r2, #28]
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  405606:	4673      	mov	r3, lr
	oval_ARDspeed.unit = "Hz";
  405608:	f8c2 c00c 	str.w	ip, [r2, #12]
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  40560c:	2213      	movs	r2, #19
	lcurves_prespeed.text = "Soft start speed";
  40560e:	f8c5 0208 	str.w	r0, [r5, #520]	; 0x208
	oval_pre_spd.data_types = fixedpt_dt;
  405612:	f88b 4000 	strb.w	r4, [fp]
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  405616:	f8cd e000 	str.w	lr, [sp]
	oval_pre_spd.mantissa_count = 2;
  40561a:	f8cb 4008 	str.w	r4, [fp, #8]
	oval_pre_spd.real_count = 2;
  40561e:	f8cb 4004 	str.w	r4, [fp, #4]
	oval_pre_spd_time.data_types = uint16_dt;
  405622:	4c29      	ldr	r4, [pc, #164]	; (4056c8 <menue_curves_init+0x3d8>)
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  405624:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 40571c <menue_curves_init+0x42c>
	oval_pre_spd_time.val = &menue_lift_data_setup.m_pre_spd_time;
  405628:	61e6      	str	r6, [r4, #28]
	oval_pre_spd_time.data_types = uint16_dt;
  40562a:	f04f 0601 	mov.w	r6, #1
	oval_pre_spd.unit = "Hz";
  40562e:	f8cb c00c 	str.w	ip, [fp, #12]
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  405632:	4640      	mov	r0, r8
	oval_pre_spd.max_value = 99.99;
  405634:	ed8b 8a05 	vstr	s16, [fp, #20]
	oval_pre_spd.min_value = 0;
  405638:	edcb 8a06 	vstr	s17, [fp, #24]
	lcurves_prespeed.option_save_val = &oval_pre_spd;	
  40563c:	f8c5 b22c 	str.w	fp, [r5, #556]	; 0x22c
	oval_pre_spd.new_val_flag = &menue_lift_data_newdata_flag;
  405640:	f8cb 7020 	str.w	r7, [fp, #32]
	oval_pre_spd.val = &menue_lift_data_setup.m_pre_speed;
  405644:	f8cb 901c 	str.w	r9, [fp, #28]
  405648:	e06a      	b.n	405720 <menue_curves_init+0x430>
  40564a:	bf00      	nop
  40564c:	20405208 	.word	0x20405208
  405650:	204019f8 	.word	0x204019f8
  405654:	20401a40 	.word	0x20401a40
  405658:	204008ea 	.word	0x204008ea
  40565c:	20401e84 	.word	0x20401e84
  405660:	42c80000 	.word	0x42c80000
  405664:	20401afc 	.word	0x20401afc
  405668:	00000000 	.word	0x00000000
  40566c:	0041a87c 	.word	0x0041a87c
  405670:	0041a88c 	.word	0x0041a88c
  405674:	0041a89c 	.word	0x0041a89c
  405678:	20401ad8 	.word	0x20401ad8
  40567c:	0041a8a8 	.word	0x0041a8a8
  405680:	2040190c 	.word	0x2040190c
  405684:	0041a8b8 	.word	0x0041a8b8
  405688:	0041a8ec 	.word	0x0041a8ec
  40568c:	204019d4 	.word	0x204019d4
  405690:	20401e18 	.word	0x20401e18
  405694:	0041a8d8 	.word	0x0041a8d8
  405698:	0041a8e8 	.word	0x0041a8e8
  40569c:	42c7fae1 	.word	0x42c7fae1
  4056a0:	0041a8fc 	.word	0x0041a8fc
  4056a4:	20401df4 	.word	0x20401df4
  4056a8:	20401a1c 	.word	0x20401a1c
  4056ac:	20401ab4 	.word	0x20401ab4
  4056b0:	0041a914 	.word	0x0041a914
  4056b4:	0041a92c 	.word	0x0041a92c
  4056b8:	20401978 	.word	0x20401978
  4056bc:	20401ecc 	.word	0x20401ecc
  4056c0:	20401954 	.word	0x20401954
  4056c4:	0041a974 	.word	0x0041a974
  4056c8:	20401e60 	.word	0x20401e60
  4056cc:	0041a888 	.word	0x0041a888
  4056d0:	0041a8c4 	.word	0x0041a8c4
  4056d4:	41a7eb85 	.word	0x41a7eb85
  4056d8:	3dcccccd 	.word	0x3dcccccd
  4056dc:	0041a8d4 	.word	0x0041a8d4
  4056e0:	0041a908 	.word	0x0041a908
  4056e4:	0041a920 	.word	0x0041a920
  4056e8:	20401ea8 	.word	0x20401ea8
  4056ec:	20401930 	.word	0x20401930
  4056f0:	20401a64 	.word	0x20401a64
  4056f4:	0041a93c 	.word	0x0041a93c
  4056f8:	2040199c 	.word	0x2040199c
  4056fc:	0041a944 	.word	0x0041a944
  405700:	0040b0ad 	.word	0x0040b0ad
  405704:	0041a950 	.word	0x0041a950
  405708:	0041a95c 	.word	0x0041a95c
  40570c:	0041a968 	.word	0x0041a968
  405710:	20401e3c 	.word	0x20401e3c
  405714:	004199e8 	.word	0x004199e8
  405718:	204018e8 	.word	0x204018e8
  40571c:	204019b8 	.word	0x204019b8
	lcurves_prespd_time.text = "Soft speed time";
  405720:	f8df c038 	ldr.w	ip, [pc, #56]	; 40575c <menue_curves_init+0x46c>
	oval_pre_spd_time.data_types = uint16_dt;
  405724:	7026      	strb	r6, [r4, #0]
	oval_pre_spd_time.real_count = 4;
  405726:	2604      	movs	r6, #4
	oval_pre_spd_time.max_value = 5000;
  405728:	f8df b034 	ldr.w	fp, [pc, #52]	; 405760 <menue_curves_init+0x470>
	oval_pre_spd_time.unit = "ms";
  40572c:	f8df 9034 	ldr.w	r9, [pc, #52]	; 405764 <menue_curves_init+0x474>
	oval_pre_spd_time.min_value = 0;
  405730:	edc4 8a06 	vstr	s17, [r4, #24]
	lcurves_prespd_time.option_save_val = &oval_pre_spd_time;
  405734:	f8c5 4254 	str.w	r4, [r5, #596]	; 0x254
	oval_pre_spd_time.new_val_flag = &menue_lift_data_newdata_flag;
  405738:	6227      	str	r7, [r4, #32]
	oval_pre_spd_time.real_count = 4;
  40573a:	6066      	str	r6, [r4, #4]
	oval_pre_spd_time.max_value = 5000;
  40573c:	f8c4 b014 	str.w	fp, [r4, #20]
	lcurves_prespd_time.text = "Soft speed time";
  405740:	f8c5 c230 	str.w	ip, [r5, #560]	; 0x230
	oval_pre_spd_time.unit = "ms";
  405744:	f8c4 900c 	str.w	r9, [r4, #12]
	oval_pre_spd_time.mantissa_count = 0;
  405748:	f8c4 e008 	str.w	lr, [r4, #8]
	fill_menue_list(&menue_curves, opt_curves, OPT_CURVES_MAX, 0, 0);
  40574c:	47d0      	blx	sl
	
	return &menue_curves;
  40574e:	4640      	mov	r0, r8
  405750:	b003      	add	sp, #12
  405752:	ecbd 8b02 	vpop	{d8}
  405756:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40575a:	bf00      	nop
  40575c:	0041a988 	.word	0x0041a988
  405760:	459c4000 	.word	0x459c4000
  405764:	0041a998 	.word	0x0041a998

00405768 <menue_drive_init>:
#define drive_ARD				(opt_drive[8])
#define drive_restore			(opt_drive[9])
#define drive_save				(opt_drive[10])

void menue_drive_init(menue_design_image_t *imgae_menue)
{
  405768:	b5f0      	push	{r4, r5, r6, r7, lr}
	fill_menue_image(imgae_menue, &menue_drive, timing, "Drive param setup (D)", &menue_lift_data_applied.set_password);
  40576a:	4a2f      	ldr	r2, [pc, #188]	; (405828 <menue_drive_init+0xc0>)
{
  40576c:	b083      	sub	sp, #12
	fill_menue_image(imgae_menue, &menue_drive, timing, "Drive param setup (D)", &menue_lift_data_applied.set_password);
  40576e:	4d2f      	ldr	r5, [pc, #188]	; (40582c <menue_drive_init+0xc4>)
{
  405770:	4606      	mov	r6, r0
	fill_menue_image(imgae_menue, &menue_drive, timing, "Drive param setup (D)", &menue_lift_data_applied.set_password);
  405772:	9200      	str	r2, [sp, #0]
  405774:	4629      	mov	r1, r5
  405776:	4b2e      	ldr	r3, [pc, #184]	; (405830 <menue_drive_init+0xc8>)
  405778:	4a2e      	ldr	r2, [pc, #184]	; (405834 <menue_drive_init+0xcc>)
  40577a:	4c2f      	ldr	r4, [pc, #188]	; (405838 <menue_drive_init+0xd0>)
  40577c:	47a0      	blx	r4
	
	drive_driver.text = "Driver";
  40577e:	4c2f      	ldr	r4, [pc, #188]	; (40583c <menue_drive_init+0xd4>)
  405780:	4a2f      	ldr	r2, [pc, #188]	; (405840 <menue_drive_init+0xd8>)
	drive_driver.child = menue_driver_drive_init();
  405782:	4b30      	ldr	r3, [pc, #192]	; (405844 <menue_drive_init+0xdc>)
	drive_driver.text = "Driver";
  405784:	6022      	str	r2, [r4, #0]
	drive_driver.child = menue_driver_drive_init();
  405786:	4798      	blx	r3
	drive_motor.text = "Motor Parameters";
  405788:	4a2f      	ldr	r2, [pc, #188]	; (405848 <menue_drive_init+0xe0>)
	drive_motor.child = menue_driver_motor_parameters_init();
  40578a:	4b30      	ldr	r3, [pc, #192]	; (40584c <menue_drive_init+0xe4>)
	drive_motor.text = "Motor Parameters";
  40578c:	62a2      	str	r2, [r4, #40]	; 0x28
	drive_driver.child = menue_driver_drive_init();
  40578e:	6220      	str	r0, [r4, #32]
	drive_motor.child = menue_driver_motor_parameters_init();
  405790:	4798      	blx	r3
	drive_vector.text = "Vector param";
  405792:	4a2f      	ldr	r2, [pc, #188]	; (405850 <menue_drive_init+0xe8>)
	drive_vector.child = menue_driver_vector_init();
  405794:	4b2f      	ldr	r3, [pc, #188]	; (405854 <menue_drive_init+0xec>)
	drive_vector.text = "Vector param";
  405796:	6522      	str	r2, [r4, #80]	; 0x50
	drive_motor.child = menue_driver_motor_parameters_init();
  405798:	64a0      	str	r0, [r4, #72]	; 0x48
	drive_vector.child = menue_driver_vector_init();
  40579a:	4798      	blx	r3
	drive_mech.text = "Mechanical data";
  40579c:	4a2e      	ldr	r2, [pc, #184]	; (405858 <menue_drive_init+0xf0>)
	drive_mech.child = menue_driver_mech_data_init();
  40579e:	4b2f      	ldr	r3, [pc, #188]	; (40585c <menue_drive_init+0xf4>)
	drive_mech.text = "Mechanical data";
  4057a0:	f8c4 2118 	str.w	r2, [r4, #280]	; 0x118
	drive_vector.child = menue_driver_vector_init();
  4057a4:	6720      	str	r0, [r4, #112]	; 0x70
	drive_mech.child = menue_driver_mech_data_init();
  4057a6:	4798      	blx	r3
	drive_encoder.text = "Encoder param";
  4057a8:	4a2d      	ldr	r2, [pc, #180]	; (405860 <menue_drive_init+0xf8>)
	drive_encoder.child = menue_driver_encoder_init();
  4057aa:	4b2e      	ldr	r3, [pc, #184]	; (405864 <menue_drive_init+0xfc>)
	drive_encoder.text = "Encoder param";
  4057ac:	67a2      	str	r2, [r4, #120]	; 0x78
	drive_mech.child = menue_driver_mech_data_init();
  4057ae:	f8c4 0138 	str.w	r0, [r4, #312]	; 0x138
	drive_encoder.child = menue_driver_encoder_init();
  4057b2:	4798      	blx	r3
	drive_vf.text = "V/F parameters";
  4057b4:	4a2c      	ldr	r2, [pc, #176]	; (405868 <menue_drive_init+0x100>)
	drive_vf.child = menue_driver_vf_init();
  4057b6:	4b2d      	ldr	r3, [pc, #180]	; (40586c <menue_drive_init+0x104>)
	drive_vf.text = "V/F parameters";
  4057b8:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	drive_encoder.child = menue_driver_encoder_init();
  4057bc:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	drive_vf.child = menue_driver_vf_init();
  4057c0:	4798      	blx	r3
	drive_overload.text = "Overload";
  4057c2:	4a2b      	ldr	r2, [pc, #172]	; (405870 <menue_drive_init+0x108>)
	drive_overload.child = menue_driver_overload_init();
  4057c4:	4b2b      	ldr	r3, [pc, #172]	; (405874 <menue_drive_init+0x10c>)
	drive_overload.text = "Overload";
  4057c6:	f8c4 20c8 	str.w	r2, [r4, #200]	; 0xc8
	drive_vf.child = menue_driver_vf_init();
  4057ca:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	drive_overload.child = menue_driver_overload_init();
  4057ce:	4798      	blx	r3
	drive_brake.text = "Motor brake";
  4057d0:	4a29      	ldr	r2, [pc, #164]	; (405878 <menue_drive_init+0x110>)
	drive_brake.child = menue_driver_brake_init();
  4057d2:	4b2a      	ldr	r3, [pc, #168]	; (40587c <menue_drive_init+0x114>)
	drive_brake.text = "Motor brake";
  4057d4:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
	drive_overload.child = menue_driver_overload_init();
  4057d8:	f8c4 00e8 	str.w	r0, [r4, #232]	; 0xe8
	drive_brake.child = menue_driver_brake_init();
  4057dc:	4798      	blx	r3
	drive_ARD.text = "ARD";
  4057de:	4a28      	ldr	r2, [pc, #160]	; (405880 <menue_drive_init+0x118>)
	drive_ARD.child = menue_drive_ARD_init();
  4057e0:	4b28      	ldr	r3, [pc, #160]	; (405884 <menue_drive_init+0x11c>)
	drive_ARD.text = "ARD";
  4057e2:	f8c4 2140 	str.w	r2, [r4, #320]	; 0x140
	drive_brake.child = menue_driver_brake_init();
  4057e6:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
	drive_ARD.child = menue_drive_ARD_init();
  4057ea:	4798      	blx	r3
	drive_restore.confirmed_sub = &menue_data_manager_drive_restore;
	drive_save.text = "Save drive param";
	drive_save.confirm_msg = "Are you sure?";
	drive_save.confirmed_sub = &menue_data_manager_saveDrive;
	
	fill_menue_list(&menue_drive, opt_drive, OPT_DRIVE_MAX, imgae_menue, 0);
  4057ec:	4633      	mov	r3, r6
  4057ee:	2100      	movs	r1, #0
	drive_restore.text = "Restore Factory set";
  4057f0:	4a25      	ldr	r2, [pc, #148]	; (405888 <menue_drive_init+0x120>)
	drive_save.text = "Save drive param";
  4057f2:	4e26      	ldr	r6, [pc, #152]	; (40588c <menue_drive_init+0x124>)
	drive_ARD.child = menue_drive_ARD_init();
  4057f4:	f8c4 0160 	str.w	r0, [r4, #352]	; 0x160
	fill_menue_list(&menue_drive, opt_drive, OPT_DRIVE_MAX, imgae_menue, 0);
  4057f8:	4628      	mov	r0, r5
	drive_restore.confirmed_sub = &menue_data_manager_drive_restore;
  4057fa:	f8df e0a0 	ldr.w	lr, [pc, #160]	; 40589c <menue_drive_init+0x134>
	drive_restore.confirm_msg = "Are you sure?";
  4057fe:	4d24      	ldr	r5, [pc, #144]	; (405890 <menue_drive_init+0x128>)
	drive_save.confirmed_sub = &menue_data_manager_saveDrive;
  405800:	4f24      	ldr	r7, [pc, #144]	; (405894 <menue_drive_init+0x12c>)
	fill_menue_list(&menue_drive, opt_drive, OPT_DRIVE_MAX, imgae_menue, 0);
  405802:	9100      	str	r1, [sp, #0]
  405804:	4621      	mov	r1, r4
	drive_restore.text = "Restore Factory set";
  405806:	f8c4 2168 	str.w	r2, [r4, #360]	; 0x168
	fill_menue_list(&menue_drive, opt_drive, OPT_DRIVE_MAX, imgae_menue, 0);
  40580a:	220b      	movs	r2, #11
	drive_save.text = "Save drive param";
  40580c:	f8c4 6190 	str.w	r6, [r4, #400]	; 0x190
	fill_menue_list(&menue_drive, opt_drive, OPT_DRIVE_MAX, imgae_menue, 0);
  405810:	4e21      	ldr	r6, [pc, #132]	; (405898 <menue_drive_init+0x130>)
	drive_restore.confirmed_sub = &menue_data_manager_drive_restore;
  405812:	f8c4 e184 	str.w	lr, [r4, #388]	; 0x184
	drive_save.confirmed_sub = &menue_data_manager_saveDrive;
  405816:	f8c4 71ac 	str.w	r7, [r4, #428]	; 0x1ac
	drive_restore.confirm_msg = "Are you sure?";
  40581a:	f8c4 516c 	str.w	r5, [r4, #364]	; 0x16c
	drive_save.confirm_msg = "Are you sure?";
  40581e:	f8c4 5194 	str.w	r5, [r4, #404]	; 0x194
	fill_menue_list(&menue_drive, opt_drive, OPT_DRIVE_MAX, imgae_menue, 0);
  405822:	47b0      	blx	r6
  405824:	b003      	add	sp, #12
  405826:	bdf0      	pop	{r4, r5, r6, r7, pc}
  405828:	20405384 	.word	0x20405384
  40582c:	204020a8 	.word	0x204020a8
  405830:	0041a99c 	.word	0x0041a99c
  405834:	0041a484 	.word	0x0041a484
  405838:	0040b0d5 	.word	0x0040b0d5
  40583c:	20401ef0 	.word	0x20401ef0
  405840:	0041a9b4 	.word	0x0041a9b4
  405844:	004058a1 	.word	0x004058a1
  405848:	0041a9bc 	.word	0x0041a9bc
  40584c:	00405efd 	.word	0x00405efd
  405850:	0041a9d0 	.word	0x0041a9d0
  405854:	00406451 	.word	0x00406451
  405858:	0041a9e0 	.word	0x0041a9e0
  40585c:	00405cc9 	.word	0x00405cc9
  405860:	0041a9f0 	.word	0x0041a9f0
  405864:	004059e1 	.word	0x004059e1
  405868:	0041aa00 	.word	0x0041aa00
  40586c:	004068e9 	.word	0x004068e9
  405870:	0041aa10 	.word	0x0041aa10
  405874:	0040635d 	.word	0x0040635d
  405878:	0041aa1c 	.word	0x0041aa1c
  40587c:	00406b55 	.word	0x00406b55
  405880:	0041aa28 	.word	0x0041aa28
  405884:	00406aa1 	.word	0x00406aa1
  405888:	0041aa2c 	.word	0x0041aa2c
  40588c:	0041aa50 	.word	0x0041aa50
  405890:	0041aa40 	.word	0x0041aa40
  405894:	00409e05 	.word	0x00409e05
  405898:	0040b0ad 	.word	0x0040b0ad
  40589c:	004098ed 	.word	0x004098ed

004058a0 <menue_driver_drive_init>:

#define phase_fail_on						(opt_driver_drive_phase_fail[0])
#define phase_fail_off						(opt_driver_drive_phase_fail[1])

menue_design_t *menue_driver_drive_init(void)
{
  4058a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	oval_ddrive_max_freq.max_value = 100;
	oval_ddrive_max_freq.min_value = 1;
	oval_ddrive_max_freq.new_val_flag = &menue_drive_data_newdata_flag;
	oval_ddrive_max_freq.unit = "Hz";
	//oval_ddrive_max_freq.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_ddrive_max_freq.val = &menue_drive_data_setup.m_max_freq;
  4058a4:	f8df 8118 	ldr.w	r8, [pc, #280]	; 4059c0 <menue_driver_drive_init+0x120>
{
  4058a8:	b082      	sub	sp, #8
	ddrive_max_freq.option_save_val = &oval_ddrive_max_freq;
//__________________________________________________

	ddrive_carier_freq.text = "Carrier Frequency";
	oval_ddrive_carier_freq.data_types = uint8_dt;
  4058aa:	4d36      	ldr	r5, [pc, #216]	; (405984 <menue_driver_drive_init+0xe4>)
	oval_ddrive_carier_freq.mantissa_count = 0;
	oval_ddrive_carier_freq.real_count = 2;
	oval_ddrive_carier_freq.max_value = 8;
	oval_ddrive_carier_freq.min_value = 2;
  4058ac:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
	control_mode_vf.text = "v/f";
	control_mode_cl_vector.text = "Closed loop vector";
	control_mode_ol_vector.text = "Open loop vector";


	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  4058b0:	f108 0205 	add.w	r2, r8, #5
	oval_ddrive_max_freq.real_count = 3;
  4058b4:	2403      	movs	r4, #3
	oval_ddrive_carier_freq.max_value = 8;
  4058b6:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
	oval_ddrive_max_freq.min_value = 1;
  4058ba:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  4058be:	9200      	str	r2, [sp, #0]
  4058c0:	4622      	mov	r2, r4
	oval_ddrive_carier_freq.min_value = 2;
  4058c2:	61ae      	str	r6, [r5, #24]
	oval_ddrive_carier_freq.data_types = uint8_dt;
  4058c4:	2700      	movs	r7, #0
	oval_ddrive_max_freq.data_types = fixedpt_dt;
  4058c6:	4e30      	ldr	r6, [pc, #192]	; (405988 <menue_driver_drive_init+0xe8>)
  4058c8:	f04f 0902 	mov.w	r9, #2
	oval_ddrive_carier_freq.max_value = 8;
  4058cc:	6169      	str	r1, [r5, #20]
	oval_ddrive_carier_freq.val = &menue_drive_data_setup.m_carier_freq;
  4058ce:	f108 0304 	add.w	r3, r8, #4
	oval_ddrive_max_freq.real_count = 3;
  4058d2:	6074      	str	r4, [r6, #4]
	oval_ddrive_carier_freq.unit = "KHz";
  4058d4:	492d      	ldr	r1, [pc, #180]	; (40598c <menue_driver_drive_init+0xec>)
	oval_ddrive_max_freq.new_val_flag = &menue_drive_data_newdata_flag;
  4058d6:	4c2e      	ldr	r4, [pc, #184]	; (405990 <menue_driver_drive_init+0xf0>)
	oval_ddrive_carier_freq.unit = "KHz";
  4058d8:	60e9      	str	r1, [r5, #12]
	oval_ddrive_max_freq.min_value = 1;
  4058da:	61b0      	str	r0, [r6, #24]
	oval_ddrive_max_freq.new_val_flag = &menue_drive_data_newdata_flag;
  4058dc:	6234      	str	r4, [r6, #32]
	oval_ddrive_carier_freq.new_val_flag = &menue_drive_data_newdata_flag;
  4058de:	622c      	str	r4, [r5, #32]
	oval_ddrive_max_freq.max_value = 100;
  4058e0:	492c      	ldr	r1, [pc, #176]	; (405994 <menue_driver_drive_init+0xf4>)
	ddrive_max_freq.text = "Maximum Frequency";
  4058e2:	4c2d      	ldr	r4, [pc, #180]	; (405998 <menue_driver_drive_init+0xf8>)
	oval_ddrive_max_freq.unit = "Hz";
  4058e4:	482d      	ldr	r0, [pc, #180]	; (40599c <menue_driver_drive_init+0xfc>)
	oval_ddrive_carier_freq.val = &menue_drive_data_setup.m_carier_freq;
  4058e6:	61eb      	str	r3, [r5, #28]
	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  4058e8:	463b      	mov	r3, r7
	oval_ddrive_max_freq.val = &menue_drive_data_setup.m_max_freq;
  4058ea:	f8c6 801c 	str.w	r8, [r6, #28]
	oval_ddrive_max_freq.max_value = 100;
  4058ee:	6171      	str	r1, [r6, #20]
	oval_ddrive_max_freq.data_types = fixedpt_dt;
  4058f0:	f886 9000 	strb.w	r9, [r6]
	oval_ddrive_max_freq.unit = "Hz";
  4058f4:	60f0      	str	r0, [r6, #12]
	oval_ddrive_max_freq.mantissa_count = 2;
  4058f6:	f8c6 9008 	str.w	r9, [r6, #8]
	oval_ddrive_carier_freq.real_count = 2;
  4058fa:	f8c5 9004 	str.w	r9, [r5, #4]
	oval_ddrive_carier_freq.data_types = uint8_dt;
  4058fe:	702f      	strb	r7, [r5, #0]
	oval_ddrive_carier_freq.mantissa_count = 0;
  405900:	60af      	str	r7, [r5, #8]
	ddrive_max_freq.option_save_val = &oval_ddrive_max_freq;
  405902:	6266      	str	r6, [r4, #36]	; 0x24
	ddrive_carier_freq.option_save_val = &oval_ddrive_carier_freq;
  405904:	64e5      	str	r5, [r4, #76]	; 0x4c
	ddrive_max_freq.text = "Maximum Frequency";
  405906:	4e26      	ldr	r6, [pc, #152]	; (4059a0 <menue_driver_drive_init+0x100>)
	ddrive_carier_freq.text = "Carrier Frequency";
  405908:	4d26      	ldr	r5, [pc, #152]	; (4059a4 <menue_driver_drive_init+0x104>)
	control_mode_vf.text = "v/f";
  40590a:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 4059c4 <menue_driver_drive_init+0x124>
	ddrive_max_freq.text = "Maximum Frequency";
  40590e:	6026      	str	r6, [r4, #0]
	ddrive_carier_freq.text = "Carrier Frequency";
  405910:	62a5      	str	r5, [r4, #40]	; 0x28
	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  405912:	4671      	mov	r1, lr
	ddrive_control_mode.text = "Control mode";
  405914:	4e24      	ldr	r6, [pc, #144]	; (4059a8 <menue_driver_drive_init+0x108>)
	control_mode_vf.text = "v/f";
  405916:	4d25      	ldr	r5, [pc, #148]	; (4059ac <menue_driver_drive_init+0x10c>)
	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  405918:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 4059c8 <menue_driver_drive_init+0x128>
	ddrive_control_mode.text = "Control mode";
  40591c:	6526      	str	r6, [r4, #80]	; 0x50
	control_mode_vf.text = "v/f";
  40591e:	f8ce 5000 	str.w	r5, [lr]
	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  405922:	4650      	mov	r0, sl
	control_mode_cl_vector.text = "Closed loop vector";
  405924:	4e22      	ldr	r6, [pc, #136]	; (4059b0 <menue_driver_drive_init+0x110>)
	control_mode_ol_vector.text = "Open loop vector";
  405926:	4d23      	ldr	r5, [pc, #140]	; (4059b4 <menue_driver_drive_init+0x114>)
	control_mode_cl_vector.text = "Closed loop vector";
  405928:	f8ce 6028 	str.w	r6, [lr, #40]	; 0x28
	control_mode_ol_vector.text = "Open loop vector";
  40592c:	f8ce 5050 	str.w	r5, [lr, #80]	; 0x50
	fill_menue_list(&menue_driver_drive_control_mode, &opt_driver_drive_control_mode, OPT_DRIVER_DRIVE_CONTROL_MODE_MAX, 0, &menue_drive_data_setup.m_control_mode);
  405930:	4d21      	ldr	r5, [pc, #132]	; (4059b8 <menue_driver_drive_init+0x118>)
  405932:	47a8      	blx	r5
	
	ddrive_inp_ph_fail.text = "Input phase fail";
	phase_fail_on.text = "On";
	phase_fail_off.text = "off";

	fill_menue_list(&menue_driver_drive_phase_fail, &opt_driver_drive_phase_fail, OPT_DRIVER_DRIVE_PHASE_FAIL_MAX, 0, &menue_drive_data_setup.m_input_phase_fail);
  405934:	f108 010e 	add.w	r1, r8, #14
	ddrive_inp_ph_fail.text = "Input phase fail";
  405938:	f8df c090 	ldr.w	ip, [pc, #144]	; 4059cc <menue_driver_drive_init+0x12c>
	fill_menue_list(&menue_driver_drive_phase_fail, &opt_driver_drive_phase_fail, OPT_DRIVER_DRIVE_PHASE_FAIL_MAX, 0, &menue_drive_data_setup.m_input_phase_fail);
  40593c:	464a      	mov	r2, r9
	phase_fail_on.text = "On";
  40593e:	f8df e090 	ldr.w	lr, [pc, #144]	; 4059d0 <menue_driver_drive_init+0x130>
	fill_menue_list(&menue_driver_drive_phase_fail, &opt_driver_drive_phase_fail, OPT_DRIVER_DRIVE_PHASE_FAIL_MAX, 0, &menue_drive_data_setup.m_input_phase_fail);
  405942:	463b      	mov	r3, r7
	phase_fail_on.text = "On";
  405944:	f8df 808c 	ldr.w	r8, [pc, #140]	; 4059d4 <menue_driver_drive_init+0x134>
	fill_menue_list(&menue_driver_drive_phase_fail, &opt_driver_drive_phase_fail, OPT_DRIVER_DRIVE_PHASE_FAIL_MAX, 0, &menue_drive_data_setup.m_input_phase_fail);
  405948:	9100      	str	r1, [sp, #0]
  40594a:	4671      	mov	r1, lr
  40594c:	4e1b      	ldr	r6, [pc, #108]	; (4059bc <menue_driver_drive_init+0x11c>)
	ddrive_inp_ph_fail.text = "Input phase fail";
  40594e:	f8c4 c078 	str.w	ip, [r4, #120]	; 0x78
	phase_fail_off.text = "off";
  405952:	f8df c084 	ldr.w	ip, [pc, #132]	; 4059d8 <menue_driver_drive_init+0x138>
	fill_menue_list(&menue_driver_drive_phase_fail, &opt_driver_drive_phase_fail, OPT_DRIVER_DRIVE_PHASE_FAIL_MAX, 0, &menue_drive_data_setup.m_input_phase_fail);
  405956:	4630      	mov	r0, r6
	phase_fail_on.text = "On";
  405958:	f8ce 8000 	str.w	r8, [lr]

	// set the 'option ladvanced_req_pins' child

	ddrive_inp_ph_fail.child = &menue_driver_drive_phase_fail;
//___________________________________________________________
	fill_menue_list(&menue_driver_drive, opt_driver_drive, OPT_DRIVER_DRIVE_MAX, 0, 0);
  40595c:	f8df 807c 	ldr.w	r8, [pc, #124]	; 4059dc <menue_driver_drive_init+0x13c>
	phase_fail_off.text = "off";
  405960:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	ddrive_control_mode.child = &menue_driver_drive_control_mode;
  405964:	f8c4 a070 	str.w	sl, [r4, #112]	; 0x70
	fill_menue_list(&menue_driver_drive_phase_fail, &opt_driver_drive_phase_fail, OPT_DRIVER_DRIVE_PHASE_FAIL_MAX, 0, &menue_drive_data_setup.m_input_phase_fail);
  405968:	47a8      	blx	r5
	fill_menue_list(&menue_driver_drive, opt_driver_drive, OPT_DRIVER_DRIVE_MAX, 0, 0);
  40596a:	9700      	str	r7, [sp, #0]
  40596c:	4640      	mov	r0, r8
  40596e:	463b      	mov	r3, r7
  405970:	4621      	mov	r1, r4
  405972:	2204      	movs	r2, #4
	ddrive_inp_ph_fail.child = &menue_driver_drive_phase_fail;
  405974:	f8c4 6098 	str.w	r6, [r4, #152]	; 0x98
	fill_menue_list(&menue_driver_drive, opt_driver_drive, OPT_DRIVER_DRIVE_MAX, 0, 0);
  405978:	47a8      	blx	r5
	return &menue_driver_drive;
}
  40597a:	4640      	mov	r0, r8
  40597c:	b002      	add	sp, #8
  40597e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  405982:	bf00      	nop
  405984:	20402190 	.word	0x20402190
  405988:	204022a4 	.word	0x204022a4
  40598c:	0041aa8c 	.word	0x0041aa8c
  405990:	20404fec 	.word	0x20404fec
  405994:	42c80000 	.word	0x42c80000
  405998:	20402204 	.word	0x20402204
  40599c:	004199e8 	.word	0x004199e8
  4059a0:	0041aa64 	.word	0x0041aa64
  4059a4:	0041aa78 	.word	0x0041aa78
  4059a8:	0041aa90 	.word	0x0041aa90
  4059ac:	0041aaa0 	.word	0x0041aaa0
  4059b0:	0041aaa4 	.word	0x0041aaa4
  4059b4:	0041aab8 	.word	0x0041aab8
  4059b8:	0040b0ad 	.word	0x0040b0ad
  4059bc:	204020c4 	.word	0x204020c4
  4059c0:	204051a8 	.word	0x204051a8
  4059c4:	204020fc 	.word	0x204020fc
  4059c8:	20402174 	.word	0x20402174
  4059cc:	0041aacc 	.word	0x0041aacc
  4059d0:	204021b4 	.word	0x204021b4
  4059d4:	0041a638 	.word	0x0041a638
  4059d8:	0041a700 	.word	0x0041a700
  4059dc:	204020e0 	.word	0x204020e0

004059e0 <menue_driver_encoder_init>:
#define enc_tune_rotational					(opt_eparam_enc_tune[1])
#define enc_tune_stand_still1				(opt_eparam_enc_tune[2])


menue_design_t *menue_driver_encoder_init(void)
{
  4059e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	dmotor_enc_type.text = "Encoder type";
	enc_type_incr.text = "Incremental";
	#ifdef PMSM_MODEL
	enc_type_siccos.text = "SinCos";
  4059e4:	f8df c1f8 	ldr.w	ip, [pc, #504]	; 405be0 <menue_driver_encoder_init+0x200>
{
  4059e8:	b083      	sub	sp, #12
	enc_type_endat.text = "Endat";
	#endif
	
	fill_menue_list(&menue_eparam_enc_type, &opt_eparam_enc_type, OPT_EPARAM_ENC_TYPE_MAX, 0, &menue_drive_data_setup.m_encoder_type);
  4059ea:	4d6f      	ldr	r5, [pc, #444]	; (405ba8 <menue_driver_encoder_init+0x1c8>)
	// set the 'option ladvanced_req_pins' child

	dmotor_enc_type.child = &menue_eparam_enc_type;
//___________________________________________________________
	dmotor_enc_pulse_count.text = "Encoder pulse/rev";
	oval_deparam_ppr.data_types = uint16_dt;
  4059ec:	f04f 0b01 	mov.w	fp, #1
	enc_type_incr.text = "Incremental";
  4059f0:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 405be4 <menue_driver_encoder_init+0x204>
	fill_menue_list(&menue_eparam_enc_type, &opt_eparam_enc_type, OPT_EPARAM_ENC_TYPE_MAX, 0, &menue_drive_data_setup.m_encoder_type);
  4059f4:	2300      	movs	r3, #0
	dmotor_enc_type.text = "Encoder type";
  4059f6:	4c6d      	ldr	r4, [pc, #436]	; (405bac <menue_driver_encoder_init+0x1cc>)
	fill_menue_list(&menue_eparam_enc_type, &opt_eparam_enc_type, OPT_EPARAM_ENC_TYPE_MAX, 0, &menue_drive_data_setup.m_encoder_type);
  4059f8:	2203      	movs	r2, #3
  4059fa:	9500      	str	r5, [sp, #0]
  4059fc:	4671      	mov	r1, lr
  4059fe:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 405be8 <menue_driver_encoder_init+0x208>
	oval_deparam_ppr.mantissa_count = 0;
  405a02:	461e      	mov	r6, r3
	enc_type_siccos.text = "SinCos";
  405a04:	f8ce c028 	str.w	ip, [lr, #40]	; 0x28
	oval_deparam_ppr.real_count = 5;
  405a08:	f04f 0a05 	mov.w	sl, #5
	dmotor_enc_type.text = "Encoder type";
  405a0c:	f8df c1dc 	ldr.w	ip, [pc, #476]	; 405bec <menue_driver_encoder_init+0x20c>
	fill_menue_list(&menue_eparam_enc_type, &opt_eparam_enc_type, OPT_EPARAM_ENC_TYPE_MAX, 0, &menue_drive_data_setup.m_encoder_type);
  405a10:	4640      	mov	r0, r8
	enc_type_incr.text = "Incremental";
  405a12:	4f67      	ldr	r7, [pc, #412]	; (405bb0 <menue_driver_encoder_init+0x1d0>)
	enc_type_endat.text = "Endat";
  405a14:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 405bf0 <menue_driver_encoder_init+0x210>
	enc_type_incr.text = "Incremental";
  405a18:	f8ce 7000 	str.w	r7, [lr]
	enc_type_endat.text = "Endat";
  405a1c:	f8ce 9050 	str.w	r9, [lr, #80]	; 0x50
	dmotor_enc_type.text = "Encoder type";
  405a20:	f8c4 c000 	str.w	ip, [r4]
	fill_menue_list(&menue_eparam_enc_type, &opt_eparam_enc_type, OPT_EPARAM_ENC_TYPE_MAX, 0, &menue_drive_data_setup.m_encoder_type);
  405a24:	4f63      	ldr	r7, [pc, #396]	; (405bb4 <menue_driver_encoder_init+0x1d4>)
  405a26:	47b8      	blx	r7
//__________________________________________________
	dmotor_enc_direction.text = "Enc direction";
	enc_dir_alead.text = "Phase A lead";
	enc_dir_blead.text = "Phase B lead";
	
	fill_menue_list(&menue_eparam_enc_dir, &opt_eparam_enc_dir, OPT_EPARAM_ENC_DIR_MAX, 0, &menue_drive_data_setup.m_pg_direction);
  405a28:	eb05 030b 	add.w	r3, r5, fp
	oval_deparam_ppr.data_types = uint16_dt;
  405a2c:	f8df e1c4 	ldr.w	lr, [pc, #452]	; 405bf4 <menue_driver_encoder_init+0x214>
	oval_deparam_ppr.val = &menue_drive_data_setup.m_encoder_p_count;
  405a30:	1caa      	adds	r2, r5, #2
	fill_menue_list(&menue_eparam_enc_dir, &opt_eparam_enc_dir, OPT_EPARAM_ENC_DIR_MAX, 0, &menue_drive_data_setup.m_pg_direction);
  405a32:	9300      	str	r3, [sp, #0]
  405a34:	4633      	mov	r3, r6
	dmotor_enc_type.child = &menue_eparam_enc_type;
  405a36:	f8c4 8020 	str.w	r8, [r4, #32]
	dmotor_enc_direction.text = "Enc direction";
  405a3a:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 405bf8 <menue_driver_encoder_init+0x218>
	oval_deparam_ppr.real_count = 5;
  405a3e:	f8ce a004 	str.w	sl, [lr, #4]
	dmotor_enc_direction.text = "Enc direction";
  405a42:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
	oval_deparam_ppr.max_value = 10000;
  405a46:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 405bfc <menue_driver_encoder_init+0x21c>
	oval_deparam_ppr.unit = "P/R";
  405a4a:	f8df a1b4 	ldr.w	sl, [pc, #436]	; 405c00 <menue_driver_encoder_init+0x220>
	oval_deparam_ppr.max_value = 10000;
  405a4e:	f8ce 8014 	str.w	r8, [lr, #20]
	oval_deparam_ppr.min_value = 100;
  405a52:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 405c04 <menue_driver_encoder_init+0x224>
	enc_dir_alead.text = "Phase A lead";
  405a56:	f8df c1b0 	ldr.w	ip, [pc, #432]	; 405c08 <menue_driver_encoder_init+0x228>
	oval_deparam_ppr.min_value = 100;
  405a5a:	f8ce 8018 	str.w	r8, [lr, #24]
	oval_deparam_ppr.new_val_flag = &menue_drive_data_newdata_flag;
  405a5e:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 405c0c <menue_driver_encoder_init+0x22c>
	fill_menue_list(&menue_eparam_enc_dir, &opt_eparam_enc_dir, OPT_EPARAM_ENC_DIR_MAX, 0, &menue_drive_data_setup.m_pg_direction);
  405a62:	4661      	mov	r1, ip
  405a64:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 405c10 <menue_driver_encoder_init+0x230>
	oval_deparam_ppr.val = &menue_drive_data_setup.m_encoder_p_count;
  405a68:	f8ce 201c 	str.w	r2, [lr, #28]
	fill_menue_list(&menue_eparam_enc_dir, &opt_eparam_enc_dir, OPT_EPARAM_ENC_DIR_MAX, 0, &menue_drive_data_setup.m_pg_direction);
  405a6c:	2202      	movs	r2, #2
	dmotor_enc_pulse_count.option_save_val = &oval_deparam_ppr;
  405a6e:	f8c4 e04c 	str.w	lr, [r4, #76]	; 0x4c
	oval_deparam_ppr.data_types = uint16_dt;
  405a72:	f88e b000 	strb.w	fp, [lr]
	oval_deparam_ppr.mantissa_count = 0;
  405a76:	f8ce 6008 	str.w	r6, [lr, #8]
	oval_deparam_ppr.unit = "P/R";
  405a7a:	f8ce a00c 	str.w	sl, [lr, #12]
	oval_deparam_ppr.new_val_flag = &menue_drive_data_newdata_flag;
  405a7e:	f8ce 8020 	str.w	r8, [lr, #32]
	dmotor_enc_pulse_count.text = "Encoder pulse/rev";
  405a82:	484d      	ldr	r0, [pc, #308]	; (405bb8 <menue_driver_encoder_init+0x1d8>)
	enc_dir_blead.text = "Phase B lead";
  405a84:	f8df e18c 	ldr.w	lr, [pc, #396]	; 405c14 <menue_driver_encoder_init+0x234>
	enc_dir_alead.text = "Phase A lead";
  405a88:	f8df a18c 	ldr.w	sl, [pc, #396]	; 405c18 <menue_driver_encoder_init+0x238>
	dmotor_enc_pulse_count.text = "Encoder pulse/rev";
  405a8c:	62a0      	str	r0, [r4, #40]	; 0x28
	fill_menue_list(&menue_eparam_enc_dir, &opt_eparam_enc_dir, OPT_EPARAM_ENC_DIR_MAX, 0, &menue_drive_data_setup.m_pg_direction);
  405a8e:	4648      	mov	r0, r9
	enc_dir_alead.text = "Phase A lead";
  405a90:	f8cc a000 	str.w	sl, [ip]
	enc_dir_blead.text = "Phase B lead";
  405a94:	f8cc e028 	str.w	lr, [ip, #40]	; 0x28
	fill_menue_list(&menue_eparam_enc_dir, &opt_eparam_enc_dir, OPT_EPARAM_ENC_DIR_MAX, 0, &menue_drive_data_setup.m_pg_direction);
  405a98:	47b8      	blx	r7

	// set the 'option ladvanced_req_pins' child

	dmotor_enc_direction.child = &menue_eparam_enc_dir;
  405a9a:	f8c4 9070 	str.w	r9, [r4, #112]	; 0x70
	enc_tune_noAction.text = "No action";
	enc_tune_rotational.text = "Rotational";
	enc_tune_rotational.option_characteristics = OPTION_HIDDEN;
	enc_tune_stand_still1.text = "stationary";
	
	fill_menue_list(&menue_eparam_enc_tune, &opt_eparam_enc_tune, OPT_EPARAM_ENC_TUNE_MAX, 0, &menue_drive_encoder_tune);
  405a9e:	4947      	ldr	r1, [pc, #284]	; (405bbc <menue_driver_encoder_init+0x1dc>)
	oval_deparam_scurrent.val = &menue_drive_data_setup.m_encoder_search_current;
  405aa0:	f105 0c04 	add.w	ip, r5, #4
	dmotor_enc_tune.text = "Enc Phase tune";
  405aa4:	f8df 9174 	ldr.w	r9, [pc, #372]	; 405c1c <menue_driver_encoder_init+0x23c>
	fill_menue_list(&menue_eparam_enc_tune, &opt_eparam_enc_tune, OPT_EPARAM_ENC_TUNE_MAX, 0, &menue_drive_encoder_tune);
  405aa8:	2203      	movs	r2, #3
  405aaa:	9100      	str	r1, [sp, #0]
  405aac:	4633      	mov	r3, r6
	enc_tune_noAction.text = "No action";
  405aae:	f8df e170 	ldr.w	lr, [pc, #368]	; 405c20 <menue_driver_encoder_init+0x240>
	dmotor_enc_tune.text = "Enc Phase tune";
  405ab2:	f8c4 90c8 	str.w	r9, [r4, #200]	; 0xc8
	enc_tune_rotational.text = "Rotational";
  405ab6:	f8df 916c 	ldr.w	r9, [pc, #364]	; 405c24 <menue_driver_encoder_init+0x244>
	fill_menue_list(&menue_eparam_enc_tune, &opt_eparam_enc_tune, OPT_EPARAM_ENC_TUNE_MAX, 0, &menue_drive_encoder_tune);
  405aba:	4671      	mov	r1, lr
	enc_tune_rotational.option_characteristics = OPTION_HIDDEN;
  405abc:	f88e b038 	strb.w	fp, [lr, #56]	; 0x38
	enc_tune_rotational.text = "Rotational";
  405ac0:	f8ce 9028 	str.w	r9, [lr, #40]	; 0x28
	enc_tune_noAction.text = "No action";
  405ac4:	f8df b160 	ldr.w	fp, [pc, #352]	; 405c28 <menue_driver_encoder_init+0x248>
	enc_tune_stand_still1.text = "stationary";
  405ac8:	f8df 9160 	ldr.w	r9, [pc, #352]	; 405c2c <menue_driver_encoder_init+0x24c>
	enc_tune_noAction.text = "No action";
  405acc:	f8ce b000 	str.w	fp, [lr]

	dmotor_enc_tune.child = &menue_eparam_enc_tune;
//__________________________________________________
	dmotor_enc_filter.text = "speed filter";
	oval_deparam_filter.data_types = float_dt;
	oval_deparam_filter.mantissa_count = 2;
  405ad0:	f04f 0b02 	mov.w	fp, #2
	enc_tune_stand_still1.text = "stationary";
  405ad4:	f8ce 9050 	str.w	r9, [lr, #80]	; 0x50
	oval_deparam_scurrent.data_types = uint8_dt;
  405ad8:	f8df e154 	ldr.w	lr, [pc, #340]	; 405c30 <menue_driver_encoder_init+0x250>
	oval_deparam_scurrent.max_value = 250;
  405adc:	f8df 9154 	ldr.w	r9, [pc, #340]	; 405c34 <menue_driver_encoder_init+0x254>
	fill_menue_list(&menue_eparam_enc_tune, &opt_eparam_enc_tune, OPT_EPARAM_ENC_TUNE_MAX, 0, &menue_drive_encoder_tune);
  405ae0:	f8df a154 	ldr.w	sl, [pc, #340]	; 405c38 <menue_driver_encoder_init+0x258>
	oval_deparam_scurrent.val = &menue_drive_data_setup.m_encoder_search_current;
  405ae4:	f8ce c01c 	str.w	ip, [lr, #28]
	oval_deparam_scurrent.max_value = 250;
  405ae8:	f8ce 9014 	str.w	r9, [lr, #20]
	oval_deparam_scurrent.unit = "%";
  405aec:	f8df c14c 	ldr.w	ip, [pc, #332]	; 405c3c <menue_driver_encoder_init+0x25c>
	dmotor_enc_search_curr.text = "Angle Srch intensity";
  405af0:	4833      	ldr	r0, [pc, #204]	; (405bc0 <menue_driver_encoder_init+0x1e0>)
	oval_deparam_scurrent.min_value = 50;
  405af2:	f8df 914c 	ldr.w	r9, [pc, #332]	; 405c40 <menue_driver_encoder_init+0x260>
	dmotor_enc_search_curr.text = "Angle Srch intensity";
  405af6:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
	fill_menue_list(&menue_eparam_enc_tune, &opt_eparam_enc_tune, OPT_EPARAM_ENC_TUNE_MAX, 0, &menue_drive_encoder_tune);
  405afa:	4650      	mov	r0, sl
	oval_deparam_scurrent.data_types = uint8_dt;
  405afc:	f88e 6000 	strb.w	r6, [lr]
	oval_deparam_scurrent.mantissa_count = 0;
  405b00:	f8ce 6008 	str.w	r6, [lr, #8]
	oval_deparam_scurrent.new_val_flag = &menue_drive_data_newdata_flag;
  405b04:	f8ce 8020 	str.w	r8, [lr, #32]
	dmotor_enc_search_curr.option_save_val = &oval_deparam_scurrent;
  405b08:	f8c4 e0c4 	str.w	lr, [r4, #196]	; 0xc4
	oval_deparam_scurrent.min_value = 50;
  405b0c:	f8ce 9018 	str.w	r9, [lr, #24]
	oval_deparam_scurrent.unit = "%";
  405b10:	f8ce c00c 	str.w	ip, [lr, #12]
	oval_deparam_scurrent.real_count = 3;
  405b14:	f8ce 2004 	str.w	r2, [lr, #4]
	fill_menue_list(&menue_eparam_enc_tune, &opt_eparam_enc_tune, OPT_EPARAM_ENC_TUNE_MAX, 0, &menue_drive_encoder_tune);
  405b18:	4f26      	ldr	r7, [pc, #152]	; (405bb4 <menue_driver_encoder_init+0x1d4>)
  405b1a:	47b8      	blx	r7
	//oval_deparam_ppos.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_deparam_ppos.val = &menue_drive_data_setup.m_pole_pos_offset;
	dmotor_enc_pole_angle.option_save_val = &oval_deparam_ppos;
#endif
//__________________________________________________
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b1c:	9600      	str	r6, [sp, #0]
	oval_deparam_filter.val = &menue_drive_data_setup.m_enc_filter_low;
  405b1e:	f105 0c0c 	add.w	ip, r5, #12
	oval_deparam_ppos.val = &menue_drive_data_setup.m_pole_pos_offset;
  405b22:	f105 0e08 	add.w	lr, r5, #8
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b26:	4633      	mov	r3, r6
	oval_deparam_filter.data_types = float_dt;
  405b28:	4d26      	ldr	r5, [pc, #152]	; (405bc4 <menue_driver_encoder_init+0x1e4>)
	oval_deparam_ppos.data_types = float_dt;
  405b2a:	4e27      	ldr	r6, [pc, #156]	; (405bc8 <menue_driver_encoder_init+0x1e8>)
	oval_deparam_filter.data_types = float_dt;
  405b2c:	f04f 0703 	mov.w	r7, #3
	dmotor_enc_filter.text = "speed filter";
  405b30:	4826      	ldr	r0, [pc, #152]	; (405bcc <menue_driver_encoder_init+0x1ec>)
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b32:	4621      	mov	r1, r4
	oval_deparam_filter.data_types = float_dt;
  405b34:	702f      	strb	r7, [r5, #0]
	oval_deparam_ppos.data_types = float_dt;
  405b36:	7037      	strb	r7, [r6, #0]
	oval_deparam_ppos.real_count = 3;
  405b38:	2703      	movs	r7, #3
	dmotor_enc_pole_angle.text = "Pole position offset";
  405b3a:	4a25      	ldr	r2, [pc, #148]	; (405bd0 <menue_driver_encoder_init+0x1f0>)
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b3c:	f8df 9104 	ldr.w	r9, [pc, #260]	; 405c44 <menue_driver_encoder_init+0x264>
	dmotor_enc_tune.child = &menue_eparam_enc_tune;
  405b40:	f8c4 a0e8 	str.w	sl, [r4, #232]	; 0xe8
	oval_deparam_filter.min_value = 0;
  405b44:	f04f 0a00 	mov.w	sl, #0
	dmotor_enc_filter.text = "speed filter";
  405b48:	67a0      	str	r0, [r4, #120]	; 0x78
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b4a:	4648      	mov	r0, r9
	dmotor_enc_pole_angle.text = "Pole position offset";
  405b4c:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b50:	2207      	movs	r2, #7
	oval_deparam_filter.val = &menue_drive_data_setup.m_enc_filter_low;
  405b52:	f8c5 c01c 	str.w	ip, [r5, #28]
	oval_deparam_filter.max_value = 99;
  405b56:	eddf 7a1f 	vldr	s15, [pc, #124]	; 405bd4 <menue_driver_encoder_init+0x1f4>
	dmotor_enc_filter.option_save_val = &oval_deparam_filter;
  405b5a:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
	oval_deparam_ppos.val = &menue_drive_data_setup.m_pole_pos_offset;
  405b5e:	f8c6 e01c 	str.w	lr, [r6, #28]
	oval_deparam_ppos.real_count = 3;
  405b62:	6077      	str	r7, [r6, #4]
	oval_deparam_filter.unit = "ms";
  405b64:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 405c48 <menue_driver_encoder_init+0x268>
	dmotor_enc_pole_angle.option_save_val = &oval_deparam_ppos;
  405b68:	f8c4 6114 	str.w	r6, [r4, #276]	; 0x114
	oval_deparam_ppos.max_value = 360;
  405b6c:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 405c4c <menue_driver_encoder_init+0x26c>
	oval_deparam_ppos.min_value = -360;
  405b70:	4f19      	ldr	r7, [pc, #100]	; (405bd8 <menue_driver_encoder_init+0x1f8>)
	oval_deparam_ppos.unit = "Deg";
  405b72:	4c1a      	ldr	r4, [pc, #104]	; (405bdc <menue_driver_encoder_init+0x1fc>)
	oval_deparam_filter.new_val_flag = &menue_drive_data_newdata_flag;
  405b74:	f8c5 8020 	str.w	r8, [r5, #32]
	oval_deparam_ppos.unit = "Deg";
  405b78:	60f4      	str	r4, [r6, #12]
	oval_deparam_ppos.new_val_flag = &menue_drive_data_newdata_flag;
  405b7a:	f8c6 8020 	str.w	r8, [r6, #32]
	oval_deparam_filter.max_value = 99;
  405b7e:	edc5 7a05 	vstr	s15, [r5, #20]
	oval_deparam_filter.min_value = 0;
  405b82:	f8c5 a018 	str.w	sl, [r5, #24]
	oval_deparam_filter.unit = "ms";
  405b86:	f8c5 c00c 	str.w	ip, [r5, #12]
	oval_deparam_ppos.max_value = 360;
  405b8a:	f8c6 e014 	str.w	lr, [r6, #20]
	oval_deparam_ppos.min_value = -360;
  405b8e:	61b7      	str	r7, [r6, #24]
	oval_deparam_ppos.mantissa_count = 2;
  405b90:	f8c6 b008 	str.w	fp, [r6, #8]
	oval_deparam_filter.mantissa_count = 2;
  405b94:	f8c5 b008 	str.w	fp, [r5, #8]
	oval_deparam_filter.real_count = 2;
  405b98:	f8c5 b004 	str.w	fp, [r5, #4]
	fill_menue_list(&menue_driver_enc, opt_driver_enc, OPT_DRIVER_ENC_MAX, 0, 0);
  405b9c:	4c05      	ldr	r4, [pc, #20]	; (405bb4 <menue_driver_encoder_init+0x1d4>)
  405b9e:	47a0      	blx	r4
	return &menue_driver_enc;	
  405ba0:	4648      	mov	r0, r9
  405ba2:	b003      	add	sp, #12
  405ba4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405ba8:	20405194 	.word	0x20405194
  405bac:	2040232c 	.word	0x2040232c
  405bb0:	0041aaf0 	.word	0x0041aaf0
  405bb4:	0040b0ad 	.word	0x0040b0ad
  405bb8:	0041ab0c 	.word	0x0041ab0c
  405bbc:	204008e8 	.word	0x204008e8
  405bc0:	0041ab54 	.word	0x0041ab54
  405bc4:	204025fc 	.word	0x204025fc
  405bc8:	204022ec 	.word	0x204022ec
  405bcc:	0041aba0 	.word	0x0041aba0
  405bd0:	0041abb0 	.word	0x0041abb0
  405bd4:	42c60000 	.word	0x42c60000
  405bd8:	c3b40000 	.word	0xc3b40000
  405bdc:	0041abc8 	.word	0x0041abc8
  405be0:	0041aafc 	.word	0x0041aafc
  405be4:	20402568 	.word	0x20402568
  405be8:	20402530 	.word	0x20402530
  405bec:	0041aae0 	.word	0x0041aae0
  405bf0:	0041ab04 	.word	0x0041ab04
  405bf4:	204022c8 	.word	0x204022c8
  405bf8:	0041ab24 	.word	0x0041ab24
  405bfc:	461c4000 	.word	0x461c4000
  405c00:	0041ab20 	.word	0x0041ab20
  405c04:	42c80000 	.word	0x42c80000
  405c08:	20402468 	.word	0x20402468
  405c0c:	20404fec 	.word	0x20404fec
  405c10:	204025e0 	.word	0x204025e0
  405c14:	0041ab44 	.word	0x0041ab44
  405c18:	0041ab34 	.word	0x0041ab34
  405c1c:	0041ab6c 	.word	0x0041ab6c
  405c20:	204024b8 	.word	0x204024b8
  405c24:	0041ab88 	.word	0x0041ab88
  405c28:	0041ab7c 	.word	0x0041ab7c
  405c2c:	0041ab94 	.word	0x0041ab94
  405c30:	20402444 	.word	0x20402444
  405c34:	437a0000 	.word	0x437a0000
  405c38:	20402310 	.word	0x20402310
  405c3c:	0041a888 	.word	0x0041a888
  405c40:	42480000 	.word	0x42480000
  405c44:	2040254c 	.word	0x2040254c
  405c48:	0041a998 	.word	0x0041a998
  405c4c:	43b40000 	.word	0x43b40000

00405c50 <estimate_inertia>:

void estimate_inertia(void)
{
	float r2 ,tmp;
	
	r2 = menue_drive_data_setup.m_mech_sheave_dia / 2;
  405c50:	4a1a      	ldr	r2, [pc, #104]	; (405cbc <estimate_inertia+0x6c>)
	r2 /= 1000;
	r2 *= r2;
	
	tmp = menue_drive_data_setup.m_mech_payload_weight / 2;
	tmp += menue_drive_data_setup.m_mech_cabin_weight;
	tmp += menue_drive_data_setup.m_mech_counter_weight;
  405c52:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
	r2 /= 1000;
  405c56:	ed9f 3a1a 	vldr	s6, [pc, #104]	; 405cc0 <estimate_inertia+0x70>
  405c5a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
	r2 = menue_drive_data_setup.m_mech_sheave_dia / 2;
  405c5e:	f8b2 30e0 	ldrh.w	r3, [r2, #224]	; 0xe0
	tmp += menue_drive_data_setup.m_mech_counter_weight;
  405c62:	edd2 5a3a 	vldr	s11, [r2, #232]	; 0xe8
	r2 = menue_drive_data_setup.m_mech_sheave_dia / 2;
  405c66:	085b      	lsrs	r3, r3, #1
	tmp += menue_drive_data_setup.m_mech_counter_weight;
  405c68:	edd2 6a3b 	vldr	s13, [r2, #236]	; 0xec
  405c6c:	edd2 3a3c 	vldr	s7, [r2, #240]	; 0xf0
	r2 = menue_drive_data_setup.m_mech_sheave_dia / 2;
  405c70:	ee07 3a90 	vmov	s15, r3
	tmp += menue_drive_data_setup.m_mech_counter_weight;
  405c74:	ee76 6aa5 	vadd.f32	s13, s13, s11
	
	tmp *= r2;
	tmp /= menue_drive_data_setup.m_mech_sus_ratio;
  405c78:	f892 30e2 	ldrb.w	r3, [r2, #226]	; 0xe2
	r2 = menue_drive_data_setup.m_mech_sheave_dia / 2;
  405c7c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
	tmp += menue_drive_data_setup.m_mech_motor_inertia;
  405c80:	edd2 4a39 	vldr	s9, [r2, #228]	; 0xe4
	tmp /= menue_drive_data_setup.m_mech_sus_ratio;
  405c84:	ee06 3a10 	vmov	s12, r3
	
	if(tmp < 1) tmp = 1;
	if (tmp > 500) tmp = 500;
	
	menue_drive_data_setup.m_mech_inertia = tmp;
  405c88:	eddf 5a0e 	vldr	s11, [pc, #56]	; 405cc4 <estimate_inertia+0x74>
	r2 /= 1000;
  405c8c:	ee67 7a03 	vmul.f32	s15, s14, s6
	tmp += menue_drive_data_setup.m_mech_counter_weight;
  405c90:	eeb0 7a66 	vmov.f32	s14, s13
	tmp /= menue_drive_data_setup.m_mech_sus_ratio;
  405c94:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
	tmp *= r2;
  405c98:	ee67 7aa7 	vmul.f32	s15, s15, s15
	tmp += menue_drive_data_setup.m_mech_counter_weight;
  405c9c:	eea3 7a84 	vfma.f32	s14, s7, s8
	tmp *= r2;
  405ca0:	ee67 7a87 	vmul.f32	s15, s15, s14
	tmp /= menue_drive_data_setup.m_mech_sus_ratio;
  405ca4:	ee87 7a86 	vdiv.f32	s14, s15, s12
	tmp += menue_drive_data_setup.m_mech_motor_inertia;
  405ca8:	ee77 7a24 	vadd.f32	s15, s14, s9
  405cac:	fec7 7a85 	vmaxnm.f32	s15, s15, s10
	menue_drive_data_setup.m_mech_inertia = tmp;
  405cb0:	fec7 7ae5 	vminnm.f32	s15, s15, s11
  405cb4:	edc2 7a3d 	vstr	s15, [r2, #244]	; 0xf4
  405cb8:	4770      	bx	lr
  405cba:	bf00      	nop
  405cbc:	204050e8 	.word	0x204050e8
  405cc0:	3a83126f 	.word	0x3a83126f
  405cc4:	43fa0000 	.word	0x43fa0000

00405cc8 <menue_driver_mech_data_init>:
}

menue_design_t *menue_driver_mech_data_init(void)
{
  405cc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	dmotor_mech_trachtion_sheave_dia.option_save_val = &oval_dmech_trachtion_sheave_dia;
//__________________________________________________
	dmotor_mech_motor_inertia.text = "Motor inertia";
	oval_dmech_motor_inertia.data_types = float_dt;
	oval_dmech_motor_inertia.mantissa_count = 3;
	oval_dmech_motor_inertia.real_count = 2;
  405ccc:	2202      	movs	r2, #2
	oval_dmech_trachtion_sheave_dia.val = &menue_drive_data_setup.m_mech_sheave_dia;
  405cce:	4e5d      	ldr	r6, [pc, #372]	; (405e44 <menue_driver_mech_data_init+0x17c>)
	//oval_dmech_motor_inertia.text = "Low speed P gain";
	oval_dmech_motor_inertia.val = &menue_drive_data_setup.m_mech_motor_inertia;
	dmotor_mech_motor_inertia.option_save_val = &oval_dmech_motor_inertia;
//__________________________________________________
	dmotor_mech_sus_ratio.text = "Suspension ratio";
	oval_dmech_sus_ratio.data_types = uint8_dt;
  405cd0:	4f5d      	ldr	r7, [pc, #372]	; (405e48 <menue_driver_mech_data_init+0x180>)
	oval_dmech_sus_ratio.mantissa_count = 0;
	oval_dmech_sus_ratio.real_count = 1;
	oval_dmech_sus_ratio.max_value = 8;
  405cd2:	f04f 4c82 	mov.w	ip, #1090519040	; 0x41000000
	oval_dmech_sus_ratio.min_value = 1;
	oval_dmech_sus_ratio.new_val_flag = &menue_drive_data_newdata_flag;
	//oval_dmech_sus_ratio.unit = "KW";
	//oval_dmech_sus_ratio.text = "Low speed P gain";
	oval_dmech_sus_ratio.val = &menue_drive_data_setup.m_mech_sus_ratio;
  405cd6:	18b1      	adds	r1, r6, r2
	oval_dmech_motor_inertia.data_types = float_dt;
  405cd8:	4b5c      	ldr	r3, [pc, #368]	; (405e4c <menue_driver_mech_data_init+0x184>)
	oval_dmech_motor_inertia.val = &menue_drive_data_setup.m_mech_motor_inertia;
  405cda:	f106 0804 	add.w	r8, r6, #4
	oval_dmech_trachtion_sheave_dia.data_types = uint16_dt;
  405cde:	2401      	movs	r4, #1
	oval_dmech_sus_ratio.val = &menue_drive_data_setup.m_mech_sus_ratio;
  405ce0:	61f9      	str	r1, [r7, #28]
	oval_dmech_sus_ratio.min_value = 1;
  405ce2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	oval_dmech_trachtion_sheave_dia.data_types = uint16_dt;
  405ce6:	495a      	ldr	r1, [pc, #360]	; (405e50 <menue_driver_mech_data_init+0x188>)
	oval_dmech_cabin_weight.max_value = 8000;
	oval_dmech_cabin_weight.min_value = 0;
	oval_dmech_cabin_weight.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmech_cabin_weight.unit = "Kg";
	//oval_dmech_cabin_weight.text = "Low speed P gain";
	oval_dmech_cabin_weight.val = &menue_drive_data_setup.m_mech_cabin_weight;
  405ce8:	f106 0a0c 	add.w	sl, r6, #12
	oval_dmech_sus_ratio.max_value = 8;
  405cec:	f8c7 c014 	str.w	ip, [r7, #20]
	oval_dmech_counter_weight.val = &menue_drive_data_setup.m_mech_counter_weight;
  405cf0:	f106 0b08 	add.w	fp, r6, #8
	oval_dmech_trachtion_sheave_dia.min_value = 20;
  405cf4:	f8df e19c 	ldr.w	lr, [pc, #412]	; 405e94 <menue_driver_mech_data_init+0x1cc>
{
  405cf8:	b083      	sub	sp, #12
	oval_dmech_trachtion_sheave_dia.max_value = 1500;
  405cfa:	f8df c19c 	ldr.w	ip, [pc, #412]	; 405e98 <menue_driver_mech_data_init+0x1d0>
	oval_dmech_motor_inertia.val = &menue_drive_data_setup.m_mech_motor_inertia;
  405cfe:	f8c3 801c 	str.w	r8, [r3, #28]
	oval_dmech_trachtion_sheave_dia.mantissa_count = 0;
  405d02:	f04f 0800 	mov.w	r8, #0
	oval_dmech_motor_inertia.real_count = 2;
  405d06:	605a      	str	r2, [r3, #4]
	oval_dmech_trachtion_sheave_dia.real_count = 4;
  405d08:	2204      	movs	r2, #4
	oval_dmech_trachtion_sheave_dia.max_value = 1500;
  405d0a:	f8c1 c014 	str.w	ip, [r1, #20]
	oval_dmech_trachtion_sheave_dia.min_value = 20;
  405d0e:	f8c1 e018 	str.w	lr, [r1, #24]
	oval_dmech_trachtion_sheave_dia.new_val_flag = &menue_drive_data_newdata_flag;
  405d12:	f8df c188 	ldr.w	ip, [pc, #392]	; 405e9c <menue_driver_mech_data_init+0x1d4>
	oval_dmech_trachtion_sheave_dia.data_types = uint16_dt;
  405d16:	700c      	strb	r4, [r1, #0]
	oval_dmech_sus_ratio.real_count = 1;
  405d18:	607c      	str	r4, [r7, #4]
	oval_dmech_trachtion_sheave_dia.unit = "mm";
  405d1a:	f8df e184 	ldr.w	lr, [pc, #388]	; 405ea0 <menue_driver_mech_data_init+0x1d8>
	dmotor_mech_trachtion_sheave_dia.text = "Traction sheave dia";
  405d1e:	4c4d      	ldr	r4, [pc, #308]	; (405e54 <menue_driver_mech_data_init+0x18c>)
	oval_dmech_trachtion_sheave_dia.new_val_flag = &menue_drive_data_newdata_flag;
  405d20:	f8c1 c020 	str.w	ip, [r1, #32]
	oval_dmech_trachtion_sheave_dia.val = &menue_drive_data_setup.m_mech_sheave_dia;
  405d24:	61ce      	str	r6, [r1, #28]
	oval_dmech_trachtion_sheave_dia.unit = "mm";
  405d26:	f8c1 e00c 	str.w	lr, [r1, #12]
	oval_dmech_trachtion_sheave_dia.mantissa_count = 0;
  405d2a:	f8c1 8008 	str.w	r8, [r1, #8]
	oval_dmech_trachtion_sheave_dia.real_count = 4;
  405d2e:	604a      	str	r2, [r1, #4]
	dmotor_mech_trachtion_sheave_dia.option_save_val = &oval_dmech_trachtion_sheave_dia;
  405d30:	6261      	str	r1, [r4, #36]	; 0x24
	dmotor_mech_trachtion_sheave_dia.text = "Traction sheave dia";
  405d32:	4949      	ldr	r1, [pc, #292]	; (405e58 <menue_driver_mech_data_init+0x190>)
	oval_dmech_sus_ratio.new_val_flag = &menue_drive_data_newdata_flag;
  405d34:	f8c7 c020 	str.w	ip, [r7, #32]
	oval_dmech_sus_ratio.min_value = 1;
  405d38:	edc7 7a06 	vstr	s15, [r7, #24]
	oval_dmech_sus_ratio.data_types = uint8_dt;
  405d3c:	f887 8000 	strb.w	r8, [r7]
	oval_dmech_sus_ratio.mantissa_count = 0;
  405d40:	f8c7 8008 	str.w	r8, [r7, #8]
	dmotor_mech_sus_ratio.option_save_val = &oval_dmech_sus_ratio;
  405d44:	6767      	str	r7, [r4, #116]	; 0x74
	dmotor_mech_trachtion_sheave_dia.text = "Traction sheave dia";
  405d46:	6021      	str	r1, [r4, #0]
	oval_dmech_motor_inertia.max_value = 99;
  405d48:	4844      	ldr	r0, [pc, #272]	; (405e5c <menue_driver_mech_data_init+0x194>)
	dmotor_mech_motor_inertia.text = "Motor inertia";
  405d4a:	4945      	ldr	r1, [pc, #276]	; (405e60 <menue_driver_mech_data_init+0x198>)
	dmotor_mech_sus_ratio.text = "Suspension ratio";
  405d4c:	4f45      	ldr	r7, [pc, #276]	; (405e64 <menue_driver_mech_data_init+0x19c>)
	oval_dmech_counter_weight.data_types = float_dt;
  405d4e:	f8df e154 	ldr.w	lr, [pc, #340]	; 405ea4 <menue_driver_mech_data_init+0x1dc>
	oval_dmech_motor_inertia.max_value = 99;
  405d52:	6158      	str	r0, [r3, #20]
	oval_dmech_motor_inertia.data_types = float_dt;
  405d54:	2003      	movs	r0, #3
	dmotor_mech_motor_inertia.text = "Motor inertia";
  405d56:	62a1      	str	r1, [r4, #40]	; 0x28
	dmotor_mech_sus_ratio.text = "Suspension ratio";
  405d58:	6527      	str	r7, [r4, #80]	; 0x50
	oval_dmech_motor_inertia.unit = "Kg.m2";
  405d5a:	f8df 914c 	ldr.w	r9, [pc, #332]	; 405ea8 <menue_driver_mech_data_init+0x1e0>
	oval_dmech_motor_inertia.min_value = 0.01;
  405d5e:	4d42      	ldr	r5, [pc, #264]	; (405e68 <menue_driver_mech_data_init+0x1a0>)
	dmotor_mech_counter_weight.text = "Counter weight";
  405d60:	4942      	ldr	r1, [pc, #264]	; (405e6c <menue_driver_mech_data_init+0x1a4>)
	dmotor_mech_cabin_weight.text = "Cabin weight";
  405d62:	4f43      	ldr	r7, [pc, #268]	; (405e70 <menue_driver_mech_data_init+0x1a8>)
	oval_dmech_motor_inertia.new_val_flag = &menue_drive_data_newdata_flag;
  405d64:	f8c3 c020 	str.w	ip, [r3, #32]
	oval_dmech_motor_inertia.min_value = 0.01;
  405d68:	619d      	str	r5, [r3, #24]
	oval_dmech_payload_weight.val = &menue_drive_data_setup.m_mech_payload_weight;
  405d6a:	f106 0510 	add.w	r5, r6, #16
	dmotor_mech_motor_inertia.option_save_val = &oval_dmech_motor_inertia;
  405d6e:	64e3      	str	r3, [r4, #76]	; 0x4c
	oval_dmech_inertia.max_value = 400;
	oval_dmech_inertia.min_value = 1;
	oval_dmech_inertia.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmech_inertia.unit = "Kg.m2";
	///oval_dmech_inertia.text = "Low speed P gain";
	oval_dmech_inertia.val = &menue_drive_data_setup.m_mech_inertia;
  405d70:	3614      	adds	r6, #20
	dmotor_mech_counter_weight.text = "Counter weight";
  405d72:	67a1      	str	r1, [r4, #120]	; 0x78
	oval_dmech_motor_inertia.data_types = float_dt;
  405d74:	7018      	strb	r0, [r3, #0]
	oval_dmech_motor_inertia.mantissa_count = 3;
  405d76:	6098      	str	r0, [r3, #8]
	oval_dmech_motor_inertia.unit = "Kg.m2";
  405d78:	f8c3 900c 	str.w	r9, [r3, #12]
	oval_dmech_counter_weight.data_types = float_dt;
  405d7c:	f88e 0000 	strb.w	r0, [lr]
	oval_dmech_counter_weight.mantissa_count = 3;
  405d80:	f8ce 0008 	str.w	r0, [lr, #8]
	dmotor_mech_cabin_weight.text = "Cabin weight";
  405d84:	f8c4 70a0 	str.w	r7, [r4, #160]	; 0xa0
	dmotor_mech_estimate_inertia.enter = &estimate_inertia;
  405d88:	4f3a      	ldr	r7, [pc, #232]	; (405e74 <menue_driver_mech_data_init+0x1ac>)
	oval_dmech_counter_weight.val = &menue_drive_data_setup.m_mech_counter_weight;
  405d8a:	f8ce b01c 	str.w	fp, [lr, #28]
	dmotor_mech_estimate_inertia.enter = &estimate_inertia;
  405d8e:	f8c4 7104 	str.w	r7, [r4, #260]	; 0x104
	dmotor_mech_inertia.text = "Total inertia";
  405d92:	4f39      	ldr	r7, [pc, #228]	; (405e78 <menue_driver_mech_data_init+0x1b0>)
	oval_dmech_counter_weight.max_value = 8000;
  405d94:	f8df b114 	ldr.w	fp, [pc, #276]	; 405eac <menue_driver_mech_data_init+0x1e4>
	dmotor_mech_inertia.text = "Total inertia";
  405d98:	f8c4 7118 	str.w	r7, [r4, #280]	; 0x118
	oval_dmech_payload_weight.data_types = float_dt;
  405d9c:	4f37      	ldr	r7, [pc, #220]	; (405e7c <menue_driver_mech_data_init+0x1b4>)
	oval_dmech_counter_weight.new_val_flag = &menue_drive_data_newdata_flag;
  405d9e:	f8ce c020 	str.w	ip, [lr, #32]
	oval_dmech_payload_weight.val = &menue_drive_data_setup.m_mech_payload_weight;
  405da2:	61fd      	str	r5, [r7, #28]
	oval_dmech_cabin_weight.data_types = float_dt;
  405da4:	4d36      	ldr	r5, [pc, #216]	; (405e80 <menue_driver_mech_data_init+0x1b8>)
	oval_dmech_payload_weight.new_val_flag = &menue_drive_data_newdata_flag;
  405da6:	f8c7 c020 	str.w	ip, [r7, #32]
	oval_dmech_cabin_weight.val = &menue_drive_data_setup.m_mech_cabin_weight;
  405daa:	f8c5 a01c 	str.w	sl, [r5, #28]
	oval_dmech_counter_weight.min_value = 0;
  405dae:	f04f 0a00 	mov.w	sl, #0
	oval_dmech_cabin_weight.data_types = float_dt;
  405db2:	7028      	strb	r0, [r5, #0]
	oval_dmech_counter_weight.min_value = 0;
  405db4:	f8ce a018 	str.w	sl, [lr, #24]
	oval_dmech_payload_weight.min_value = 0;
  405db8:	f8c7 a018 	str.w	sl, [r7, #24]
	oval_dmech_cabin_weight.min_value = 0;
  405dbc:	f8c5 a018 	str.w	sl, [r5, #24]
	oval_dmech_counter_weight.unit = "Kg";
  405dc0:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 405eb0 <menue_driver_mech_data_init+0x1e8>
	oval_dmech_cabin_weight.mantissa_count = 3;
  405dc4:	60a8      	str	r0, [r5, #8]
	oval_dmech_cabin_weight.new_val_flag = &menue_drive_data_newdata_flag;
  405dc6:	f8c5 c020 	str.w	ip, [r5, #32]
	oval_dmech_counter_weight.real_count = 4;
  405dca:	f8ce 2004 	str.w	r2, [lr, #4]
	dmotor_mech_counter_weight.option_save_val = &oval_dmech_counter_weight;
  405dce:	f8c4 e09c 	str.w	lr, [r4, #156]	; 0x9c
	oval_dmech_payload_weight.data_types = float_dt;
  405dd2:	7038      	strb	r0, [r7, #0]
	oval_dmech_payload_weight.mantissa_count = 3;
  405dd4:	60b8      	str	r0, [r7, #8]
	oval_dmech_payload_weight.real_count = 4;
  405dd6:	607a      	str	r2, [r7, #4]
	dmotor_mech_payload_weight.option_save_val = &oval_dmech_payload_weight;
  405dd8:	f8c4 70ec 	str.w	r7, [r4, #236]	; 0xec
	oval_dmech_cabin_weight.real_count = 4;
  405ddc:	606a      	str	r2, [r5, #4]
	dmotor_mech_inertia.option_save_val = &oval_dmech_inertia;

//__________________________________________________

	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405dde:	2208      	movs	r2, #8
	dmotor_mech_cabin_weight.option_save_val = &oval_dmech_cabin_weight;
  405de0:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
	oval_dmech_counter_weight.max_value = 8000;
  405de4:	f8ce b014 	str.w	fp, [lr, #20]
	oval_dmech_payload_weight.max_value = 8000;
  405de8:	f8c7 b014 	str.w	fp, [r7, #20]
	oval_dmech_cabin_weight.max_value = 8000;
  405dec:	f8c5 b014 	str.w	fp, [r5, #20]
	oval_dmech_counter_weight.unit = "Kg";
  405df0:	f8ce a00c 	str.w	sl, [lr, #12]
	oval_dmech_payload_weight.unit = "Kg";
  405df4:	f8c7 a00c 	str.w	sl, [r7, #12]
	oval_dmech_cabin_weight.unit = "Kg";
  405df8:	f8c5 a00c 	str.w	sl, [r5, #12]
	oval_dmech_inertia.max_value = 400;
  405dfc:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 405eb4 <menue_driver_mech_data_init+0x1ec>
	oval_dmech_inertia.data_types = float_dt;
  405e00:	4d20      	ldr	r5, [pc, #128]	; (405e84 <menue_driver_mech_data_init+0x1bc>)
	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405e02:	4f21      	ldr	r7, [pc, #132]	; (405e88 <menue_driver_mech_data_init+0x1c0>)
	dmotor_mech_payload_weight.text = "PayLoad weight";
  405e04:	4b21      	ldr	r3, [pc, #132]	; (405e8c <menue_driver_mech_data_init+0x1c4>)
	dmotor_mech_estimate_inertia.text = "Estimate inertia";
  405e06:	4922      	ldr	r1, [pc, #136]	; (405e90 <menue_driver_mech_data_init+0x1c8>)
	dmotor_mech_payload_weight.text = "PayLoad weight";
  405e08:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405e0c:	4643      	mov	r3, r8
	dmotor_mech_estimate_inertia.text = "Estimate inertia";
  405e0e:	f8c4 10f0 	str.w	r1, [r4, #240]	; 0xf0
	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405e12:	4621      	mov	r1, r4
	oval_dmech_inertia.data_types = float_dt;
  405e14:	7028      	strb	r0, [r5, #0]
	oval_dmech_inertia.mantissa_count = 3;
  405e16:	60a8      	str	r0, [r5, #8]
	oval_dmech_inertia.real_count = 3;
  405e18:	6068      	str	r0, [r5, #4]
	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405e1a:	4638      	mov	r0, r7
	oval_dmech_inertia.max_value = 400;
  405e1c:	f8c5 e014 	str.w	lr, [r5, #20]
	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405e20:	f8cd 8000 	str.w	r8, [sp]
  405e24:	f8df 8090 	ldr.w	r8, [pc, #144]	; 405eb8 <menue_driver_mech_data_init+0x1f0>
	oval_dmech_inertia.min_value = 1;
  405e28:	edc5 7a06 	vstr	s15, [r5, #24]
	oval_dmech_inertia.val = &menue_drive_data_setup.m_mech_inertia;
  405e2c:	61ee      	str	r6, [r5, #28]
	oval_dmech_inertia.new_val_flag = &menue_drive_data_newdata_flag;
  405e2e:	f8c5 c020 	str.w	ip, [r5, #32]
	oval_dmech_inertia.unit = "Kg.m2";
  405e32:	f8c5 900c 	str.w	r9, [r5, #12]
	dmotor_mech_inertia.option_save_val = &oval_dmech_inertia;
  405e36:	f8c4 513c 	str.w	r5, [r4, #316]	; 0x13c
	fill_menue_list(&menue_driver_mech_data, opt_driver_mech, OPT_DRIVER_MECH_MAX, 0, 0);
  405e3a:	47c0      	blx	r8
	return &menue_driver_mech_data;
  405e3c:	4638      	mov	r0, r7
  405e3e:	b003      	add	sp, #12
  405e40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405e44:	204051c8 	.word	0x204051c8
  405e48:	204027e8 	.word	0x204027e8
  405e4c:	20402620 	.word	0x20402620
  405e50:	20402854 	.word	0x20402854
  405e54:	20402668 	.word	0x20402668
  405e58:	0041abcc 	.word	0x0041abcc
  405e5c:	42c60000 	.word	0x42c60000
  405e60:	0041abe0 	.word	0x0041abe0
  405e64:	0041abf8 	.word	0x0041abf8
  405e68:	3c23d70a 	.word	0x3c23d70a
  405e6c:	0041ac0c 	.word	0x0041ac0c
  405e70:	0041ac30 	.word	0x0041ac30
  405e74:	00405c51 	.word	0x00405c51
  405e78:	0041ac54 	.word	0x0041ac54
  405e7c:	20402644 	.word	0x20402644
  405e80:	20402830 	.word	0x20402830
  405e84:	2040280c 	.word	0x2040280c
  405e88:	204027a8 	.word	0x204027a8
  405e8c:	0041ac20 	.word	0x0041ac20
  405e90:	0041ac40 	.word	0x0041ac40
  405e94:	41a00000 	.word	0x41a00000
  405e98:	44bb8000 	.word	0x44bb8000
  405e9c:	20404fec 	.word	0x20404fec
  405ea0:	0041a5ec 	.word	0x0041a5ec
  405ea4:	204027c4 	.word	0x204027c4
  405ea8:	0041abf0 	.word	0x0041abf0
  405eac:	45fa0000 	.word	0x45fa0000
  405eb0:	0041ac1c 	.word	0x0041ac1c
  405eb4:	43c80000 	.word	0x43c80000
  405eb8:	0040b0ad 	.word	0x0040b0ad

00405ebc <calc_syn_motor_nPoles>:
option_t opt_dmparam_m_type[OPT_DMPARAM_M_TYPE_MAX];
#define m_type_induct				(opt_dmparam_m_type[0])
#define m_type_sync					(opt_dmparam_m_type[1])

void calc_syn_motor_nPoles(void)
{
  405ebc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	fixedpt temp = menue_drive_data_setup.m_motor_rated_speed;
	if (menue_drive_data_setup.m_motor_type == 1) //Syn motor
  405ebe:	4c0c      	ldr	r4, [pc, #48]	; (405ef0 <calc_syn_motor_nPoles+0x34>)
  405ec0:	7823      	ldrb	r3, [r4, #0]
  405ec2:	2b01      	cmp	r3, #1
  405ec4:	d113      	bne.n	405eee <calc_syn_motor_nPoles+0x32>
	fixedpt temp = menue_drive_data_setup.m_motor_rated_speed;
  405ec6:	68e0      	ldr	r0, [r4, #12]
	{
		temp /= 60;
  405ec8:	4a0a      	ldr	r2, [pc, #40]	; (405ef4 <calc_syn_motor_nPoles+0x38>)
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  405eca:	68a1      	ldr	r1, [r4, #8]
  405ecc:	17c3      	asrs	r3, r0, #31
  405ece:	fb82 5200 	smull	r5, r2, r2, r0
  405ed2:	4d09      	ldr	r5, [pc, #36]	; (405ef8 <calc_syn_motor_nPoles+0x3c>)
  405ed4:	17cf      	asrs	r7, r1, #31
  405ed6:	4402      	add	r2, r0
  405ed8:	03c8      	lsls	r0, r1, #15
  405eda:	03fe      	lsls	r6, r7, #15
  405edc:	ebc3 1262 	rsb	r2, r3, r2, asr #5
  405ee0:	ea46 4151 	orr.w	r1, r6, r1, lsr #17
  405ee4:	17d3      	asrs	r3, r2, #31
  405ee6:	47a8      	blx	r5
		temp = fixedpt_div(menue_drive_data_setup.m_motor_rated_freq, temp);
		menue_drive_data_setup.m_motor_pole_pair_count = fixedpt_toint(temp);
  405ee8:	13c0      	asrs	r0, r0, #15
  405eea:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  405eee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  405ef0:	204050e8 	.word	0x204050e8
  405ef4:	88888889 	.word	0x88888889
  405ef8:	0041905d 	.word	0x0041905d

00405efc <menue_driver_motor_parameters_init>:
	}
}

menue_design_t *menue_driver_motor_parameters_init(void)
{
  405efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	dmotor_param_m_type.text = "Motor type";
	m_type_induct.text = "Induction";
	#ifdef PMSM_MODEL
	m_type_sync.text = "Synchronous";
  405f00:	f8df c3f8 	ldr.w	ip, [pc, #1016]	; 4062fc <menue_driver_motor_parameters_init+0x400>
{
  405f04:	b083      	sub	sp, #12
	dmotor_param_m_type.text = "Motor type";
  405f06:	4cd3      	ldr	r4, [pc, #844]	; (406254 <menue_driver_motor_parameters_init+0x358>)
	#endif
	
	fill_menue_list(&menue_dmparam_m_type, &opt_dmparam_m_type, OPT_DMPARAM_M_TYPE_MAX, 0, &menue_drive_data_setup.m_motor_type);
  405f08:	2300      	movs	r3, #0
  405f0a:	4fd3      	ldr	r7, [pc, #844]	; (406258 <menue_driver_motor_parameters_init+0x35c>)
  405f0c:	2202      	movs	r2, #2
	m_type_induct.text = "Induction";
  405f0e:	4ed3      	ldr	r6, [pc, #844]	; (40625c <menue_driver_motor_parameters_init+0x360>)
	fill_menue_list(&menue_dmparam_m_type, &opt_dmparam_m_type, OPT_DMPARAM_M_TYPE_MAX, 0, &menue_drive_data_setup.m_motor_type);
  405f10:	4dd3      	ldr	r5, [pc, #844]	; (406260 <menue_driver_motor_parameters_init+0x364>)
	dmotor_param_m_type.text = "Motor type";
  405f12:	f8df e3ec 	ldr.w	lr, [pc, #1004]	; 406300 <menue_driver_motor_parameters_init+0x404>
	fill_menue_list(&menue_dmparam_m_type, &opt_dmparam_m_type, OPT_DMPARAM_M_TYPE_MAX, 0, &menue_drive_data_setup.m_motor_type);
  405f16:	4631      	mov	r1, r6
	m_type_induct.text = "Induction";
  405f18:	f8df 83e8 	ldr.w	r8, [pc, #1000]	; 406304 <menue_driver_motor_parameters_init+0x408>
	fill_menue_list(&menue_dmparam_m_type, &opt_dmparam_m_type, OPT_DMPARAM_M_TYPE_MAX, 0, &menue_drive_data_setup.m_motor_type);
  405f1c:	4628      	mov	r0, r5
  405f1e:	9700      	str	r7, [sp, #0]
	m_type_induct.text = "Induction";
  405f20:	f8c6 8000 	str.w	r8, [r6]
	m_type_sync.text = "Synchronous";
  405f24:	f8c6 c028 	str.w	ip, [r6, #40]	; 0x28
	dmotor_param_m_type.text = "Motor type";
  405f28:	f8c4 e000 	str.w	lr, [r4]
	fill_menue_list(&menue_dmparam_m_type, &opt_dmparam_m_type, OPT_DMPARAM_M_TYPE_MAX, 0, &menue_drive_data_setup.m_motor_type);
  405f2c:	4ecd      	ldr	r6, [pc, #820]	; (406264 <menue_driver_motor_parameters_init+0x368>)
  405f2e:	47b0      	blx	r6
	//oval_dmparam_rated_power.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmparam_rated_power.val = &menue_drive_data_setup.m_motor_rated_power;
	dmotor_param_rated_power.option_save_val = &oval_dmparam_rated_power;
//__________________________________________________
	dmotor_param_rated_freq.text = "Rated frequency";
	oval_dmparam_rated_freq.data_types = fixedpt_dt;
  405f30:	4acd      	ldr	r2, [pc, #820]	; (406268 <menue_driver_motor_parameters_init+0x36c>)
	oval_dmparam_rated_freq.max_value = 100;
	oval_dmparam_rated_freq.min_value = 1;
	oval_dmparam_rated_freq.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmparam_rated_freq.unit = "Hz";
	//oval_dmparam_rated_freq.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmparam_rated_freq.val = &menue_drive_data_setup.m_motor_rated_freq;
  405f32:	f107 0308 	add.w	r3, r7, #8
	oval_dmparam_rated_speed.max_value = 3000;
	oval_dmparam_rated_speed.min_value = 1;
	oval_dmparam_rated_speed.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmparam_rated_speed.unit = "RPM";
	//oval_dmparam_rated_speed.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmparam_rated_speed.val = &menue_drive_data_setup.m_motor_rated_speed;
  405f36:	f107 0e0c 	add.w	lr, r7, #12
	oval_dmparam_rated_freq.min_value = 1;
  405f3a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	dmotor_param_m_type.child = &menue_dmparam_m_type;
  405f3e:	6225      	str	r5, [r4, #32]
	oval_dmparam_rated_freq.val = &menue_drive_data_setup.m_motor_rated_freq;
  405f40:	61d3      	str	r3, [r2, #28]
	oval_dmparam_rated_power.real_count = 2;
  405f42:	2502      	movs	r5, #2
	oval_dmparam_rated_freq.max_value = 100;
  405f44:	4bc9      	ldr	r3, [pc, #804]	; (40626c <menue_driver_motor_parameters_init+0x370>)
	oval_dmparam_rated_power.max_value = 15;
  405f46:	eeb2 6a0e 	vmov.f32	s12, #46	; 0x41700000  15.0
	oval_dmparam_rated_freq.min_value = 1;
  405f4a:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_dmparam_rated_power.min_value = 0.75;
  405f4e:	eef6 6a08 	vmov.f32	s13, #104	; 0x3f400000  0.750
	oval_dmparam_rated_freq.max_value = 100;
  405f52:	6153      	str	r3, [r2, #20]
	oval_dmparam_rated_power.data_types = float_dt;
  405f54:	2603      	movs	r6, #3
	oval_dmparam_rated_freq.unit = "Hz";
  405f56:	4bc6      	ldr	r3, [pc, #792]	; (406270 <menue_driver_motor_parameters_init+0x374>)
	oval_dmparam_rated_power.val = &menue_drive_data_setup.m_motor_rated_power;
  405f58:	1d38      	adds	r0, r7, #4
	dmotor_param_rated_freq.option_save_val = &oval_dmparam_rated_freq;
  405f5a:	6762      	str	r2, [r4, #116]	; 0x74
//__________________________________________________
	dmotor_param_auto_tune.text = "Auto tune";
	oval_dmparam_auto_tune.data_types = uint8_dt;
	oval_dmparam_auto_tune.mantissa_count = 0;
	oval_dmparam_auto_tune.real_count = 1;
	oval_dmparam_auto_tune.max_value = 3;
  405f5c:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
	oval_dmparam_rated_freq.unit = "Hz";
  405f60:	60d3      	str	r3, [r2, #12]
	oval_dmparam_rated_speed.data_types = fixedpt_dt;
  405f62:	4bc4      	ldr	r3, [pc, #784]	; (406274 <menue_driver_motor_parameters_init+0x378>)
	oval_dmparam_rated_freq.data_types = fixedpt_dt;
  405f64:	7015      	strb	r5, [r2, #0]
	oval_dmparam_rated_speed.val = &menue_drive_data_setup.m_motor_rated_speed;
  405f66:	f8c3 e01c 	str.w	lr, [r3, #28]
	oval_dmparam_rated_speed.max_value = 3000;
  405f6a:	f8df e39c 	ldr.w	lr, [pc, #924]	; 406308 <menue_driver_motor_parameters_init+0x40c>
	oval_dmparam_rated_freq.mantissa_count = 2;
  405f6e:	6095      	str	r5, [r2, #8]
	oval_dmparam_rated_speed.max_value = 3000;
  405f70:	f8c3 e014 	str.w	lr, [r3, #20]
	oval_dmparam_rated_speed.unit = "RPM";
  405f74:	f8df e394 	ldr.w	lr, [pc, #916]	; 40630c <menue_driver_motor_parameters_init+0x410>
	oval_dmparam_rated_freq.real_count = 2;
  405f78:	6055      	str	r5, [r2, #4]
	oval_dmparam_rated_speed.unit = "RPM";
  405f7a:	f8c3 e00c 	str.w	lr, [r3, #12]
	oval_dmparam_rated_power.new_val_flag = &menue_drive_data_newdata_flag;
  405f7e:	f8df e390 	ldr.w	lr, [pc, #912]	; 406310 <menue_driver_motor_parameters_init+0x414>
	oval_dmparam_rated_power.data_types = float_dt;
  405f82:	49bd      	ldr	r1, [pc, #756]	; (406278 <menue_driver_motor_parameters_init+0x37c>)
	oval_dmparam_rated_freq.new_val_flag = &menue_drive_data_newdata_flag;
  405f84:	f8c2 e020 	str.w	lr, [r2, #32]
	oval_dmparam_rated_speed.real_count = 4;
  405f88:	2204      	movs	r2, #4
	oval_dmparam_rated_speed.new_val_flag = &menue_drive_data_newdata_flag;
  405f8a:	f8c3 e020 	str.w	lr, [r3, #32]
	oval_dmparam_rated_speed.min_value = 1;
  405f8e:	edc3 7a06 	vstr	s15, [r3, #24]
	dmotor_param_rated_speed.option_save_val = &oval_dmparam_rated_speed;
  405f92:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	oval_dmparam_rated_speed.data_types = fixedpt_dt;
  405f96:	701d      	strb	r5, [r3, #0]
	oval_dmparam_rated_speed.mantissa_count = 2;
  405f98:	609d      	str	r5, [r3, #8]
	oval_dmparam_rated_speed.real_count = 4;
  405f9a:	605a      	str	r2, [r3, #4]
	dmotor_param_rated_power.text = "Rated power";
  405f9c:	f8df a374 	ldr.w	sl, [pc, #884]	; 406314 <menue_driver_motor_parameters_init+0x418>
	dmotor_param_rated_freq.text = "Rated frequency";
  405fa0:	f8df 9374 	ldr.w	r9, [pc, #884]	; 406318 <menue_driver_motor_parameters_init+0x41c>
	dmotor_param_rated_speed.text = "Rated speed";
  405fa4:	f8df 8374 	ldr.w	r8, [pc, #884]	; 40631c <menue_driver_motor_parameters_init+0x420>
	dmotor_param_rated_speed.exit_menue = &calc_syn_motor_nPoles;
  405fa8:	f8df c374 	ldr.w	ip, [pc, #884]	; 406320 <menue_driver_motor_parameters_init+0x424>
	oval_dmparam_rated_power.unit = "KW";
  405fac:	f8df b374 	ldr.w	fp, [pc, #884]	; 406324 <menue_driver_motor_parameters_init+0x428>
	dmotor_param_rated_voltage.text = "Rated voltage";
  405fb0:	4bb2      	ldr	r3, [pc, #712]	; (40627c <menue_driver_motor_parameters_init+0x380>)
	oval_dmparam_rated_power.new_val_flag = &menue_drive_data_newdata_flag;
  405fb2:	f8c1 e020 	str.w	lr, [r1, #32]
	dmotor_param_rated_power.text = "Rated power";
  405fb6:	f8c4 a028 	str.w	sl, [r4, #40]	; 0x28
	oval_dmparam_rated_voltage.val = &menue_drive_data_setup.m_motor_rated_voltage;
  405fba:	f107 0a10 	add.w	sl, r7, #16
	dmotor_param_rated_freq.text = "Rated frequency";
  405fbe:	f8c4 9050 	str.w	r9, [r4, #80]	; 0x50
	oval_dmparam_rated_current.val = &menue_drive_data_setup.m_motor_rated_current;
  405fc2:	f107 0914 	add.w	r9, r7, #20
	dmotor_param_rated_speed.text = "Rated speed";
  405fc6:	f8c4 8078 	str.w	r8, [r4, #120]	; 0x78
	oval_dmparam_rated_pf.val = &menue_drive_data_setup.m_motor_rated_pfactor;
  405fca:	f107 0818 	add.w	r8, r7, #24
	dmotor_param_rated_speed.exit_menue = &calc_syn_motor_nPoles;
  405fce:	f8c4 c090 	str.w	ip, [r4, #144]	; 0x90
	oval_dmparam_auto_tune.data_types = uint8_dt;
  405fd2:	f04f 0c00 	mov.w	ip, #0
	oval_dmparam_rated_power.val = &menue_drive_data_setup.m_motor_rated_power;
  405fd6:	61c8      	str	r0, [r1, #28]
	oval_dmparam_auto_tune.real_count = 1;
  405fd8:	2001      	movs	r0, #1
	dmotor_param_rated_power.option_save_val = &oval_dmparam_rated_power;
  405fda:	64e1      	str	r1, [r4, #76]	; 0x4c
	oval_dmparam_rated_power.max_value = 15;
  405fdc:	ed81 6a05 	vstr	s12, [r1, #20]
	oval_dmparam_rated_power.min_value = 0.75;
  405fe0:	edc1 6a06 	vstr	s13, [r1, #24]
	oval_dmparam_rated_power.unit = "KW";
  405fe4:	f8c1 b00c 	str.w	fp, [r1, #12]
	oval_dmparam_rotor_res.max_value = 999;
	oval_dmparam_rotor_res.min_value = 0.001;
	oval_dmparam_rotor_res.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmparam_rotor_res.unit = "Ohm";
	//oval_dmparam_rotor_res.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmparam_rotor_res.val = &menue_drive_data_setup.m_motor_rotor_resistance;
  405fe8:	f107 0b20 	add.w	fp, r7, #32
	oval_dmparam_rated_power.data_types = float_dt;
  405fec:	700e      	strb	r6, [r1, #0]
	oval_dmparam_rated_power.mantissa_count = 3;
  405fee:	608e      	str	r6, [r1, #8]
	oval_dmparam_rated_power.real_count = 2;
  405ff0:	604d      	str	r5, [r1, #4]
	oval_dmparam_stator_res.val = &menue_drive_data_setup.m_motor_stator_resistance;
  405ff2:	f107 011c 	add.w	r1, r7, #28
	dmotor_param_rated_voltage.text = "Rated voltage";
  405ff6:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	dmotor_param_rated_current.text = "Rated current";
  405ffa:	4ba1      	ldr	r3, [pc, #644]	; (406280 <menue_driver_motor_parameters_init+0x384>)
	oval_dmparam_rated_voltage.max_value = 450;
  405ffc:	4aa1      	ldr	r2, [pc, #644]	; (406284 <menue_driver_motor_parameters_init+0x388>)
	dmotor_param_rated_current.text = "Rated current";
  405ffe:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
	dmotor_param_rated_pf.text = "Power factor";
  406002:	4ba1      	ldr	r3, [pc, #644]	; (406288 <menue_driver_motor_parameters_init+0x38c>)
	oval_dmparam_stator_res.max_value = 999;
  406004:	eddf 6aa1 	vldr	s13, [pc, #644]	; 40628c <menue_driver_motor_parameters_init+0x390>
	dmotor_param_rated_pf.text = "Power factor";
  406008:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
	dmotor_param_auto_tune.text = "Auto tune";
  40600c:	4ba0      	ldr	r3, [pc, #640]	; (406290 <menue_driver_motor_parameters_init+0x394>)
//__________________________________________________	
	dmotor_param_no_load_current.text = "No load current";
	oval_dmparam_no_load_current.data_types = float_dt;
	oval_dmparam_no_load_current.mantissa_count = 2;
	oval_dmparam_no_load_current.real_count = 2;
	oval_dmparam_no_load_current.max_value = 99;
  40600e:	ed9f 6aa1 	vldr	s12, [pc, #644]	; 406294 <menue_driver_motor_parameters_init+0x398>
	dmotor_param_auto_tune.text = "Auto tune";
  406012:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
	oval_dmparam_rated_voltage.data_types = fixedpt_dt;
  406016:	4ba0      	ldr	r3, [pc, #640]	; (406298 <menue_driver_motor_parameters_init+0x39c>)
	oval_dmparam_rated_voltage.max_value = 450;
  406018:	615a      	str	r2, [r3, #20]
	oval_dmparam_rated_voltage.unit = "V";
  40601a:	4aa0      	ldr	r2, [pc, #640]	; (40629c <menue_driver_motor_parameters_init+0x3a0>)
	oval_dmparam_rated_voltage.data_types = fixedpt_dt;
  40601c:	701d      	strb	r5, [r3, #0]
	oval_dmparam_rated_voltage.mantissa_count = 2;
  40601e:	609d      	str	r5, [r3, #8]
	oval_dmparam_rated_voltage.min_value = 1;
  406020:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_dmparam_rated_voltage.new_val_flag = &menue_drive_data_newdata_flag;
  406024:	f8c3 e020 	str.w	lr, [r3, #32]
	oval_dmparam_rated_voltage.val = &menue_drive_data_setup.m_motor_rated_voltage;
  406028:	f8c3 a01c 	str.w	sl, [r3, #28]
	oval_dmparam_auto_tune.min_value = 0;
  40602c:	f04f 0a00 	mov.w	sl, #0
	oval_dmparam_rated_voltage.real_count = 3;
  406030:	605e      	str	r6, [r3, #4]
	oval_dmparam_rated_voltage.unit = "V";
  406032:	60da      	str	r2, [r3, #12]
	dmotor_param_rated_voltage.option_save_val = &oval_dmparam_rated_voltage;
  406034:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	oval_dmparam_rated_current.max_value = 50;
  406038:	4a99      	ldr	r2, [pc, #612]	; (4062a0 <menue_driver_motor_parameters_init+0x3a4>)
	oval_dmparam_rated_current.data_types = fixedpt_dt;
  40603a:	4b9a      	ldr	r3, [pc, #616]	; (4062a4 <menue_driver_motor_parameters_init+0x3a8>)
	oval_dmparam_rated_current.max_value = 50;
  40603c:	615a      	str	r2, [r3, #20]
	oval_dmparam_rated_current.unit = "A";
  40603e:	4a9a      	ldr	r2, [pc, #616]	; (4062a8 <menue_driver_motor_parameters_init+0x3ac>)
	oval_dmparam_rated_current.data_types = fixedpt_dt;
  406040:	701d      	strb	r5, [r3, #0]
	oval_dmparam_rated_current.mantissa_count = 2;
  406042:	609d      	str	r5, [r3, #8]
	oval_dmparam_rated_current.min_value = 1;
  406044:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_dmparam_rated_current.new_val_flag = &menue_drive_data_newdata_flag;
  406048:	f8c3 e020 	str.w	lr, [r3, #32]
	oval_dmparam_rated_current.val = &menue_drive_data_setup.m_motor_rated_current;
  40604c:	f8c3 901c 	str.w	r9, [r3, #28]
	oval_dmparam_rated_current.real_count = 2;
  406050:	605d      	str	r5, [r3, #4]
	oval_dmparam_rated_current.unit = "A";
  406052:	60da      	str	r2, [r3, #12]
	dmotor_param_rated_current.option_save_val = &oval_dmparam_rated_current;
  406054:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
	oval_dmparam_rated_pf.data_types = float_dt;
  406058:	4b94      	ldr	r3, [pc, #592]	; (4062ac <menue_driver_motor_parameters_init+0x3b0>)
	oval_dmparam_stator_res.unit = "Ohm";
  40605a:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 406328 <menue_driver_motor_parameters_init+0x42c>
	oval_dmparam_rated_pf.val = &menue_drive_data_setup.m_motor_rated_pfactor;
  40605e:	f8c3 801c 	str.w	r8, [r3, #28]
	oval_dmparam_rated_pf.max_value = 99.99;
  406062:	f8df 82c8 	ldr.w	r8, [pc, #712]	; 40632c <menue_driver_motor_parameters_init+0x430>
	oval_dmparam_rated_pf.data_types = float_dt;
  406066:	701e      	strb	r6, [r3, #0]
	oval_dmparam_rated_pf.max_value = 99.99;
  406068:	f8c3 8014 	str.w	r8, [r3, #20]
	oval_dmparam_rated_pf.min_value = 60;
  40606c:	f8df 82c0 	ldr.w	r8, [pc, #704]	; 406330 <menue_driver_motor_parameters_init+0x434>
	oval_dmparam_rated_pf.mantissa_count = 2;
  406070:	609d      	str	r5, [r3, #8]
	oval_dmparam_rated_pf.min_value = 60;
  406072:	f8c3 8018 	str.w	r8, [r3, #24]
	oval_dmparam_rated_pf.unit = "%";
  406076:	f8df 82bc 	ldr.w	r8, [pc, #700]	; 406334 <menue_driver_motor_parameters_init+0x438>
	oval_dmparam_rated_pf.new_val_flag = &menue_drive_data_newdata_flag;
  40607a:	f8c3 e020 	str.w	lr, [r3, #32]
	oval_dmparam_rated_pf.real_count = 2;
  40607e:	605d      	str	r5, [r3, #4]
	dmotor_param_rated_pf.option_save_val = &oval_dmparam_rated_pf;
  406080:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	oval_dmparam_rated_pf.unit = "%";
  406084:	f8c3 800c 	str.w	r8, [r3, #12]
	oval_dmparam_auto_tune.data_types = uint8_dt;
  406088:	4b89      	ldr	r3, [pc, #548]	; (4062b0 <menue_driver_motor_parameters_init+0x3b4>)
	oval_dmparam_stator_res.min_value = 0.001;
  40608a:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 406338 <menue_driver_motor_parameters_init+0x43c>
	oval_dmparam_auto_tune.data_types = uint8_dt;
  40608e:	f883 c000 	strb.w	ip, [r3]
	oval_dmparam_auto_tune.mantissa_count = 0;
  406092:	f8c3 c008 	str.w	ip, [r3, #8]
	oval_dmparam_auto_tune.real_count = 1;
  406096:	6058      	str	r0, [r3, #4]
	dmotor_param_stator_res.text = "Stator resistance";
  406098:	4886      	ldr	r0, [pc, #536]	; (4062b4 <menue_driver_motor_parameters_init+0x3b8>)
	oval_dmparam_auto_tune.max_value = 3;
  40609a:	ed83 7a05 	vstr	s14, [r3, #20]
	dmotor_param_stator_res.text = "Stator resistance";
  40609e:	f8c4 0168 	str.w	r0, [r4, #360]	; 0x168
	oval_dmparam_auto_tune.val = &menue_drive_motor_tune;
  4060a2:	4885      	ldr	r0, [pc, #532]	; (4062b8 <menue_driver_motor_parameters_init+0x3bc>)
	oval_dmparam_auto_tune.min_value = 0;
  4060a4:	f8c3 a018 	str.w	sl, [r3, #24]
	oval_dmparam_auto_tune.val = &menue_drive_motor_tune;
  4060a8:	61d8      	str	r0, [r3, #28]
	dmotor_param_auto_tune.option_save_val = &oval_dmparam_auto_tune;
  4060aa:	f8c4 3164 	str.w	r3, [r4, #356]	; 0x164
	dmotor_param_rotor_res.text = "Rotor resistance";
  4060ae:	4883      	ldr	r0, [pc, #524]	; (4062bc <menue_driver_motor_parameters_init+0x3c0>)
	dmotor_param_leakage_induct.text = "Leakage induct";
  4060b0:	4b83      	ldr	r3, [pc, #524]	; (4062c0 <menue_driver_motor_parameters_init+0x3c4>)
	dmotor_param_rotor_res.text = "Rotor resistance";
  4060b2:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	dmotor_param_leakage_induct.text = "Leakage induct";
  4060b6:	f8c4 31b8 	str.w	r3, [r4, #440]	; 0x1b8
	oval_dmparam_stator_res.data_types = float_dt;
  4060ba:	4882      	ldr	r0, [pc, #520]	; (4062c4 <menue_driver_motor_parameters_init+0x3c8>)
	oval_dmparam_rotor_res.data_types = float_dt;
  4060bc:	4b82      	ldr	r3, [pc, #520]	; (4062c8 <menue_driver_motor_parameters_init+0x3cc>)
	oval_dmparam_leakage_induct.min_value = 0.01;
  4060be:	ed9f 7a83 	vldr	s14, [pc, #524]	; 4062cc <menue_driver_motor_parameters_init+0x3d0>
	oval_dmparam_rotor_res.new_val_flag = &menue_drive_data_newdata_flag;
  4060c2:	f8c3 e020 	str.w	lr, [r3, #32]
	oval_dmparam_rotor_res.max_value = 999;
  4060c6:	edc3 6a05 	vstr	s13, [r3, #20]
	oval_dmparam_rotor_res.val = &menue_drive_data_setup.m_motor_rotor_resistance;
  4060ca:	f8c3 b01c 	str.w	fp, [r3, #28]
	oval_dmparam_rotor_res.data_types = float_dt;
  4060ce:	701e      	strb	r6, [r3, #0]
	oval_dmparam_leakage_induct.unit = "mH";
  4060d0:	f8df b268 	ldr.w	fp, [pc, #616]	; 40633c <menue_driver_motor_parameters_init+0x440>
	oval_dmparam_rotor_res.mantissa_count = 3;
  4060d4:	609e      	str	r6, [r3, #8]
	oval_dmparam_rotor_res.real_count = 3;
  4060d6:	605e      	str	r6, [r3, #4]
	dmotor_param_rotor_res.option_save_val = &oval_dmparam_rotor_res;
  4060d8:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
	oval_dmparam_stator_res.min_value = 0.001;
  4060dc:	f8c0 8018 	str.w	r8, [r0, #24]
	oval_dmparam_rotor_res.min_value = 0.001;
  4060e0:	f8c3 8018 	str.w	r8, [r3, #24]
	oval_dmparam_rotor_res.unit = "Ohm";
  4060e4:	f8c3 900c 	str.w	r9, [r3, #12]
	oval_dmparam_leakage_induct.val = &menue_drive_data_setup.m_motor_leakage_inductance;
  4060e8:	f107 0324 	add.w	r3, r7, #36	; 0x24
	oval_dmparam_leakage_induct.data_types = float_dt;
  4060ec:	f8df 8250 	ldr.w	r8, [pc, #592]	; 406340 <menue_driver_motor_parameters_init+0x444>
	oval_dmparam_stator_res.new_val_flag = &menue_drive_data_newdata_flag;
  4060f0:	f8c0 e020 	str.w	lr, [r0, #32]
	oval_dmparam_stator_res.max_value = 999;
  4060f4:	edc0 6a05 	vstr	s13, [r0, #20]
	oval_dmparam_leakage_induct.max_value = 999;
  4060f8:	edc8 6a05 	vstr	s13, [r8, #20]
	oval_dmparam_leakage_induct.new_val_flag = &menue_drive_data_newdata_flag;
  4060fc:	f8c8 e020 	str.w	lr, [r8, #32]
	oval_dmparam_stator_res.val = &menue_drive_data_setup.m_motor_stator_resistance;
  406100:	61c1      	str	r1, [r0, #28]
	oval_dmparam_magnetizing_induct.real_count = 4;
  406102:	2104      	movs	r1, #4
	oval_dmparam_stator_res.data_types = float_dt;
  406104:	7006      	strb	r6, [r0, #0]
	oval_dmparam_stator_res.mantissa_count = 3;
  406106:	6086      	str	r6, [r0, #8]
	oval_dmparam_stator_res.real_count = 3;
  406108:	6046      	str	r6, [r0, #4]
	dmotor_param_stator_res.option_save_val = &oval_dmparam_stator_res;
  40610a:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
	oval_dmparam_stator_res.unit = "Ohm";
  40610e:	f8c0 900c 	str.w	r9, [r0, #12]
	oval_dmparam_pole_pair.max_value = 40;
	oval_dmparam_pole_pair.min_value = 1;
	oval_dmparam_pole_pair.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmparam_pole_pair.unit = "";
	//oval_dmparam_pole_pair.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmparam_pole_pair.val = &menue_drive_data_setup.m_motor_pole_pair_count;
  406112:	f107 093c 	add.w	r9, r7, #60	; 0x3c
	oval_dmparam_leakage_induct.data_types = float_dt;
  406116:	f888 6000 	strb.w	r6, [r8]
	oval_dmparam_leakage_induct.mantissa_count = 2;
  40611a:	f8c8 5008 	str.w	r5, [r8, #8]
	oval_dmparam_leakage_induct.real_count = 3;
  40611e:	f8c8 6004 	str.w	r6, [r8, #4]
	oval_dmparam_leakage_induct.min_value = 0.01;
  406122:	ed88 7a06 	vstr	s14, [r8, #24]
	oval_dmparam_leakage_induct.unit = "mH";
  406126:	f8c8 b00c 	str.w	fp, [r8, #12]
	oval_dmparam_leakage_induct.val = &menue_drive_data_setup.m_motor_leakage_inductance;
  40612a:	f8c8 301c 	str.w	r3, [r8, #28]
	dmotor_param_magnetizing_induct.text = "Magnetizing induct";
  40612e:	4b68      	ldr	r3, [pc, #416]	; (4062d0 <menue_driver_motor_parameters_init+0x3d4>)
	dmotor_param_leakage_induct.option_save_val = &oval_dmparam_leakage_induct;
  406130:	f8c4 81dc 	str.w	r8, [r4, #476]	; 0x1dc
	oval_dmparam_BEMF.val = &menue_drive_data_setup.m_motor_BEMF;
  406134:	f107 0838 	add.w	r8, r7, #56	; 0x38
	dmotor_param_magnetizing_induct.text = "Magnetizing induct";
  406138:	f8c4 31e0 	str.w	r3, [r4, #480]	; 0x1e0
	oval_dmparam_magnetizing_induct.max_value = 9999;
  40613c:	4f65      	ldr	r7, [pc, #404]	; (4062d4 <menue_driver_motor_parameters_init+0x3d8>)
	oval_dmparam_LD.val = &menue_drive_data_setup.m_motor_LD;
  40613e:	f1a8 0010 	sub.w	r0, r8, #16
	oval_dmparam_magnetizing_induct.data_types = float_dt;
  406142:	4b65      	ldr	r3, [pc, #404]	; (4062d8 <menue_driver_motor_parameters_init+0x3dc>)
	oval_dmparam_magnetizing_induct.max_value = 9999;
  406144:	615f      	str	r7, [r3, #20]
	oval_dmparam_no_load_current.data_types = float_dt;
  406146:	4f65      	ldr	r7, [pc, #404]	; (4062dc <menue_driver_motor_parameters_init+0x3e0>)
	oval_dmparam_magnetizing_induct.real_count = 4;
  406148:	6059      	str	r1, [r3, #4]
	oval_dmparam_magnetizing_induct.val = &menue_drive_data_setup.m_motor_magnetizing_inductance;
  40614a:	f1a8 0108 	sub.w	r1, r8, #8
	oval_dmparam_no_load_current.unit = "A";
  40614e:	60fa      	str	r2, [r7, #12]
	oval_dmparam_no_load_current.val = &menue_drive_data_setup.m_motor_noload_current;
  406150:	f1a8 0204 	sub.w	r2, r8, #4
	oval_dmparam_no_load_current.new_val_flag = &menue_drive_data_newdata_flag;
  406154:	f8c7 e020 	str.w	lr, [r7, #32]
	oval_dmparam_no_load_current.max_value = 99;
  406158:	ed87 6a05 	vstr	s12, [r7, #20]
	oval_dmparam_no_load_current.min_value = 0;
  40615c:	f8c7 a018 	str.w	sl, [r7, #24]
	oval_dmparam_no_load_current.data_types = float_dt;
  406160:	703e      	strb	r6, [r7, #0]
	oval_dmparam_no_load_current.mantissa_count = 2;
  406162:	60bd      	str	r5, [r7, #8]
	oval_dmparam_no_load_current.real_count = 2;
  406164:	607d      	str	r5, [r7, #4]
	oval_dmparam_no_load_current.val = &menue_drive_data_setup.m_motor_noload_current;
  406166:	61fa      	str	r2, [r7, #28]
	dmotor_param_no_load_current.option_save_val = &oval_dmparam_no_load_current;
  406168:	f8c4 722c 	str.w	r7, [r4, #556]	; 0x22c
	dmotor_param_LQ.text = "LQ";
  40616c:	4f5c      	ldr	r7, [pc, #368]	; (4062e0 <menue_driver_motor_parameters_init+0x3e4>)
	oval_dmparam_LQ.data_types = float_dt;
  40616e:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 406344 <menue_driver_motor_parameters_init+0x448>
	oval_dmparam_magnetizing_induct.val = &menue_drive_data_setup.m_motor_magnetizing_inductance;
  406172:	61d9      	str	r1, [r3, #28]
	dmotor_param_LQ.text = "LQ";
  406174:	f8c4 7258 	str.w	r7, [r4, #600]	; 0x258
	dmotor_param_no_load_current.text = "No load current";
  406178:	495a      	ldr	r1, [pc, #360]	; (4062e4 <menue_driver_motor_parameters_init+0x3e8>)
	oval_dmparam_LD.data_types = float_dt;
  40617a:	4f5b      	ldr	r7, [pc, #364]	; (4062e8 <menue_driver_motor_parameters_init+0x3ec>)
	dmotor_param_LD.text = "LD";
  40617c:	4a5b      	ldr	r2, [pc, #364]	; (4062ec <menue_driver_motor_parameters_init+0x3f0>)
	oval_dmparam_magnetizing_induct.new_val_flag = &menue_drive_data_newdata_flag;
  40617e:	f8c3 e020 	str.w	lr, [r3, #32]
	oval_dmparam_LD.max_value = 999;
  406182:	edc7 6a05 	vstr	s13, [r7, #20]
	oval_dmparam_LD.new_val_flag = &menue_drive_data_newdata_flag;
  406186:	f8c7 e020 	str.w	lr, [r7, #32]
	oval_dmparam_magnetizing_induct.data_types = float_dt;
  40618a:	701e      	strb	r6, [r3, #0]
	oval_dmparam_magnetizing_induct.mantissa_count = 2;
  40618c:	609d      	str	r5, [r3, #8]
	oval_dmparam_magnetizing_induct.min_value = 0.01;
  40618e:	ed83 7a06 	vstr	s14, [r3, #24]
	oval_dmparam_magnetizing_induct.unit = "mH";
  406192:	f8c3 b00c 	str.w	fp, [r3, #12]
	dmotor_param_magnetizing_induct.option_save_val = &oval_dmparam_magnetizing_induct;
  406196:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
	dmotor_param_pole_pair.option_save_val = &oval_dmparam_pole_pair;
//___________________________________________________________
	fill_menue_list(&menue_driver_motor_param, opt_driver_motor_param, OPT_DRIVER_MOTOR_PARAM_MAX, 0, 0);
  40619a:	4663      	mov	r3, ip
	dmotor_param_no_load_current.text = "No load current";
  40619c:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
	fill_menue_list(&menue_driver_motor_param, opt_driver_motor_param, OPT_DRIVER_MOTOR_PARAM_MAX, 0, 0);
  4061a0:	4621      	mov	r1, r4
	dmotor_param_LD.text = "LD";
  4061a2:	f8c4 2230 	str.w	r2, [r4, #560]	; 0x230
	fill_menue_list(&menue_driver_motor_param, opt_driver_motor_param, OPT_DRIVER_MOTOR_PARAM_MAX, 0, 0);
  4061a6:	2211      	movs	r2, #17
	oval_dmparam_LD.val = &menue_drive_data_setup.m_motor_LD;
  4061a8:	61f8      	str	r0, [r7, #28]
	oval_dmparam_LD.data_types = float_dt;
  4061aa:	703e      	strb	r6, [r7, #0]
	oval_dmparam_LD.mantissa_count = 2;
  4061ac:	60bd      	str	r5, [r7, #8]
	oval_dmparam_LD.real_count = 3;
  4061ae:	607e      	str	r6, [r7, #4]
	oval_dmparam_LD.min_value = 0.01;
  4061b0:	ed87 7a06 	vstr	s14, [r7, #24]
	oval_dmparam_LD.unit = "mH";
  4061b4:	f8c7 b00c 	str.w	fp, [r7, #12]
	dmotor_param_LD.option_save_val = &oval_dmparam_LD;
  4061b8:	f8c4 7254 	str.w	r7, [r4, #596]	; 0x254
	oval_dmparam_LQ.val = &menue_drive_data_setup.m_motor_LQ;
  4061bc:	f1a8 070c 	sub.w	r7, r8, #12
	oval_dmparam_LQ.data_types = float_dt;
  4061c0:	f88a 6000 	strb.w	r6, [sl]
	fill_menue_list(&menue_driver_motor_param, opt_driver_motor_param, OPT_DRIVER_MOTOR_PARAM_MAX, 0, 0);
  4061c4:	f8cd c000 	str.w	ip, [sp]
	oval_dmparam_LQ.unit = "mH";
  4061c8:	f8ca b00c 	str.w	fp, [sl, #12]
	oval_dmparam_BEMF.data_types = float_dt;
  4061cc:	f8df b178 	ldr.w	fp, [pc, #376]	; 406348 <menue_driver_motor_parameters_init+0x44c>
	oval_dmparam_LQ.max_value = 999;
  4061d0:	edca 6a05 	vstr	s13, [sl, #20]
	oval_dmparam_LQ.min_value = 0.01;
  4061d4:	ed8a 7a06 	vstr	s14, [sl, #24]
	oval_dmparam_LQ.new_val_flag = &menue_drive_data_newdata_flag;
  4061d8:	f8ca e020 	str.w	lr, [sl, #32]
	oval_dmparam_LQ.mantissa_count = 2;
  4061dc:	f8ca 5008 	str.w	r5, [sl, #8]
	oval_dmparam_LQ.real_count = 3;
  4061e0:	f8ca 6004 	str.w	r6, [sl, #4]
	dmotor_param_LQ.option_save_val = &oval_dmparam_LQ;
  4061e4:	f8c4 a27c 	str.w	sl, [r4, #636]	; 0x27c
	oval_dmparam_BEMF.max_value = 99;
  4061e8:	ed8b 6a05 	vstr	s12, [fp, #20]
	oval_dmparam_BEMF.min_value = 0.01;
  4061ec:	ed8b 7a06 	vstr	s14, [fp, #24]
	oval_dmparam_BEMF.new_val_flag = &menue_drive_data_newdata_flag;
  4061f0:	f8cb e020 	str.w	lr, [fp, #32]
	oval_dmparam_BEMF.real_count = 2;
  4061f4:	f8cb 5004 	str.w	r5, [fp, #4]
	oval_dmparam_BEMF.data_types = float_dt;
  4061f8:	f88b 6000 	strb.w	r6, [fp]
	oval_dmparam_BEMF.mantissa_count = 3;
  4061fc:	f8cb 6008 	str.w	r6, [fp, #8]
	dmotor_param_BEMF.option_save_val = &oval_dmparam_BEMF;
  406200:	f8c4 b2a4 	str.w	fp, [r4, #676]	; 0x2a4
	oval_dmparam_pole_pair.data_types = uint8_dt;
  406204:	4e3a      	ldr	r6, [pc, #232]	; (4062f0 <menue_driver_motor_parameters_init+0x3f4>)
	oval_dmparam_LQ.val = &menue_drive_data_setup.m_motor_LQ;
  406206:	f8ca 701c 	str.w	r7, [sl, #28]
	oval_dmparam_pole_pair.max_value = 40;
  40620a:	ed9f 7a3a 	vldr	s14, [pc, #232]	; 4062f4 <menue_driver_motor_parameters_init+0x3f8>
	oval_dmparam_BEMF.val = &menue_drive_data_setup.m_motor_BEMF;
  40620e:	f8cb 801c 	str.w	r8, [fp, #28]
	dmotor_param_BEMF.text = "Back EMF";
  406212:	f8df a138 	ldr.w	sl, [pc, #312]	; 40634c <menue_driver_motor_parameters_init+0x450>
	dmotor_param_pole_pair.text = "Pole pair count";
  406216:	f8df b138 	ldr.w	fp, [pc, #312]	; 406350 <menue_driver_motor_parameters_init+0x454>
	oval_dmparam_pole_pair.unit = "";
  40621a:	f8df 8138 	ldr.w	r8, [pc, #312]	; 406354 <menue_driver_motor_parameters_init+0x458>
	dmotor_param_pole_pair.option_save_val = &oval_dmparam_pole_pair;
  40621e:	f8c4 613c 	str.w	r6, [r4, #316]	; 0x13c
	dmotor_param_BEMF.text = "Back EMF";
  406222:	f8c4 a280 	str.w	sl, [r4, #640]	; 0x280
	dmotor_param_pole_pair.text = "Pole pair count";
  406226:	f8c4 b118 	str.w	fp, [r4, #280]	; 0x118
	fill_menue_list(&menue_driver_motor_param, opt_driver_motor_param, OPT_DRIVER_MOTOR_PARAM_MAX, 0, 0);
  40622a:	4833      	ldr	r0, [pc, #204]	; (4062f8 <menue_driver_motor_parameters_init+0x3fc>)
	oval_dmparam_pole_pair.val = &menue_drive_data_setup.m_motor_pole_pair_count;
  40622c:	f8c6 901c 	str.w	r9, [r6, #28]
	oval_dmparam_pole_pair.data_types = uint8_dt;
  406230:	f886 c000 	strb.w	ip, [r6]
	oval_dmparam_pole_pair.mantissa_count = 0;
  406234:	f8c6 c008 	str.w	ip, [r6, #8]
	oval_dmparam_pole_pair.min_value = 1;
  406238:	edc6 7a06 	vstr	s15, [r6, #24]
	oval_dmparam_pole_pair.new_val_flag = &menue_drive_data_newdata_flag;
  40623c:	f8c6 e020 	str.w	lr, [r6, #32]
	oval_dmparam_pole_pair.real_count = 2;
  406240:	6075      	str	r5, [r6, #4]
	oval_dmparam_pole_pair.max_value = 40;
  406242:	ed86 7a05 	vstr	s14, [r6, #20]
	oval_dmparam_pole_pair.unit = "";
  406246:	f8c6 800c 	str.w	r8, [r6, #12]
	fill_menue_list(&menue_driver_motor_param, opt_driver_motor_param, OPT_DRIVER_MOTOR_PARAM_MAX, 0, 0);
  40624a:	4c06      	ldr	r4, [pc, #24]	; (406264 <menue_driver_motor_parameters_init+0x368>)
  40624c:	47a0      	blx	r4
	return &menue_driver_motor_param;	
  40624e:	482a      	ldr	r0, [pc, #168]	; (4062f8 <menue_driver_motor_parameters_init+0x3fc>)
  406250:	b003      	add	sp, #12
  406252:	e081      	b.n	406358 <menue_driver_motor_parameters_init+0x45c>
  406254:	20402ad4 	.word	0x20402ad4
  406258:	204050e8 	.word	0x204050e8
  40625c:	20402a84 	.word	0x20402a84
  406260:	20402974 	.word	0x20402974
  406264:	0040b0ad 	.word	0x0040b0ad
  406268:	20402a3c 	.word	0x20402a3c
  40626c:	42c80000 	.word	0x42c80000
  406270:	004199e8 	.word	0x004199e8
  406274:	20402d7c 	.word	0x20402d7c
  406278:	20402a18 	.word	0x20402a18
  40627c:	0041acb8 	.word	0x0041acb8
  406280:	0041accc 	.word	0x0041accc
  406284:	43e10000 	.word	0x43e10000
  406288:	0041acdc 	.word	0x0041acdc
  40628c:	4479c000 	.word	0x4479c000
  406290:	0041acec 	.word	0x0041acec
  406294:	42c60000 	.word	0x42c60000
  406298:	204028e4 	.word	0x204028e4
  40629c:	0041acc8 	.word	0x0041acc8
  4062a0:	42480000 	.word	0x42480000
  4062a4:	20402990 	.word	0x20402990
  4062a8:	004199e4 	.word	0x004199e4
  4062ac:	20402878 	.word	0x20402878
  4062b0:	204028c0 	.word	0x204028c0
  4062b4:	0041acf8 	.word	0x0041acf8
  4062b8:	204008e9 	.word	0x204008e9
  4062bc:	0041ad10 	.word	0x0041ad10
  4062c0:	0041ad24 	.word	0x0041ad24
  4062c4:	20402908 	.word	0x20402908
  4062c8:	204029d0 	.word	0x204029d0
  4062cc:	3c23d70a 	.word	0x3c23d70a
  4062d0:	0041ad38 	.word	0x0041ad38
  4062d4:	461c3c00 	.word	0x461c3c00
  4062d8:	20402a60 	.word	0x20402a60
  4062dc:	2040289c 	.word	0x2040289c
  4062e0:	0041ad60 	.word	0x0041ad60
  4062e4:	0041ad4c 	.word	0x0041ad4c
  4062e8:	204029f4 	.word	0x204029f4
  4062ec:	0041ad5c 	.word	0x0041ad5c
  4062f0:	20402950 	.word	0x20402950
  4062f4:	42200000 	.word	0x42200000
  4062f8:	204029b4 	.word	0x204029b4
  4062fc:	0041ac7c 	.word	0x0041ac7c
  406300:	0041ac64 	.word	0x0041ac64
  406304:	0041ac70 	.word	0x0041ac70
  406308:	453b8000 	.word	0x453b8000
  40630c:	0041acb4 	.word	0x0041acb4
  406310:	20404fec 	.word	0x20404fec
  406314:	0041ac88 	.word	0x0041ac88
  406318:	0041ac98 	.word	0x0041ac98
  40631c:	0041aca8 	.word	0x0041aca8
  406320:	00405ebd 	.word	0x00405ebd
  406324:	0041ac94 	.word	0x0041ac94
  406328:	0041ad0c 	.word	0x0041ad0c
  40632c:	42c7fae1 	.word	0x42c7fae1
  406330:	42700000 	.word	0x42700000
  406334:	0041a888 	.word	0x0041a888
  406338:	3a83126f 	.word	0x3a83126f
  40633c:	0041ad34 	.word	0x0041ad34
  406340:	20402da0 	.word	0x20402da0
  406344:	2040292c 	.word	0x2040292c
  406348:	20402dc4 	.word	0x20402dc4
  40634c:	0041ad64 	.word	0x0041ad64
  406350:	0041ad70 	.word	0x0041ad70
  406354:	0041b014 	.word	0x0041b014
  406358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0040635c <menue_driver_overload_init>:
#define overload_off				(opt_overload_types[2])



menue_design_t *menue_driver_overload_init(void)
{
  40635c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dmotor_overload_type.text = "Settings";
	overload_vfd.text = "VFD motor";
  406360:	4d27      	ldr	r5, [pc, #156]	; (406400 <menue_driver_overload_init+0xa4>)
{
  406362:	b082      	sub	sp, #8
	overload_normal.text = "Normal motor";
	overload_off.text = "Off";
	
	fill_menue_list(&menue_overload_types, &opt_overload_types, OPT_OVERLOAD_TYPES_MAX, 0, &menue_drive_data_setup.m_overload_type);
  406364:	4c27      	ldr	r4, [pc, #156]	; (406404 <menue_driver_overload_init+0xa8>)
  406366:	2300      	movs	r3, #0
	overload_vfd.text = "VFD motor";
  406368:	4f27      	ldr	r7, [pc, #156]	; (406408 <menue_driver_overload_init+0xac>)
	fill_menue_list(&menue_overload_types, &opt_overload_types, OPT_OVERLOAD_TYPES_MAX, 0, &menue_drive_data_setup.m_overload_type);
  40636a:	4629      	mov	r1, r5
  40636c:	9400      	str	r4, [sp, #0]
  40636e:	2203      	movs	r2, #3
	overload_vfd.text = "VFD motor";
  406370:	602f      	str	r7, [r5, #0]
	overload_normal.text = "Normal motor";
  406372:	4e26      	ldr	r6, [pc, #152]	; (40640c <menue_driver_overload_init+0xb0>)
	overload_off.text = "Off";
  406374:	4f26      	ldr	r7, [pc, #152]	; (406410 <menue_driver_overload_init+0xb4>)
	fill_menue_list(&menue_overload_types, &opt_overload_types, OPT_OVERLOAD_TYPES_MAX, 0, &menue_drive_data_setup.m_overload_type);
  406376:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 406440 <menue_driver_overload_init+0xe4>
	overload_normal.text = "Normal motor";
  40637a:	62ae      	str	r6, [r5, #40]	; 0x28
	overload_off.text = "Off";
  40637c:	652f      	str	r7, [r5, #80]	; 0x50
	fill_menue_list(&menue_overload_types, &opt_overload_types, OPT_OVERLOAD_TYPES_MAX, 0, &menue_drive_data_setup.m_overload_type);
  40637e:	4650      	mov	r0, sl
	dmotor_overload_type.text = "Settings";
  406380:	4e24      	ldr	r6, [pc, #144]	; (406414 <menue_driver_overload_init+0xb8>)
	oval_dover_val.val = &menue_drive_data_setup.m_overload_value;
	dmotor_overload_val.option_save_val = &oval_dover_val;
//___________________________________________________________

	dmotor_overload_time.text = "Time";
	oval_dover_time.data_types = uint8_dt;
  406382:	2700      	movs	r7, #0
	dmotor_overload_type.text = "Settings";
  406384:	4d24      	ldr	r5, [pc, #144]	; (406418 <menue_driver_overload_init+0xbc>)
	fill_menue_list(&menue_overload_types, &opt_overload_types, OPT_OVERLOAD_TYPES_MAX, 0, &menue_drive_data_setup.m_overload_type);
  406386:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 406444 <menue_driver_overload_init+0xe8>
	dmotor_overload_type.text = "Settings";
  40638a:	6035      	str	r5, [r6, #0]
	fill_menue_list(&menue_overload_types, &opt_overload_types, OPT_OVERLOAD_TYPES_MAX, 0, &menue_drive_data_setup.m_overload_type);
  40638c:	47c8      	blx	r9
	oval_dover_val.data_types = fixedpt_dt;
  40638e:	4d23      	ldr	r5, [pc, #140]	; (40641c <menue_driver_overload_init+0xc0>)
	oval_dover_val.mantissa_count = 1;
  406390:	2001      	movs	r0, #1
	dmotor_overload_type.child = &menue_overload_types;
  406392:	f8c6 a020 	str.w	sl, [r6, #32]
	//oval_dover_time.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dover_time.val = &menue_drive_data_setup.m_overload_time;
	dmotor_overload_time.option_save_val = &oval_dover_time;
	
//__________________________________________________
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  406396:	9700      	str	r7, [sp, #0]
	oval_dover_val.val = &menue_drive_data_setup.m_overload_value;
  406398:	f104 0a05 	add.w	sl, r4, #5
	oval_dover_val.mantissa_count = 1;
  40639c:	60a8      	str	r0, [r5, #8]
	oval_dover_time.val = &menue_drive_data_setup.m_overload_time;
  40639e:	1c61      	adds	r1, r4, #1
	oval_dover_val.max_value = 120;
  4063a0:	481f      	ldr	r0, [pc, #124]	; (406420 <menue_driver_overload_init+0xc4>)
	oval_dover_val.real_count = 3;
  4063a2:	f04f 0e03 	mov.w	lr, #3
	dmotor_overload_val.text = "Value";
  4063a6:	4b1f      	ldr	r3, [pc, #124]	; (406424 <menue_driver_overload_init+0xc8>)
	oval_dover_time.min_value = 1;
  4063a8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
	oval_dover_val.max_value = 120;
  4063ac:	6168      	str	r0, [r5, #20]
	oval_dover_val.unit = "%";
  4063ae:	481e      	ldr	r0, [pc, #120]	; (406428 <menue_driver_overload_init+0xcc>)
	oval_dover_time.data_types = uint8_dt;
  4063b0:	4c1e      	ldr	r4, [pc, #120]	; (40642c <menue_driver_overload_init+0xd0>)
	dmotor_overload_val.text = "Value";
  4063b2:	62b3      	str	r3, [r6, #40]	; 0x28
	oval_dover_val.unit = "%";
  4063b4:	60e8      	str	r0, [r5, #12]
	dmotor_overload_time.text = "Time";
  4063b6:	4b1e      	ldr	r3, [pc, #120]	; (406430 <menue_driver_overload_init+0xd4>)
	oval_dover_time.max_value = 60;
  4063b8:	481e      	ldr	r0, [pc, #120]	; (406434 <menue_driver_overload_init+0xd8>)
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  4063ba:	f8df 808c 	ldr.w	r8, [pc, #140]	; 406448 <menue_driver_overload_init+0xec>
	oval_dover_val.min_value = 20;
  4063be:	f8df c08c 	ldr.w	ip, [pc, #140]	; 40644c <menue_driver_overload_init+0xf0>
	dmotor_overload_time.text = "Time";
  4063c2:	6533      	str	r3, [r6, #80]	; 0x50
	oval_dover_val.data_types = fixedpt_dt;
  4063c4:	2302      	movs	r3, #2
	dmotor_overload_val.option_save_val = &oval_dover_val;
  4063c6:	64f5      	str	r5, [r6, #76]	; 0x4c
	oval_dover_time.val = &menue_drive_data_setup.m_overload_time;
  4063c8:	61e1      	str	r1, [r4, #28]
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  4063ca:	4631      	mov	r1, r6
	dmotor_overload_time.option_save_val = &oval_dover_time;
  4063cc:	6774      	str	r4, [r6, #116]	; 0x74
	oval_dover_time.max_value = 60;
  4063ce:	6160      	str	r0, [r4, #20]
	oval_dover_val.new_val_flag = &menue_drive_data_newdata_flag;
  4063d0:	4e19      	ldr	r6, [pc, #100]	; (406438 <menue_driver_overload_init+0xdc>)
	oval_dover_time.unit = "Sec";
  4063d2:	481a      	ldr	r0, [pc, #104]	; (40643c <menue_driver_overload_init+0xe0>)
	oval_dover_time.min_value = 1;
  4063d4:	61a2      	str	r2, [r4, #24]
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  4063d6:	4672      	mov	r2, lr
	oval_dover_val.data_types = fixedpt_dt;
  4063d8:	702b      	strb	r3, [r5, #0]
	oval_dover_time.real_count = 2;
  4063da:	6063      	str	r3, [r4, #4]
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  4063dc:	463b      	mov	r3, r7
	oval_dover_time.unit = "Sec";
  4063de:	60e0      	str	r0, [r4, #12]
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  4063e0:	4640      	mov	r0, r8
	oval_dover_val.val = &menue_drive_data_setup.m_overload_value;
  4063e2:	f8c5 a01c 	str.w	sl, [r5, #28]
	oval_dover_val.min_value = 20;
  4063e6:	f8c5 c018 	str.w	ip, [r5, #24]
	oval_dover_val.real_count = 3;
  4063ea:	f8c5 e004 	str.w	lr, [r5, #4]
	oval_dover_time.data_types = uint8_dt;
  4063ee:	7027      	strb	r7, [r4, #0]
	oval_dover_val.new_val_flag = &menue_drive_data_newdata_flag;
  4063f0:	622e      	str	r6, [r5, #32]
	oval_dover_time.new_val_flag = &menue_drive_data_newdata_flag;
  4063f2:	6226      	str	r6, [r4, #32]
	oval_dover_time.mantissa_count = 0;
  4063f4:	60a7      	str	r7, [r4, #8]
	fill_menue_list(&menue_driver_overload, opt_driver_overload, OPT_OVERLOAD_TYPES_MAX, 0, 0);
  4063f6:	47c8      	blx	r9
	return &menue_driver_overload;	
  4063f8:	4640      	mov	r0, r8
  4063fa:	b002      	add	sp, #8
  4063fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  406400:	20402ea0 	.word	0x20402ea0
  406404:	204051b7 	.word	0x204051b7
  406408:	0041ad8c 	.word	0x0041ad8c
  40640c:	0041ad98 	.word	0x0041ad98
  406410:	0041a63c 	.word	0x0041a63c
  406414:	20402e28 	.word	0x20402e28
  406418:	0041ad80 	.word	0x0041ad80
  40641c:	20402f18 	.word	0x20402f18
  406420:	42f00000 	.word	0x42f00000
  406424:	0041ada8 	.word	0x0041ada8
  406428:	0041a888 	.word	0x0041a888
  40642c:	20402de8 	.word	0x20402de8
  406430:	0041adb0 	.word	0x0041adb0
  406434:	42700000 	.word	0x42700000
  406438:	20404fec 	.word	0x20404fec
  40643c:	0041a8d4 	.word	0x0041a8d4
  406440:	20402f3c 	.word	0x20402f3c
  406444:	0040b0ad 	.word	0x0040b0ad
  406448:	20402e0c 	.word	0x20402e0c
  40644c:	41a00000 	.word	0x41a00000

00406450 <menue_driver_vector_init>:
option_val_t oval_dmvector_lspeed_filter;
option_val_t oval_dmvector_hspeed_filter;
option_val_t oval_dmvector_apr_level_p;

menue_design_t *menue_driver_vector_init(void)
{
  406450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	dmotor_vector_ASR_ls_p.text = "ASR low P";
	oval_dmvector_ASR_ls_p.data_types = float_dt;
  406454:	f8df a408 	ldr.w	sl, [pc, #1032]	; 406860 <menue_driver_vector_init+0x410>
  406458:	2403      	movs	r4, #3
	oval_dmvector_ASR_ls_p.real_count = 3;
	oval_dmvector_ASR_ls_p.max_value = 500;
	oval_dmvector_ASR_ls_p.min_value = 0.01;
	oval_dmvector_ASR_ls_p.new_val_flag = &menue_drive_data_newdata_flag;
	//oval_dmvector_ASR_ls_p.unit = "KW";
	oval_dmvector_ASR_ls_p.text = "Low speed P gain";
  40645a:	4de1      	ldr	r5, [pc, #900]	; (4067e0 <menue_driver_vector_init+0x390>)
	dmotor_vector_t_decay.text = "Tourque decay";
	oval_dmvector_t_decay.data_types = uint16_dt;
	oval_dmvector_t_decay.mantissa_count = 0;
	oval_dmvector_t_decay.real_count = 4;
	oval_dmvector_t_decay.max_value = 3000;
	oval_dmvector_t_decay.min_value = 10;
  40645c:	eef2 5a04 	vmov.f32	s11, #36	; 0x41200000  10.0
	oval_dmvector_ASR_ls_p.val = &menue_drive_data_setup.m_ASR_lows_p;
  406460:	4ee0      	ldr	r6, [pc, #896]	; (4067e4 <menue_driver_vector_init+0x394>)
{
  406462:	b083      	sub	sp, #12
	oval_dmvector_ASR_hs_p.data_types = float_dt;
  406464:	49e0      	ldr	r1, [pc, #896]	; (4067e8 <menue_driver_vector_init+0x398>)
	oval_dmvector_ASR_ls_p.text = "Low speed P gain";
  406466:	f8ca 5010 	str.w	r5, [sl, #16]
	oval_dmvector_ASR_ls_p.mantissa_count = 1;
  40646a:	2501      	movs	r5, #1
	oval_dmvector_ASR_hs_p.text = "High speed P gain";
  40646c:	4fdf      	ldr	r7, [pc, #892]	; (4067ec <menue_driver_vector_init+0x39c>)
	oval_dmvector_ASR_hs_p.val = &menue_drive_data_setup.m_ASR_highs_p;
  40646e:	f106 0c08 	add.w	ip, r6, #8
	oval_dmvector_ASR_ls_p.min_value = 0.01;
  406472:	eddf 7adf 	vldr	s15, [pc, #892]	; 4067f0 <menue_driver_vector_init+0x3a0>
	oval_dmvector_ASR_ls_i.val = &menue_drive_data_setup.m_ASR_lows_i;
  406476:	1d32      	adds	r2, r6, #4
	oval_dmvector_ASR_ls_p.max_value = 500;
  406478:	ed9f 7ade 	vldr	s14, [pc, #888]	; 4067f4 <menue_driver_vector_init+0x3a4>
	oval_dmvector_ASR_hs_i.val = &menue_drive_data_setup.m_ASR_highs_i;
  40647c:	f106 0e0c 	add.w	lr, r6, #12
	oval_dmvector_ASR_hs_p.text = "High speed P gain";
  406480:	610f      	str	r7, [r1, #16]
	oval_dmvector_apr_level_p.val = &menue_drive_data_setup.m_APR_level_p;
  406482:	f106 0b14 	add.w	fp, r6, #20
	oval_dmvector_ASR_ls_p.new_val_flag = &menue_drive_data_newdata_flag;
  406486:	4fdc      	ldr	r7, [pc, #880]	; (4067f8 <menue_driver_vector_init+0x3a8>)
	oval_dmvector_ASR_ZS_P.val = &menue_drive_data_setup.m_ASR_zs_p;
  406488:	f106 0918 	add.w	r9, r6, #24
	oval_dmvector_ASR_ls_p.mantissa_count = 1;
  40648c:	f8ca 5008 	str.w	r5, [sl, #8]
	oval_dmvector_APR_ZS_P.val = &menue_drive_data_setup.m_APR_zs_p;
  406490:	f106 0820 	add.w	r8, r6, #32
	dmotor_vector_ASR_ls_p.text = "ASR low P";
  406494:	4dd9      	ldr	r5, [pc, #868]	; (4067fc <menue_driver_vector_init+0x3ac>)
	oval_dmvector_ASR_hs_p.min_value = 0.01;
  406496:	edc1 7a06 	vstr	s15, [r1, #24]
	oval_dmvector_ASR_hs_p.val = &menue_drive_data_setup.m_ASR_highs_p;
  40649a:	f8c1 c01c 	str.w	ip, [r1, #28]
	oval_dmvector_sw_lw_point.val = &menue_drive_data_setup.m_ASR_sw_lw_point;
  40649e:	f106 0c2c 	add.w	ip, r6, #44	; 0x2c
	oval_dmvector_ASR_hs_p.data_types = float_dt;
  4064a2:	700c      	strb	r4, [r1, #0]
	oval_dmvector_ASR_hs_p.mantissa_count = 3;
  4064a4:	608c      	str	r4, [r1, #8]
	oval_dmvector_ASR_hs_p.real_count = 3;
  4064a6:	604c      	str	r4, [r1, #4]
	oval_dmvector_ASR_hs_p.max_value = 500;
  4064a8:	ed81 7a05 	vstr	s14, [r1, #20]
	oval_dmvector_ASR_hs_p.new_val_flag = &menue_drive_data_newdata_flag;
  4064ac:	620f      	str	r7, [r1, #32]
	dmotor_vector_ASR_hs_p.option_save_val = &oval_dmvector_ASR_hs_p;
  4064ae:	f8c5 109c 	str.w	r1, [r5, #156]	; 0x9c
	dmotor_vector_ASR_ls_i.text = "ASR low I";
  4064b2:	49d3      	ldr	r1, [pc, #844]	; (406800 <menue_driver_vector_init+0x3b0>)
	oval_dmvector_ASR_ls_p.min_value = 0.01;
  4064b4:	edca 7a06 	vstr	s15, [sl, #24]
	oval_dmvector_ASR_ls_p.val = &menue_drive_data_setup.m_ASR_lows_p;
  4064b8:	f8ca 601c 	str.w	r6, [sl, #28]
	oval_dmvector_ASR_ls_p.data_types = float_dt;
  4064bc:	f88a 4000 	strb.w	r4, [sl]
	oval_dmvector_ASR_ls_p.real_count = 3;
  4064c0:	f8ca 4004 	str.w	r4, [sl, #4]
	oval_dmvector_ASR_ls_p.max_value = 500;
  4064c4:	ed8a 7a05 	vstr	s14, [sl, #20]
	oval_dmvector_ASR_ls_p.new_val_flag = &menue_drive_data_newdata_flag;
  4064c8:	f8ca 7020 	str.w	r7, [sl, #32]
	dmotor_vector_ASR_ls_p.option_save_val = &oval_dmvector_ASR_ls_p;
  4064cc:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
	dmotor_vector_ASR_ls_i.text = "ASR low I";
  4064d0:	62a9      	str	r1, [r5, #40]	; 0x28
	dmotor_vector_ASR_ls_p.text = "ASR low P";
  4064d2:	f8df a390 	ldr.w	sl, [pc, #912]	; 406864 <menue_driver_vector_init+0x414>
	dmotor_vector_ASR_hs_i.text = "ASR high I";
  4064d6:	49cb      	ldr	r1, [pc, #812]	; (406804 <menue_driver_vector_init+0x3b4>)
	oval_dmvector_ASR_ls_i.data_types = float_dt;
  4064d8:	4bcb      	ldr	r3, [pc, #812]	; (406808 <menue_driver_vector_init+0x3b8>)
	oval_dmvector_ASR_ls_i.max_value = 50;
  4064da:	ed9f 7acc 	vldr	s14, [pc, #816]	; 40680c <menue_driver_vector_init+0x3bc>
	dmotor_vector_ASR_ls_p.text = "ASR low P";
  4064de:	f8c5 a000 	str.w	sl, [r5]
	dmotor_vector_ASR_hs_i.text = "ASR high I";
  4064e2:	f8c5 10a0 	str.w	r1, [r5, #160]	; 0xa0
	oval_dmvector_ASR_ls_i.text = "Low speed integ time";
  4064e6:	48ca      	ldr	r0, [pc, #808]	; (406810 <menue_driver_vector_init+0x3c0>)
	oval_dmvector_ASR_ls_i.unit = "Sec";
  4064e8:	49ca      	ldr	r1, [pc, #808]	; (406814 <menue_driver_vector_init+0x3c4>)
	dmotor_vector_ASR_hs_p.text = "ASR high P";
  4064ea:	f8df a37c 	ldr.w	sl, [pc, #892]	; 406868 <menue_driver_vector_init+0x418>
	oval_dmvector_ASR_ls_i.min_value = 0.01;
  4064ee:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_dmvector_ASR_ls_i.val = &menue_drive_data_setup.m_ASR_lows_i;
  4064f2:	61da      	str	r2, [r3, #28]
	oval_dmvector_apr_level_p.mantissa_count = 2;
  4064f4:	2202      	movs	r2, #2
	oval_dmvector_ASR_ls_i.text = "Low speed integ time";
  4064f6:	6118      	str	r0, [r3, #16]
	oval_dmvector_ASR_ZS_ESO.val = &menue_drive_data_setup.m_APR_zs_eso;
  4064f8:	f106 0024 	add.w	r0, r6, #36	; 0x24
	oval_dmvector_ASR_ls_i.data_types = float_dt;
  4064fc:	701c      	strb	r4, [r3, #0]
	oval_dmvector_ASR_ls_i.mantissa_count = 3;
  4064fe:	609c      	str	r4, [r3, #8]
	oval_dmvector_ASR_ls_i.real_count = 3;
  406500:	605c      	str	r4, [r3, #4]
	oval_dmvector_ASR_ls_i.new_val_flag = &menue_drive_data_newdata_flag;
  406502:	621f      	str	r7, [r3, #32]
	dmotor_vector_ASR_ls_i.option_save_val = &oval_dmvector_ASR_ls_i;
  406504:	64eb      	str	r3, [r5, #76]	; 0x4c
	dmotor_vector_ASR_hs_p.text = "ASR high P";
  406506:	f8c5 a078 	str.w	sl, [r5, #120]	; 0x78
	oval_dmvector_ACRD_p.val = &menue_drive_data_setup.m_ACRD_p;
  40650a:	f106 0a30 	add.w	sl, r6, #48	; 0x30
	oval_dmvector_ASR_ls_i.max_value = 50;
  40650e:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_dmvector_ASR_ls_i.unit = "Sec";
  406512:	60d9      	str	r1, [r3, #12]
	oval_dmvector_ASR_hs_i.data_types = float_dt;
  406514:	4bc0      	ldr	r3, [pc, #768]	; (406818 <menue_driver_vector_init+0x3c8>)
	oval_dmvector_sw_lw_point.max_value = 100;
  406516:	ed9f 6ac1 	vldr	s12, [pc, #772]	; 40681c <menue_driver_vector_init+0x3cc>
	oval_dmvector_ASR_hs_i.unit = "Sec";
  40651a:	60d9      	str	r1, [r3, #12]
	dmotor_vector_APR_LEVEL_P.text = "APR Level P";
  40651c:	49c0      	ldr	r1, [pc, #768]	; (406820 <menue_driver_vector_init+0x3d0>)
	oval_dmvector_ASR_hs_i.min_value = 0.01;
  40651e:	edc3 7a06 	vstr	s15, [r3, #24]
	dmotor_vector_APR_LEVEL_P.text = "APR Level P";
  406522:	f8c5 10f0 	str.w	r1, [r5, #240]	; 0xf0
	oval_dmvector_ASR_hs_i.text = "High speed integ time";
  406526:	49bf      	ldr	r1, [pc, #764]	; (406824 <menue_driver_vector_init+0x3d4>)
	oval_dmvector_ASR_hs_i.data_types = float_dt;
  406528:	701c      	strb	r4, [r3, #0]
	oval_dmvector_ASR_hs_i.mantissa_count = 3;
  40652a:	609c      	str	r4, [r3, #8]
	oval_dmvector_ASR_hs_i.real_count = 3;
  40652c:	605c      	str	r4, [r3, #4]
	oval_dmvector_ASR_hs_i.max_value = 50;
  40652e:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_dmvector_ASR_hs_i.new_val_flag = &menue_drive_data_newdata_flag;
  406532:	621f      	str	r7, [r3, #32]
	oval_dmvector_ASR_hs_i.val = &menue_drive_data_setup.m_ASR_highs_i;
  406534:	f8c3 e01c 	str.w	lr, [r3, #28]
	oval_dmvector_ACRD_i.val = &menue_drive_data_setup.m_ACRD_i;
  406538:	f106 0e34 	add.w	lr, r6, #52	; 0x34
	oval_dmvector_ASR_hs_i.text = "High speed integ time";
  40653c:	6119      	str	r1, [r3, #16]
	dmotor_vector_ASR_hs_i.option_save_val = &oval_dmvector_ASR_hs_i;
  40653e:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	oval_dmvector_apr_level_p.text = "positioning gain";
  406542:	49b9      	ldr	r1, [pc, #740]	; (406828 <menue_driver_vector_init+0x3d8>)
	oval_dmvector_apr_level_p.data_types = float_dt;
  406544:	4bb9      	ldr	r3, [pc, #740]	; (40682c <menue_driver_vector_init+0x3dc>)
	oval_dmvector_ACRD_p.max_value = 99999;
  406546:	eddf 6aba 	vldr	s13, [pc, #744]	; 406830 <menue_driver_vector_init+0x3e0>
	oval_dmvector_apr_level_p.text = "positioning gain";
  40654a:	6119      	str	r1, [r3, #16]
	dmotor_vector_ASR_ZS_P.text = "ASR zero speed P";
  40654c:	49b9      	ldr	r1, [pc, #740]	; (406834 <menue_driver_vector_init+0x3e4>)
	oval_dmvector_apr_level_p.val = &menue_drive_data_setup.m_APR_level_p;
  40654e:	f8c3 b01c 	str.w	fp, [r3, #28]
	dmotor_vector_ASR_ZS_P.text = "ASR zero speed P";
  406552:	f8c5 1118 	str.w	r1, [r5, #280]	; 0x118
	dmotor_vector_ASR_ZS_ESO.text = "ASR zero speed ESO";
  406556:	f8df b314 	ldr.w	fp, [pc, #788]	; 40686c <menue_driver_vector_init+0x41c>
	oval_dmvector_ASR_ZS_P.data_types = float_dt;
  40655a:	49b7      	ldr	r1, [pc, #732]	; (406838 <menue_driver_vector_init+0x3e8>)
	dmotor_vector_ASR_ZS_ESO.text = "ASR zero speed ESO";
  40655c:	f8c5 b140 	str.w	fp, [r5, #320]	; 0x140
	oval_dmvector_ASR_ZS_P.val = &menue_drive_data_setup.m_ASR_zs_p;
  406560:	f8c1 901c 	str.w	r9, [r1, #28]
	oval_dmvector_ASR_ZS_P.min_value = 0.1;
  406564:	f8df b308 	ldr.w	fp, [pc, #776]	; 406870 <menue_driver_vector_init+0x420>
	oval_dmvector_ASR_ZS_P.max_value = 999;
  406568:	f8df 9308 	ldr.w	r9, [pc, #776]	; 406874 <menue_driver_vector_init+0x424>
	oval_dmvector_ASR_ZS_P.data_types = float_dt;
  40656c:	700c      	strb	r4, [r1, #0]
	oval_dmvector_ASR_ZS_P.mantissa_count = 3;
  40656e:	608c      	str	r4, [r1, #8]
	oval_dmvector_apr_level_p.max_value = 50;
  406570:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_dmvector_ASR_ZS_P.real_count = 3;
  406574:	604c      	str	r4, [r1, #4]
	oval_dmvector_apr_level_p.min_value = 0.0;
  406576:	ed9f 7ab1 	vldr	s14, [pc, #708]	; 40683c <menue_driver_vector_init+0x3ec>
	oval_dmvector_ASR_ZS_P.new_val_flag = &menue_drive_data_newdata_flag;
  40657a:	620f      	str	r7, [r1, #32]
	dmotor_vector_ASR_ZS_P.option_save_val = &oval_dmvector_ASR_ZS_P;
  40657c:	f8c5 113c 	str.w	r1, [r5, #316]	; 0x13c
	oval_dmvector_ASR_ZS_P.min_value = 0.1;
  406580:	f8c1 b018 	str.w	fp, [r1, #24]
	oval_dmvector_ASR_ZS_P.max_value = 999;
  406584:	f8c1 9014 	str.w	r9, [r1, #20]
	oval_dmvector_ASR_ZS_ESO.data_types = float_dt;
  406588:	49ad      	ldr	r1, [pc, #692]	; (406840 <menue_driver_vector_init+0x3f0>)
	oval_dmvector_apr_level_p.min_value = 0.0;
  40658a:	ed83 7a06 	vstr	s14, [r3, #24]
	oval_dmvector_apr_level_p.data_types = float_dt;
  40658e:	701c      	strb	r4, [r3, #0]
	oval_dmvector_apr_level_p.new_val_flag = &menue_drive_data_newdata_flag;
  406590:	621f      	str	r7, [r3, #32]
	dmotor_vector_APR_LEVEL_P.option_save_val = &oval_dmvector_apr_level_p;
  406592:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
	oval_dmvector_apr_level_p.mantissa_count = 2;
  406596:	609a      	str	r2, [r3, #8]
	oval_dmvector_apr_level_p.real_count = 2;
  406598:	605a      	str	r2, [r3, #4]
	oval_dmvector_ASR_ZS_ESO.data_types = float_dt;
  40659a:	700c      	strb	r4, [r1, #0]
	oval_dmvector_ASR_ZS_ESO.mantissa_count = 3;
  40659c:	608c      	str	r4, [r1, #8]
	oval_dmvector_ASR_ZS_ESO.real_count = 3;
  40659e:	604c      	str	r4, [r1, #4]
	oval_dmvector_ASR_ZS_ESO.min_value = 0.0;
  4065a0:	ed81 7a06 	vstr	s14, [r1, #24]
	oval_dmvector_ASR_ZS_ESO.max_value = 999;
  4065a4:	f8c1 9014 	str.w	r9, [r1, #20]
	oval_dmvector_ASR_ZS_ESO.new_val_flag = &menue_drive_data_newdata_flag;
  4065a8:	620f      	str	r7, [r1, #32]
	oval_dmvector_ASR_ZS_ESO.val = &menue_drive_data_setup.m_APR_zs_eso;
  4065aa:	61c8      	str	r0, [r1, #28]
	oval_dmvector_ACRQ_p.val = &menue_drive_data_setup.m_ACRQ_p;
  4065ac:	f106 0038 	add.w	r0, r6, #56	; 0x38
	dmotor_vector_ASR_ZS_ESO.option_save_val = &oval_dmvector_ASR_ZS_ESO;
  4065b0:	f8c5 1164 	str.w	r1, [r5, #356]	; 0x164
	oval_dmvector_APR_ZS_P.data_types = float_dt;
  4065b4:	49a3      	ldr	r1, [pc, #652]	; (406844 <menue_driver_vector_init+0x3f4>)
	oval_dmvector_sw_lw_point.data_types = float_dt;
  4065b6:	f8df b2c0 	ldr.w	fp, [pc, #704]	; 406878 <menue_driver_vector_init+0x428>
	oval_dmvector_APR_ZS_P.min_value = 0.0;
  4065ba:	ed81 7a06 	vstr	s14, [r1, #24]
	oval_dmvector_APR_ZS_P.max_value = 999;
  4065be:	f8c1 9014 	str.w	r9, [r1, #20]
	oval_dmvector_ACRQ_i.val = &menue_drive_data_setup.m_ACRQ_i;
  4065c2:	f106 093c 	add.w	r9, r6, #60	; 0x3c
	oval_dmvector_APR_ZS_P.data_types = float_dt;
  4065c6:	700c      	strb	r4, [r1, #0]
	oval_dmvector_APR_ZS_P.mantissa_count = 3;
  4065c8:	608c      	str	r4, [r1, #8]
	oval_dmvector_APR_ZS_P.real_count = 3;
  4065ca:	604c      	str	r4, [r1, #4]
	oval_dmvector_APR_ZS_P.new_val_flag = &menue_drive_data_newdata_flag;
  4065cc:	620f      	str	r7, [r1, #32]
	dmotor_vector_APR_ZS_P.option_save_val = &oval_dmvector_APR_ZS_P;
  4065ce:	f8c5 118c 	str.w	r1, [r5, #396]	; 0x18c
	oval_dmvector_APR_ZS_P.val = &menue_drive_data_setup.m_APR_zs_p;
  4065d2:	f8c1 801c 	str.w	r8, [r1, #28]
	dmotor_vector_sw_lw_point.text = "Switch LS point";
  4065d6:	f8df 82a4 	ldr.w	r8, [pc, #676]	; 40687c <menue_driver_vector_init+0x42c>
	dmotor_vector_sw_hi_point.text = "Switch HS point";
  4065da:	499b      	ldr	r1, [pc, #620]	; (406848 <menue_driver_vector_init+0x3f8>)
	dmotor_vector_sw_lw_point.text = "Switch LS point";
  4065dc:	f8c5 8050 	str.w	r8, [r5, #80]	; 0x50
	dmotor_vector_sw_hi_point.text = "Switch HS point";
  4065e0:	f8c5 10c8 	str.w	r1, [r5, #200]	; 0xc8
	oval_dmvector_sw_hi_point.val = &menue_drive_data_setup.m_ASR_sw_hi_point;
  4065e4:	f106 0128 	add.w	r1, r6, #40	; 0x28
	oval_dmvector_sw_hi_point.data_types = float_dt;
  4065e8:	f8df 8294 	ldr.w	r8, [pc, #660]	; 406880 <menue_driver_vector_init+0x430>
	oval_dmvector_sw_lw_point.val = &menue_drive_data_setup.m_ASR_sw_lw_point;
  4065ec:	f8cb c01c 	str.w	ip, [fp, #28]
	oval_dmvector_sw_hi_point.val = &menue_drive_data_setup.m_ASR_sw_hi_point;
  4065f0:	f8c8 101c 	str.w	r1, [r8, #28]
	oval_dmvector_sw_lw_point.unit = "Hz";
  4065f4:	f8df c28c 	ldr.w	ip, [pc, #652]	; 406884 <menue_driver_vector_init+0x434>
	oval_dmvector_sw_lw_point.min_value = 0.05;
  4065f8:	4994      	ldr	r1, [pc, #592]	; (40684c <menue_driver_vector_init+0x3fc>)
	oval_dmvector_sw_lw_point.max_value = 100;
  4065fa:	ed8b 6a05 	vstr	s12, [fp, #20]
	oval_dmvector_sw_lw_point.data_types = float_dt;
  4065fe:	f88b 4000 	strb.w	r4, [fp]
	oval_dmvector_sw_lw_point.mantissa_count = 3;
  406602:	f8cb 4008 	str.w	r4, [fp, #8]
	oval_dmvector_sw_lw_point.real_count = 3;
  406606:	f8cb 4004 	str.w	r4, [fp, #4]
	oval_dmvector_sw_lw_point.new_val_flag = &menue_drive_data_newdata_flag;
  40660a:	f8cb 7020 	str.w	r7, [fp, #32]
	dmotor_vector_sw_lw_point.option_save_val = &oval_dmvector_sw_lw_point;
  40660e:	f8c5 b074 	str.w	fp, [r5, #116]	; 0x74
	oval_dmvector_sw_lw_point.min_value = 0.05;
  406612:	f8cb 1018 	str.w	r1, [fp, #24]
	oval_dmvector_sw_lw_point.unit = "Hz";
  406616:	f8cb c00c 	str.w	ip, [fp, #12]
	dmotor_vector_APR_ZS_P.text = "APR zero speed P";
  40661a:	4b8d      	ldr	r3, [pc, #564]	; (406850 <menue_driver_vector_init+0x400>)
	dmotor_vector_ACRD_i.text = "ACR-D I";
  40661c:	f8df b268 	ldr.w	fp, [pc, #616]	; 406888 <menue_driver_vector_init+0x438>
	oval_dmvector_sw_hi_point.max_value = 100;
  406620:	ed88 6a05 	vstr	s12, [r8, #20]
	dmotor_vector_APR_ZS_P.text = "APR zero speed P";
  406624:	f8c5 3168 	str.w	r3, [r5, #360]	; 0x168
	oval_dmvector_ACRD_p.real_count = 5;
  406628:	2305      	movs	r3, #5
	oval_dmvector_sw_hi_point.data_types = float_dt;
  40662a:	f888 4000 	strb.w	r4, [r8]
	oval_dmvector_sw_hi_point.mantissa_count = 3;
  40662e:	f8c8 4008 	str.w	r4, [r8, #8]
	oval_dmvector_sw_hi_point.real_count = 3;
  406632:	f8c8 4004 	str.w	r4, [r8, #4]
	oval_dmvector_sw_hi_point.new_val_flag = &menue_drive_data_newdata_flag;
  406636:	f8c8 7020 	str.w	r7, [r8, #32]
	oval_dmvector_sw_hi_point.min_value = 0.05;
  40663a:	f8c8 1018 	str.w	r1, [r8, #24]
	oval_dmvector_ACR_bandwidth.val = &menue_drive_data_setup.m_ACR_bandwidth;
  40663e:	f106 0140 	add.w	r1, r6, #64	; 0x40
	oval_dmvector_sw_hi_point.unit = "Hz";
  406642:	f8c8 c00c 	str.w	ip, [r8, #12]
	dmotor_vector_ACRD_i.text = "ACR-D I";
  406646:	f8c5 b1b8 	str.w	fp, [r5, #440]	; 0x1b8
	dmotor_vector_ACRQ_p.text = "ACR-Q P";
  40664a:	f8df b240 	ldr.w	fp, [pc, #576]	; 40688c <menue_driver_vector_init+0x43c>
	dmotor_vector_ACRD_p.text = "ACR-D P";
  40664e:	f8df c240 	ldr.w	ip, [pc, #576]	; 406890 <menue_driver_vector_init+0x440>
	dmotor_vector_ACRQ_p.text = "ACR-Q P";
  406652:	f8c5 b1e0 	str.w	fp, [r5, #480]	; 0x1e0
	dmotor_vector_ACRQ_i.text = "ACR-Q I";
  406656:	f8df b23c 	ldr.w	fp, [pc, #572]	; 406894 <menue_driver_vector_init+0x444>
	dmotor_vector_sw_hi_point.option_save_val = &oval_dmvector_sw_hi_point;
  40665a:	f8c5 80ec 	str.w	r8, [r5, #236]	; 0xec
	oval_dmvector_ACR_bandwidth_zs.val = &menue_drive_data_setup.m_ACR_bandwidth_zs;
  40665e:	f106 0844 	add.w	r8, r6, #68	; 0x44
	dmotor_vector_ACRQ_i.text = "ACR-Q I";
  406662:	f8c5 b208 	str.w	fp, [r5, #520]	; 0x208
	oval_dmvector_ACRD_p.data_types = float_dt;
  406666:	f8df b230 	ldr.w	fp, [pc, #560]	; 406898 <menue_driver_vector_init+0x448>
	dmotor_vector_ACRD_p.text = "ACR-D P";
  40666a:	f8c5 c190 	str.w	ip, [r5, #400]	; 0x190
	oval_dmvector_t_decay.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmvector_t_decay.unit = "ms";
	//oval_dmvector_t_decay.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvector_t_decay.val = &menue_drive_data_setup.m_tourque_decay;
  40666e:	f106 0c4c 	add.w	ip, r6, #76	; 0x4c
	oval_dmvector_ACRD_p.val = &menue_drive_data_setup.m_ACRD_p;
  406672:	f8cb a01c 	str.w	sl, [fp, #28]
	oval_dmvector_speed_dev.max_value = 100;
	oval_dmvector_speed_dev.min_value = 0;
	oval_dmvector_speed_dev.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmvector_speed_dev.unit = "%";
	//oval_dmvector_speed_dev.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvector_speed_dev.val = &menue_drive_data_setup.m_speed_dev;
  406676:	364e      	adds	r6, #78	; 0x4e
	oval_dmvector_ACRD_i.data_types = float_dt;
  406678:	f8df a220 	ldr.w	sl, [pc, #544]	; 40689c <menue_driver_vector_init+0x44c>
	oval_dmvector_ACRD_p.min_value = 0.01;
  40667c:	edcb 7a06 	vstr	s15, [fp, #24]
	oval_dmvector_ACRD_i.data_types = float_dt;
  406680:	f88a 4000 	strb.w	r4, [sl]
	oval_dmvector_ACRD_i.mantissa_count = 3;
  406684:	f8ca 4008 	str.w	r4, [sl, #8]
	oval_dmvector_ACRD_i.min_value = 0.01;
  406688:	edca 7a06 	vstr	s15, [sl, #24]
	oval_dmvector_ACRD_i.real_count = 5;
  40668c:	f8ca 3004 	str.w	r3, [sl, #4]
	oval_dmvector_ACRD_i.max_value = 99999;
  406690:	edca 6a05 	vstr	s13, [sl, #20]
	oval_dmvector_ACRD_i.val = &menue_drive_data_setup.m_ACRD_i;
  406694:	f8ca e01c 	str.w	lr, [sl, #28]
	oval_dmvector_ACRD_i.new_val_flag = &menue_drive_data_newdata_flag;
  406698:	f8ca 7020 	str.w	r7, [sl, #32]
	oval_dmvector_ACRQ_p.data_types = float_dt;
  40669c:	f8df e200 	ldr.w	lr, [pc, #512]	; 4068a0 <menue_driver_vector_init+0x450>
	dmotor_vector_ACRD_i.option_save_val = &oval_dmvector_ACRD_i;
  4066a0:	f8c5 a1dc 	str.w	sl, [r5, #476]	; 0x1dc
	oval_dmvector_ACRQ_i.data_types = float_dt;
  4066a4:	f8df a1fc 	ldr.w	sl, [pc, #508]	; 4068a4 <menue_driver_vector_init+0x454>
	oval_dmvector_ACRQ_p.min_value = 0.01;
  4066a8:	edce 7a06 	vstr	s15, [lr, #24]
	oval_dmvector_ACRQ_p.max_value = 99999;
  4066ac:	edce 6a05 	vstr	s13, [lr, #20]
	oval_dmvector_ACRQ_p.val = &menue_drive_data_setup.m_ACRQ_p;
  4066b0:	f8ce 001c 	str.w	r0, [lr, #28]
	oval_dmvector_t_decay.real_count = 4;
  4066b4:	2004      	movs	r0, #4
	oval_dmvector_ACRQ_p.data_types = float_dt;
  4066b6:	f88e 4000 	strb.w	r4, [lr]
	oval_dmvector_ACRQ_p.mantissa_count = 3;
  4066ba:	f8ce 4008 	str.w	r4, [lr, #8]
	oval_dmvector_ACRQ_p.new_val_flag = &menue_drive_data_newdata_flag;
  4066be:	f8ce 7020 	str.w	r7, [lr, #32]
	dmotor_vector_ACRQ_p.option_save_val = &oval_dmvector_ACRQ_p;
  4066c2:	f8c5 e204 	str.w	lr, [r5, #516]	; 0x204
	oval_dmvector_ACRD_p.real_count = 5;
  4066c6:	f8cb 3004 	str.w	r3, [fp, #4]
	oval_dmvector_ACRQ_p.real_count = 5;
  4066ca:	f8ce 3004 	str.w	r3, [lr, #4]
	oval_dmvector_t_decay.mantissa_count = 0;
  4066ce:	f04f 0e00 	mov.w	lr, #0
	oval_dmvector_ACRD_p.max_value = 99999;
  4066d2:	edcb 6a05 	vstr	s13, [fp, #20]
	oval_dmvector_ACRQ_i.real_count = 5;
  4066d6:	f8ca 3004 	str.w	r3, [sl, #4]
	oval_dmvector_ACRQ_i.data_types = float_dt;
  4066da:	f88a 4000 	strb.w	r4, [sl]
	oval_dmvector_ACRQ_i.mantissa_count = 3;
  4066de:	f8ca 4008 	str.w	r4, [sl, #8]
	oval_dmvector_ACRD_p.data_types = float_dt;
  4066e2:	f88b 4000 	strb.w	r4, [fp]
	oval_dmvector_ACRD_p.mantissa_count = 3;
  4066e6:	f8cb 4008 	str.w	r4, [fp, #8]
	oval_dmvector_ACRD_p.new_val_flag = &menue_drive_data_newdata_flag;
  4066ea:	f8cb 7020 	str.w	r7, [fp, #32]
	dmotor_vector_ACRD_p.option_save_val = &oval_dmvector_ACRD_p;
  4066ee:	f8c5 b1b4 	str.w	fp, [r5, #436]	; 0x1b4
	oval_dmvector_ACRQ_i.max_value = 99999;
  4066f2:	edca 6a05 	vstr	s13, [sl, #20]
	oval_dmvector_ACRQ_i.val = &menue_drive_data_setup.m_ACRQ_i;
  4066f6:	f8ca 901c 	str.w	r9, [sl, #28]
	dmotor_vector_ACR_bandwidth_zs.text = "ACR bandwidth ZS";
  4066fa:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 4068a8 <menue_driver_vector_init+0x458>
	dmotor_vector_ACR_bandwidth.text = "ACR bandwidth";
  4066fe:	4b55      	ldr	r3, [pc, #340]	; (406854 <menue_driver_vector_init+0x404>)
	dmotor_vector_ACR_bandwidth_zs.text = "ACR bandwidth ZS";
  406700:	f8c5 9258 	str.w	r9, [r5, #600]	; 0x258
	dmotor_vector_t_decay.text = "Tourque decay";
  406704:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 4068ac <menue_driver_vector_init+0x45c>
	oval_dmvector_ACRQ_i.min_value = 0.01;
  406708:	edca 7a06 	vstr	s15, [sl, #24]
	dmotor_vector_t_decay.text = "Tourque decay";
  40670c:	f8c5 9280 	str.w	r9, [r5, #640]	; 0x280
	dmotor_vector_speed_dev.text = "Allowed speed dev";
  406710:	f8df 919c 	ldr.w	r9, [pc, #412]	; 4068b0 <menue_driver_vector_init+0x460>
	oval_dmvector_ACRQ_i.new_val_flag = &menue_drive_data_newdata_flag;
  406714:	f8ca 7020 	str.w	r7, [sl, #32]
	dmotor_vector_speed_dev.text = "Allowed speed dev";
  406718:	f8c5 92a8 	str.w	r9, [r5, #680]	; 0x2a8
	oval_dmvector_ACR_bandwidth.data_types = float_dt;
  40671c:	f8df 9194 	ldr.w	r9, [pc, #404]	; 4068b4 <menue_driver_vector_init+0x464>
	dmotor_vector_ACRQ_i.option_save_val = &oval_dmvector_ACRQ_i;
  406720:	f8c5 a22c 	str.w	sl, [r5, #556]	; 0x22c
	oval_dmvector_ACR_bandwidth.val = &menue_drive_data_setup.m_ACR_bandwidth;
  406724:	f8c9 101c 	str.w	r1, [r9, #28]
	oval_dmvector_ACR_bandwidth.max_value = 999.99;
  406728:	494b      	ldr	r1, [pc, #300]	; (406858 <menue_driver_vector_init+0x408>)
	oval_dmvector_ACR_bandwidth.min_value = 0.01;
  40672a:	edc9 7a06 	vstr	s15, [r9, #24]
	oval_dmvector_ACR_bandwidth.data_types = float_dt;
  40672e:	f889 4000 	strb.w	r4, [r9]
	oval_dmvector_ACR_bandwidth.mantissa_count = 2;
  406732:	f8c9 2008 	str.w	r2, [r9, #8]
	oval_dmvector_ACR_bandwidth.real_count = 3;
  406736:	f8c9 4004 	str.w	r4, [r9, #4]
	oval_dmvector_ACR_bandwidth.new_val_flag = &menue_drive_data_newdata_flag;
  40673a:	f8c9 7020 	str.w	r7, [r9, #32]
	oval_dmvector_ACR_bandwidth.max_value = 999.99;
  40673e:	f8c9 1014 	str.w	r1, [r9, #20]
	dmotor_vector_ACR_bandwidth.option_save_val = &oval_dmvector_ACR_bandwidth;
  406742:	f8c5 9254 	str.w	r9, [r5, #596]	; 0x254
	oval_dmvector_ACR_bandwidth_zs.data_types = float_dt;
  406746:	f8df 9170 	ldr.w	r9, [pc, #368]	; 4068b8 <menue_driver_vector_init+0x468>
	dmotor_vector_ACR_bandwidth.text = "ACR bandwidth";
  40674a:	f8c5 3230 	str.w	r3, [r5, #560]	; 0x230
	dmotor_vector_speed_dev.option_save_val = &oval_dmvector_speed_dev;
//__________________________________________________
	
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  40674e:	4673      	mov	r3, lr
	oval_dmvector_ACR_bandwidth_zs.val = &menue_drive_data_setup.m_ACR_bandwidth_zs;
  406750:	f8c9 801c 	str.w	r8, [r9, #28]
	oval_dmvector_t_decay.data_types = uint16_dt;
  406754:	f8df 8164 	ldr.w	r8, [pc, #356]	; 4068bc <menue_driver_vector_init+0x46c>
	oval_dmvector_ACR_bandwidth_zs.min_value = 0.01;
  406758:	edc9 7a06 	vstr	s15, [r9, #24]
	oval_dmvector_ACR_bandwidth_zs.mantissa_count = 2;
  40675c:	f8c9 2008 	str.w	r2, [r9, #8]
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  406760:	2212      	movs	r2, #18
	oval_dmvector_ACR_bandwidth_zs.data_types = float_dt;
  406762:	f889 4000 	strb.w	r4, [r9]
	oval_dmvector_ACR_bandwidth_zs.real_count = 3;
  406766:	f8c9 4004 	str.w	r4, [r9, #4]
	oval_dmvector_ACR_bandwidth_zs.max_value = 999.99;
  40676a:	f8c9 1014 	str.w	r1, [r9, #20]
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  40676e:	4629      	mov	r1, r5
	oval_dmvector_ACR_bandwidth_zs.new_val_flag = &menue_drive_data_newdata_flag;
  406770:	f8c9 7020 	str.w	r7, [r9, #32]
	dmotor_vector_ACR_bandwidth_zs.option_save_val = &oval_dmvector_ACR_bandwidth_zs;
  406774:	f8c5 927c 	str.w	r9, [r5, #636]	; 0x27c
	oval_dmvector_t_decay.val = &menue_drive_data_setup.m_tourque_decay;
  406778:	f8c8 c01c 	str.w	ip, [r8, #28]
	oval_dmvector_t_decay.data_types = uint16_dt;
  40677c:	f04f 0c01 	mov.w	ip, #1
	oval_dmvector_t_decay.real_count = 4;
  406780:	f8c8 0004 	str.w	r0, [r8, #4]
	oval_dmvector_t_decay.max_value = 3000;
  406784:	f8df 9138 	ldr.w	r9, [pc, #312]	; 4068c0 <menue_driver_vector_init+0x470>
	oval_dmvector_t_decay.unit = "ms";
  406788:	4834      	ldr	r0, [pc, #208]	; (40685c <menue_driver_vector_init+0x40c>)
	oval_dmvector_t_decay.min_value = 10;
  40678a:	edc8 5a06 	vstr	s11, [r8, #24]
	oval_dmvector_t_decay.data_types = uint16_dt;
  40678e:	f888 c000 	strb.w	ip, [r8]
	oval_dmvector_t_decay.new_val_flag = &menue_drive_data_newdata_flag;
  406792:	f8c8 7020 	str.w	r7, [r8, #32]
	oval_dmvector_speed_dev.data_types = uint16_dt;
  406796:	f8df c12c 	ldr.w	ip, [pc, #300]	; 4068c4 <menue_driver_vector_init+0x474>
	dmotor_vector_t_decay.option_save_val = &oval_dmvector_t_decay;
  40679a:	f8c5 82a4 	str.w	r8, [r5, #676]	; 0x2a4
	oval_dmvector_t_decay.max_value = 3000;
  40679e:	f8c8 9014 	str.w	r9, [r8, #20]
	oval_dmvector_t_decay.unit = "ms";
  4067a2:	f8c8 000c 	str.w	r0, [r8, #12]
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  4067a6:	f8df 9120 	ldr.w	r9, [pc, #288]	; 4068c8 <menue_driver_vector_init+0x478>
	oval_dmvector_t_decay.mantissa_count = 0;
  4067aa:	f8c8 e008 	str.w	lr, [r8, #8]
	oval_dmvector_speed_dev.data_types = uint16_dt;
  4067ae:	f04f 0801 	mov.w	r8, #1
	oval_dmvector_speed_dev.unit = "%";
  4067b2:	f8df a118 	ldr.w	sl, [pc, #280]	; 4068cc <menue_driver_vector_init+0x47c>
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  4067b6:	4648      	mov	r0, r9
	oval_dmvector_speed_dev.data_types = uint16_dt;
  4067b8:	f88c 8000 	strb.w	r8, [ip]
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  4067bc:	f8cd e000 	str.w	lr, [sp]
  4067c0:	f8df 810c 	ldr.w	r8, [pc, #268]	; 4068d0 <menue_driver_vector_init+0x480>
	oval_dmvector_speed_dev.max_value = 100;
  4067c4:	ed8c 6a05 	vstr	s12, [ip, #20]
	oval_dmvector_speed_dev.val = &menue_drive_data_setup.m_speed_dev;
  4067c8:	f8cc 601c 	str.w	r6, [ip, #28]
	oval_dmvector_speed_dev.mantissa_count = 0;
  4067cc:	f8cc e008 	str.w	lr, [ip, #8]
	oval_dmvector_speed_dev.min_value = 0;
  4067d0:	ed8c 7a06 	vstr	s14, [ip, #24]
	dmotor_vector_speed_dev.option_save_val = &oval_dmvector_speed_dev;
  4067d4:	f8c5 c2cc 	str.w	ip, [r5, #716]	; 0x2cc
	oval_dmvector_speed_dev.new_val_flag = &menue_drive_data_newdata_flag;
  4067d8:	f8cc 7020 	str.w	r7, [ip, #32]
  4067dc:	e07a      	b.n	4068d4 <menue_driver_vector_init+0x484>
  4067de:	bf00      	nop
  4067e0:	0041adc4 	.word	0x0041adc4
  4067e4:	20405128 	.word	0x20405128
  4067e8:	20403420 	.word	0x20403420
  4067ec:	0041ae08 	.word	0x0041ae08
  4067f0:	3c23d70a 	.word	0x3c23d70a
  4067f4:	43fa0000 	.word	0x43fa0000
  4067f8:	20404fec 	.word	0x20404fec
  4067fc:	20402fc4 	.word	0x20402fc4
  406800:	0041add8 	.word	0x0041add8
  406804:	0041ae1c 	.word	0x0041ae1c
  406808:	204034a8 	.word	0x204034a8
  40680c:	42480000 	.word	0x42480000
  406810:	0041ade4 	.word	0x0041ade4
  406814:	0041a8d4 	.word	0x0041a8d4
  406818:	204034cc 	.word	0x204034cc
  40681c:	42c80000 	.word	0x42c80000
  406820:	0041ae40 	.word	0x0041ae40
  406824:	0041ae28 	.word	0x0041ae28
  406828:	0041ae4c 	.word	0x0041ae4c
  40682c:	204032b8 	.word	0x204032b8
  406830:	47c34f80 	.word	0x47c34f80
  406834:	0041ae60 	.word	0x0041ae60
  406838:	20403390 	.word	0x20403390
  40683c:	00000000 	.word	0x00000000
  406840:	20402f58 	.word	0x20402f58
  406844:	20403348 	.word	0x20403348
  406848:	0041aeac 	.word	0x0041aeac
  40684c:	3d4ccccd 	.word	0x3d4ccccd
  406850:	0041ae88 	.word	0x0041ae88
  406854:	0041aedc 	.word	0x0041aedc
  406858:	4479ff5c 	.word	0x4479ff5c
  40685c:	0041a998 	.word	0x0041a998
  406860:	204033b4 	.word	0x204033b4
  406864:	0041adb8 	.word	0x0041adb8
  406868:	0041adfc 	.word	0x0041adfc
  40686c:	0041ae74 	.word	0x0041ae74
  406870:	3dcccccd 	.word	0x3dcccccd
  406874:	4479c000 	.word	0x4479c000
  406878:	204034f0 	.word	0x204034f0
  40687c:	0041ae9c 	.word	0x0041ae9c
  406880:	20403514 	.word	0x20403514
  406884:	004199e8 	.word	0x004199e8
  406888:	0041aec4 	.word	0x0041aec4
  40688c:	0041aecc 	.word	0x0041aecc
  406890:	0041aebc 	.word	0x0041aebc
  406894:	0041aed4 	.word	0x0041aed4
  406898:	204033fc 	.word	0x204033fc
  40689c:	20403300 	.word	0x20403300
  4068a0:	20403538 	.word	0x20403538
  4068a4:	20403444 	.word	0x20403444
  4068a8:	0041aeec 	.word	0x0041aeec
  4068ac:	0041af00 	.word	0x0041af00
  4068b0:	0041af10 	.word	0x0041af10
  4068b4:	20403324 	.word	0x20403324
  4068b8:	20402fa0 	.word	0x20402fa0
  4068bc:	2040336c 	.word	0x2040336c
  4068c0:	453b8000 	.word	0x453b8000
  4068c4:	20403294 	.word	0x20403294
  4068c8:	20403468 	.word	0x20403468
  4068cc:	0041a888 	.word	0x0041a888
  4068d0:	0040b0ad 	.word	0x0040b0ad
	oval_dmvector_speed_dev.real_count = 3;
  4068d4:	f8cc 4004 	str.w	r4, [ip, #4]
	oval_dmvector_speed_dev.unit = "%";
  4068d8:	f8cc a00c 	str.w	sl, [ip, #12]
	fill_menue_list(&menue_driver_vector, opt_driver_vector, OPT_DRIVER_VECTOR_MAX, 0, 0);
  4068dc:	47c0      	blx	r8
	return &menue_driver_vector;	
  4068de:	4648      	mov	r0, r9
  4068e0:	b003      	add	sp, #12
  4068e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4068e6:	bf00      	nop

004068e8 <menue_driver_vf_init>:
option_val_t oval_dmvf_m_break_freq;
option_val_t oval_dmvf_m_break_voltage;


menue_design_t *menue_driver_vf_init(void)
{
  4068e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	oval_dmvf_m_vmin.max_value = 99;
	oval_dmvf_m_vmin.min_value = 0.0;
	oval_dmvf_m_vmin.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmvf_m_vmin.unit = "V";
	//oval_dmvf_m_vmin.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvf_m_vmin.val = &menue_drive_data_setup.m_vmin;
  4068ec:	4e51      	ldr	r6, [pc, #324]	; (406a34 <menue_driver_vf_init+0x14c>)
	oval_dmvf_m_vmin.data_types = fixedpt_dt;
  4068ee:	2002      	movs	r0, #2
	dmotor_vf_m_vmin.option_save_val = &oval_dmvf_m_vmin;
	//__________________________________________________
	dmotor_vf_m_fmin.text = "Fmin";
	oval_dmvf_m_fmin.data_types = fixedpt_dt;
  4068f0:	4b51      	ldr	r3, [pc, #324]	; (406a38 <menue_driver_vf_init+0x150>)
	dmotor_vf_m_fmin.option_save_val = &oval_dmvf_m_fmin;
	//__________________________________________________
	dmotor_vf_m_vm.text = "Vm";
	oval_dmvf_m_vm.data_types = fixedpt_dt;
	oval_dmvf_m_vm.mantissa_count = 2;
	oval_dmvf_m_vm.real_count = 3;
  4068f2:	f04f 0803 	mov.w	r8, #3
	oval_dmvf_m_vm.data_types = fixedpt_dt;
  4068f6:	4a51      	ldr	r2, [pc, #324]	; (406a3c <menue_driver_vf_init+0x154>)
	oval_dmvf_m_fmin.val = &menue_drive_data_setup.m_fmin;
  4068f8:	1d37      	adds	r7, r6, #4
	oval_dmvf_m_vm.max_value = 400;
	oval_dmvf_m_vm.min_value = 0.0;
	oval_dmvf_m_vm.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmvf_m_vm.unit = "V";
	//oval_dmvf_m_vm.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvf_m_vm.val = &menue_drive_data_setup.m_vm;
  4068fa:	f106 0e08 	add.w	lr, r6, #8
	oval_dmvf_m_vm.max_value = 400;
  4068fe:	4c50      	ldr	r4, [pc, #320]	; (406a40 <menue_driver_vf_init+0x158>)
	oval_dmvf_m_vmin.data_types = fixedpt_dt;
  406900:	4d50      	ldr	r5, [pc, #320]	; (406a44 <menue_driver_vf_init+0x15c>)
	oval_dmvf_m_fm.max_value = 50;
	oval_dmvf_m_fm.min_value = 0.0;
	oval_dmvf_m_fm.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmvf_m_fm.unit = "Hz";
	//oval_dmvf_m_fm.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvf_m_fm.val = &menue_drive_data_setup.m_fm;
  406902:	f106 0a0c 	add.w	sl, r6, #12
	oval_dmvf_m_vmin.min_value = 0.0;
  406906:	eddf 7a50 	vldr	s15, [pc, #320]	; 406a48 <menue_driver_vf_init+0x160>
	oval_dmvf_m_tboost.max_value = 300;
	oval_dmvf_m_tboost.min_value = 0.0;
	oval_dmvf_m_tboost.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dmvf_m_tboost.unit = "Hz";
	//oval_dmvf_m_tboost.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvf_m_tboost.val = &menue_drive_data_setup.m_tboost;
  40690a:	f106 0918 	add.w	r9, r6, #24
	oval_dmvf_m_vmin.max_value = 99;
  40690e:	ed9f 7a4f 	vldr	s14, [pc, #316]	; 406a4c <menue_driver_vf_init+0x164>
	oval_dmvf_m_break_voltage.unit = "V";
	//oval_dmvf_m_break_voltage.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dmvf_m_break_voltage.val = &menue_drive_data_setup.m_break_voltage;
	dmotor_vf_m_break_voltage.option_save_val = &oval_dmvf_m_break_voltage;
	//__________________________________________________	
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  406912:	f04f 0c00 	mov.w	ip, #0
	oval_dmvf_m_fmin.val = &menue_drive_data_setup.m_fmin;
  406916:	61df      	str	r7, [r3, #28]
{
  406918:	b083      	sub	sp, #12
	oval_dmvf_m_vmin.new_val_flag = &menue_drive_data_newdata_flag;
  40691a:	4f4d      	ldr	r7, [pc, #308]	; (406a50 <menue_driver_vf_init+0x168>)
	oval_dmvf_m_break_freq.val = &menue_drive_data_setup.m_break_freq;
  40691c:	f106 0110 	add.w	r1, r6, #16
	oval_dmvf_m_vm.val = &menue_drive_data_setup.m_vm;
  406920:	f8c2 e01c 	str.w	lr, [r2, #28]
	oval_dmvf_m_vm.max_value = 400;
  406924:	6154      	str	r4, [r2, #20]
	oval_dmvf_m_vmin.unit = "V";
  406926:	f8df e158 	ldr.w	lr, [pc, #344]	; 406a80 <menue_driver_vf_init+0x198>
	dmotor_vf_m_vmin.text = "Vmin";
  40692a:	4c4a      	ldr	r4, [pc, #296]	; (406a54 <menue_driver_vf_init+0x16c>)
	oval_dmvf_m_vmin.max_value = 99;
  40692c:	ed85 7a05 	vstr	s14, [r5, #20]
	oval_dmvf_m_vmin.min_value = 0.0;
  406930:	edc5 7a06 	vstr	s15, [r5, #24]
	oval_dmvf_m_vmin.unit = "V";
  406934:	f8c5 e00c 	str.w	lr, [r5, #12]
	oval_dmvf_m_vmin.val = &menue_drive_data_setup.m_vmin;
  406938:	61ee      	str	r6, [r5, #28]
	oval_dmvf_m_break_voltage.val = &menue_drive_data_setup.m_break_voltage;
  40693a:	3614      	adds	r6, #20
	oval_dmvf_m_vmin.data_types = fixedpt_dt;
  40693c:	7028      	strb	r0, [r5, #0]
	oval_dmvf_m_vmin.mantissa_count = 2;
  40693e:	60a8      	str	r0, [r5, #8]
	oval_dmvf_m_vmin.real_count = 2;
  406940:	6068      	str	r0, [r5, #4]
	oval_dmvf_m_vmin.new_val_flag = &menue_drive_data_newdata_flag;
  406942:	622f      	str	r7, [r5, #32]
	dmotor_vf_m_vmin.option_save_val = &oval_dmvf_m_vmin;
  406944:	6265      	str	r5, [r4, #36]	; 0x24
	dmotor_vf_m_vmin.text = "Vmin";
  406946:	4d44      	ldr	r5, [pc, #272]	; (406a58 <menue_driver_vf_init+0x170>)
	oval_dmvf_m_vm.min_value = 0.0;
  406948:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_dmvf_m_vm.unit = "V";
  40694c:	f8c2 e00c 	str.w	lr, [r2, #12]
	oval_dmvf_m_vm.data_types = fixedpt_dt;
  406950:	7010      	strb	r0, [r2, #0]
	oval_dmvf_m_vm.mantissa_count = 2;
  406952:	6090      	str	r0, [r2, #8]
	oval_dmvf_m_vm.new_val_flag = &menue_drive_data_newdata_flag;
  406954:	6217      	str	r7, [r2, #32]
	dmotor_vf_m_vm.option_save_val = &oval_dmvf_m_vm;
  406956:	6762      	str	r2, [r4, #116]	; 0x74
	dmotor_vf_m_vmin.text = "Vmin";
  406958:	6025      	str	r5, [r4, #0]
	oval_dmvf_m_vm.real_count = 3;
  40695a:	f8c2 8004 	str.w	r8, [r2, #4]
	oval_dmvf_m_fmin.unit = "Hz";
  40695e:	4d3f      	ldr	r5, [pc, #252]	; (406a5c <menue_driver_vf_init+0x174>)
	dmotor_vf_m_fmin.text = "Fmin";
  406960:	f8df b120 	ldr.w	fp, [pc, #288]	; 406a84 <menue_driver_vf_init+0x19c>
	dmotor_vf_m_vm.text = "Vm";
  406964:	4a3e      	ldr	r2, [pc, #248]	; (406a60 <menue_driver_vf_init+0x178>)
	oval_dmvf_m_fmin.max_value = 99;
  406966:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_dmvf_m_fmin.min_value = 0.0;
  40696a:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_dmvf_m_fmin.data_types = fixedpt_dt;
  40696e:	7018      	strb	r0, [r3, #0]
	oval_dmvf_m_fmin.mantissa_count = 2;
  406970:	6098      	str	r0, [r3, #8]
	oval_dmvf_m_fmin.real_count = 2;
  406972:	6058      	str	r0, [r3, #4]
	oval_dmvf_m_fmin.new_val_flag = &menue_drive_data_newdata_flag;
  406974:	621f      	str	r7, [r3, #32]
	dmotor_vf_m_fmin.option_save_val = &oval_dmvf_m_fmin;
  406976:	64e3      	str	r3, [r4, #76]	; 0x4c
	dmotor_vf_m_fmin.text = "Fmin";
  406978:	f8c4 b028 	str.w	fp, [r4, #40]	; 0x28
	oval_dmvf_m_fmin.unit = "Hz";
  40697c:	60dd      	str	r5, [r3, #12]
	dmotor_vf_m_vm.text = "Vm";
  40697e:	6522      	str	r2, [r4, #80]	; 0x50
	dmotor_vf_m_fm.text = "Fm";
  406980:	4b38      	ldr	r3, [pc, #224]	; (406a64 <menue_driver_vf_init+0x17c>)
	oval_dmvf_m_fm.data_types = fixedpt_dt;
  406982:	4a39      	ldr	r2, [pc, #228]	; (406a68 <menue_driver_vf_init+0x180>)
	oval_dmvf_m_fm.max_value = 50;
  406984:	f8df b100 	ldr.w	fp, [pc, #256]	; 406a88 <menue_driver_vf_init+0x1a0>
	dmotor_vf_m_fm.text = "Fm";
  406988:	67a3      	str	r3, [r4, #120]	; 0x78
	oval_dmvf_m_fm.data_types = fixedpt_dt;
  40698a:	7010      	strb	r0, [r2, #0]
	oval_dmvf_m_fm.min_value = 0.0;
  40698c:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_dmvf_m_fm.mantissa_count = 2;
  406990:	6090      	str	r0, [r2, #8]
	oval_dmvf_m_fm.real_count = 2;
  406992:	6050      	str	r0, [r2, #4]
	oval_dmvf_m_fm.new_val_flag = &menue_drive_data_newdata_flag;
  406994:	6217      	str	r7, [r2, #32]
	oval_dmvf_m_fm.unit = "Hz";
  406996:	60d5      	str	r5, [r2, #12]
	oval_dmvf_m_fm.max_value = 50;
  406998:	f8c2 b014 	str.w	fp, [r2, #20]
	oval_dmvf_m_fm.val = &menue_drive_data_setup.m_fm;
  40699c:	f8c2 a01c 	str.w	sl, [r2, #28]
	dmotor_vf_m_fm.option_save_val = &oval_dmvf_m_fm;
  4069a0:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
	dmotor_vf_m_tboost.text = "Torque boost";
  4069a4:	4a31      	ldr	r2, [pc, #196]	; (406a6c <menue_driver_vf_init+0x184>)
	oval_dmvf_m_break_freq.data_types = fixedpt_dt;
  4069a6:	4b32      	ldr	r3, [pc, #200]	; (406a70 <menue_driver_vf_init+0x188>)
	dmotor_vf_m_tboost.text = "Torque boost";
  4069a8:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	oval_dmvf_m_tboost.data_types = fixedpt_dt;
  4069ac:	4a31      	ldr	r2, [pc, #196]	; (406a74 <menue_driver_vf_init+0x18c>)
	oval_dmvf_m_break_freq.unit = "Hz";
  4069ae:	60dd      	str	r5, [r3, #12]
	oval_dmvf_m_tboost.unit = "Hz";
  4069b0:	60d5      	str	r5, [r2, #12]
	dmotor_vf_m_break_voltage.text = "Break voltage";
  4069b2:	4d31      	ldr	r5, [pc, #196]	; (406a78 <menue_driver_vf_init+0x190>)
	oval_dmvf_m_tboost.val = &menue_drive_data_setup.m_tboost;
  4069b4:	f8c2 901c 	str.w	r9, [r2, #28]
	dmotor_vf_m_break_voltage.text = "Break voltage";
  4069b8:	f8c4 50f0 	str.w	r5, [r4, #240]	; 0xf0
	dmotor_vf_m_break_freq.text = "Break frequency";
  4069bc:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 406a8c <menue_driver_vf_init+0x1a4>
	oval_dmvf_m_break_voltage.data_types = fixedpt_dt;
  4069c0:	4d2e      	ldr	r5, [pc, #184]	; (406a7c <menue_driver_vf_init+0x194>)
	oval_dmvf_m_tboost.real_count = 3;
  4069c2:	f8c2 8004 	str.w	r8, [r2, #4]
	dmotor_vf_m_break_freq.text = "Break frequency";
  4069c6:	f8c4 90c8 	str.w	r9, [r4, #200]	; 0xc8
	oval_dmvf_m_break_voltage.real_count = 3;
  4069ca:	f8c5 8004 	str.w	r8, [r5, #4]
	oval_dmvf_m_tboost.max_value = 300;
  4069ce:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 406a90 <menue_driver_vf_init+0x1a8>
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  4069d2:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 406a94 <menue_driver_vf_init+0x1ac>
	oval_dmvf_m_break_voltage.max_value = 380;
  4069d6:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 406a98 <menue_driver_vf_init+0x1b0>
	oval_dmvf_m_break_freq.max_value = 99;
  4069da:	ed83 7a05 	vstr	s14, [r3, #20]
	oval_dmvf_m_break_freq.min_value = 0.0;
  4069de:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_dmvf_m_tboost.min_value = 0.0;
  4069e2:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_dmvf_m_break_freq.data_types = fixedpt_dt;
  4069e6:	7018      	strb	r0, [r3, #0]
	oval_dmvf_m_break_freq.mantissa_count = 2;
  4069e8:	6098      	str	r0, [r3, #8]
	oval_dmvf_m_break_freq.real_count = 2;
  4069ea:	6058      	str	r0, [r3, #4]
	oval_dmvf_m_break_freq.new_val_flag = &menue_drive_data_newdata_flag;
  4069ec:	621f      	str	r7, [r3, #32]
	dmotor_vf_m_break_freq.option_save_val = &oval_dmvf_m_break_freq;
  4069ee:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
	oval_dmvf_m_break_freq.val = &menue_drive_data_setup.m_break_freq;
  4069f2:	61d9      	str	r1, [r3, #28]
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  4069f4:	4621      	mov	r1, r4
	oval_dmvf_m_tboost.data_types = fixedpt_dt;
  4069f6:	7010      	strb	r0, [r2, #0]
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  4069f8:	4663      	mov	r3, ip
	oval_dmvf_m_tboost.mantissa_count = 2;
  4069fa:	6090      	str	r0, [r2, #8]
	oval_dmvf_m_tboost.new_val_flag = &menue_drive_data_newdata_flag;
  4069fc:	6217      	str	r7, [r2, #32]
	dmotor_vf_m_tboost.option_save_val = &oval_dmvf_m_tboost;
  4069fe:	f8c4 20c4 	str.w	r2, [r4, #196]	; 0xc4
	oval_dmvf_m_tboost.max_value = 300;
  406a02:	f8c2 a014 	str.w	sl, [r2, #20]
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  406a06:	2207      	movs	r2, #7
	oval_dmvf_m_break_voltage.data_types = fixedpt_dt;
  406a08:	7028      	strb	r0, [r5, #0]
	oval_dmvf_m_break_voltage.mantissa_count = 2;
  406a0a:	60a8      	str	r0, [r5, #8]
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  406a0c:	4640      	mov	r0, r8
	oval_dmvf_m_break_voltage.max_value = 380;
  406a0e:	f8c5 9014 	str.w	r9, [r5, #20]
	oval_dmvf_m_break_voltage.min_value = 0.0;
  406a12:	edc5 7a06 	vstr	s15, [r5, #24]
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  406a16:	f8df 9084 	ldr.w	r9, [pc, #132]	; 406a9c <menue_driver_vf_init+0x1b4>
  406a1a:	f8cd c000 	str.w	ip, [sp]
	oval_dmvf_m_break_voltage.val = &menue_drive_data_setup.m_break_voltage;
  406a1e:	61ee      	str	r6, [r5, #28]
	oval_dmvf_m_break_voltage.new_val_flag = &menue_drive_data_newdata_flag;
  406a20:	622f      	str	r7, [r5, #32]
	oval_dmvf_m_break_voltage.unit = "V";
  406a22:	f8c5 e00c 	str.w	lr, [r5, #12]
	dmotor_vf_m_break_voltage.option_save_val = &oval_dmvf_m_break_voltage;
  406a26:	f8c4 5114 	str.w	r5, [r4, #276]	; 0x114
	fill_menue_list(&menue_driver_vf, opt_driver_vf, OPT_DRIVER_VF_MAX, 0, 0);
  406a2a:	47c8      	blx	r9
	return &menue_driver_vf;
  406a2c:	4640      	mov	r0, r8
  406a2e:	b003      	add	sp, #12
  406a30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406a34:	20405178 	.word	0x20405178
  406a38:	20403580 	.word	0x20403580
  406a3c:	2040355c 	.word	0x2040355c
  406a40:	43c80000 	.word	0x43c80000
  406a44:	20403608 	.word	0x20403608
  406a48:	00000000 	.word	0x00000000
  406a4c:	42c60000 	.word	0x42c60000
  406a50:	20404fec 	.word	0x20404fec
  406a54:	2040362c 	.word	0x2040362c
  406a58:	0041af24 	.word	0x0041af24
  406a5c:	004199e8 	.word	0x004199e8
  406a60:	0041af34 	.word	0x0041af34
  406a64:	0041af38 	.word	0x0041af38
  406a68:	204035c0 	.word	0x204035c0
  406a6c:	0041af3c 	.word	0x0041af3c
  406a70:	204035e4 	.word	0x204035e4
  406a74:	20403768 	.word	0x20403768
  406a78:	0041af5c 	.word	0x0041af5c
  406a7c:	20403744 	.word	0x20403744
  406a80:	0041acc8 	.word	0x0041acc8
  406a84:	0041af2c 	.word	0x0041af2c
  406a88:	42480000 	.word	0x42480000
  406a8c:	0041af4c 	.word	0x0041af4c
  406a90:	43960000 	.word	0x43960000
  406a94:	204035a4 	.word	0x204035a4
  406a98:	43be0000 	.word	0x43be0000
  406a9c:	0040b0ad 	.word	0x0040b0ad

00406aa0 <menue_drive_ARD_init>:
option_val_t oval_ard_max_current;
//__________________________________________________


menue_design_t *menue_drive_ARD_init(void)
{
  406aa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	dard_ard_type.text = "ARD type";
	ard_type_Battery.text = "Battery";
  406aa4:	4e1d      	ldr	r6, [pc, #116]	; (406b1c <menue_drive_ARD_init+0x7c>)
{
  406aa6:	b082      	sub	sp, #8
	ard_type_UPS.text = "UPS";


	fill_menue_list(&menue_drive_ard_types, &opt_ard_types, OPT_ARD_TYPES_MAX, 0, &menue_drive_data_setup.m_ard_type);
  406aa8:	4c1d      	ldr	r4, [pc, #116]	; (406b20 <menue_drive_ARD_init+0x80>)
  406aaa:	2300      	movs	r3, #0
	ard_type_Battery.text = "Battery";
  406aac:	4d1d      	ldr	r5, [pc, #116]	; (406b24 <menue_drive_ARD_init+0x84>)
	fill_menue_list(&menue_drive_ard_types, &opt_ard_types, OPT_ARD_TYPES_MAX, 0, &menue_drive_data_setup.m_ard_type);
  406aae:	4631      	mov	r1, r6
	ard_type_UPS.text = "UPS";
  406ab0:	4f1d      	ldr	r7, [pc, #116]	; (406b28 <menue_drive_ARD_init+0x88>)
	fill_menue_list(&menue_drive_ard_types, &opt_ard_types, OPT_ARD_TYPES_MAX, 0, &menue_drive_data_setup.m_ard_type);
  406ab2:	2202      	movs	r2, #2
  406ab4:	9400      	str	r4, [sp, #0]
  406ab6:	f8df 8090 	ldr.w	r8, [pc, #144]	; 406b48 <menue_drive_ARD_init+0xa8>
	ard_type_Battery.text = "Battery";
  406aba:	6035      	str	r5, [r6, #0]
	ard_type_UPS.text = "UPS";
  406abc:	62b7      	str	r7, [r6, #40]	; 0x28
	fill_menue_list(&menue_drive_ard_types, &opt_ard_types, OPT_ARD_TYPES_MAX, 0, &menue_drive_data_setup.m_ard_type);
  406abe:	4640      	mov	r0, r8
	dard_ard_type.text = "ARD type";
  406ac0:	4d1a      	ldr	r5, [pc, #104]	; (406b2c <menue_drive_ARD_init+0x8c>)
  406ac2:	4e1b      	ldr	r6, [pc, #108]	; (406b30 <menue_drive_ARD_init+0x90>)
	fill_menue_list(&menue_drive_ard_types, &opt_ard_types, OPT_ARD_TYPES_MAX, 0, &menue_drive_data_setup.m_ard_type);
  406ac4:	4f1b      	ldr	r7, [pc, #108]	; (406b34 <menue_drive_ARD_init+0x94>)
	dard_ard_type.text = "ARD type";
  406ac6:	602e      	str	r6, [r5, #0]
	fill_menue_list(&menue_drive_ard_types, &opt_ard_types, OPT_ARD_TYPES_MAX, 0, &menue_drive_data_setup.m_ard_type);
  406ac8:	47b8      	blx	r7
	oval_ard_max_current.unit = "A";
	//oval_ard_max_current.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_ard_max_current.val = &menue_drive_data_setup.m_ard_current_max;
	dard_ard_max_current.option_save_val = &oval_ard_max_current;	
//__________________________________________________	
	fill_menue_list(&menue_drive_ARD, opt_ard, OPT_DRIVE_ARD_MAX, 0, 0);
  406aca:	2300      	movs	r3, #0
	oval_ard_max_current.val = &menue_drive_data_setup.m_ard_current_max;
  406acc:	1d22      	adds	r2, r4, #4
	oval_ard_max_current.data_types = float_dt;
  406ace:	4c1a      	ldr	r4, [pc, #104]	; (406b38 <menue_drive_ARD_init+0x98>)
	fill_menue_list(&menue_drive_ARD, opt_ard, OPT_DRIVE_ARD_MAX, 0, 0);
  406ad0:	9300      	str	r3, [sp, #0]
	oval_ard_max_current.real_count = 2;
  406ad2:	f04f 0e02 	mov.w	lr, #2
	oval_ard_max_current.val = &menue_drive_data_setup.m_ard_current_max;
  406ad6:	61e2      	str	r2, [r4, #28]
	fill_menue_list(&menue_drive_ARD, opt_ard, OPT_DRIVE_ARD_MAX, 0, 0);
  406ad8:	4629      	mov	r1, r5
	dard_ard_max_current.text = "ARD max current";
  406ada:	4a18      	ldr	r2, [pc, #96]	; (406b3c <menue_drive_ARD_init+0x9c>)
	oval_ard_max_current.mantissa_count = 1;
  406adc:	2001      	movs	r0, #1
	dard_ard_type.child = &menue_drive_ard_types;
  406ade:	f8c5 8020 	str.w	r8, [r5, #32]
	oval_ard_max_current.data_types = float_dt;
  406ae2:	f04f 0803 	mov.w	r8, #3
	dard_ard_max_current.option_save_val = &oval_ard_max_current;	
  406ae6:	64ec      	str	r4, [r5, #76]	; 0x4c
	dard_ard_max_current.text = "ARD max current";
  406ae8:	62aa      	str	r2, [r5, #40]	; 0x28
	oval_ard_max_current.min_value = 0.0;
  406aea:	2500      	movs	r5, #0
	fill_menue_list(&menue_drive_ARD, opt_ard, OPT_DRIVE_ARD_MAX, 0, 0);
  406aec:	4e14      	ldr	r6, [pc, #80]	; (406b40 <menue_drive_ARD_init+0xa0>)
  406aee:	4672      	mov	r2, lr
	oval_ard_max_current.max_value = 25;
  406af0:	f8df c058 	ldr.w	ip, [pc, #88]	; 406b4c <menue_drive_ARD_init+0xac>
	oval_ard_max_current.real_count = 2;
  406af4:	f8c4 e004 	str.w	lr, [r4, #4]
	oval_ard_max_current.min_value = 0.0;
  406af8:	61a5      	str	r5, [r4, #24]
	oval_ard_max_current.new_val_flag = &menue_drive_data_newdata_flag;
  406afa:	f8df e054 	ldr.w	lr, [pc, #84]	; 406b50 <menue_drive_ARD_init+0xb0>
	oval_ard_max_current.unit = "A";
  406afe:	4d11      	ldr	r5, [pc, #68]	; (406b44 <menue_drive_ARD_init+0xa4>)
	oval_ard_max_current.mantissa_count = 1;
  406b00:	60a0      	str	r0, [r4, #8]
	fill_menue_list(&menue_drive_ARD, opt_ard, OPT_DRIVE_ARD_MAX, 0, 0);
  406b02:	4630      	mov	r0, r6
	oval_ard_max_current.data_types = float_dt;
  406b04:	f884 8000 	strb.w	r8, [r4]
	oval_ard_max_current.max_value = 25;
  406b08:	f8c4 c014 	str.w	ip, [r4, #20]
	oval_ard_max_current.new_val_flag = &menue_drive_data_newdata_flag;
  406b0c:	f8c4 e020 	str.w	lr, [r4, #32]
	oval_ard_max_current.unit = "A";
  406b10:	60e5      	str	r5, [r4, #12]
	fill_menue_list(&menue_drive_ARD, opt_ard, OPT_DRIVE_ARD_MAX, 0, 0);
  406b12:	47b8      	blx	r7
	return &menue_drive_ARD;
  406b14:	4630      	mov	r0, r6
  406b16:	b002      	add	sp, #8
  406b18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  406b1c:	2040378c 	.word	0x2040378c
  406b20:	204051c0 	.word	0x204051c0
  406b24:	0041af78 	.word	0x0041af78
  406b28:	0041af80 	.word	0x0041af80
  406b2c:	204037dc 	.word	0x204037dc
  406b30:	0041af6c 	.word	0x0041af6c
  406b34:	0040b0ad 	.word	0x0040b0ad
  406b38:	20403864 	.word	0x20403864
  406b3c:	0041af84 	.word	0x0041af84
  406b40:	20403848 	.word	0x20403848
  406b44:	004199e4 	.word	0x004199e4
  406b48:	2040382c 	.word	0x2040382c
  406b4c:	41c80000 	.word	0x41c80000
  406b50:	20404fec 	.word	0x20404fec

00406b54 <menue_driver_brake_init>:
	oval_dcbreak_delay.max_value = 3000;
	oval_dcbreak_delay.min_value = 0.0;
	oval_dcbreak_delay.new_val_flag = &menue_drive_data_newdata_flag;
	oval_dcbreak_delay.unit = "ms";
	//oval_dcbreak_delay.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_dcbreak_delay.val = &menue_drive_data_setup.m_dcbreak_delay;
  406b54:	4a35      	ldr	r2, [pc, #212]	; (406c2c <menue_driver_brake_init+0xd8>)
	dmotor_dcbreak_delay.option_save_val = &oval_dcbreak_delay;
	//__________________________________________________
	dmotor_brake_release_delay.text = "Brake release delay";
	oval_brake_release_delay.data_types = uint16_dt;
  406b56:	4936      	ldr	r1, [pc, #216]	; (406c30 <menue_driver_brake_init+0xdc>)
	//oval_brake_release_delay.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_brake_release_delay.val = &menue_drive_data_setup.m_brake_release_delay;
	dmotor_brake_release_delay.option_save_val = &oval_brake_release_delay;
	//__________________________________________________
	dmotor_brake_hold_delay.text = "Brake hold delay";
	oval_brake_hold_delay.data_types = uint16_dt;
  406b58:	4836      	ldr	r0, [pc, #216]	; (406c34 <menue_driver_brake_init+0xe0>)
	oval_brake_hold_delay.max_value = 3000;
	oval_brake_hold_delay.min_value = 0.0;
	oval_brake_hold_delay.new_val_flag = &menue_drive_data_newdata_flag;
	oval_brake_hold_delay.unit = "ms";
	//oval_brake_hold_delay.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_brake_hold_delay.val = &menue_drive_data_setup.m_brake_hold_delay;
  406b5a:	f1a2 0c04 	sub.w	ip, r2, #4
{
  406b5e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	oval_dcbreak_delay.data_types = uint16_dt;
  406b62:	4e35      	ldr	r6, [pc, #212]	; (406c38 <menue_driver_brake_init+0xe4>)
  406b64:	2401      	movs	r4, #1
	dmotor_brake_hold_delay.option_save_val = &oval_brake_hold_delay;
	//__________________________________________________
	dmotor_motor_move_delay.text = "Motor move delay";
	oval_motor_move_delay.data_types = uint16_dt;
  406b66:	4d35      	ldr	r5, [pc, #212]	; (406c3c <menue_driver_brake_init+0xe8>)
	oval_brake_release_delay.val = &menue_drive_data_setup.m_brake_release_delay;
  406b68:	f1a2 0806 	sub.w	r8, r2, #6
	oval_dcbreak_delay.mantissa_count = 0;
  406b6c:	2700      	movs	r7, #0
	oval_dcbreak_delay.real_count = 4;
  406b6e:	f04f 0e04 	mov.w	lr, #4
	oval_dcbreak_delay.max_value = 3000;
  406b72:	f8df b0e8 	ldr.w	fp, [pc, #232]	; 406c5c <menue_driver_brake_init+0x108>
	oval_dcbreak_delay.min_value = 0.0;
  406b76:	f04f 0a00 	mov.w	sl, #0
	oval_brake_release_delay.val = &menue_drive_data_setup.m_brake_release_delay;
  406b7a:	f8c1 801c 	str.w	r8, [r1, #28]
{
  406b7e:	b083      	sub	sp, #12
	oval_dcbreak_delay.new_val_flag = &menue_drive_data_newdata_flag;
  406b80:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 406c60 <menue_driver_brake_init+0x10c>
	oval_motor_move_delay.max_value = 3000;
	oval_motor_move_delay.min_value = 0.0;
	oval_motor_move_delay.new_val_flag = &menue_drive_data_newdata_flag;
	oval_motor_move_delay.unit = "ms";
	//oval_motor_move_delay.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_motor_move_delay.val = &menue_drive_data_setup.m_motor_move_delay;
  406b84:	f1a2 0902 	sub.w	r9, r2, #2
	oval_brake_hold_delay.val = &menue_drive_data_setup.m_brake_hold_delay;
  406b88:	f8c0 c01c 	str.w	ip, [r0, #28]
	dmotor_motor_move_delay.option_save_val = &oval_motor_move_delay;
	//__________________________________________________	
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406b8c:	463b      	mov	r3, r7
	oval_dcbreak_delay.unit = "ms";
  406b8e:	f8df c0d4 	ldr.w	ip, [pc, #212]	; 406c64 <menue_driver_brake_init+0x110>
	oval_dcbreak_delay.data_types = uint16_dt;
  406b92:	7034      	strb	r4, [r6, #0]
	oval_brake_release_delay.data_types = uint16_dt;
  406b94:	700c      	strb	r4, [r1, #0]
	oval_brake_hold_delay.data_types = uint16_dt;
  406b96:	7004      	strb	r4, [r0, #0]
	oval_motor_move_delay.data_types = uint16_dt;
  406b98:	702c      	strb	r4, [r5, #0]
	dmotor_dcbreak_delay.text = "DC brake delay";
  406b9a:	4c29      	ldr	r4, [pc, #164]	; (406c40 <menue_driver_brake_init+0xec>)
	oval_dcbreak_delay.real_count = 4;
  406b9c:	f8c6 e004 	str.w	lr, [r6, #4]
	oval_dcbreak_delay.unit = "ms";
  406ba0:	f8c6 c00c 	str.w	ip, [r6, #12]
	oval_dcbreak_delay.val = &menue_drive_data_setup.m_dcbreak_delay;
  406ba4:	61f2      	str	r2, [r6, #28]
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406ba6:	4672      	mov	r2, lr
	oval_dcbreak_delay.mantissa_count = 0;
  406ba8:	60b7      	str	r7, [r6, #8]
	oval_dcbreak_delay.max_value = 3000;
  406baa:	f8c6 b014 	str.w	fp, [r6, #20]
	oval_dcbreak_delay.min_value = 0.0;
  406bae:	f8c6 a018 	str.w	sl, [r6, #24]
	oval_dcbreak_delay.new_val_flag = &menue_drive_data_newdata_flag;
  406bb2:	f8c6 8020 	str.w	r8, [r6, #32]
	dmotor_dcbreak_delay.option_save_val = &oval_dcbreak_delay;
  406bb6:	6266      	str	r6, [r4, #36]	; 0x24
	dmotor_dcbreak_delay.text = "DC brake delay";
  406bb8:	4e22      	ldr	r6, [pc, #136]	; (406c44 <menue_driver_brake_init+0xf0>)
	oval_brake_hold_delay.real_count = 4;
  406bba:	f8c0 e004 	str.w	lr, [r0, #4]
	oval_brake_hold_delay.unit = "ms";
  406bbe:	f8c0 c00c 	str.w	ip, [r0, #12]
	oval_brake_hold_delay.mantissa_count = 0;
  406bc2:	6087      	str	r7, [r0, #8]
	oval_brake_hold_delay.max_value = 3000;
  406bc4:	f8c0 b014 	str.w	fp, [r0, #20]
	oval_brake_hold_delay.min_value = 0.0;
  406bc8:	f8c0 a018 	str.w	sl, [r0, #24]
	oval_brake_hold_delay.new_val_flag = &menue_drive_data_newdata_flag;
  406bcc:	f8c0 8020 	str.w	r8, [r0, #32]
	dmotor_brake_hold_delay.option_save_val = &oval_brake_hold_delay;
  406bd0:	6760      	str	r0, [r4, #116]	; 0x74
	dmotor_dcbreak_delay.text = "DC brake delay";
  406bd2:	6026      	str	r6, [r4, #0]
	dmotor_brake_release_delay.text = "Brake release delay";
  406bd4:	481c      	ldr	r0, [pc, #112]	; (406c48 <menue_driver_brake_init+0xf4>)
	dmotor_brake_hold_delay.text = "Brake hold delay";
  406bd6:	4e1d      	ldr	r6, [pc, #116]	; (406c4c <menue_driver_brake_init+0xf8>)
	dmotor_brake_release_delay.text = "Brake release delay";
  406bd8:	62a0      	str	r0, [r4, #40]	; 0x28
	dmotor_brake_hold_delay.text = "Brake hold delay";
  406bda:	6526      	str	r6, [r4, #80]	; 0x50
	dmotor_motor_move_delay.text = "Motor move delay";
  406bdc:	481c      	ldr	r0, [pc, #112]	; (406c50 <menue_driver_brake_init+0xfc>)
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406bde:	4e1d      	ldr	r6, [pc, #116]	; (406c54 <menue_driver_brake_init+0x100>)
	oval_brake_release_delay.real_count = 4;
  406be0:	f8c1 e004 	str.w	lr, [r1, #4]
	oval_brake_release_delay.unit = "ms";
  406be4:	f8c1 c00c 	str.w	ip, [r1, #12]
	oval_brake_release_delay.mantissa_count = 0;
  406be8:	608f      	str	r7, [r1, #8]
	oval_brake_release_delay.max_value = 3000;
  406bea:	f8c1 b014 	str.w	fp, [r1, #20]
	oval_brake_release_delay.min_value = 0.0;
  406bee:	f8c1 a018 	str.w	sl, [r1, #24]
	oval_brake_release_delay.new_val_flag = &menue_drive_data_newdata_flag;
  406bf2:	f8c1 8020 	str.w	r8, [r1, #32]
	dmotor_brake_release_delay.option_save_val = &oval_brake_release_delay;
  406bf6:	64e1      	str	r1, [r4, #76]	; 0x4c
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406bf8:	4621      	mov	r1, r4
	dmotor_motor_move_delay.text = "Motor move delay";
  406bfa:	67a0      	str	r0, [r4, #120]	; 0x78
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406bfc:	4630      	mov	r0, r6
  406bfe:	9700      	str	r7, [sp, #0]
	oval_motor_move_delay.mantissa_count = 0;
  406c00:	60af      	str	r7, [r5, #8]
	dmotor_motor_move_delay.option_save_val = &oval_motor_move_delay;
  406c02:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406c06:	4f14      	ldr	r7, [pc, #80]	; (406c58 <menue_driver_brake_init+0x104>)
	oval_motor_move_delay.val = &menue_drive_data_setup.m_motor_move_delay;
  406c08:	f8c5 901c 	str.w	r9, [r5, #28]
	oval_motor_move_delay.real_count = 4;
  406c0c:	f8c5 e004 	str.w	lr, [r5, #4]
	oval_motor_move_delay.max_value = 3000;
  406c10:	f8c5 b014 	str.w	fp, [r5, #20]
	oval_motor_move_delay.min_value = 0.0;
  406c14:	f8c5 a018 	str.w	sl, [r5, #24]
	oval_motor_move_delay.new_val_flag = &menue_drive_data_newdata_flag;
  406c18:	f8c5 8020 	str.w	r8, [r5, #32]
	oval_motor_move_delay.unit = "ms";
  406c1c:	f8c5 c00c 	str.w	ip, [r5, #12]
	fill_menue_list(&menue_driver_brake, opt_driver_brake, OPT_DRIVER_BRAKE_MAX, 0, 0);
  406c20:	47b8      	blx	r7
	return &menue_driver_brake;
  406c22:	4630      	mov	r0, r6
  406c24:	b003      	add	sp, #12
  406c26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406c2a:	bf00      	nop
  406c2c:	204051b4 	.word	0x204051b4
  406c30:	20403968 	.word	0x20403968
  406c34:	204039b0 	.word	0x204039b0
  406c38:	20403944 	.word	0x20403944
  406c3c:	2040398c 	.word	0x2040398c
  406c40:	204038a4 	.word	0x204038a4
  406c44:	0041af94 	.word	0x0041af94
  406c48:	0041afa4 	.word	0x0041afa4
  406c4c:	0041afb8 	.word	0x0041afb8
  406c50:	0041afcc 	.word	0x0041afcc
  406c54:	20403888 	.word	0x20403888
  406c58:	0040b0ad 	.word	0x0040b0ad
  406c5c:	453b8000 	.word	0x453b8000
  406c60:	20404fec 	.word	0x20404fec
  406c64:	0041a998 	.word	0x0041a998

00406c68 <display_faults_enter>:
#define faults_clear			(opt_faults[1])

fault_history_t *current_fualt_id;
uint8_t fault_ptr, fault_index;
void display_faults_enter(void)
{
  406c68:	b508      	push	{r3, lr}
	current_fualt_id = get_first_fault(&fault_ptr, &fault_index);
  406c6a:	4903      	ldr	r1, [pc, #12]	; (406c78 <display_faults_enter+0x10>)
  406c6c:	4b03      	ldr	r3, [pc, #12]	; (406c7c <display_faults_enter+0x14>)
  406c6e:	4804      	ldr	r0, [pc, #16]	; (406c80 <display_faults_enter+0x18>)
  406c70:	4798      	blx	r3
  406c72:	4b04      	ldr	r3, [pc, #16]	; (406c84 <display_faults_enter+0x1c>)
  406c74:	6018      	str	r0, [r3, #0]
  406c76:	bd08      	pop	{r3, pc}
  406c78:	20403a41 	.word	0x20403a41
  406c7c:	00412c1d 	.word	0x00412c1d
  406c80:	20403a40 	.word	0x20403a40
  406c84:	20403a44 	.word	0x20403a44

00406c88 <display_faults>:
char display_faults(char enter, char esc, char up, char down, char left, char right)
{
	uint32_t hour, PM;
	fixedpt tmp;
	
	if (esc || enter)
  406c88:	2900      	cmp	r1, #0
  406c8a:	f040 81be 	bne.w	40700a <display_faults+0x382>
  406c8e:	2800      	cmp	r0, #0
  406c90:	f040 81bb 	bne.w	40700a <display_faults+0x382>
{
  406c94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406c98:	b089      	sub	sp, #36	; 0x24
	{
		return 0;
	}
	else if(up)
  406c9a:	2a00      	cmp	r2, #0
  406c9c:	f040 81c3 	bne.w	407026 <display_faults+0x39e>
	{
		current_fualt_id = get_next_fault(&fault_ptr, &fault_index);	
	}
	else if (down)
  406ca0:	2b00      	cmp	r3, #0
  406ca2:	f040 81dd 	bne.w	407060 <display_faults+0x3d8>
  406ca6:	f8df a264 	ldr.w	sl, [pc, #612]	; 406f0c <display_faults+0x284>
  406caa:	f8da 4000 	ldr.w	r4, [sl]
	{
		current_fualt_id = get_previous_fault(&fault_ptr, &fault_index);
	}
	
	
	if (current_fualt_id)
  406cae:	2c00      	cmp	r4, #0
  406cb0:	f000 81e0 	beq.w	407074 <display_faults+0x3ec>
	{
		glcd_gotoxy(60, 3);
  406cb4:	2103      	movs	r1, #3
  406cb6:	4b88      	ldr	r3, [pc, #544]	; (406ed8 <display_faults+0x250>)
  406cb8:	203c      	movs	r0, #60	; 0x3c
  406cba:	4798      	blx	r3
		if (fault_index > 0)
  406cbc:	4b87      	ldr	r3, [pc, #540]	; (406edc <display_faults+0x254>)
  406cbe:	7819      	ldrb	r1, [r3, #0]
  406cc0:	2900      	cmp	r1, #0
  406cc2:	f000 81a4 	beq.w	40700e <display_faults+0x386>
		{
			write_r_text(itos(fault_index), 0);
  406cc6:	4b86      	ldr	r3, [pc, #536]	; (406ee0 <display_faults+0x258>)
  406cc8:	4608      	mov	r0, r1
  406cca:	2100      	movs	r1, #0
  406ccc:	f8df b240 	ldr.w	fp, [pc, #576]	; 406f10 <display_faults+0x288>
  406cd0:	9301      	str	r3, [sp, #4]
  406cd2:	4798      	blx	r3
  406cd4:	2100      	movs	r1, #0
  406cd6:	47d8      	blx	fp
		} 
		else
		{
			write_r_text(" (Last)", 0);	
		}
		glcd_gotoxy(1, 18);
  406cd8:	2112      	movs	r1, #18
  406cda:	2001      	movs	r0, #1
  406cdc:	4b7e      	ldr	r3, [pc, #504]	; (406ed8 <display_faults+0x250>)
  406cde:	4798      	blx	r3
		write_r_text(sph_faults_get_fault_string(fault_ptr), 0);
  406ce0:	4a80      	ldr	r2, [pc, #512]	; (406ee4 <display_faults+0x25c>)
  406ce2:	4b81      	ldr	r3, [pc, #516]	; (406ee8 <display_faults+0x260>)
  406ce4:	7810      	ldrb	r0, [r2, #0]
  406ce6:	4798      	blx	r3
  406ce8:	2100      	movs	r1, #0
  406cea:	47d8      	blx	fp
		glcd_gotoxy(1, 26);
  406cec:	4b7a      	ldr	r3, [pc, #488]	; (406ed8 <display_faults+0x250>)
  406cee:	211a      	movs	r1, #26
  406cf0:	2001      	movs	r0, #1
  406cf2:	4798      	blx	r3
		write_r_text("N ", 0);
  406cf4:	2100      	movs	r1, #0
  406cf6:	487d      	ldr	r0, [pc, #500]	; (406eec <display_faults+0x264>)
  406cf8:	47d8      	blx	fp
		glcd_puts(itos(current_fualt_id->occurance_count), 0);
  406cfa:	f8da 3000 	ldr.w	r3, [sl]
  406cfe:	2100      	movs	r1, #0
  406d00:	8918      	ldrh	r0, [r3, #8]
  406d02:	9b01      	ldr	r3, [sp, #4]
  406d04:	4798      	blx	r3
  406d06:	4b7a      	ldr	r3, [pc, #488]	; (406ef0 <display_faults+0x268>)
  406d08:	2100      	movs	r1, #0
  406d0a:	4798      	blx	r3
		
		write_r_text(" / F", 0);
  406d0c:	4879      	ldr	r0, [pc, #484]	; (406ef4 <display_faults+0x26c>)
  406d0e:	2100      	movs	r1, #0
  406d10:	47d8      	blx	fp
		if(current_fualt_id->floor & 0x80) write_r_text(" =", 0);
  406d12:	f8da 3000 	ldr.w	r3, [sl]
  406d16:	7ad8      	ldrb	r0, [r3, #11]
  406d18:	0603      	lsls	r3, r0, #24
  406d1a:	f100 81bd 	bmi.w	407098 <display_faults+0x410>
		glcd_puts(itos(current_fualt_id->floor & 0x7F), 0);
  406d1e:	2100      	movs	r1, #0
  406d20:	9c01      	ldr	r4, [sp, #4]
  406d22:	f000 007f 	and.w	r0, r0, #127	; 0x7f
	char tmp[12] = {0};
  406d26:	af05      	add	r7, sp, #20
  406d28:	47a0      	blx	r4
  406d2a:	4b71      	ldr	r3, [pc, #452]	; (406ef0 <display_faults+0x268>)
  406d2c:	2100      	movs	r1, #0
  406d2e:	4798      	blx	r3
		
		write_r_text(" / E", 0);
  406d30:	2100      	movs	r1, #0
  406d32:	4871      	ldr	r0, [pc, #452]	; (406ef8 <display_faults+0x270>)
  406d34:	47d8      	blx	fp
		glcd_puts(itos(current_fualt_id->states), 0);
  406d36:	f8da 3000 	ldr.w	r3, [sl]
  406d3a:	2100      	movs	r1, #0
  406d3c:	7a98      	ldrb	r0, [r3, #10]
  406d3e:	47a0      	blx	r4
  406d40:	2100      	movs	r1, #0
  406d42:	4b6b      	ldr	r3, [pc, #428]	; (406ef0 <display_faults+0x268>)
  406d44:	4798      	blx	r3
		
		glcd_gotoxy(1, 26 + 9);
  406d46:	2123      	movs	r1, #35	; 0x23
  406d48:	2001      	movs	r0, #1
  406d4a:	4b63      	ldr	r3, [pc, #396]	; (406ed8 <display_faults+0x250>)
  406d4c:	4798      	blx	r3
		tmp = (current_fualt_id->id * FIXEDPT_ONE);
  406d4e:	f8da 3000 	ldr.w	r3, [sl]
		write_r_text("Id ", 0);
  406d52:	2100      	movs	r1, #0
  406d54:	4869      	ldr	r0, [pc, #420]	; (406efc <display_faults+0x274>)
		tmp = (current_fualt_id->id * FIXEDPT_ONE);
  406d56:	edd3 7a03 	vldr	s15, [r3, #12]
  406d5a:	eeb0 7a67 	vmov.f32	s14, s15
  406d5e:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
  406d62:	ed8d 7a02 	vstr	s14, [sp, #8]
		write_r_text("Id ", 0);
  406d66:	47d8      	blx	fp
  406d68:	2300      	movs	r3, #0
	if (A < 0) {
  406d6a:	9a02      	ldr	r2, [sp, #8]
  406d6c:	429a      	cmp	r2, r3
	char tmp[12] = {0};
  406d6e:	607b      	str	r3, [r7, #4]
  406d70:	9305      	str	r3, [sp, #20]
  406d72:	60bb      	str	r3, [r7, #8]
	if (A < 0) {
  406d74:	f2c0 8169 	blt.w	40704a <display_faults+0x3c2>
	int ndec = 0, slen = 0;
  406d78:	9303      	str	r3, [sp, #12]
  406d7a:	4b61      	ldr	r3, [pc, #388]	; (406f00 <display_faults+0x278>)
  406d7c:	9300      	str	r3, [sp, #0]
	ip = fixedpt_toint(A);
  406d7e:	9b02      	ldr	r3, [sp, #8]
  406d80:	46b9      	mov	r9, r7
	int ndec = 0, slen = 0;
  406d82:	f04f 0800 	mov.w	r8, #0
  406d86:	4e5f      	ldr	r6, [pc, #380]	; (406f04 <display_faults+0x27c>)
	ip = fixedpt_toint(A);
  406d88:	13dc      	asrs	r4, r3, #15
  406d8a:	17e5      	asrs	r5, r4, #31
  406d8c:	e000      	b.n	406d90 <display_faults+0x108>
		tmp[ndec++] = '0' + ip % 10;
  406d8e:	4698      	mov	r8, r3
  406d90:	4620      	mov	r0, r4
  406d92:	4629      	mov	r1, r5
  406d94:	220a      	movs	r2, #10
  406d96:	2300      	movs	r3, #0
  406d98:	47b0      	blx	r6
  406d9a:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  406d9e:	4620      	mov	r0, r4
  406da0:	4629      	mov	r1, r5
  406da2:	220a      	movs	r2, #10
  406da4:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  406da6:	f809 eb01 	strb.w	lr, [r9], #1
		ip /= 10;
  406daa:	47b0      	blx	r6
  406dac:	4604      	mov	r4, r0
  406dae:	460d      	mov	r5, r1
		tmp[ndec++] = '0' + ip % 10;
  406db0:	f108 0301 	add.w	r3, r8, #1
	} while (ip != 0);
  406db4:	ea54 0205 	orrs.w	r2, r4, r5
  406db8:	d1e9      	bne.n	406d8e <display_faults+0x106>
  406dba:	9a03      	ldr	r2, [sp, #12]
  406dbc:	443b      	add	r3, r7
  406dbe:	9900      	ldr	r1, [sp, #0]
  406dc0:	3a01      	subs	r2, #1
  406dc2:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  406dc4:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  406dc8:	429f      	cmp	r7, r3
		str[slen++] = tmp[--ndec];
  406dca:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  406dce:	d1f9      	bne.n	406dc4 <display_faults+0x13c>
  406dd0:	9903      	ldr	r1, [sp, #12]
	str[slen++] = '.';
  406dd2:	202e      	movs	r0, #46	; 0x2e
  406dd4:	9c00      	ldr	r4, [sp, #0]
  406dd6:	eb08 0501 	add.w	r5, r8, r1
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  406dda:	9b02      	ldr	r3, [sp, #8]
	str[slen++] = '.';
  406ddc:	44a0      	add	r8, r4
  406dde:	3101      	adds	r1, #1
  406de0:	f105 0e01 	add.w	lr, r5, #1
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  406de4:	045a      	lsls	r2, r3, #17
	str[slen++] = '.';
  406de6:	3502      	adds	r5, #2
  406de8:	f808 0001 	strb.w	r0, [r8, r1]
  406dec:	44a6      	add	lr, r4
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  406dee:	2400      	movs	r4, #0
  406df0:	e001      	b.n	406df6 <display_faults+0x16e>
	} while (fr != 0 && ndec < max_dec);
  406df2:	2c01      	cmp	r4, #1
  406df4:	dc12      	bgt.n	406e1c <display_faults+0x194>
		fr = (fr & mask) * 10;
  406df6:	2300      	movs	r3, #0
  406df8:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  406dfa:	3501      	adds	r5, #1
		ndec++;
  406dfc:	3401      	adds	r4, #1
		fr = (fr & mask) * 10;
  406dfe:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  406e02:	ea4c 7192 	orr.w	r1, ip, r2, lsr #30
  406e06:	1812      	adds	r2, r2, r0
  406e08:	414b      	adcs	r3, r1
  406e0a:	1892      	adds	r2, r2, r2
  406e0c:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  406e0e:	f103 0130 	add.w	r1, r3, #48	; 0x30
  406e12:	f80e 1f01 	strb.w	r1, [lr, #1]!
	} while (fr != 0 && ndec < max_dec);
  406e16:	ea52 0103 	orrs.w	r1, r2, r3
  406e1a:	d1ea      	bne.n	406df2 <display_faults+0x16a>
	if (ndec > 1 && str[slen-1] == '0')
  406e1c:	2c02      	cmp	r4, #2
  406e1e:	d105      	bne.n	406e2c <display_faults+0x1a4>
  406e20:	1e6b      	subs	r3, r5, #1
  406e22:	9a00      	ldr	r2, [sp, #0]
  406e24:	5cd2      	ldrb	r2, [r2, r3]
  406e26:	2a30      	cmp	r2, #48	; 0x30
  406e28:	f000 8132 	beq.w	407090 <display_faults+0x408>
		str[slen] = '\0';
  406e2c:	2300      	movs	r3, #0
  406e2e:	9a00      	ldr	r2, [sp, #0]
  406e30:	5553      	strb	r3, [r2, r5]
		glcd_puts(fixedpt_cstr(tmp, 2),0);
  406e32:	2100      	movs	r1, #0
  406e34:	4832      	ldr	r0, [pc, #200]	; (406f00 <display_faults+0x278>)
  406e36:	4b2e      	ldr	r3, [pc, #184]	; (406ef0 <display_faults+0x268>)
  406e38:	4798      	blx	r3
		tmp = (current_fualt_id->iq * FIXEDPT_ONE);
  406e3a:	f8da 3000 	ldr.w	r3, [sl]
		write_r_text(" Iq ", 0);
  406e3e:	2100      	movs	r1, #0
  406e40:	4831      	ldr	r0, [pc, #196]	; (406f08 <display_faults+0x280>)
		tmp = (current_fualt_id->iq * FIXEDPT_ONE);
  406e42:	edd3 7a04 	vldr	s15, [r3, #16]
  406e46:	eeb0 7a67 	vmov.f32	s14, s15
  406e4a:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
  406e4e:	ed8d 7a02 	vstr	s14, [sp, #8]
		write_r_text(" Iq ", 0);
  406e52:	47d8      	blx	fp
	char tmp[12] = {0};
  406e54:	2300      	movs	r3, #0
	if (A < 0) {
  406e56:	9a02      	ldr	r2, [sp, #8]
  406e58:	429a      	cmp	r2, r3
	char tmp[12] = {0};
  406e5a:	9305      	str	r3, [sp, #20]
  406e5c:	607b      	str	r3, [r7, #4]
  406e5e:	60bb      	str	r3, [r7, #8]
	if (A < 0) {
  406e60:	f2c0 80eb 	blt.w	40703a <display_faults+0x3b2>
	int ndec = 0, slen = 0;
  406e64:	469b      	mov	fp, r3
	ip = fixedpt_toint(A);
  406e66:	9b02      	ldr	r3, [sp, #8]
  406e68:	46b9      	mov	r9, r7
	int ndec = 0, slen = 0;
  406e6a:	f04f 0800 	mov.w	r8, #0
	ip = fixedpt_toint(A);
  406e6e:	13dc      	asrs	r4, r3, #15
  406e70:	17e5      	asrs	r5, r4, #31
  406e72:	e000      	b.n	406e76 <display_faults+0x1ee>
		tmp[ndec++] = '0' + ip % 10;
  406e74:	4698      	mov	r8, r3
  406e76:	4620      	mov	r0, r4
  406e78:	4629      	mov	r1, r5
  406e7a:	220a      	movs	r2, #10
  406e7c:	2300      	movs	r3, #0
  406e7e:	47b0      	blx	r6
  406e80:	f102 0e30 	add.w	lr, r2, #48	; 0x30
		ip /= 10;
  406e84:	4620      	mov	r0, r4
  406e86:	4629      	mov	r1, r5
  406e88:	220a      	movs	r2, #10
  406e8a:	2300      	movs	r3, #0
		tmp[ndec++] = '0' + ip % 10;
  406e8c:	f809 eb01 	strb.w	lr, [r9], #1
		ip /= 10;
  406e90:	47b0      	blx	r6
  406e92:	4604      	mov	r4, r0
  406e94:	460d      	mov	r5, r1
		tmp[ndec++] = '0' + ip % 10;
  406e96:	f108 0301 	add.w	r3, r8, #1
	} while (ip != 0);
  406e9a:	ea54 0205 	orrs.w	r2, r4, r5
  406e9e:	d1e9      	bne.n	406e74 <display_faults+0x1ec>
  406ea0:	f10b 32ff 	add.w	r2, fp, #4294967295
  406ea4:	9900      	ldr	r1, [sp, #0]
  406ea6:	443b      	add	r3, r7
  406ea8:	440a      	add	r2, r1
		str[slen++] = tmp[--ndec];
  406eaa:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
	while (ndec > 0)
  406eae:	429f      	cmp	r7, r3
		str[slen++] = tmp[--ndec];
  406eb0:	f802 1f01 	strb.w	r1, [r2, #1]!
	while (ndec > 0)
  406eb4:	d1f9      	bne.n	406eaa <display_faults+0x222>
  406eb6:	eb08 040b 	add.w	r4, r8, fp
	str[slen++] = '.';
  406eba:	9800      	ldr	r0, [sp, #0]
  406ebc:	f10b 0b01 	add.w	fp, fp, #1
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  406ec0:	9b02      	ldr	r3, [sp, #8]
  406ec2:	1c65      	adds	r5, r4, #1
	str[slen++] = '.';
  406ec4:	212e      	movs	r1, #46	; 0x2e
  406ec6:	4483      	add	fp, r0
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  406ec8:	045a      	lsls	r2, r3, #17
	str[slen++] = '.';
  406eca:	3402      	adds	r4, #2
  406ecc:	4405      	add	r5, r0
  406ece:	f80b 1008 	strb.w	r1, [fp, r8]
	fr = (fixedpt_fracpart(A) << FIXEDPT_WBITS) & mask;
  406ed2:	2600      	movs	r6, #0
  406ed4:	e020      	b.n	406f18 <display_faults+0x290>
  406ed6:	bf00      	nop
  406ed8:	0040c7a5 	.word	0x0040c7a5
  406edc:	20403a41 	.word	0x20403a41
  406ee0:	0040c205 	.word	0x0040c205
  406ee4:	20403a40 	.word	0x20403a40
  406ee8:	0041298d 	.word	0x0041298d
  406eec:	0041afe8 	.word	0x0041afe8
  406ef0:	0040ca05 	.word	0x0040ca05
  406ef4:	0041afec 	.word	0x0041afec
  406ef8:	0041aff8 	.word	0x0041aff8
  406efc:	004199c4 	.word	0x004199c4
  406f00:	20400898 	.word	0x20400898
  406f04:	004190fd 	.word	0x004190fd
  406f08:	0041b000 	.word	0x0041b000
  406f0c:	20403a44 	.word	0x20403a44
  406f10:	0040cf51 	.word	0x0040cf51
	} while (fr != 0 && ndec < max_dec);
  406f14:	2e01      	cmp	r6, #1
  406f16:	dc11      	bgt.n	406f3c <display_faults+0x2b4>
		fr = (fr & mask) * 10;
  406f18:	2300      	movs	r3, #0
  406f1a:	0090      	lsls	r0, r2, #2
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  406f1c:	3401      	adds	r4, #1
		ndec++;
  406f1e:	3601      	adds	r6, #1
		fr = (fr & mask) * 10;
  406f20:	009f      	lsls	r7, r3, #2
  406f22:	ea47 7192 	orr.w	r1, r7, r2, lsr #30
  406f26:	1812      	adds	r2, r2, r0
  406f28:	414b      	adcs	r3, r1
  406f2a:	1892      	adds	r2, r2, r2
  406f2c:	415b      	adcs	r3, r3
		str[slen++] = '0' + (fr >> FIXEDPT_BITS) % 10;
  406f2e:	f103 0130 	add.w	r1, r3, #48	; 0x30
  406f32:	f805 1f01 	strb.w	r1, [r5, #1]!
	} while (fr != 0 && ndec < max_dec);
  406f36:	ea52 0103 	orrs.w	r1, r2, r3
  406f3a:	d1eb      	bne.n	406f14 <display_faults+0x28c>
	if (ndec > 1 && str[slen-1] == '0')
  406f3c:	2e02      	cmp	r6, #2
  406f3e:	d105      	bne.n	406f4c <display_faults+0x2c4>
  406f40:	1e63      	subs	r3, r4, #1
  406f42:	9a00      	ldr	r2, [sp, #0]
  406f44:	5cd2      	ldrb	r2, [r2, r3]
  406f46:	2a30      	cmp	r2, #48	; 0x30
  406f48:	f000 809e 	beq.w	407088 <display_faults+0x400>
		str[slen] = '\0';
  406f4c:	2300      	movs	r3, #0
  406f4e:	9a00      	ldr	r2, [sp, #0]
  406f50:	5513      	strb	r3, [r2, r4]
		glcd_puts(fixedpt_cstr(tmp, 2),0);
  406f52:	2100      	movs	r1, #0
  406f54:	4855      	ldr	r0, [pc, #340]	; (4070ac <display_faults+0x424>)
  406f56:	4b56      	ldr	r3, [pc, #344]	; (4070b0 <display_faults+0x428>)
  406f58:	4798      	blx	r3
		
		glcd_gotoxy(1, 36 + 9);
  406f5a:	212d      	movs	r1, #45	; 0x2d
  406f5c:	2001      	movs	r0, #1
  406f5e:	4b55      	ldr	r3, [pc, #340]	; (4070b4 <display_faults+0x42c>)
  406f60:	4798      	blx	r3
		glcd_puts(itos(current_fualt_id->f_year + 2012), 0);
  406f62:	f8da 3000 	ldr.w	r3, [sl]
  406f66:	9c01      	ldr	r4, [sp, #4]
  406f68:	7998      	ldrb	r0, [r3, #6]
		glcd_putsf("/", 0);
  406f6a:	4e53      	ldr	r6, [pc, #332]	; (4070b8 <display_faults+0x430>)
		glcd_puts(itos(current_fualt_id->f_year + 2012), 0);
  406f6c:	f200 70dc 	addw	r0, r0, #2012	; 0x7dc
  406f70:	17c1      	asrs	r1, r0, #31
  406f72:	47a0      	blx	r4
  406f74:	4b4e      	ldr	r3, [pc, #312]	; (4070b0 <display_faults+0x428>)
  406f76:	2100      	movs	r1, #0
  406f78:	4798      	blx	r3
		glcd_putsf("/", 0);
  406f7a:	2100      	movs	r1, #0
  406f7c:	484f      	ldr	r0, [pc, #316]	; (4070bc <display_faults+0x434>)
  406f7e:	47b0      	blx	r6
		glcd_puts(itos(current_fualt_id->f_month), 0);
  406f80:	f8da 3000 	ldr.w	r3, [sl]
  406f84:	2100      	movs	r1, #0
  406f86:	7958      	ldrb	r0, [r3, #5]
  406f88:	47a0      	blx	r4
  406f8a:	4b49      	ldr	r3, [pc, #292]	; (4070b0 <display_faults+0x428>)
  406f8c:	2100      	movs	r1, #0
  406f8e:	4798      	blx	r3
		glcd_putsf("/", 0);
  406f90:	2100      	movs	r1, #0
  406f92:	484a      	ldr	r0, [pc, #296]	; (4070bc <display_faults+0x434>)
  406f94:	47b0      	blx	r6
		glcd_puts(itos(current_fualt_id->f_day), 0);
  406f96:	f8da 3000 	ldr.w	r3, [sl]
  406f9a:	2100      	movs	r1, #0
  406f9c:	7918      	ldrb	r0, [r3, #4]
  406f9e:	47a0      	blx	r4
  406fa0:	4b43      	ldr	r3, [pc, #268]	; (4070b0 <display_faults+0x428>)
  406fa2:	2100      	movs	r1, #0
		glcd_putsf("  ", 0);
		glcd_putsf(rtc_get_week(current_fualt_id->f_year + 2012, current_fualt_id->f_month, current_fualt_id->f_day), 0);
  406fa4:	4c46      	ldr	r4, [pc, #280]	; (4070c0 <display_faults+0x438>)
		glcd_puts(itos(current_fualt_id->f_day), 0);
  406fa6:	4798      	blx	r3
		glcd_putsf("  ", 0);
  406fa8:	2100      	movs	r1, #0
  406faa:	4846      	ldr	r0, [pc, #280]	; (4070c4 <display_faults+0x43c>)
  406fac:	47b0      	blx	r6
		glcd_putsf(rtc_get_week(current_fualt_id->f_year + 2012, current_fualt_id->f_month, current_fualt_id->f_day), 0);
  406fae:	f8da 3000 	ldr.w	r3, [sl]
  406fb2:	7998      	ldrb	r0, [r3, #6]
  406fb4:	7959      	ldrb	r1, [r3, #5]
  406fb6:	791a      	ldrb	r2, [r3, #4]
  406fb8:	f200 70dc 	addw	r0, r0, #2012	; 0x7dc
  406fbc:	47a0      	blx	r4
  406fbe:	2100      	movs	r1, #0
  406fc0:	47b0      	blx	r6
		
		hour = current_fualt_id->f_hour;
  406fc2:	f8da 3000 	ldr.w	r3, [sl]
  406fc6:	78dc      	ldrb	r4, [r3, #3]
		if (hour > 12)
  406fc8:	2c0c      	cmp	r4, #12
  406fca:	d927      	bls.n	40701c <display_faults+0x394>
		{
			PM = 1;
			hour -= 12;
  406fcc:	3c0c      	subs	r4, #12
  406fce:	2500      	movs	r5, #0
		}
		if (hour == 0) hour = 12;
		glcd_gotoxy(1, 45 + 9);
  406fd0:	4b38      	ldr	r3, [pc, #224]	; (4070b4 <display_faults+0x42c>)
  406fd2:	2136      	movs	r1, #54	; 0x36
  406fd4:	2001      	movs	r0, #1
  406fd6:	4798      	blx	r3
		glcd_puts(itos(hour), 0);
  406fd8:	4620      	mov	r0, r4
  406fda:	4629      	mov	r1, r5
  406fdc:	9c01      	ldr	r4, [sp, #4]
  406fde:	47a0      	blx	r4
  406fe0:	4b33      	ldr	r3, [pc, #204]	; (4070b0 <display_faults+0x428>)
  406fe2:	2100      	movs	r1, #0
  406fe4:	4798      	blx	r3
		glcd_putsf(":", 0);
  406fe6:	2100      	movs	r1, #0
  406fe8:	4837      	ldr	r0, [pc, #220]	; (4070c8 <display_faults+0x440>)
  406fea:	47b0      	blx	r6
		glcd_puts(itos(current_fualt_id->f_minute), 0);
  406fec:	f8da 3000 	ldr.w	r3, [sl]
  406ff0:	2100      	movs	r1, #0
  406ff2:	7898      	ldrb	r0, [r3, #2]
  406ff4:	47a0      	blx	r4
  406ff6:	2100      	movs	r1, #0
  406ff8:	4b2d      	ldr	r3, [pc, #180]	; (4070b0 <display_faults+0x428>)
  406ffa:	4798      	blx	r3
		
		if (PM) glcd_putsf(" PM ", 0);
  406ffc:	4833      	ldr	r0, [pc, #204]	; (4070cc <display_faults+0x444>)
  406ffe:	2100      	movs	r1, #0
  407000:	47b0      	blx	r6
  407002:	2001      	movs	r0, #1
	{
		glcd_gotoxy(1, 26);
		write_r_text("No fault to view", 0);
	}
	return 1;
}
  407004:	b009      	add	sp, #36	; 0x24
  407006:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return 0;
  40700a:	2000      	movs	r0, #0
  40700c:	4770      	bx	lr
  40700e:	4b30      	ldr	r3, [pc, #192]	; (4070d0 <display_faults+0x448>)
			write_r_text(" (Last)", 0);	
  407010:	4830      	ldr	r0, [pc, #192]	; (4070d4 <display_faults+0x44c>)
  407012:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 4070ec <display_faults+0x464>
  407016:	9301      	str	r3, [sp, #4]
  407018:	47d8      	blx	fp
  40701a:	e65d      	b.n	406cd8 <display_faults+0x50>
		if (hour == 0) hour = 12;
  40701c:	2c00      	cmp	r4, #0
  40701e:	d142      	bne.n	4070a6 <display_faults+0x41e>
  407020:	240c      	movs	r4, #12
  407022:	2500      	movs	r5, #0
  407024:	e7d4      	b.n	406fd0 <display_faults+0x348>
		current_fualt_id = get_next_fault(&fault_ptr, &fault_index);	
  407026:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 4070f4 <display_faults+0x46c>
  40702a:	492b      	ldr	r1, [pc, #172]	; (4070d8 <display_faults+0x450>)
  40702c:	482b      	ldr	r0, [pc, #172]	; (4070dc <display_faults+0x454>)
  40702e:	4b2c      	ldr	r3, [pc, #176]	; (4070e0 <display_faults+0x458>)
  407030:	4798      	blx	r3
  407032:	4604      	mov	r4, r0
  407034:	f8ca 0000 	str.w	r0, [sl]
  407038:	e639      	b.n	406cae <display_faults+0x26>
		A *= -1;
  40703a:	4252      	negs	r2, r2
		str[slen++] = '-';
  40703c:	232d      	movs	r3, #45	; 0x2d
  40703e:	f04f 0b01 	mov.w	fp, #1
		A *= -1;
  407042:	9202      	str	r2, [sp, #8]
		str[slen++] = '-';
  407044:	9a00      	ldr	r2, [sp, #0]
  407046:	7013      	strb	r3, [r2, #0]
  407048:	e70d      	b.n	406e66 <display_faults+0x1de>
		A *= -1;
  40704a:	9902      	ldr	r1, [sp, #8]
		str[slen++] = '-';
  40704c:	4b17      	ldr	r3, [pc, #92]	; (4070ac <display_faults+0x424>)
		A *= -1;
  40704e:	4249      	negs	r1, r1
		str[slen++] = '-';
  407050:	461a      	mov	r2, r3
  407052:	9300      	str	r3, [sp, #0]
		A *= -1;
  407054:	9102      	str	r1, [sp, #8]
		str[slen++] = '-';
  407056:	232d      	movs	r3, #45	; 0x2d
  407058:	2101      	movs	r1, #1
  40705a:	7013      	strb	r3, [r2, #0]
  40705c:	9103      	str	r1, [sp, #12]
  40705e:	e68e      	b.n	406d7e <display_faults+0xf6>
		current_fualt_id = get_previous_fault(&fault_ptr, &fault_index);
  407060:	f8df a090 	ldr.w	sl, [pc, #144]	; 4070f4 <display_faults+0x46c>
  407064:	491c      	ldr	r1, [pc, #112]	; (4070d8 <display_faults+0x450>)
  407066:	481d      	ldr	r0, [pc, #116]	; (4070dc <display_faults+0x454>)
  407068:	4b1e      	ldr	r3, [pc, #120]	; (4070e4 <display_faults+0x45c>)
  40706a:	4798      	blx	r3
  40706c:	4604      	mov	r4, r0
  40706e:	f8ca 0000 	str.w	r0, [sl]
  407072:	e61c      	b.n	406cae <display_faults+0x26>
		glcd_gotoxy(1, 26);
  407074:	211a      	movs	r1, #26
  407076:	2001      	movs	r0, #1
  407078:	4b0e      	ldr	r3, [pc, #56]	; (4070b4 <display_faults+0x42c>)
  40707a:	4798      	blx	r3
		write_r_text("No fault to view", 0);
  40707c:	481a      	ldr	r0, [pc, #104]	; (4070e8 <display_faults+0x460>)
  40707e:	4621      	mov	r1, r4
  407080:	4b1a      	ldr	r3, [pc, #104]	; (4070ec <display_faults+0x464>)
  407082:	4798      	blx	r3
	return 1;
  407084:	2001      	movs	r0, #1
  407086:	e7bd      	b.n	407004 <display_faults+0x37c>
		str[slen-1] = '\0'; /* cut off trailing 0 */
  407088:	2200      	movs	r2, #0
  40708a:	9900      	ldr	r1, [sp, #0]
  40708c:	54ca      	strb	r2, [r1, r3]
  40708e:	e760      	b.n	406f52 <display_faults+0x2ca>
  407090:	2200      	movs	r2, #0
  407092:	9900      	ldr	r1, [sp, #0]
  407094:	54ca      	strb	r2, [r1, r3]
  407096:	e6cc      	b.n	406e32 <display_faults+0x1aa>
		if(current_fualt_id->floor & 0x80) write_r_text(" =", 0);
  407098:	4815      	ldr	r0, [pc, #84]	; (4070f0 <display_faults+0x468>)
  40709a:	2100      	movs	r1, #0
  40709c:	47d8      	blx	fp
  40709e:	f8da 3000 	ldr.w	r3, [sl]
  4070a2:	7ad8      	ldrb	r0, [r3, #11]
  4070a4:	e63b      	b.n	406d1e <display_faults+0x96>
  4070a6:	b2e4      	uxtb	r4, r4
  4070a8:	2500      	movs	r5, #0
  4070aa:	e791      	b.n	406fd0 <display_faults+0x348>
  4070ac:	20400898 	.word	0x20400898
  4070b0:	0040ca05 	.word	0x0040ca05
  4070b4:	0040c7a5 	.word	0x0040c7a5
  4070b8:	0040c7b9 	.word	0x0040c7b9
  4070bc:	0041b008 	.word	0x0041b008
  4070c0:	0040c1a1 	.word	0x0040c1a1
  4070c4:	00419a30 	.word	0x00419a30
  4070c8:	0041b00c 	.word	0x0041b00c
  4070cc:	0041b010 	.word	0x0041b010
  4070d0:	0040c205 	.word	0x0040c205
  4070d4:	0041afe0 	.word	0x0041afe0
  4070d8:	20403a41 	.word	0x20403a41
  4070dc:	20403a40 	.word	0x20403a40
  4070e0:	00412c59 	.word	0x00412c59
  4070e4:	00412cad 	.word	0x00412cad
  4070e8:	0041b018 	.word	0x0041b018
  4070ec:	0040cf51 	.word	0x0040cf51
  4070f0:	0041aff4 	.word	0x0041aff4
  4070f4:	20403a44 	.word	0x20403a44

004070f8 <menue_faults_init>:

void menue_faults_init(menue_design_image_t *imgae_menue)
{
  4070f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	fill_menue_image(imgae_menue, &menue_faults, faults, "Faults (F)", 0);
  4070fc:	4e13      	ldr	r6, [pc, #76]	; (40714c <menue_faults_init+0x54>)
{
  4070fe:	b082      	sub	sp, #8
	fill_menue_image(imgae_menue, &menue_faults, faults, "Faults (F)", 0);
  407100:	2500      	movs	r5, #0
  407102:	4b13      	ldr	r3, [pc, #76]	; (407150 <menue_faults_init+0x58>)
  407104:	4631      	mov	r1, r6
  407106:	4a13      	ldr	r2, [pc, #76]	; (407154 <menue_faults_init+0x5c>)
  407108:	9500      	str	r5, [sp, #0]
{
  40710a:	4680      	mov	r8, r0
	fill_menue_image(imgae_menue, &menue_faults, faults, "Faults (F)", 0);
  40710c:	4c12      	ldr	r4, [pc, #72]	; (407158 <menue_faults_init+0x60>)
  40710e:	47a0      	blx	r4
	
	faults_view.text = "View faults";
  407110:	4f12      	ldr	r7, [pc, #72]	; (40715c <menue_faults_init+0x64>)
  407112:	4c13      	ldr	r4, [pc, #76]	; (407160 <menue_faults_init+0x68>)
	
	faults_clear.text = "Clear history";
	faults_clear.confirmed_sub = &fault_history_eraseAndSaveAll;
	faults_clear.confirm_msg = "Are you sure?";
	
	fill_menue_list(&menue_faults, opt_faults, OPT_FAULTS_MAX, imgae_menue, 0);
  407114:	4643      	mov	r3, r8
  407116:	9500      	str	r5, [sp, #0]
  407118:	4630      	mov	r0, r6
	faults_view.enter = &display_faults_enter;
  40711a:	f8df c054 	ldr.w	ip, [pc, #84]	; 407170 <menue_faults_init+0x78>
	fill_menue_list(&menue_faults, opt_faults, OPT_FAULTS_MAX, imgae_menue, 0);
  40711e:	4621      	mov	r1, r4
	faults_clear.text = "Clear history";
  407120:	f8df e050 	ldr.w	lr, [pc, #80]	; 407174 <menue_faults_init+0x7c>
	fill_menue_list(&menue_faults, opt_faults, OPT_FAULTS_MAX, imgae_menue, 0);
  407124:	2202      	movs	r2, #2
	faults_view.text = "View faults";
  407126:	6027      	str	r7, [r4, #0]
	faults_view.exe = &display_faults;
  407128:	f8df 804c 	ldr.w	r8, [pc, #76]	; 407178 <menue_faults_init+0x80>
	faults_clear.confirmed_sub = &fault_history_eraseAndSaveAll;
  40712c:	4f0d      	ldr	r7, [pc, #52]	; (407164 <menue_faults_init+0x6c>)
	faults_clear.confirm_msg = "Are you sure?";
  40712e:	4e0e      	ldr	r6, [pc, #56]	; (407168 <menue_faults_init+0x70>)
	fill_menue_list(&menue_faults, opt_faults, OPT_FAULTS_MAX, imgae_menue, 0);
  407130:	4d0e      	ldr	r5, [pc, #56]	; (40716c <menue_faults_init+0x74>)
	faults_view.exe = &display_faults;
  407132:	f8c4 8008 	str.w	r8, [r4, #8]
	faults_view.enter = &display_faults_enter;
  407136:	f8c4 c014 	str.w	ip, [r4, #20]
	faults_clear.text = "Clear history";
  40713a:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
	faults_clear.confirmed_sub = &fault_history_eraseAndSaveAll;
  40713e:	6467      	str	r7, [r4, #68]	; 0x44
	faults_clear.confirm_msg = "Are you sure?";
  407140:	62e6      	str	r6, [r4, #44]	; 0x2c
	fill_menue_list(&menue_faults, opt_faults, OPT_FAULTS_MAX, imgae_menue, 0);
  407142:	47a8      	blx	r5
  407144:	b002      	add	sp, #8
  407146:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40714a:	bf00      	nop
  40714c:	20403a24 	.word	0x20403a24
  407150:	0041b02c 	.word	0x0041b02c
  407154:	00419d88 	.word	0x00419d88
  407158:	0040b0d5 	.word	0x0040b0d5
  40715c:	0041b038 	.word	0x0041b038
  407160:	204039d4 	.word	0x204039d4
  407164:	00412a61 	.word	0x00412a61
  407168:	0041aa40 	.word	0x0041aa40
  40716c:	0040b0ad 	.word	0x0040b0ad
  407170:	00406c69 	.word	0x00406c69
  407174:	0041b044 	.word	0x0041b044
  407178:	00406c89 	.word	0x00406c89

0040717c <menue_util_hoist_show>:


void menue_util_hoist_show(uint32_t indx)
{
	uint32_t i;
	if(indx > 24) return;
  40717c:	2818      	cmp	r0, #24
  40717e:	d82e      	bhi.n	4071de <menue_util_hoist_show+0x62>
  407180:	2300      	movs	r3, #0
{
  407182:	b470      	push	{r4, r5, r6}
  407184:	4c19      	ldr	r4, [pc, #100]	; (4071ec <menue_util_hoist_show+0x70>)
		}
		#else
		
		else if (i < 22)
		{
			opt_util_hoist_i[i].option_characteristics = OPTION_HIDDEN;
  407186:	2501      	movs	r5, #1
		}
		else if (i < 30)
		{
			opt_util_hoist_i[i].option_characteristics = 0;
  407188:	4619      	mov	r1, r3
  40718a:	4622      	mov	r2, r4
  40718c:	e008      	b.n	4071a0 <menue_util_hoist_show+0x24>
		else if (i < 22)
  40718e:	2b15      	cmp	r3, #21
  407190:	d826      	bhi.n	4071e0 <menue_util_hoist_show+0x64>
	for (i=0; i<OPT_UTIL_HOIST_I_MAX; i++)
  407192:	3301      	adds	r3, #1
			opt_util_hoist_i[i].option_characteristics = OPTION_HIDDEN;
  407194:	7415      	strb	r5, [r2, #16]
		}
		#endif
		
		opt_util_hoist_i[30].option_characteristics = 0;
  407196:	f884 14c0 	strb.w	r1, [r4, #1216]	; 0x4c0
  40719a:	3228      	adds	r2, #40	; 0x28
	for (i=0; i<OPT_UTIL_HOIST_I_MAX; i++)
  40719c:	2b1f      	cmp	r3, #31
  40719e:	d008      	beq.n	4071b2 <menue_util_hoist_show+0x36>
		if (i < 16)
  4071a0:	2b0f      	cmp	r3, #15
  4071a2:	d8f4      	bhi.n	40718e <menue_util_hoist_show+0x12>
	for (i=0; i<OPT_UTIL_HOIST_I_MAX; i++)
  4071a4:	3301      	adds	r3, #1
			opt_util_hoist_i[i].option_characteristics = 0;
  4071a6:	7411      	strb	r1, [r2, #16]
		opt_util_hoist_i[30].option_characteristics = 0;
  4071a8:	f884 14c0 	strb.w	r1, [r4, #1216]	; 0x4c0
  4071ac:	3228      	adds	r2, #40	; 0x28
	for (i=0; i<OPT_UTIL_HOIST_I_MAX; i++)
  4071ae:	2b1f      	cmp	r3, #31
  4071b0:	d1f6      	bne.n	4071a0 <menue_util_hoist_show+0x24>
  4071b2:	4d0f      	ldr	r5, [pc, #60]	; (4071f0 <menue_util_hoist_show+0x74>)
	if(indx > 24) return;
  4071b4:	2300      	movs	r3, #0
	for (i=0; i<25; i++)
	{
		if ((menue_lift_data_setup.m_hoist[i] < 30) && (i != indx))
		{
			//hide selected inputs
			opt_util_hoist_i[menue_lift_data_setup.m_hoist[i]].option_characteristics = OPTION_HIDDEN;
  4071b6:	2601      	movs	r6, #1
		if ((menue_lift_data_setup.m_hoist[i] < 30) && (i != indx))
  4071b8:	f815 2f01 	ldrb.w	r2, [r5, #1]!
			opt_util_hoist_i[menue_lift_data_setup.m_hoist[i]].option_characteristics = OPTION_HIDDEN;
  4071bc:	eb02 0182 	add.w	r1, r2, r2, lsl #2
		if ((menue_lift_data_setup.m_hoist[i] < 30) && (i != indx))
  4071c0:	2a1d      	cmp	r2, #29
			opt_util_hoist_i[menue_lift_data_setup.m_hoist[i]].option_characteristics = OPTION_HIDDEN;
  4071c2:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
		if ((menue_lift_data_setup.m_hoist[i] < 30) && (i != indx))
  4071c6:	d802      	bhi.n	4071ce <menue_util_hoist_show+0x52>
  4071c8:	4298      	cmp	r0, r3
			opt_util_hoist_i[menue_lift_data_setup.m_hoist[i]].option_characteristics = OPTION_HIDDEN;
  4071ca:	bf18      	it	ne
  4071cc:	740e      	strbne	r6, [r1, #16]
	for (i=0; i<25; i++)
  4071ce:	3301      	adds	r3, #1
  4071d0:	2b19      	cmp	r3, #25
  4071d2:	d1f1      	bne.n	4071b8 <menue_util_hoist_show+0x3c>
		} 		
	}
	menue_util_hoist_i.save_val = &(menue_lift_data_setup.m_hoist[indx]);
  4071d4:	4b07      	ldr	r3, [pc, #28]	; (4071f4 <menue_util_hoist_show+0x78>)
  4071d6:	4a08      	ldr	r2, [pc, #32]	; (4071f8 <menue_util_hoist_show+0x7c>)
  4071d8:	4418      	add	r0, r3
  4071da:	6110      	str	r0, [r2, #16]
}
  4071dc:	bc70      	pop	{r4, r5, r6}
  4071de:	4770      	bx	lr
		else if (i < 30)
  4071e0:	2b1e      	cmp	r3, #30
  4071e2:	d1df      	bne.n	4071a4 <menue_util_hoist_show+0x28>
		opt_util_hoist_i[30].option_characteristics = 0;
  4071e4:	2300      	movs	r3, #0
  4071e6:	f884 34c0 	strb.w	r3, [r4, #1216]	; 0x4c0
  4071ea:	e7e2      	b.n	4071b2 <menue_util_hoist_show+0x36>
  4071ec:	20403a48 	.word	0x20403a48
  4071f0:	20405260 	.word	0x20405260
  4071f4:	20405261 	.word	0x20405261
  4071f8:	20403f20 	.word	0x20403f20

004071fc <menue_util_hoist_i_init>:

menue_design_t *menue_util_hoist_i_init(void)
{
  4071fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	opt_util_hoist_i[0].text = "X0";
  4071fe:	4c33      	ldr	r4, [pc, #204]	; (4072cc <menue_util_hoist_i_init+0xd0>)
{
  407200:	b083      	sub	sp, #12
	opt_util_hoist_i[1].text = "X1";
  407202:	4f33      	ldr	r7, [pc, #204]	; (4072d0 <menue_util_hoist_i_init+0xd4>)
	opt_util_hoist_i[27].text = "CTB X5";
	opt_util_hoist_i[28].text = "CTB X6";
	opt_util_hoist_i[29].text = "CTB X7";
	opt_util_hoist_i[30].text = "None";

	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  407204:	2600      	movs	r6, #0
	opt_util_hoist_i[0].text = "X0";
  407206:	4b33      	ldr	r3, [pc, #204]	; (4072d4 <menue_util_hoist_i_init+0xd8>)
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  407208:	221f      	movs	r2, #31
	opt_util_hoist_i[1].text = "X1";
  40720a:	62a7      	str	r7, [r4, #40]	; 0x28
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  40720c:	4621      	mov	r1, r4
	opt_util_hoist_i[2].text = "X2";
  40720e:	4f32      	ldr	r7, [pc, #200]	; (4072d8 <menue_util_hoist_i_init+0xdc>)
	opt_util_hoist_i[0].text = "X0";
  407210:	6023      	str	r3, [r4, #0]
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  407212:	4633      	mov	r3, r6
  407214:	9600      	str	r6, [sp, #0]
	opt_util_hoist_i[3].text = "X3";
  407216:	4e31      	ldr	r6, [pc, #196]	; (4072dc <menue_util_hoist_i_init+0xe0>)
	opt_util_hoist_i[2].text = "X2";
  407218:	6527      	str	r7, [r4, #80]	; 0x50
	opt_util_hoist_i[4].text = "X4";
  40721a:	4f31      	ldr	r7, [pc, #196]	; (4072e0 <menue_util_hoist_i_init+0xe4>)
	opt_util_hoist_i[3].text = "X3";
  40721c:	67a6      	str	r6, [r4, #120]	; 0x78
	opt_util_hoist_i[5].text = "X5";
  40721e:	4e31      	ldr	r6, [pc, #196]	; (4072e4 <menue_util_hoist_i_init+0xe8>)
	opt_util_hoist_i[4].text = "X4";
  407220:	f8c4 70a0 	str.w	r7, [r4, #160]	; 0xa0
	opt_util_hoist_i[6].text = "X6";
  407224:	4f30      	ldr	r7, [pc, #192]	; (4072e8 <menue_util_hoist_i_init+0xec>)
	opt_util_hoist_i[5].text = "X5";
  407226:	f8c4 60c8 	str.w	r6, [r4, #200]	; 0xc8
	opt_util_hoist_i[7].text = "X7";
  40722a:	4e30      	ldr	r6, [pc, #192]	; (4072ec <menue_util_hoist_i_init+0xf0>)
	opt_util_hoist_i[6].text = "X6";
  40722c:	f8c4 70f0 	str.w	r7, [r4, #240]	; 0xf0
	opt_util_hoist_i[8].text = "X8";
  407230:	4f2f      	ldr	r7, [pc, #188]	; (4072f0 <menue_util_hoist_i_init+0xf4>)
	opt_util_hoist_i[7].text = "X7";
  407232:	f8c4 6118 	str.w	r6, [r4, #280]	; 0x118
	opt_util_hoist_i[9].text = "X9";
  407236:	4e2f      	ldr	r6, [pc, #188]	; (4072f4 <menue_util_hoist_i_init+0xf8>)
	opt_util_hoist_i[8].text = "X8";
  407238:	f8c4 7140 	str.w	r7, [r4, #320]	; 0x140
	opt_util_hoist_i[10].text = "X10";
  40723c:	4f2e      	ldr	r7, [pc, #184]	; (4072f8 <menue_util_hoist_i_init+0xfc>)
	opt_util_hoist_i[9].text = "X9";
  40723e:	f8c4 6168 	str.w	r6, [r4, #360]	; 0x168
	opt_util_hoist_i[11].text = "X11";
  407242:	4e2e      	ldr	r6, [pc, #184]	; (4072fc <menue_util_hoist_i_init+0x100>)
	opt_util_hoist_i[10].text = "X10";
  407244:	f8c4 7190 	str.w	r7, [r4, #400]	; 0x190
	opt_util_hoist_i[12].text = "X12";
  407248:	4f2d      	ldr	r7, [pc, #180]	; (407300 <menue_util_hoist_i_init+0x104>)
	opt_util_hoist_i[11].text = "X11";
  40724a:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
	opt_util_hoist_i[13].text = "X13";
  40724e:	4e2d      	ldr	r6, [pc, #180]	; (407304 <menue_util_hoist_i_init+0x108>)
	opt_util_hoist_i[12].text = "X12";
  407250:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
	opt_util_hoist_i[14].text = "X14";
  407254:	4f2c      	ldr	r7, [pc, #176]	; (407308 <menue_util_hoist_i_init+0x10c>)
	opt_util_hoist_i[13].text = "X13";
  407256:	f8c4 6208 	str.w	r6, [r4, #520]	; 0x208
	opt_util_hoist_i[15].text = "X15";
  40725a:	4e2c      	ldr	r6, [pc, #176]	; (40730c <menue_util_hoist_i_init+0x110>)
	opt_util_hoist_i[14].text = "X14";
  40725c:	f8c4 7230 	str.w	r7, [r4, #560]	; 0x230
	opt_util_hoist_i[16].text = "X16";
  407260:	4f2b      	ldr	r7, [pc, #172]	; (407310 <menue_util_hoist_i_init+0x114>)
	opt_util_hoist_i[15].text = "X15";
  407262:	f8c4 6258 	str.w	r6, [r4, #600]	; 0x258
	opt_util_hoist_i[17].text = "X17";
  407266:	4e2b      	ldr	r6, [pc, #172]	; (407314 <menue_util_hoist_i_init+0x118>)
	opt_util_hoist_i[16].text = "X16";
  407268:	f8c4 7280 	str.w	r7, [r4, #640]	; 0x280
	opt_util_hoist_i[18].text = "X18";
  40726c:	4f2a      	ldr	r7, [pc, #168]	; (407318 <menue_util_hoist_i_init+0x11c>)
	opt_util_hoist_i[17].text = "X17";
  40726e:	f8c4 62a8 	str.w	r6, [r4, #680]	; 0x2a8
	opt_util_hoist_i[19].text = "X19";
  407272:	4e2a      	ldr	r6, [pc, #168]	; (40731c <menue_util_hoist_i_init+0x120>)
	opt_util_hoist_i[18].text = "X18";
  407274:	f8c4 72d0 	str.w	r7, [r4, #720]	; 0x2d0
	opt_util_hoist_i[20].text = "X20";
  407278:	4f29      	ldr	r7, [pc, #164]	; (407320 <menue_util_hoist_i_init+0x124>)
	opt_util_hoist_i[19].text = "X19";
  40727a:	f8c4 62f8 	str.w	r6, [r4, #760]	; 0x2f8
	opt_util_hoist_i[21].text = "X21";
  40727e:	4e29      	ldr	r6, [pc, #164]	; (407324 <menue_util_hoist_i_init+0x128>)
	opt_util_hoist_i[20].text = "X20";
  407280:	f8c4 7320 	str.w	r7, [r4, #800]	; 0x320
	opt_util_hoist_i[22].text = "CTB X0";
  407284:	4f28      	ldr	r7, [pc, #160]	; (407328 <menue_util_hoist_i_init+0x12c>)
	opt_util_hoist_i[21].text = "X21";
  407286:	f8c4 6348 	str.w	r6, [r4, #840]	; 0x348
	opt_util_hoist_i[23].text = "CTB X1";
  40728a:	4e28      	ldr	r6, [pc, #160]	; (40732c <menue_util_hoist_i_init+0x130>)
	opt_util_hoist_i[22].text = "CTB X0";
  40728c:	f8c4 7370 	str.w	r7, [r4, #880]	; 0x370
	opt_util_hoist_i[24].text = "CTB X2";
  407290:	4f27      	ldr	r7, [pc, #156]	; (407330 <menue_util_hoist_i_init+0x134>)
	opt_util_hoist_i[23].text = "CTB X1";
  407292:	f8c4 6398 	str.w	r6, [r4, #920]	; 0x398
	opt_util_hoist_i[25].text = "CTB X3";
  407296:	4e27      	ldr	r6, [pc, #156]	; (407334 <menue_util_hoist_i_init+0x138>)
	opt_util_hoist_i[24].text = "CTB X2";
  407298:	f8c4 73c0 	str.w	r7, [r4, #960]	; 0x3c0
	opt_util_hoist_i[26].text = "CTB X4";
  40729c:	4f26      	ldr	r7, [pc, #152]	; (407338 <menue_util_hoist_i_init+0x13c>)
	opt_util_hoist_i[25].text = "CTB X3";
  40729e:	f8c4 63e8 	str.w	r6, [r4, #1000]	; 0x3e8
	opt_util_hoist_i[27].text = "CTB X5";
  4072a2:	4e26      	ldr	r6, [pc, #152]	; (40733c <menue_util_hoist_i_init+0x140>)
	opt_util_hoist_i[26].text = "CTB X4";
  4072a4:	f8c4 7410 	str.w	r7, [r4, #1040]	; 0x410
	opt_util_hoist_i[28].text = "CTB X6";
  4072a8:	4f25      	ldr	r7, [pc, #148]	; (407340 <menue_util_hoist_i_init+0x144>)
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  4072aa:	4d26      	ldr	r5, [pc, #152]	; (407344 <menue_util_hoist_i_init+0x148>)
	opt_util_hoist_i[27].text = "CTB X5";
  4072ac:	f8c4 6438 	str.w	r6, [r4, #1080]	; 0x438
	opt_util_hoist_i[29].text = "CTB X7";
  4072b0:	4e25      	ldr	r6, [pc, #148]	; (407348 <menue_util_hoist_i_init+0x14c>)
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  4072b2:	4628      	mov	r0, r5
	opt_util_hoist_i[28].text = "CTB X6";
  4072b4:	f8c4 7460 	str.w	r7, [r4, #1120]	; 0x460
	opt_util_hoist_i[30].text = "None";
  4072b8:	4f24      	ldr	r7, [pc, #144]	; (40734c <menue_util_hoist_i_init+0x150>)
	opt_util_hoist_i[29].text = "CTB X7";
  4072ba:	f8c4 6488 	str.w	r6, [r4, #1160]	; 0x488
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  4072be:	4e24      	ldr	r6, [pc, #144]	; (407350 <menue_util_hoist_i_init+0x154>)
	opt_util_hoist_i[30].text = "None";
  4072c0:	f8c4 74b0 	str.w	r7, [r4, #1200]	; 0x4b0
	fill_menue_list(&menue_util_hoist_i, opt_util_hoist_i, OPT_UTIL_HOIST_I_MAX, 0, 0);
  4072c4:	47b0      	blx	r6

	return &menue_util_hoist_i;
  4072c6:	4628      	mov	r0, r5
  4072c8:	b003      	add	sp, #12
  4072ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4072cc:	20403a48 	.word	0x20403a48
  4072d0:	0041b098 	.word	0x0041b098
  4072d4:	0041b090 	.word	0x0041b090
  4072d8:	0041b0a0 	.word	0x0041b0a0
  4072dc:	0041b0a8 	.word	0x0041b0a8
  4072e0:	0041b0b0 	.word	0x0041b0b0
  4072e4:	0041b0b8 	.word	0x0041b0b8
  4072e8:	0041b0c0 	.word	0x0041b0c0
  4072ec:	0041b0c8 	.word	0x0041b0c8
  4072f0:	0041b054 	.word	0x0041b054
  4072f4:	0041b058 	.word	0x0041b058
  4072f8:	0041b05c 	.word	0x0041b05c
  4072fc:	0041b060 	.word	0x0041b060
  407300:	0041b064 	.word	0x0041b064
  407304:	0041b068 	.word	0x0041b068
  407308:	0041b06c 	.word	0x0041b06c
  40730c:	0041b070 	.word	0x0041b070
  407310:	0041b074 	.word	0x0041b074
  407314:	0041b078 	.word	0x0041b078
  407318:	0041b07c 	.word	0x0041b07c
  40731c:	0041b080 	.word	0x0041b080
  407320:	0041b084 	.word	0x0041b084
  407324:	0041b088 	.word	0x0041b088
  407328:	0041b08c 	.word	0x0041b08c
  40732c:	0041b094 	.word	0x0041b094
  407330:	0041b09c 	.word	0x0041b09c
  407334:	0041b0a4 	.word	0x0041b0a4
  407338:	0041b0ac 	.word	0x0041b0ac
  40733c:	0041b0b4 	.word	0x0041b0b4
  407340:	0041b0bc 	.word	0x0041b0bc
  407344:	20403f20 	.word	0x20403f20
  407348:	0041b0c4 	.word	0x0041b0c4
  40734c:	0041b0cc 	.word	0x0041b0cc
  407350:	0040b0ad 	.word	0x0040b0ad

00407354 <menue_lift_init>:
#define lift_restore_param		(opt_lift[5])
#define lift_save_param			(opt_lift[6])
#define lift_save_hoist			(opt_lift[7])

void menue_lift_init(menue_design_image_t *imgae_menue)
{
  407354:	b5f0      	push	{r4, r5, r6, r7, lr}
	fill_menue_image(imgae_menue, &menue_lift, basic_set, "Lift param setup (L)", &menue_lift_data_applied.set_password);
  407356:	4a25      	ldr	r2, [pc, #148]	; (4073ec <menue_lift_init+0x98>)
{
  407358:	b083      	sub	sp, #12
	fill_menue_image(imgae_menue, &menue_lift, basic_set, "Lift param setup (L)", &menue_lift_data_applied.set_password);
  40735a:	4d25      	ldr	r5, [pc, #148]	; (4073f0 <menue_lift_init+0x9c>)
{
  40735c:	4607      	mov	r7, r0
	fill_menue_image(imgae_menue, &menue_lift, basic_set, "Lift param setup (L)", &menue_lift_data_applied.set_password);
  40735e:	9200      	str	r2, [sp, #0]
  407360:	4629      	mov	r1, r5
  407362:	4b24      	ldr	r3, [pc, #144]	; (4073f4 <menue_lift_init+0xa0>)
  407364:	4a24      	ldr	r2, [pc, #144]	; (4073f8 <menue_lift_init+0xa4>)
  407366:	4c25      	ldr	r4, [pc, #148]	; (4073fc <menue_lift_init+0xa8>)
  407368:	47a0      	blx	r4
	
	lift_basic.text = "Basic setup";
  40736a:	4c25      	ldr	r4, [pc, #148]	; (407400 <menue_lift_init+0xac>)
  40736c:	4a25      	ldr	r2, [pc, #148]	; (407404 <menue_lift_init+0xb0>)
	lift_basic.child = menue_basic_init();
  40736e:	4b26      	ldr	r3, [pc, #152]	; (407408 <menue_lift_init+0xb4>)
	lift_basic.text = "Basic setup";
  407370:	6022      	str	r2, [r4, #0]
	lift_basic.child = menue_basic_init();
  407372:	4798      	blx	r3
	
	lift_advanced.text = "Advanced setup";
  407374:	4a25      	ldr	r2, [pc, #148]	; (40740c <menue_lift_init+0xb8>)
	lift_advanced.child = menue_advanced_init();
  407376:	4b26      	ldr	r3, [pc, #152]	; (407410 <menue_lift_init+0xbc>)
	lift_advanced.text = "Advanced setup";
  407378:	62a2      	str	r2, [r4, #40]	; 0x28
	lift_basic.child = menue_basic_init();
  40737a:	6220      	str	r0, [r4, #32]
	lift_advanced.child = menue_advanced_init();
  40737c:	4798      	blx	r3
	
	lift_timers.text = "Timers & delays";
  40737e:	4a25      	ldr	r2, [pc, #148]	; (407414 <menue_lift_init+0xc0>)
	lift_timers.child = menue_timers_init();
  407380:	4b25      	ldr	r3, [pc, #148]	; (407418 <menue_lift_init+0xc4>)
	lift_timers.text = "Timers & delays";
  407382:	6522      	str	r2, [r4, #80]	; 0x50
	lift_advanced.child = menue_advanced_init();
  407384:	64a0      	str	r0, [r4, #72]	; 0x48
	lift_timers.child = menue_timers_init();
  407386:	4798      	blx	r3
	
	lift_curve_param.text = "Speed curves";
  407388:	4a24      	ldr	r2, [pc, #144]	; (40741c <menue_lift_init+0xc8>)
	lift_curve_param.child = menue_curves_init();
  40738a:	4b25      	ldr	r3, [pc, #148]	; (407420 <menue_lift_init+0xcc>)
	lift_curve_param.text = "Speed curves";
  40738c:	67a2      	str	r2, [r4, #120]	; 0x78
	lift_timers.child = menue_timers_init();
  40738e:	6720      	str	r0, [r4, #112]	; 0x70
	lift_curve_param.child = menue_curves_init();
  407390:	4798      	blx	r3
	
	Hoist_info.text = "Hoist data";
  407392:	4a24      	ldr	r2, [pc, #144]	; (407424 <menue_lift_init+0xd0>)
	Hoist_info.child = menue_direct_stop_init();
  407394:	4b24      	ldr	r3, [pc, #144]	; (407428 <menue_lift_init+0xd4>)
	Hoist_info.text = "Hoist data";
  407396:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	lift_curve_param.child = menue_curves_init();
  40739a:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	Hoist_info.child = menue_direct_stop_init();
  40739e:	4798      	blx	r3
	
	lift_save_param.text = "Save lift param";
	lift_save_param.confirm_msg = "Are you sure?";
	lift_save_param.confirmed_sub = &menue_data_manager_saveLift;
  4073a0:	4e22      	ldr	r6, [pc, #136]	; (40742c <menue_lift_init+0xd8>)
	
	lift_restore_param.text = "Restore factory set";
	lift_restore_param.confirm_msg = "Are you sure?";
	lift_restore_param.confirmed_sub = &menue_data_manager_lift_restore;
	//lift_restore_param.option_characteristics |= OPTION_HIDDEN;
	fill_menue_list(&menue_lift, opt_lift, OPT_LIFT_MAX, imgae_menue, 0);
  4073a2:	2100      	movs	r1, #0
	Hoist_info.child = menue_direct_stop_init();
  4073a4:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	fill_menue_list(&menue_lift, opt_lift, OPT_LIFT_MAX, imgae_menue, 0);
  4073a8:	463b      	mov	r3, r7
  4073aa:	4628      	mov	r0, r5
	lift_save_hoist.text = "Save Hoist data";
  4073ac:	4f20      	ldr	r7, [pc, #128]	; (407430 <menue_lift_init+0xdc>)
	lift_save_hoist.confirmed_sub = &menue_data_manager_hoist_save;
  4073ae:	4d21      	ldr	r5, [pc, #132]	; (407434 <menue_lift_init+0xe0>)
	fill_menue_list(&menue_lift, opt_lift, OPT_LIFT_MAX, imgae_menue, 0);
  4073b0:	9100      	str	r1, [sp, #0]
  4073b2:	4621      	mov	r1, r4
	lift_save_param.confirmed_sub = &menue_data_manager_saveLift;
  4073b4:	f8c4 610c 	str.w	r6, [r4, #268]	; 0x10c
	lift_save_param.text = "Save lift param";
  4073b8:	4a1f      	ldr	r2, [pc, #124]	; (407438 <menue_lift_init+0xe4>)
	lift_restore_param.text = "Restore factory set";
  4073ba:	4e20      	ldr	r6, [pc, #128]	; (40743c <menue_lift_init+0xe8>)
	lift_save_hoist.text = "Save Hoist data";
  4073bc:	f8c4 7118 	str.w	r7, [r4, #280]	; 0x118
	lift_save_hoist.confirmed_sub = &menue_data_manager_hoist_save;
  4073c0:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
	lift_restore_param.confirmed_sub = &menue_data_manager_lift_restore;
  4073c4:	4f1e      	ldr	r7, [pc, #120]	; (407440 <menue_lift_init+0xec>)
	lift_save_param.confirm_msg = "Are you sure?";
  4073c6:	4d1f      	ldr	r5, [pc, #124]	; (407444 <menue_lift_init+0xf0>)
	lift_save_param.text = "Save lift param";
  4073c8:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
	fill_menue_list(&menue_lift, opt_lift, OPT_LIFT_MAX, imgae_menue, 0);
  4073cc:	2208      	movs	r2, #8
	lift_restore_param.text = "Restore factory set";
  4073ce:	f8c4 60c8 	str.w	r6, [r4, #200]	; 0xc8
	fill_menue_list(&menue_lift, opt_lift, OPT_LIFT_MAX, imgae_menue, 0);
  4073d2:	4e1d      	ldr	r6, [pc, #116]	; (407448 <menue_lift_init+0xf4>)
	lift_restore_param.confirmed_sub = &menue_data_manager_lift_restore;
  4073d4:	f8c4 70e4 	str.w	r7, [r4, #228]	; 0xe4
	lift_save_param.confirm_msg = "Are you sure?";
  4073d8:	f8c4 50f4 	str.w	r5, [r4, #244]	; 0xf4
	lift_save_hoist.confirm_msg = "Are you sure?";
  4073dc:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
	lift_restore_param.confirm_msg = "Are you sure?";
  4073e0:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
	fill_menue_list(&menue_lift, opt_lift, OPT_LIFT_MAX, imgae_menue, 0);
  4073e4:	47b0      	blx	r6
  4073e6:	b003      	add	sp, #12
  4073e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4073ea:	bf00      	nop
  4073ec:	20405384 	.word	0x20405384
  4073f0:	20403f3c 	.word	0x20403f3c
  4073f4:	0041b0d4 	.word	0x0041b0d4
  4073f8:	00419ba8 	.word	0x00419ba8
  4073fc:	0040b0d5 	.word	0x0040b0d5
  407400:	20403f58 	.word	0x20403f58
  407404:	0041b0ec 	.word	0x0041b0ec
  407408:	004050a1 	.word	0x004050a1
  40740c:	0041b0f8 	.word	0x0041b0f8
  407410:	00404e9d 	.word	0x00404e9d
  407414:	0041b108 	.word	0x0041b108
  407418:	00407531 	.word	0x00407531
  40741c:	0041b118 	.word	0x0041b118
  407420:	004052f1 	.word	0x004052f1
  407424:	0041b128 	.word	0x0041b128
  407428:	00404ac1 	.word	0x00404ac1
  40742c:	00409db9 	.word	0x00409db9
  407430:	0041b144 	.word	0x0041b144
  407434:	00409d95 	.word	0x00409d95
  407438:	0041b134 	.word	0x0041b134
  40743c:	0041b154 	.word	0x0041b154
  407440:	00409b99 	.word	0x00409b99
  407444:	0041aa40 	.word	0x0041aa40
  407448:	0040b0ad 	.word	0x0040b0ad

0040744c <menue_util_outputList_show>:


void menue_util_outputList_show(uint32_t indx)
{
	uint32_t i;
	if(indx > 14) return;
  40744c:	280e      	cmp	r0, #14
  40744e:	d803      	bhi.n	407458 <menue_util_outputList_show+0xc>
	
	menue_util_output_list.save_val = &(menue_lift_data_setup.m_outputs[indx]);
  407450:	4a02      	ldr	r2, [pc, #8]	; (40745c <menue_util_outputList_show+0x10>)
  407452:	4b03      	ldr	r3, [pc, #12]	; (407460 <menue_util_outputList_show+0x14>)
  407454:	4410      	add	r0, r2
  407456:	6118      	str	r0, [r3, #16]
  407458:	4770      	bx	lr
  40745a:	bf00      	nop
  40745c:	20405292 	.word	0x20405292
  407460:	20404098 	.word	0x20404098

00407464 <menue_util_outputs_list_init>:
}

menue_design_t *menue_util_outputs_list_init(void)
{
  407464:	b5f0      	push	{r4, r5, r6, r7, lr}
	opt_util_outputs_list[0].text = "Motor Brake";
  407466:	4c1e      	ldr	r4, [pc, #120]	; (4074e0 <menue_util_outputs_list_init+0x7c>)
{
  407468:	b083      	sub	sp, #12
	opt_util_outputs_list[0].text = "Motor Brake";
  40746a:	4f1e      	ldr	r7, [pc, #120]	; (4074e4 <menue_util_outputs_list_init+0x80>)
	opt_util_outputs_list[13].text = "Door2 Open";
	opt_util_outputs_list[14].text = "Door3 Close";
	opt_util_outputs_list[15].text = "Door3 Open";
	opt_util_outputs_list[16].text = "Null";

	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  40746c:	2300      	movs	r3, #0
	opt_util_outputs_list[1].text = "CAM";
  40746e:	4e1e      	ldr	r6, [pc, #120]	; (4074e8 <menue_util_outputs_list_init+0x84>)
	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  407470:	2211      	movs	r2, #17
	opt_util_outputs_list[0].text = "Motor Brake";
  407472:	6027      	str	r7, [r4, #0]
	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  407474:	4621      	mov	r1, r4
	opt_util_outputs_list[2].text = "Light timer";
  407476:	4f1d      	ldr	r7, [pc, #116]	; (4074ec <menue_util_outputs_list_init+0x88>)
	opt_util_outputs_list[1].text = "CAM";
  407478:	62a6      	str	r6, [r4, #40]	; 0x28
	opt_util_outputs_list[2].text = "Light timer";
  40747a:	6527      	str	r7, [r4, #80]	; 0x50
	opt_util_outputs_list[3].text = "ARD";
  40747c:	4e1c      	ldr	r6, [pc, #112]	; (4074f0 <menue_util_outputs_list_init+0x8c>)
	opt_util_outputs_list[4].text = "Arrow up";
  40747e:	4f1d      	ldr	r7, [pc, #116]	; (4074f4 <menue_util_outputs_list_init+0x90>)
	opt_util_outputs_list[3].text = "ARD";
  407480:	67a6      	str	r6, [r4, #120]	; 0x78
	opt_util_outputs_list[4].text = "Arrow up";
  407482:	f8c4 70a0 	str.w	r7, [r4, #160]	; 0xa0
	opt_util_outputs_list[5].text = "Arrow Down";
  407486:	4e1c      	ldr	r6, [pc, #112]	; (4074f8 <menue_util_outputs_list_init+0x94>)
	opt_util_outputs_list[6].text = "MOC";
  407488:	4f1c      	ldr	r7, [pc, #112]	; (4074fc <menue_util_outputs_list_init+0x98>)
	opt_util_outputs_list[5].text = "Arrow Down";
  40748a:	f8c4 60c8 	str.w	r6, [r4, #200]	; 0xc8
	opt_util_outputs_list[6].text = "MOC";
  40748e:	f8c4 70f0 	str.w	r7, [r4, #240]	; 0xf0
	opt_util_outputs_list[7].text = "Gong";
  407492:	4e1b      	ldr	r6, [pc, #108]	; (407500 <menue_util_outputs_list_init+0x9c>)
	opt_util_outputs_list[8].text = "ARD Toff";
  407494:	4f1b      	ldr	r7, [pc, #108]	; (407504 <menue_util_outputs_list_init+0xa0>)
	opt_util_outputs_list[7].text = "Gong";
  407496:	f8c4 6118 	str.w	r6, [r4, #280]	; 0x118
	opt_util_outputs_list[8].text = "ARD Toff";
  40749a:	f8c4 7140 	str.w	r7, [r4, #320]	; 0x140
	opt_util_outputs_list[9].text = "Fx";
  40749e:	4e1a      	ldr	r6, [pc, #104]	; (407508 <menue_util_outputs_list_init+0xa4>)
	opt_util_outputs_list[10].text = "Door1 Close";
  4074a0:	4f1a      	ldr	r7, [pc, #104]	; (40750c <menue_util_outputs_list_init+0xa8>)
	opt_util_outputs_list[9].text = "Fx";
  4074a2:	f8c4 6168 	str.w	r6, [r4, #360]	; 0x168
	opt_util_outputs_list[10].text = "Door1 Close";
  4074a6:	f8c4 7190 	str.w	r7, [r4, #400]	; 0x190
	opt_util_outputs_list[11].text = "Door1 Open";
  4074aa:	4e19      	ldr	r6, [pc, #100]	; (407510 <menue_util_outputs_list_init+0xac>)
	opt_util_outputs_list[12].text = "Door2 Close";
  4074ac:	4f19      	ldr	r7, [pc, #100]	; (407514 <menue_util_outputs_list_init+0xb0>)
	opt_util_outputs_list[11].text = "Door1 Open";
  4074ae:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
	opt_util_outputs_list[12].text = "Door2 Close";
  4074b2:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
	opt_util_outputs_list[13].text = "Door2 Open";
  4074b6:	4e18      	ldr	r6, [pc, #96]	; (407518 <menue_util_outputs_list_init+0xb4>)
	opt_util_outputs_list[14].text = "Door3 Close";
  4074b8:	4f18      	ldr	r7, [pc, #96]	; (40751c <menue_util_outputs_list_init+0xb8>)
	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  4074ba:	4d19      	ldr	r5, [pc, #100]	; (407520 <menue_util_outputs_list_init+0xbc>)
	opt_util_outputs_list[13].text = "Door2 Open";
  4074bc:	f8c4 6208 	str.w	r6, [r4, #520]	; 0x208
	opt_util_outputs_list[14].text = "Door3 Close";
  4074c0:	f8c4 7230 	str.w	r7, [r4, #560]	; 0x230
	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  4074c4:	4628      	mov	r0, r5
	opt_util_outputs_list[15].text = "Door3 Open";
  4074c6:	4e17      	ldr	r6, [pc, #92]	; (407524 <menue_util_outputs_list_init+0xc0>)
	opt_util_outputs_list[16].text = "Null";
  4074c8:	4f17      	ldr	r7, [pc, #92]	; (407528 <menue_util_outputs_list_init+0xc4>)
	opt_util_outputs_list[15].text = "Door3 Open";
  4074ca:	f8c4 6258 	str.w	r6, [r4, #600]	; 0x258
	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  4074ce:	9300      	str	r3, [sp, #0]
  4074d0:	4e16      	ldr	r6, [pc, #88]	; (40752c <menue_util_outputs_list_init+0xc8>)
	opt_util_outputs_list[16].text = "Null";
  4074d2:	f8c4 7280 	str.w	r7, [r4, #640]	; 0x280
	fill_menue_list(&menue_util_output_list, opt_util_outputs_list, OPT_UTIL_OUTPUTS_LIST_MAX, 0, 0);
  4074d6:	47b0      	blx	r6

	return &menue_util_output_list;
  4074d8:	4628      	mov	r0, r5
  4074da:	b003      	add	sp, #12
  4074dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4074de:	bf00      	nop
  4074e0:	204040b4 	.word	0x204040b4
  4074e4:	0041b168 	.word	0x0041b168
  4074e8:	0041b174 	.word	0x0041b174
  4074ec:	0041b178 	.word	0x0041b178
  4074f0:	0041aa28 	.word	0x0041aa28
  4074f4:	0041b184 	.word	0x0041b184
  4074f8:	0041b190 	.word	0x0041b190
  4074fc:	0041b19c 	.word	0x0041b19c
  407500:	0041b1a0 	.word	0x0041b1a0
  407504:	0041b1a8 	.word	0x0041b1a8
  407508:	0041b1b4 	.word	0x0041b1b4
  40750c:	0041b1b8 	.word	0x0041b1b8
  407510:	0041b1c4 	.word	0x0041b1c4
  407514:	0041b1d0 	.word	0x0041b1d0
  407518:	0041b1dc 	.word	0x0041b1dc
  40751c:	0041b1e8 	.word	0x0041b1e8
  407520:	20404098 	.word	0x20404098
  407524:	0041b1f4 	.word	0x0041b1f4
  407528:	0041b200 	.word	0x0041b200
  40752c:	0040b0ad 	.word	0x0040b0ad

00407530 <menue_timers_init>:
option_val_t oval_ltimers_ers_stop_timer;
option_val_t oval_ltimers_ers_ldir_delay;
option_val_t oval_ltimers_ers_ldir_waitTime;

menue_design_t *menue_timers_init(void)
{
  407530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	oval_ltimers_slow_timer.max_value = 50;
	oval_ltimers_slow_timer.min_value = 1;
	oval_ltimers_slow_timer.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_slow_timer.unit = "Sec";
	oval_ltimers_slow_timer.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_ltimers_slow_timer.val = &menue_lift_data_setup.m_slow_time;
  407534:	4e93      	ldr	r6, [pc, #588]	; (407784 <menue_timers_init+0x254>)
	oval_ltimers_slow_timer.min_value = 1;
  407536:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	ltimers_slow_timer.option_save_val = &oval_ltimers_slow_timer;
//__________________________________________________

	ltimers_fast_timer.text = "Fast time-out";
	oval_ltimers_fast_timer.data_types = uint8_dt;
  40753a:	4b93      	ldr	r3, [pc, #588]	; (407788 <menue_timers_init+0x258>)
	oval_ltimers_slow_timer.data_types = uint8_dt;
  40753c:	2500      	movs	r5, #0
  40753e:	f8df a2a8 	ldr.w	sl, [pc, #680]	; 4077e8 <menue_timers_init+0x2b8>
	oval_ltimers_cam_timer.max_value = 50;
	oval_ltimers_cam_timer.min_value = 1;
	oval_ltimers_cam_timer.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_cam_timer.unit = "Sec";
	//oval_ltimers_cam_timer.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ltimers_cam_timer.val = &menue_lift_data_setup.m_cam_time;
  407542:	1cb7      	adds	r7, r6, #2
	oval_ltimers_cam_timer.data_types = uint8_dt;
  407544:	4a91      	ldr	r2, [pc, #580]	; (40778c <menue_timers_init+0x25c>)
	oval_ltimers_slow_timer.real_count = 2;
  407546:	2002      	movs	r0, #2
	oval_ltimers_slow_timer.max_value = 50;
  407548:	4c91      	ldr	r4, [pc, #580]	; (407790 <menue_timers_init+0x260>)
	oval_ltimers_fast_timer.val = &menue_lift_data_setup.m_fast_time;
  40754a:	1c71      	adds	r1, r6, #1
	oval_ltimers_slow_timer.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
  40754c:	f8df e29c 	ldr.w	lr, [pc, #668]	; 4077ec <menue_timers_init+0x2bc>
//__________________________________________________
	ltimers_stop_timer.text = "Stop wait time";
	oval_ltimers_stop_timer.data_types = uint8_dt;
	oval_ltimers_stop_timer.mantissa_count = 0;
	oval_ltimers_stop_timer.real_count = 2;
	oval_ltimers_stop_timer.max_value = 10;
  407550:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
	oval_ltimers_cam_timer.val = &menue_lift_data_setup.m_cam_time;
  407554:	61d7      	str	r7, [r2, #28]
	oval_ltimers_stop_timer.min_value = 1;
	oval_ltimers_stop_timer.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_stop_timer.unit = "Sec";
	//oval_ltimers_cam_timer.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ltimers_stop_timer.val = &menue_lift_data_setup.m_stop_wait_time;
  407556:	f106 0903 	add.w	r9, r6, #3
	oval_ltimers_slow_timer.new_val_flag = &menue_lift_data_newdata_flag;
  40755a:	4f8e      	ldr	r7, [pc, #568]	; (407794 <menue_timers_init+0x264>)
	ltimers_stop_timer.option_save_val = &oval_ltimers_stop_timer;
//__________________________________________________
	ltimers_light_timer.text = "Light-on time";
	oval_ltimers_light_timer.data_types = uint8_dt;
	oval_ltimers_light_timer.mantissa_count = 0;
	oval_ltimers_light_timer.real_count = 3;
  40755c:	f04f 0803 	mov.w	r8, #3
	oval_ltimers_slow_timer.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
  407560:	f8ca e010 	str.w	lr, [sl, #16]
	oval_ltimers_downstop_timer.max_value = 9999;
	oval_ltimers_downstop_timer.min_value = 1;
	oval_ltimers_downstop_timer.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_downstop_timer.unit = "40ms";
	//oval_ltimers_downstop_timer.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ltimers_downstop_timer.val = &menue_lift_data_setup.m_down_stop_delay;
  407564:	f106 0b11 	add.w	fp, r6, #17
	oval_ltimers_slow_timer.unit = "Sec";
  407568:	f8df e284 	ldr.w	lr, [pc, #644]	; 4077f0 <menue_timers_init+0x2c0>
{
  40756c:	b083      	sub	sp, #12
	oval_ltimers_slow_timer.max_value = 50;
  40756e:	f8ca 4014 	str.w	r4, [sl, #20]
	oval_ltimers_fast_timer.max_value = 50;
  407572:	615c      	str	r4, [r3, #20]
	oval_ltimers_cam_timer.max_value = 50;
  407574:	6154      	str	r4, [r2, #20]
	ltimers_slow_timer.text = "Slow time-out";
  407576:	4c88      	ldr	r4, [pc, #544]	; (407798 <menue_timers_init+0x268>)
	oval_ltimers_cam_timer.min_value = 1;
  407578:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_ltimers_cam_timer.unit = "Sec";
  40757c:	f8c2 e00c 	str.w	lr, [r2, #12]
	oval_ltimers_cam_timer.data_types = uint8_dt;
  407580:	7015      	strb	r5, [r2, #0]
	oval_ltimers_cam_timer.mantissa_count = 0;
  407582:	6095      	str	r5, [r2, #8]
	oval_ltimers_cam_timer.real_count = 2;
  407584:	6050      	str	r0, [r2, #4]
	oval_ltimers_cam_timer.new_val_flag = &menue_lift_data_newdata_flag;
  407586:	6217      	str	r7, [r2, #32]
	ltimers_cam_timer.option_save_val = &oval_ltimers_cam_timer;
  407588:	6762      	str	r2, [r4, #116]	; 0x74
	ltimers_slow_timer.text = "Slow time-out";
  40758a:	4a84      	ldr	r2, [pc, #528]	; (40779c <menue_timers_init+0x26c>)
	oval_ltimers_fast_timer.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
  40758c:	f8df c264 	ldr.w	ip, [pc, #612]	; 4077f4 <menue_timers_init+0x2c4>
	ltimers_slow_timer.text = "Slow time-out";
  407590:	6022      	str	r2, [r4, #0]
	ltimers_fast_timer.text = "Fast time-out";
  407592:	4a83      	ldr	r2, [pc, #524]	; (4077a0 <menue_timers_init+0x270>)
	oval_ltimers_slow_timer.min_value = 1;
  407594:	edca 7a06 	vstr	s15, [sl, #24]
	ltimers_fast_timer.text = "Fast time-out";
  407598:	62a2      	str	r2, [r4, #40]	; 0x28
	ltimers_cam_timer.text = "CAM time-out";
  40759a:	4a82      	ldr	r2, [pc, #520]	; (4077a4 <menue_timers_init+0x274>)
	oval_ltimers_fast_timer.min_value = 1;
  40759c:	edc3 7a06 	vstr	s15, [r3, #24]
	oval_ltimers_slow_timer.unit = "Sec";
  4075a0:	f8ca e00c 	str.w	lr, [sl, #12]
	oval_ltimers_fast_timer.unit = "Sec";
  4075a4:	f8c3 e00c 	str.w	lr, [r3, #12]
	oval_ltimers_fast_timer.val = &menue_lift_data_setup.m_fast_time;
  4075a8:	61d9      	str	r1, [r3, #28]
	oval_ltimers_light_timer.val = &menue_lift_data_setup.m_light_time;
  4075aa:	1d31      	adds	r1, r6, #4
	oval_ltimers_fast_timer.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
  4075ac:	f8c3 c010 	str.w	ip, [r3, #16]
	oval_ltimers_parking_timer.data_types = uint16_dt;
  4075b0:	f04f 0c01 	mov.w	ip, #1
	oval_ltimers_slow_timer.val = &menue_lift_data_setup.m_slow_time;
  4075b4:	f8ca 601c 	str.w	r6, [sl, #28]
	oval_ltimers_slow_timer.data_types = uint8_dt;
  4075b8:	f88a 5000 	strb.w	r5, [sl]
	oval_ltimers_slow_timer.mantissa_count = 0;
  4075bc:	f8ca 5008 	str.w	r5, [sl, #8]
	oval_ltimers_fast_timer.data_types = uint8_dt;
  4075c0:	701d      	strb	r5, [r3, #0]
	oval_ltimers_fast_timer.mantissa_count = 0;
  4075c2:	609d      	str	r5, [r3, #8]
	oval_ltimers_slow_timer.real_count = 2;
  4075c4:	f8ca 0004 	str.w	r0, [sl, #4]
	oval_ltimers_fast_timer.real_count = 2;
  4075c8:	6058      	str	r0, [r3, #4]
	oval_ltimers_slow_timer.new_val_flag = &menue_lift_data_newdata_flag;
  4075ca:	f8ca 7020 	str.w	r7, [sl, #32]
	oval_ltimers_fast_timer.new_val_flag = &menue_lift_data_newdata_flag;
  4075ce:	621f      	str	r7, [r3, #32]
	ltimers_slow_timer.option_save_val = &oval_ltimers_slow_timer;
  4075d0:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
	oval_ltimers_toff_timer.max_value = 999;
	oval_ltimers_toff_timer.min_value = 1;
	oval_ltimers_toff_timer.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_toff_timer.unit = "Sec";
	//oval_ltimers_toff_timer.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ltimers_toff_timer.val = &menue_lift_data_setup.m_ers_toff_delay;
  4075d4:	f106 0a13 	add.w	sl, r6, #19
	ltimers_fast_timer.option_save_val = &oval_ltimers_fast_timer;
  4075d8:	64e3      	str	r3, [r4, #76]	; 0x4c
	oval_ltimers_parking_timer.real_count = 4;
  4075da:	2304      	movs	r3, #4
	ltimers_cam_timer.text = "CAM time-out";
  4075dc:	6522      	str	r2, [r4, #80]	; 0x50
	ltimers_stop_timer.text = "Stop wait time";
  4075de:	4a72      	ldr	r2, [pc, #456]	; (4077a8 <menue_timers_init+0x278>)
  4075e0:	67a2      	str	r2, [r4, #120]	; 0x78
	oval_ltimers_stop_timer.data_types = uint8_dt;
  4075e2:	4a72      	ldr	r2, [pc, #456]	; (4077ac <menue_timers_init+0x27c>)
	oval_ltimers_stop_timer.min_value = 1;
  4075e4:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_ltimers_stop_timer.unit = "Sec";
  4075e8:	f8c2 e00c 	str.w	lr, [r2, #12]
	oval_ltimers_stop_timer.real_count = 2;
  4075ec:	6050      	str	r0, [r2, #4]
	oval_ltimers_ers_ldir_delay.max_value = 999;
	oval_ltimers_ers_ldir_delay.min_value = 1;
	oval_ltimers_ers_ldir_delay.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_ers_ldir_delay.unit = "Sec";
	//oval_ltimers_ers_ldir_delay.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ltimers_ers_ldir_delay.val = &menue_lift_data_setup.m_ers_ldir_delay;
  4075ee:	f106 0017 	add.w	r0, r6, #23
	oval_ltimers_stop_timer.data_types = uint8_dt;
  4075f2:	7015      	strb	r5, [r2, #0]
	oval_ltimers_stop_timer.mantissa_count = 0;
  4075f4:	6095      	str	r5, [r2, #8]
	oval_ltimers_stop_timer.new_val_flag = &menue_lift_data_newdata_flag;
  4075f6:	6217      	str	r7, [r2, #32]
	oval_ltimers_stop_timer.max_value = 10;
  4075f8:	ed82 7a05 	vstr	s14, [r2, #20]
	oval_ltimers_stop_timer.val = &menue_lift_data_setup.m_stop_wait_time;
  4075fc:	f8c2 901c 	str.w	r9, [r2, #28]
	oval_ltimers_ers_stop_timer.val = &menue_lift_data_setup.m_ers_stop_time;
  407600:	f106 091b 	add.w	r9, r6, #27
	ltimers_stop_timer.option_save_val = &oval_ltimers_stop_timer;
  407604:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
	oval_ltimers_ers_ldir_waitTime.max_value = 999;
	oval_ltimers_ers_ldir_waitTime.min_value = 1;
	oval_ltimers_ers_ldir_waitTime.new_val_flag = &menue_lift_data_newdata_flag;
	oval_ltimers_ers_ldir_waitTime.unit = "Sec";
	//oval_ltimers_ers_ldir_waitTime.text = "When this time elapses if the lift couldn't find selector signal, it will stop flaging an error";
	oval_ltimers_ers_ldir_waitTime.val = &menue_lift_data_setup.m_ers_ldir_test_time;
  407608:	3619      	adds	r6, #25
	ltimers_light_timer.text = "Light-on time";
  40760a:	4a69      	ldr	r2, [pc, #420]	; (4077b0 <menue_timers_init+0x280>)
	oval_ltimers_toff_timer.max_value = 999;
  40760c:	ed9f 7a69 	vldr	s14, [pc, #420]	; 4077b4 <menue_timers_init+0x284>
	ltimers_light_timer.text = "Light-on time";
  407610:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
	ltimers_parking_timer.text = "Parking delay";
  407614:	4a68      	ldr	r2, [pc, #416]	; (4077b8 <menue_timers_init+0x288>)
  407616:	f8c4 20c8 	str.w	r2, [r4, #200]	; 0xc8
	ltimers_upstop_timer.text = "Up_stop delay";
  40761a:	4a68      	ldr	r2, [pc, #416]	; (4077bc <menue_timers_init+0x28c>)
  40761c:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
	oval_ltimers_light_timer.data_types = uint8_dt;
  407620:	4a67      	ldr	r2, [pc, #412]	; (4077c0 <menue_timers_init+0x290>)
	oval_ltimers_light_timer.val = &menue_lift_data_setup.m_light_time;
  407622:	61d1      	str	r1, [r2, #28]
	oval_ltimers_light_timer.max_value = 180;
  407624:	4967      	ldr	r1, [pc, #412]	; (4077c4 <menue_timers_init+0x294>)
	oval_ltimers_light_timer.min_value = 1;
  407626:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_ltimers_light_timer.unit = "Sec";
  40762a:	f8c2 e00c 	str.w	lr, [r2, #12]
	oval_ltimers_light_timer.data_types = uint8_dt;
  40762e:	7015      	strb	r5, [r2, #0]
	oval_ltimers_light_timer.mantissa_count = 0;
  407630:	6095      	str	r5, [r2, #8]
	oval_ltimers_light_timer.new_val_flag = &menue_lift_data_newdata_flag;
  407632:	6217      	str	r7, [r2, #32]
	oval_ltimers_light_timer.max_value = 180;
  407634:	6151      	str	r1, [r2, #20]
	oval_ltimers_parking_timer.val = &menue_lift_data_setup.m_parking_time;
  407636:	f1a0 010a 	sub.w	r1, r0, #10
	oval_ltimers_light_timer.real_count = 3;
  40763a:	f8c2 8004 	str.w	r8, [r2, #4]
	ltimers_light_timer.option_save_val = &oval_ltimers_light_timer;
  40763e:	f8c4 20c4 	str.w	r2, [r4, #196]	; 0xc4
	oval_ltimers_parking_timer.data_types = uint16_dt;
  407642:	4a61      	ldr	r2, [pc, #388]	; (4077c8 <menue_timers_init+0x298>)
	oval_ltimers_parking_timer.val = &menue_lift_data_setup.m_parking_time;
  407644:	61d1      	str	r1, [r2, #28]
	oval_ltimers_parking_timer.max_value = 1000;
  407646:	4961      	ldr	r1, [pc, #388]	; (4077cc <menue_timers_init+0x29c>)
	oval_ltimers_parking_timer.unit = "Sec";
  407648:	f8c2 e00c 	str.w	lr, [r2, #12]
	oval_ltimers_parking_timer.max_value = 1000;
  40764c:	6151      	str	r1, [r2, #20]
	oval_ltimers_parking_timer.min_value = 0;
  40764e:	2100      	movs	r1, #0
	oval_ltimers_parking_timer.data_types = uint16_dt;
  407650:	f882 c000 	strb.w	ip, [r2]
	oval_ltimers_parking_timer.mantissa_count = 0;
  407654:	6095      	str	r5, [r2, #8]
	oval_ltimers_parking_timer.new_val_flag = &menue_lift_data_newdata_flag;
  407656:	6217      	str	r7, [r2, #32]
	ltimers_parking_timer.option_save_val = &oval_ltimers_parking_timer;	
  407658:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
	oval_ltimers_parking_timer.min_value = 0;
  40765c:	6191      	str	r1, [r2, #24]
	oval_ltimers_parking_timer.real_count = 4;
  40765e:	6053      	str	r3, [r2, #4]
	oval_ltimers_upstop_timer.data_types = uint16_dt;
  407660:	495b      	ldr	r1, [pc, #364]	; (4077d0 <menue_timers_init+0x2a0>)
	ltimers_downstop_timer.text = "Down-stop delay";
  407662:	4a5c      	ldr	r2, [pc, #368]	; (4077d4 <menue_timers_init+0x2a4>)
	oval_ltimers_upstop_timer.data_types = uint16_dt;
  407664:	f881 c000 	strb.w	ip, [r1]
	oval_ltimers_upstop_timer.mantissa_count = 0;
  407668:	608d      	str	r5, [r1, #8]
	ltimers_downstop_timer.text = "Down-stop delay";
  40766a:	f8c4 2118 	str.w	r2, [r4, #280]	; 0x118
	oval_ltimers_upstop_timer.val = &menue_lift_data_setup.m_up_stop_delay;
  40766e:	f1a0 0208 	sub.w	r2, r0, #8
	oval_ltimers_upstop_timer.min_value = 1;
  407672:	edc1 7a06 	vstr	s15, [r1, #24]
	oval_ltimers_upstop_timer.val = &menue_lift_data_setup.m_up_stop_delay;
  407676:	61ca      	str	r2, [r1, #28]
	oval_ltimers_downstop_timer.data_types = uint16_dt;
  407678:	4a57      	ldr	r2, [pc, #348]	; (4077d8 <menue_timers_init+0x2a8>)
	oval_ltimers_upstop_timer.real_count = 4;
  40767a:	604b      	str	r3, [r1, #4]
	oval_ltimers_downstop_timer.val = &menue_lift_data_setup.m_down_stop_delay;
  40767c:	f8c2 b01c 	str.w	fp, [r2, #28]
	ltimers_ers_toff_timer.text = "ARD T-Off delay";
  407680:	f8df b174 	ldr.w	fp, [pc, #372]	; 4077f8 <menue_timers_init+0x2c8>
	oval_ltimers_downstop_timer.data_types = uint16_dt;
  407684:	f882 c000 	strb.w	ip, [r2]
	ltimers_ers_toff_timer.text = "ARD T-Off delay";
  407688:	f8c4 b140 	str.w	fp, [r4, #320]	; 0x140
	ltimers_ers_stop_timer.text = "ARD stop time-out";
  40768c:	f8df b16c 	ldr.w	fp, [pc, #364]	; 4077fc <menue_timers_init+0x2cc>
	oval_ltimers_downstop_timer.real_count = 4;
  407690:	6053      	str	r3, [r2, #4]
	ltimers_ers_ldir_waitTime.option_save_val = &oval_ltimers_ers_ldir_waitTime;
	//__________________________________________________
		
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  407692:	462b      	mov	r3, r5
	ltimers_ers_stop_timer.text = "ARD stop time-out";
  407694:	f8c4 b168 	str.w	fp, [r4, #360]	; 0x168
	oval_ltimers_toff_timer.data_types = uint16_dt;
  407698:	f8df b164 	ldr.w	fp, [pc, #356]	; 407800 <menue_timers_init+0x2d0>
	oval_ltimers_downstop_timer.mantissa_count = 0;
  40769c:	6095      	str	r5, [r2, #8]
	oval_ltimers_toff_timer.data_types = uint16_dt;
  40769e:	f88b c000 	strb.w	ip, [fp]
	oval_ltimers_toff_timer.min_value = 1;
  4076a2:	edcb 7a06 	vstr	s15, [fp, #24]
	oval_ltimers_toff_timer.unit = "Sec";
  4076a6:	f8cb e00c 	str.w	lr, [fp, #12]
	oval_ltimers_toff_timer.max_value = 999;
  4076aa:	ed8b 7a05 	vstr	s14, [fp, #20]
	oval_ltimers_toff_timer.val = &menue_lift_data_setup.m_ers_toff_delay;
  4076ae:	f8cb a01c 	str.w	sl, [fp, #28]
	oval_ltimers_toff_timer.mantissa_count = 0;
  4076b2:	f8cb 5008 	str.w	r5, [fp, #8]
	oval_ltimers_toff_timer.real_count = 3;
  4076b6:	f8cb 8004 	str.w	r8, [fp, #4]
	oval_ltimers_toff_timer.new_val_flag = &menue_lift_data_newdata_flag;
  4076ba:	f8cb 7020 	str.w	r7, [fp, #32]
	ltimers_ers_toff_timer.option_save_val = &oval_ltimers_toff_timer;
  4076be:	f8c4 b164 	str.w	fp, [r4, #356]	; 0x164
	oval_ltimers_upstop_timer.unit = "40ms";
  4076c2:	f8df a140 	ldr.w	sl, [pc, #320]	; 407804 <menue_timers_init+0x2d4>
	oval_ltimers_upstop_timer.max_value = 9999;
  4076c6:	f8df b140 	ldr.w	fp, [pc, #320]	; 407808 <menue_timers_init+0x2d8>
	oval_ltimers_downstop_timer.min_value = 1;
  4076ca:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_ltimers_downstop_timer.max_value = 9999;
  4076ce:	f8c2 b014 	str.w	fp, [r2, #20]
	oval_ltimers_downstop_timer.new_val_flag = &menue_lift_data_newdata_flag;
  4076d2:	6217      	str	r7, [r2, #32]
	ltimers_downstop_timer.option_save_val = &oval_ltimers_downstop_timer;
  4076d4:	f8c4 213c 	str.w	r2, [r4, #316]	; 0x13c
	oval_ltimers_upstop_timer.unit = "40ms";
  4076d8:	f8c1 a00c 	str.w	sl, [r1, #12]
	oval_ltimers_downstop_timer.unit = "40ms";
  4076dc:	f8c2 a00c 	str.w	sl, [r2, #12]
	oval_ltimers_ers_stop_timer.data_types = uint16_dt;
  4076e0:	4a3e      	ldr	r2, [pc, #248]	; (4077dc <menue_timers_init+0x2ac>)
	ltimers_ers_ldir_waitTime.text = "ARD L_dir test time";
  4076e2:	f8df a128 	ldr.w	sl, [pc, #296]	; 40780c <menue_timers_init+0x2dc>
	oval_ltimers_ers_stop_timer.data_types = uint16_dt;
  4076e6:	f882 c000 	strb.w	ip, [r2]
	oval_ltimers_ers_stop_timer.max_value = 999;
  4076ea:	ed82 7a05 	vstr	s14, [r2, #20]
	oval_ltimers_upstop_timer.new_val_flag = &menue_lift_data_newdata_flag;
  4076ee:	620f      	str	r7, [r1, #32]
	ltimers_upstop_timer.option_save_val = &oval_ltimers_upstop_timer;
  4076f0:	f8c4 1114 	str.w	r1, [r4, #276]	; 0x114
	oval_ltimers_upstop_timer.max_value = 9999;
  4076f4:	f8c1 b014 	str.w	fp, [r1, #20]
	oval_ltimers_ers_stop_timer.mantissa_count = 0;
  4076f8:	6095      	str	r5, [r2, #8]
	oval_ltimers_ers_stop_timer.real_count = 3;
  4076fa:	f8c2 8004 	str.w	r8, [r2, #4]
	oval_ltimers_ers_stop_timer.min_value = 1;
  4076fe:	edc2 7a06 	vstr	s15, [r2, #24]
	oval_ltimers_ers_stop_timer.new_val_flag = &menue_lift_data_newdata_flag;
  407702:	6217      	str	r7, [r2, #32]
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  407704:	9500      	str	r5, [sp, #0]
	ltimers_ers_ldir_waitTime.text = "ARD L_dir test time";
  407706:	f8c4 a1b8 	str.w	sl, [r4, #440]	; 0x1b8
	oval_ltimers_ers_ldir_delay.data_types = uint16_dt;
  40770a:	f8df a104 	ldr.w	sl, [pc, #260]	; 407810 <menue_timers_init+0x2e0>
	oval_ltimers_ers_stop_timer.val = &menue_lift_data_setup.m_ers_stop_time;
  40770e:	f8c2 901c 	str.w	r9, [r2, #28]
	oval_ltimers_ers_ldir_delay.val = &menue_lift_data_setup.m_ers_ldir_delay;
  407712:	f8ca 001c 	str.w	r0, [sl, #28]
	oval_ltimers_ers_ldir_delay.data_types = uint16_dt;
  407716:	f88a c000 	strb.w	ip, [sl]
	oval_ltimers_ers_ldir_delay.mantissa_count = 0;
  40771a:	f8ca 5008 	str.w	r5, [sl, #8]
	oval_ltimers_ers_ldir_delay.real_count = 3;
  40771e:	f8ca 8004 	str.w	r8, [sl, #4]
	oval_ltimers_ers_ldir_delay.max_value = 999;
  407722:	ed8a 7a05 	vstr	s14, [sl, #20]
	oval_ltimers_ers_ldir_delay.min_value = 1;
  407726:	edca 7a06 	vstr	s15, [sl, #24]
	oval_ltimers_ers_ldir_delay.new_val_flag = &menue_lift_data_newdata_flag;
  40772a:	f8ca 7020 	str.w	r7, [sl, #32]
	oval_ltimers_ers_ldir_delay.unit = "Sec";
  40772e:	f8ca e00c 	str.w	lr, [sl, #12]
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  407732:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 407814 <menue_timers_init+0x2e4>
	ltimers_ers_ldir_delay.option_save_val = &oval_ltimers_ers_ldir_delay;
  407736:	f8c4 a1b4 	str.w	sl, [r4, #436]	; 0x1b4
	ltimers_ers_ldir_delay.text = "ARD L-Dir delay";
  40773a:	4929      	ldr	r1, [pc, #164]	; (4077e0 <menue_timers_init+0x2b0>)
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  40773c:	4648      	mov	r0, r9
	oval_ltimers_ers_ldir_waitTime.data_types = uint16_dt;
  40773e:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 407818 <menue_timers_init+0x2e8>
	oval_ltimers_ers_stop_timer.unit = "Sec";
  407742:	f8c2 e00c 	str.w	lr, [r2, #12]
	ltimers_ers_stop_timer.option_save_val = &oval_ltimers_ers_stop_timer;
  407746:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  40774a:	220c      	movs	r2, #12
	ltimers_ers_ldir_delay.text = "ARD L-Dir delay";
  40774c:	f8c4 1190 	str.w	r1, [r4, #400]	; 0x190
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  407750:	4621      	mov	r1, r4
	oval_ltimers_ers_ldir_waitTime.mantissa_count = 0;
  407752:	f8ca 5008 	str.w	r5, [sl, #8]
	oval_ltimers_ers_ldir_waitTime.val = &menue_lift_data_setup.m_ers_ldir_test_time;
  407756:	f8ca 601c 	str.w	r6, [sl, #28]
	oval_ltimers_ers_ldir_waitTime.data_types = uint16_dt;
  40775a:	f88a c000 	strb.w	ip, [sl]
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  40775e:	4d21      	ldr	r5, [pc, #132]	; (4077e4 <menue_timers_init+0x2b4>)
	oval_ltimers_ers_ldir_waitTime.real_count = 3;
  407760:	f8ca 8004 	str.w	r8, [sl, #4]
	oval_ltimers_ers_ldir_waitTime.max_value = 999;
  407764:	ed8a 7a05 	vstr	s14, [sl, #20]
	oval_ltimers_ers_ldir_waitTime.min_value = 1;
  407768:	edca 7a06 	vstr	s15, [sl, #24]
	oval_ltimers_ers_ldir_waitTime.new_val_flag = &menue_lift_data_newdata_flag;
  40776c:	f8ca 7020 	str.w	r7, [sl, #32]
	oval_ltimers_ers_ldir_waitTime.unit = "Sec";
  407770:	f8ca e00c 	str.w	lr, [sl, #12]
	ltimers_ers_ldir_waitTime.option_save_val = &oval_ltimers_ers_ldir_waitTime;
  407774:	f8c4 a1dc 	str.w	sl, [r4, #476]	; 0x1dc
	fill_menue_list(&menue_timers,opt_timers,OPT_TIMERS_MAX, 0, 0);
  407778:	47a8      	blx	r5
	
	return &menue_timers;
  40777a:	4648      	mov	r0, r9
  40777c:	b003      	add	sp, #12
  40777e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  407782:	bf00      	nop
  407784:	204051e3 	.word	0x204051e3
  407788:	20404654 	.word	0x20404654
  40778c:	204043a4 	.word	0x204043a4
  407790:	42480000 	.word	0x42480000
  407794:	204008ea 	.word	0x204008ea
  407798:	20404450 	.word	0x20404450
  40779c:	0041b208 	.word	0x0041b208
  4077a0:	0041b27c 	.word	0x0041b27c
  4077a4:	0041b2ec 	.word	0x0041b2ec
  4077a8:	0041b2fc 	.word	0x0041b2fc
  4077ac:	204046c0 	.word	0x204046c0
  4077b0:	0041b30c 	.word	0x0041b30c
  4077b4:	4479c000 	.word	0x4479c000
  4077b8:	0041b31c 	.word	0x0041b31c
  4077bc:	0041b32c 	.word	0x0041b32c
  4077c0:	2040469c 	.word	0x2040469c
  4077c4:	43340000 	.word	0x43340000
  4077c8:	204043ec 	.word	0x204043ec
  4077cc:	447a0000 	.word	0x447a0000
  4077d0:	20404410 	.word	0x20404410
  4077d4:	0041b344 	.word	0x0041b344
  4077d8:	2040435c 	.word	0x2040435c
  4077dc:	204043c8 	.word	0x204043c8
  4077e0:	0041b378 	.word	0x0041b378
  4077e4:	0040b0ad 	.word	0x0040b0ad
  4077e8:	20404380 	.word	0x20404380
  4077ec:	0041b218 	.word	0x0041b218
  4077f0:	0041a8d4 	.word	0x0041a8d4
  4077f4:	0041b28c 	.word	0x0041b28c
  4077f8:	0041b354 	.word	0x0041b354
  4077fc:	0041b364 	.word	0x0041b364
  407800:	20404630 	.word	0x20404630
  407804:	0041b33c 	.word	0x0041b33c
  407808:	461c3c00 	.word	0x461c3c00
  40780c:	0041b388 	.word	0x0041b388
  407810:	204046e4 	.word	0x204046e4
  407814:	20404434 	.word	0x20404434
  407818:	20404678 	.word	0x20404678

0040781c <make_i_call>:
option_val_t oval_set_password;
option_val_t oval_req;

uint8_t req = 0;
void make_i_call(void)
{
  40781c:	b510      	push	{r4, lr}
	insert_irequest(req);
  40781e:	4c03      	ldr	r4, [pc, #12]	; (40782c <make_i_call+0x10>)
  407820:	4b03      	ldr	r3, [pc, #12]	; (407830 <make_i_call+0x14>)
  407822:	7820      	ldrb	r0, [r4, #0]
  407824:	4798      	blx	r3
	req = 0;
  407826:	2300      	movs	r3, #0
  407828:	7023      	strb	r3, [r4, #0]
  40782a:	bd10      	pop	{r4, pc}
  40782c:	204008b1 	.word	0x204008b1
  407830:	00400f31 	.word	0x00400f31

00407834 <menue_util_init>:
}
void menue_util_init(menue_design_image_t *imgae_menue)
{
  407834:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	fill_menue_image(imgae_menue, &menue_util, advanced_p, "Utilities (U)", &menue_lift_data_applied.set_password);
  407838:	4a2f      	ldr	r2, [pc, #188]	; (4078f8 <menue_util_init+0xc4>)
{
  40783a:	b083      	sub	sp, #12
	fill_menue_image(imgae_menue, &menue_util, advanced_p, "Utilities (U)", &menue_lift_data_applied.set_password);
  40783c:	4d2f      	ldr	r5, [pc, #188]	; (4078fc <menue_util_init+0xc8>)
{
  40783e:	4681      	mov	r9, r0
	fill_menue_image(imgae_menue, &menue_util, advanced_p, "Utilities (U)", &menue_lift_data_applied.set_password);
  407840:	9200      	str	r2, [sp, #0]
	util_time_date.text = "Date/Time";
	util_time_date.child = menue_util_date_time_init();
//////////////////////////////////////////////////////////////////////////
	utii_pass.text = "Setup Password";
	oval_set_password.data_types = uint16_dt;
	oval_set_password.mantissa_count = 0;
  407842:	2600      	movs	r6, #0
	fill_menue_image(imgae_menue, &menue_util, advanced_p, "Utilities (U)", &menue_lift_data_applied.set_password);
  407844:	4629      	mov	r1, r5
  407846:	4b2e      	ldr	r3, [pc, #184]	; (407900 <menue_util_init+0xcc>)
  407848:	4a2e      	ldr	r2, [pc, #184]	; (407904 <menue_util_init+0xd0>)
	oval_set_password.real_count = 4;
	oval_set_password.max_value = 9999;
	oval_set_password.min_value = 0;
  40784a:	f04f 0800 	mov.w	r8, #0
	fill_menue_image(imgae_menue, &menue_util, advanced_p, "Utilities (U)", &menue_lift_data_applied.set_password);
  40784e:	4c2e      	ldr	r4, [pc, #184]	; (407908 <menue_util_init+0xd4>)
  407850:	47a0      	blx	r4
	util_ioset.text = "IO addressing";
  407852:	4c2e      	ldr	r4, [pc, #184]	; (40790c <menue_util_init+0xd8>)
  407854:	4a2e      	ldr	r2, [pc, #184]	; (407910 <menue_util_init+0xdc>)
	util_ioset.child = menue_util_io_init();
  407856:	4b2f      	ldr	r3, [pc, #188]	; (407914 <menue_util_init+0xe0>)
	util_ioset.text = "IO addressing";
  407858:	6022      	str	r2, [r4, #0]
	util_ioset.child = menue_util_io_init();
  40785a:	4798      	blx	r3
	util_time_date.text = "Date/Time";
  40785c:	4a2e      	ldr	r2, [pc, #184]	; (407918 <menue_util_init+0xe4>)
	util_time_date.child = menue_util_date_time_init();
  40785e:	4b2f      	ldr	r3, [pc, #188]	; (40791c <menue_util_init+0xe8>)
	util_time_date.text = "Date/Time";
  407860:	62a2      	str	r2, [r4, #40]	; 0x28
	util_ioset.child = menue_util_io_init();
  407862:	6220      	str	r0, [r4, #32]
	util_time_date.child = menue_util_date_time_init();
  407864:	4798      	blx	r3
  407866:	64a0      	str	r0, [r4, #72]	; 0x48
	util_restore.confirmed_sub = &menue_data_manager_restore;	
	util_save.text = "Save all data";
	util_save.confirm_msg = "Are you sure?";
	util_save.confirmed_sub = &menue_data_manager_save;
	
	fill_menue_list(&menue_util, opt_util, OPT_UTIL_MAX, imgae_menue, 0);
  407868:	4628      	mov	r0, r5
	util_restore.confirmed_sub = &menue_data_manager_restore;	
  40786a:	4d2d      	ldr	r5, [pc, #180]	; (407920 <menue_util_init+0xec>)
	fill_menue_list(&menue_util, opt_util, OPT_UTIL_MAX, imgae_menue, 0);
  40786c:	9600      	str	r6, [sp, #0]
	oval_set_password.real_count = 4;
  40786e:	f04f 0e04 	mov.w	lr, #4
	util_restore.confirmed_sub = &menue_data_manager_restore;	
  407872:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
	oval_set_password.data_types = uint16_dt;
  407876:	f04f 0c01 	mov.w	ip, #1
	util_restore.text = "Restore factory set";
  40787a:	4f2a      	ldr	r7, [pc, #168]	; (407924 <menue_util_init+0xf0>)
	fill_menue_list(&menue_util, opt_util, OPT_UTIL_MAX, imgae_menue, 0);
  40787c:	464b      	mov	r3, r9
	util_save.confirmed_sub = &menue_data_manager_save;
  40787e:	4d2a      	ldr	r5, [pc, #168]	; (407928 <menue_util_init+0xf4>)
	fill_menue_list(&menue_util, opt_util, OPT_UTIL_MAX, imgae_menue, 0);
  407880:	4621      	mov	r1, r4
	util_restore.text = "Restore factory set";
  407882:	67a7      	str	r7, [r4, #120]	; 0x78
	util_save.confirmed_sub = &menue_data_manager_save;
  407884:	f8c4 50bc 	str.w	r5, [r4, #188]	; 0xbc
	util_save.text = "Save all data";
  407888:	4f28      	ldr	r7, [pc, #160]	; (40792c <menue_util_init+0xf8>)
	oval_set_password.data_types = uint16_dt;
  40788a:	4d29      	ldr	r5, [pc, #164]	; (407930 <menue_util_init+0xfc>)
	util_save.text = "Save all data";
  40788c:	f8c4 70a0 	str.w	r7, [r4, #160]	; 0xa0
	oval_set_password.real_count = 4;
  407890:	f8c5 e004 	str.w	lr, [r5, #4]
	oval_set_password.max_value = 9999;
  407894:	4f27      	ldr	r7, [pc, #156]	; (407934 <menue_util_init+0x100>)
	oval_set_password.val = &menue_lift_data_setup.set_password;
  407896:	f8df e0bc 	ldr.w	lr, [pc, #188]	; 407954 <menue_util_init+0x120>
	oval_set_password.max_value = 9999;
  40789a:	616f      	str	r7, [r5, #20]
	oval_set_password.val = &menue_lift_data_setup.set_password;
  40789c:	f8c5 e01c 	str.w	lr, [r5, #28]
	oval_set_password.new_val_flag = &menue_lift_data_newdata_flag;
  4078a0:	4f25      	ldr	r7, [pc, #148]	; (407938 <menue_util_init+0x104>)
	util_restore.confirm_msg = "Are you sure?";
  4078a2:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 407958 <menue_util_init+0x124>
	utii_pass.text = "Setup Password";
  4078a6:	4a25      	ldr	r2, [pc, #148]	; (40793c <menue_util_init+0x108>)
	utii_pass.option_save_val = &oval_set_password;
  4078a8:	6765      	str	r5, [r4, #116]	; 0x74
	utii_pass.text = "Setup Password";
  4078aa:	6522      	str	r2, [r4, #80]	; 0x50
	fill_menue_list(&menue_util, opt_util, OPT_UTIL_MAX, imgae_menue, 0);
  4078ac:	2206      	movs	r2, #6
	oval_set_password.data_types = uint16_dt;
  4078ae:	f885 c000 	strb.w	ip, [r5]
	oval_set_password.mantissa_count = 0;
  4078b2:	60ae      	str	r6, [r5, #8]
	oval_set_password.min_value = 0;
  4078b4:	f8c5 8018 	str.w	r8, [r5, #24]
	oval_set_password.new_val_flag = &menue_lift_data_newdata_flag;
  4078b8:	622f      	str	r7, [r5, #32]
	util_restore.confirm_msg = "Are you sure?";
  4078ba:	f8c4 e07c 	str.w	lr, [r4, #124]	; 0x7c
	util_save.confirm_msg = "Are you sure?";
  4078be:	f8c4 e0a4 	str.w	lr, [r4, #164]	; 0xa4
	fill_menue_list(&menue_util, opt_util, OPT_UTIL_MAX, imgae_menue, 0);
  4078c2:	4d1f      	ldr	r5, [pc, #124]	; (407940 <menue_util_init+0x10c>)
  4078c4:	47a8      	blx	r5
	
	//////////////////////////////////////////////////////////////////////////
	util_req.text = "internal call";
	oval_req.data_types = uint8_dt;
  4078c6:	4b1f      	ldr	r3, [pc, #124]	; (407944 <menue_util_init+0x110>)
	oval_req.mantissa_count = 0;
	oval_req.real_count = 2;
	oval_req.max_value = 31;
  4078c8:	481f      	ldr	r0, [pc, #124]	; (407948 <menue_util_init+0x114>)
	oval_req.real_count = 2;
  4078ca:	2502      	movs	r5, #2
	util_req.text = "internal call";
  4078cc:	f8df e08c 	ldr.w	lr, [pc, #140]	; 40795c <menue_util_init+0x128>
	oval_req.min_value = 0;
	oval_req.new_val_flag = &menue_lift_data_newdata_flag;
	//oval_req.unit = "A";
	//oval_req.text = "When this time elapse if the lift couldn't find the door level signal it will stop flaging an error";
	oval_req.val = &req;
  4078d0:	491e      	ldr	r1, [pc, #120]	; (40794c <menue_util_init+0x118>)
	util_req.option_save_val = &oval_req;
	util_req.exit_menue = &make_i_call;
  4078d2:	4a1f      	ldr	r2, [pc, #124]	; (407950 <menue_util_init+0x11c>)
	util_req.text = "internal call";
  4078d4:	f8c4 e0c8 	str.w	lr, [r4, #200]	; 0xc8
	oval_req.min_value = 0;
  4078d8:	f8c3 8018 	str.w	r8, [r3, #24]
	oval_req.data_types = uint8_dt;
  4078dc:	701e      	strb	r6, [r3, #0]
	oval_req.mantissa_count = 0;
  4078de:	609e      	str	r6, [r3, #8]
	oval_req.new_val_flag = &menue_lift_data_newdata_flag;
  4078e0:	621f      	str	r7, [r3, #32]
	util_req.option_save_val = &oval_req;
  4078e2:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
	oval_req.real_count = 2;
  4078e6:	605d      	str	r5, [r3, #4]
	oval_req.max_value = 31;
  4078e8:	6158      	str	r0, [r3, #20]
	oval_req.val = &req;
  4078ea:	61d9      	str	r1, [r3, #28]
	util_req.exit_menue = &make_i_call;
  4078ec:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
  4078f0:	b003      	add	sp, #12
  4078f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4078f6:	bf00      	nop
  4078f8:	20405384 	.word	0x20405384
  4078fc:	20404840 	.word	0x20404840
  407900:	0041b39c 	.word	0x0041b39c
  407904:	00419aa8 	.word	0x00419aa8
  407908:	0040b0d5 	.word	0x0040b0d5
  40790c:	20404750 	.word	0x20404750
  407910:	0041b3ac 	.word	0x0041b3ac
  407914:	00407d55 	.word	0x00407d55
  407918:	0041a714 	.word	0x0041a714
  40791c:	00407961 	.word	0x00407961
  407920:	00409e31 	.word	0x00409e31
  407924:	0041b154 	.word	0x0041b154
  407928:	00409d5d 	.word	0x00409d5d
  40792c:	0041b3cc 	.word	0x0041b3cc
  407930:	2040472c 	.word	0x2040472c
  407934:	461c3c00 	.word	0x461c3c00
  407938:	204008ea 	.word	0x204008ea
  40793c:	0041b3bc 	.word	0x0041b3bc
  407940:	0040b0ad 	.word	0x0040b0ad
  407944:	20404708 	.word	0x20404708
  407948:	41f80000 	.word	0x41f80000
  40794c:	204008b1 	.word	0x204008b1
  407950:	0040781d 	.word	0x0040781d
  407954:	204052b0 	.word	0x204052b0
  407958:	0041aa40 	.word	0x0041aa40
  40795c:	0041b3dc 	.word	0x0041b3dc

00407960 <menue_util_date_time_init>:
#define udate	          (opt_util_date_time[0])
#define utime	          (opt_util_date_time[1])


menue_design_t *menue_util_date_time_init(void)
{
  407960:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	utime.text = "Set time";
	utime.option_save_val = 2; //set time option
	//////////////////////////////////////////////////////////////////////////

	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  407962:	2300      	movs	r3, #0
	udate.text = "Set date";
  407964:	4c09      	ldr	r4, [pc, #36]	; (40798c <menue_util_date_time_init+0x2c>)
{
  407966:	b083      	sub	sp, #12
	utime.option_save_val = 2; //set time option
  407968:	2602      	movs	r6, #2
	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  40796a:	4d09      	ldr	r5, [pc, #36]	; (407990 <menue_util_date_time_init+0x30>)
	udate.option_save_val = 1; //set date option
  40796c:	2001      	movs	r0, #1
	udate.text = "Set date";
  40796e:	4a09      	ldr	r2, [pc, #36]	; (407994 <menue_util_date_time_init+0x34>)
	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  407970:	4621      	mov	r1, r4
	utime.text = "Set time";
  407972:	4f09      	ldr	r7, [pc, #36]	; (407998 <menue_util_date_time_init+0x38>)
	udate.text = "Set date";
  407974:	6022      	str	r2, [r4, #0]
	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  407976:	4632      	mov	r2, r6
	udate.option_save_val = 1; //set date option
  407978:	6260      	str	r0, [r4, #36]	; 0x24
	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  40797a:	4628      	mov	r0, r5
	utime.text = "Set time";
  40797c:	62a7      	str	r7, [r4, #40]	; 0x28
	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  40797e:	9300      	str	r3, [sp, #0]
  407980:	4f06      	ldr	r7, [pc, #24]	; (40799c <menue_util_date_time_init+0x3c>)
	utime.option_save_val = 2; //set time option
  407982:	64e6      	str	r6, [r4, #76]	; 0x4c
	fill_menue_list(&menue_util_date_time, opt_util_date_time, OPT_UTIL_DATE_TIME_MAX, 0, 0);
  407984:	47b8      	blx	r7

	return &menue_util_date_time;
  407986:	4628      	mov	r0, r5
  407988:	b003      	add	sp, #12
  40798a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40798c:	2040485c 	.word	0x2040485c
  407990:	204048ac 	.word	0x204048ac
  407994:	0041a720 	.word	0x0041a720
  407998:	0041a72c 	.word	0x0041a72c
  40799c:	0040b0ad 	.word	0x0040b0ad

004079a0 <uhoist_mstp_init>:
#define uhoist_dnfdl2         (opt_util_hoist[24])
menue_design_t *hoist_io_options;

void uhoist_mstp_init(void)
{
	menue_util_hoist_show(0);
  4079a0:	2000      	movs	r0, #0
  4079a2:	4b01      	ldr	r3, [pc, #4]	; (4079a8 <uhoist_mstp_init+0x8>)
  4079a4:	4718      	bx	r3
  4079a6:	bf00      	nop
  4079a8:	0040717d 	.word	0x0040717d

004079ac <uhoist_sel_init>:
}

void uhoist_sel_init(void)
{
	menue_util_hoist_show(1);
  4079ac:	2001      	movs	r0, #1
  4079ae:	4b01      	ldr	r3, [pc, #4]	; (4079b4 <uhoist_sel_init+0x8>)
  4079b0:	4718      	bx	r3
  4079b2:	bf00      	nop
  4079b4:	0040717d 	.word	0x0040717d

004079b8 <uhoist_estp_init>:
}

void uhoist_estp_init(void)
{
	menue_util_hoist_show(2);
  4079b8:	2002      	movs	r0, #2
  4079ba:	4b01      	ldr	r3, [pc, #4]	; (4079c0 <uhoist_estp_init+0x8>)
  4079bc:	4718      	bx	r3
  4079be:	bf00      	nop
  4079c0:	0040717d 	.word	0x0040717d

004079c4 <uhoist_shk_init>:
}

void uhoist_shk_init(void)
{
	menue_util_hoist_show(3);
  4079c4:	2003      	movs	r0, #3
  4079c6:	4b01      	ldr	r3, [pc, #4]	; (4079cc <uhoist_shk_init+0x8>)
  4079c8:	4718      	bx	r3
  4079ca:	bf00      	nop
  4079cc:	0040717d 	.word	0x0040717d

004079d0 <uhoist_lock_init>:
}

void uhoist_lock_init(void)
{
	menue_util_hoist_show(4);
  4079d0:	2004      	movs	r0, #4
  4079d2:	4b01      	ldr	r3, [pc, #4]	; (4079d8 <uhoist_lock_init+0x8>)
  4079d4:	4718      	bx	r3
  4079d6:	bf00      	nop
  4079d8:	0040717d 	.word	0x0040717d

004079dc <uhoist_fire_init>:
}

void uhoist_fire_init(void)
{
	menue_util_hoist_show(5);
  4079dc:	2005      	movs	r0, #5
  4079de:	4b01      	ldr	r3, [pc, #4]	; (4079e4 <uhoist_fire_init+0x8>)
  4079e0:	4718      	bx	r3
  4079e2:	bf00      	nop
  4079e4:	0040717d 	.word	0x0040717d

004079e8 <uhoist_ins_init>:
}
void uhoist_ins_init(void)
{
	menue_util_hoist_show(6);
  4079e8:	2006      	movs	r0, #6
  4079ea:	4b01      	ldr	r3, [pc, #4]	; (4079f0 <uhoist_ins_init+0x8>)
  4079ec:	4718      	bx	r3
  4079ee:	bf00      	nop
  4079f0:	0040717d 	.word	0x0040717d

004079f4 <uhoist_iup_init>:
}

void uhoist_iup_init(void)
{
	menue_util_hoist_show(7);
  4079f4:	2007      	movs	r0, #7
  4079f6:	4b01      	ldr	r3, [pc, #4]	; (4079fc <uhoist_iup_init+0x8>)
  4079f8:	4718      	bx	r3
  4079fa:	bf00      	nop
  4079fc:	0040717d 	.word	0x0040717d

00407a00 <uhoist_idn_init>:
}

void uhoist_idn_init(void)
{
	menue_util_hoist_show(8);
  407a00:	2008      	movs	r0, #8
  407a02:	4b01      	ldr	r3, [pc, #4]	; (407a08 <uhoist_idn_init+0x8>)
  407a04:	4718      	bx	r3
  407a06:	bf00      	nop
  407a08:	0040717d 	.word	0x0040717d

00407a0c <uhoist_upl_init>:
}

void uhoist_upl_init(void)
{
	menue_util_hoist_show(9);
  407a0c:	2009      	movs	r0, #9
  407a0e:	4b01      	ldr	r3, [pc, #4]	; (407a14 <uhoist_upl_init+0x8>)
  407a10:	4718      	bx	r3
  407a12:	bf00      	nop
  407a14:	0040717d 	.word	0x0040717d

00407a18 <uhoist_dnl_init>:
}
void uhoist_dnl_init(void)
{
	menue_util_hoist_show(10);
  407a18:	200a      	movs	r0, #10
  407a1a:	4b01      	ldr	r3, [pc, #4]	; (407a20 <uhoist_dnl_init+0x8>)
  407a1c:	4718      	bx	r3
  407a1e:	bf00      	nop
  407a20:	0040717d 	.word	0x0040717d

00407a24 <uhoist_fw_init>:
}

void uhoist_fw_init(void)
{
	menue_util_hoist_show(11);
  407a24:	200b      	movs	r0, #11
  407a26:	4b01      	ldr	r3, [pc, #4]	; (407a2c <uhoist_fw_init+0x8>)
  407a28:	4718      	bx	r3
  407a2a:	bf00      	nop
  407a2c:	0040717d 	.word	0x0040717d

00407a30 <uhoist_ow_init>:
}

void uhoist_ow_init(void)
{
	menue_util_hoist_show(12);
  407a30:	200c      	movs	r0, #12
  407a32:	4b01      	ldr	r3, [pc, #4]	; (407a38 <uhoist_ow_init+0x8>)
  407a34:	4718      	bx	r3
  407a36:	bf00      	nop
  407a38:	0040717d 	.word	0x0040717d

00407a3c <uhoist_hopen_init>:
}

void uhoist_hopen_init(void)
{
	menue_util_hoist_show(13);
  407a3c:	200d      	movs	r0, #13
  407a3e:	4b01      	ldr	r3, [pc, #4]	; (407a44 <uhoist_hopen_init+0x8>)
  407a40:	4718      	bx	r3
  407a42:	bf00      	nop
  407a44:	0040717d 	.word	0x0040717d

00407a48 <uhoist_hclose_init>:
}

void uhoist_hclose_init(void)
{
	menue_util_hoist_show(14);
  407a48:	200e      	movs	r0, #14
  407a4a:	4b01      	ldr	r3, [pc, #4]	; (407a50 <uhoist_hclose_init+0x8>)
  407a4c:	4718      	bx	r3
  407a4e:	bf00      	nop
  407a50:	0040717d 	.word	0x0040717d

00407a54 <uhoist_ersin_init>:
}

void uhoist_ersin_init(void)
{
	menue_util_hoist_show(15);
  407a54:	200f      	movs	r0, #15
  407a56:	4b01      	ldr	r3, [pc, #4]	; (407a5c <uhoist_ersin_init+0x8>)
  407a58:	4718      	bx	r3
  407a5a:	bf00      	nop
  407a5c:	0040717d 	.word	0x0040717d

00407a60 <uhoist_mConFB_init>:
}

void uhoist_mConFB_init(void)
{
	menue_util_hoist_show(16);
  407a60:	2010      	movs	r0, #16
  407a62:	4b01      	ldr	r3, [pc, #4]	; (407a68 <uhoist_mConFB_init+0x8>)
  407a64:	4718      	bx	r3
  407a66:	bf00      	nop
  407a68:	0040717d 	.word	0x0040717d

00407a6c <uhoist_bkConFB_init>:
}

void uhoist_bkConFB_init(void)
{
	menue_util_hoist_show(17);
  407a6c:	2011      	movs	r0, #17
  407a6e:	4b01      	ldr	r3, [pc, #4]	; (407a74 <uhoist_bkConFB_init+0x8>)
  407a70:	4718      	bx	r3
  407a72:	bf00      	nop
  407a74:	0040717d 	.word	0x0040717d

00407a78 <uhoist_fxConFB_init>:
}

void uhoist_fxConFB_init(void)
{
	menue_util_hoist_show(18);
  407a78:	2012      	movs	r0, #18
  407a7a:	4b01      	ldr	r3, [pc, #4]	; (407a80 <uhoist_fxConFB_init+0x8>)
  407a7c:	4718      	bx	r3
  407a7e:	bf00      	nop
  407a80:	0040717d 	.word	0x0040717d

00407a84 <uhoist_upfl_init>:
}

void uhoist_upfl_init(void)
{
	menue_util_hoist_show(19);
  407a84:	2013      	movs	r0, #19
  407a86:	4b01      	ldr	r3, [pc, #4]	; (407a8c <uhoist_upfl_init+0x8>)
  407a88:	4718      	bx	r3
  407a8a:	bf00      	nop
  407a8c:	0040717d 	.word	0x0040717d

00407a90 <uhoist_dnfl_init>:
}

void uhoist_dnfl_init(void)
{
	menue_util_hoist_show(20);
  407a90:	2014      	movs	r0, #20
  407a92:	4b01      	ldr	r3, [pc, #4]	; (407a98 <uhoist_dnfl_init+0x8>)
  407a94:	4718      	bx	r3
  407a96:	bf00      	nop
  407a98:	0040717d 	.word	0x0040717d

00407a9c <uhoist_upfdl1_init>:
}

void uhoist_upfdl1_init(void)
{
	menue_util_hoist_show(21);
  407a9c:	2015      	movs	r0, #21
  407a9e:	4b01      	ldr	r3, [pc, #4]	; (407aa4 <uhoist_upfdl1_init+0x8>)
  407aa0:	4718      	bx	r3
  407aa2:	bf00      	nop
  407aa4:	0040717d 	.word	0x0040717d

00407aa8 <uhoist_upfdl2_init>:
}

void uhoist_upfdl2_init(void)
{
	menue_util_hoist_show(22);
  407aa8:	2016      	movs	r0, #22
  407aaa:	4b01      	ldr	r3, [pc, #4]	; (407ab0 <uhoist_upfdl2_init+0x8>)
  407aac:	4718      	bx	r3
  407aae:	bf00      	nop
  407ab0:	0040717d 	.word	0x0040717d

00407ab4 <uhoist_dnfdl1_init>:
}

void uhoist_dnfdl1_init(void)
{
	menue_util_hoist_show(23);
  407ab4:	2017      	movs	r0, #23
  407ab6:	4b01      	ldr	r3, [pc, #4]	; (407abc <uhoist_dnfdl1_init+0x8>)
  407ab8:	4718      	bx	r3
  407aba:	bf00      	nop
  407abc:	0040717d 	.word	0x0040717d

00407ac0 <uhoist_dnfdl2_init>:
}

void uhoist_dnfdl2_init(void)
{
	menue_util_hoist_show(24);
  407ac0:	2018      	movs	r0, #24
  407ac2:	4b01      	ldr	r3, [pc, #4]	; (407ac8 <uhoist_dnfdl2_init+0x8>)
  407ac4:	4718      	bx	r3
  407ac6:	bf00      	nop
  407ac8:	0040717d 	.word	0x0040717d

00407acc <menue_util_hoist_init>:
}

menue_design_t *menue_util_hoist_init(void)
{
  407acc:	b5f0      	push	{r4, r5, r6, r7, lr}
	hoist_io_options = menue_util_hoist_i_init();
  407ace:	4b6a      	ldr	r3, [pc, #424]	; (407c78 <menue_util_hoist_init+0x1ac>)
{
  407ad0:	b083      	sub	sp, #12
	
	uhoist_mstp.text = "Door level signal";
  407ad2:	4c6a      	ldr	r4, [pc, #424]	; (407c7c <menue_util_hoist_init+0x1b0>)
	hoist_io_options = menue_util_hoist_i_init();
  407ad4:	4798      	blx	r3
  407ad6:	4605      	mov	r5, r0
	uhoist_mstp.child = hoist_io_options;
	uhoist_mstp.enter = &uhoist_mstp_init;
	//////////////////////////////////////////////////////////////////////////
	
	uhoist_sel.text = "Door counter signal";
  407ad8:	4869      	ldr	r0, [pc, #420]	; (407c80 <menue_util_hoist_init+0x1b4>)
	uhoist_sel.child = hoist_io_options;
	uhoist_sel.enter = &uhoist_sel_init;
  407ada:	4e6a      	ldr	r6, [pc, #424]	; (407c84 <menue_util_hoist_init+0x1b8>)
	
	uhoist_dnfdl2.text = " Down f_decel lmt2";
	uhoist_dnfdl2.child = hoist_io_options;
	uhoist_dnfdl2.enter = &uhoist_dnfdl2_init;
	//////////////////////////////////////////////////////////////////////////		
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407adc:	4621      	mov	r1, r4
	uhoist_sel.text = "Door counter signal";
  407ade:	62a0      	str	r0, [r4, #40]	; 0x28
	uhoist_shk.enter = &uhoist_shk_init;
  407ae0:	4869      	ldr	r0, [pc, #420]	; (407c88 <menue_util_hoist_init+0x1bc>)
	uhoist_sel.enter = &uhoist_sel_init;
  407ae2:	63e6      	str	r6, [r4, #60]	; 0x3c
	uhoist_shk.enter = &uhoist_shk_init;
  407ae4:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
	uhoist_ins.text = "Inspection";
  407ae8:	4868      	ldr	r0, [pc, #416]	; (407c8c <menue_util_hoist_init+0x1c0>)
	uhoist_lock.text = "Lock contact";
  407aea:	4e69      	ldr	r6, [pc, #420]	; (407c90 <menue_util_hoist_init+0x1c4>)
	uhoist_ins.text = "Inspection";
  407aec:	f8c4 00f0 	str.w	r0, [r4, #240]	; 0xf0
	uhoist_iup.text = "Inspection up";
  407af0:	4868      	ldr	r0, [pc, #416]	; (407c94 <menue_util_hoist_init+0x1c8>)
	uhoist_lock.text = "Lock contact";
  407af2:	f8c4 60a0 	str.w	r6, [r4, #160]	; 0xa0
	uhoist_iup.text = "Inspection up";
  407af6:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
	uhoist_ins.enter = &uhoist_ins_init;
  407afa:	4e67      	ldr	r6, [pc, #412]	; (407c98 <menue_util_hoist_init+0x1cc>)
	uhoist_idn.text = "Inspection down";
  407afc:	4867      	ldr	r0, [pc, #412]	; (407c9c <menue_util_hoist_init+0x1d0>)
	uhoist_ins.enter = &uhoist_ins_init;
  407afe:	f8c4 6104 	str.w	r6, [r4, #260]	; 0x104
	uhoist_idn.text = "Inspection down";
  407b02:	f8c4 0140 	str.w	r0, [r4, #320]	; 0x140
	uhoist_mstp.text = "Door level signal";
  407b06:	4b66      	ldr	r3, [pc, #408]	; (407ca0 <menue_util_hoist_init+0x1d4>)
	uhoist_mstp.enter = &uhoist_mstp_init;
  407b08:	4a66      	ldr	r2, [pc, #408]	; (407ca4 <menue_util_hoist_init+0x1d8>)
	uhoist_iup.enter = &uhoist_iup_init;
  407b0a:	4e67      	ldr	r6, [pc, #412]	; (407ca8 <menue_util_hoist_init+0x1dc>)
	uhoist_upl.text = "Up f_decel lmt0";
  407b0c:	4867      	ldr	r0, [pc, #412]	; (407cac <menue_util_hoist_init+0x1e0>)
	uhoist_mstp.text = "Door level signal";
  407b0e:	6023      	str	r3, [r4, #0]
	uhoist_mstp.enter = &uhoist_mstp_init;
  407b10:	6162      	str	r2, [r4, #20]
	uhoist_iup.enter = &uhoist_iup_init;
  407b12:	f8c4 612c 	str.w	r6, [r4, #300]	; 0x12c
	uhoist_upl.text = "Up f_decel lmt0";
  407b16:	f8c4 0168 	str.w	r0, [r4, #360]	; 0x168
	hoist_io_options = menue_util_hoist_i_init();
  407b1a:	4f65      	ldr	r7, [pc, #404]	; (407cb0 <menue_util_hoist_init+0x1e4>)
	uhoist_estp.enter = &uhoist_estp_init;
  407b1c:	4b65      	ldr	r3, [pc, #404]	; (407cb4 <menue_util_hoist_init+0x1e8>)
	uhoist_shk.text = "Fork contact";
  407b1e:	4a66      	ldr	r2, [pc, #408]	; (407cb8 <menue_util_hoist_init+0x1ec>)
	uhoist_idn.enter = &uhoist_idn_init;
  407b20:	4e66      	ldr	r6, [pc, #408]	; (407cbc <menue_util_hoist_init+0x1f0>)
	uhoist_dnl.text = "Down f_decel lmt0";
  407b22:	4867      	ldr	r0, [pc, #412]	; (407cc0 <menue_util_hoist_init+0x1f4>)
	hoist_io_options = menue_util_hoist_i_init();
  407b24:	603d      	str	r5, [r7, #0]
	uhoist_estp.enter = &uhoist_estp_init;
  407b26:	6663      	str	r3, [r4, #100]	; 0x64
	uhoist_shk.text = "Fork contact";
  407b28:	67a2      	str	r2, [r4, #120]	; 0x78
	uhoist_idn.enter = &uhoist_idn_init;
  407b2a:	f8c4 6154 	str.w	r6, [r4, #340]	; 0x154
	uhoist_dnl.text = "Down f_decel lmt0";
  407b2e:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	uhoist_estp.text = "Emergency stop";
  407b32:	4f64      	ldr	r7, [pc, #400]	; (407cc4 <menue_util_hoist_init+0x1f8>)
	uhoist_lock.enter = &uhoist_lock_init;
  407b34:	f8df e210 	ldr.w	lr, [pc, #528]	; 407d48 <menue_util_hoist_init+0x27c>
	uhoist_fire.text = "Fire mode";
  407b38:	4b63      	ldr	r3, [pc, #396]	; (407cc8 <menue_util_hoist_init+0x1fc>)
	uhoist_fire.enter = &uhoist_fire_init;
  407b3a:	4a64      	ldr	r2, [pc, #400]	; (407ccc <menue_util_hoist_init+0x200>)
	uhoist_upl.enter = &uhoist_upl_init;
  407b3c:	4e64      	ldr	r6, [pc, #400]	; (407cd0 <menue_util_hoist_init+0x204>)
	uhoist_fw.text = "Full weight";
  407b3e:	4865      	ldr	r0, [pc, #404]	; (407cd4 <menue_util_hoist_init+0x208>)
	uhoist_mstp.child = hoist_io_options;
  407b40:	6225      	str	r5, [r4, #32]
	uhoist_sel.child = hoist_io_options;
  407b42:	64a5      	str	r5, [r4, #72]	; 0x48
	uhoist_estp.child = hoist_io_options;
  407b44:	6725      	str	r5, [r4, #112]	; 0x70
	uhoist_shk.child = hoist_io_options;
  407b46:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
	uhoist_lock.child = hoist_io_options;
  407b4a:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
	uhoist_fire.child = hoist_io_options;
  407b4e:	f8c4 50e8 	str.w	r5, [r4, #232]	; 0xe8
	uhoist_ins.child = hoist_io_options;
  407b52:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
	uhoist_iup.child = hoist_io_options;
  407b56:	f8c4 5138 	str.w	r5, [r4, #312]	; 0x138
	uhoist_idn.child = hoist_io_options;
  407b5a:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160
	uhoist_upl.child = hoist_io_options;
  407b5e:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
	uhoist_estp.text = "Emergency stop";
  407b62:	6527      	str	r7, [r4, #80]	; 0x50
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407b64:	2700      	movs	r7, #0
	uhoist_lock.enter = &uhoist_lock_init;
  407b66:	f8c4 e0b4 	str.w	lr, [r4, #180]	; 0xb4
	uhoist_fire.text = "Fire mode";
  407b6a:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407b6e:	463b      	mov	r3, r7
	uhoist_fire.enter = &uhoist_fire_init;
  407b70:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407b74:	2219      	movs	r2, #25
	uhoist_upl.enter = &uhoist_upl_init;
  407b76:	f8c4 617c 	str.w	r6, [r4, #380]	; 0x17c
	uhoist_dnl.child = hoist_io_options;
  407b7a:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
	uhoist_fw.enter = &uhoist_fw_init;
  407b7e:	4e56      	ldr	r6, [pc, #344]	; (407cd8 <menue_util_hoist_init+0x20c>)
	uhoist_fw.text = "Full weight";
  407b80:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
	uhoist_ow.text = "Over weight";
  407b84:	4855      	ldr	r0, [pc, #340]	; (407cdc <menue_util_hoist_init+0x210>)
	uhoist_fw.enter = &uhoist_fw_init;
  407b86:	f8c4 61cc 	str.w	r6, [r4, #460]	; 0x1cc
	uhoist_ow.text = "Over weight";
  407b8a:	f8c4 01e0 	str.w	r0, [r4, #480]	; 0x1e0
	uhoist_ow.enter = &uhoist_ow_init;
  407b8e:	4e54      	ldr	r6, [pc, #336]	; (407ce0 <menue_util_hoist_init+0x214>)
	uhoist_hopen.text = "Open door";
  407b90:	4854      	ldr	r0, [pc, #336]	; (407ce4 <menue_util_hoist_init+0x218>)
	uhoist_ow.enter = &uhoist_ow_init;
  407b92:	f8c4 61f4 	str.w	r6, [r4, #500]	; 0x1f4
	uhoist_hopen.text = "Open door";
  407b96:	f8c4 0208 	str.w	r0, [r4, #520]	; 0x208
	uhoist_hopen.enter = &uhoist_hopen_init;
  407b9a:	4e53      	ldr	r6, [pc, #332]	; (407ce8 <menue_util_hoist_init+0x21c>)
	uhoist_hclose.text = "Close door";
  407b9c:	4853      	ldr	r0, [pc, #332]	; (407cec <menue_util_hoist_init+0x220>)
	uhoist_hopen.enter = &uhoist_hopen_init;
  407b9e:	f8c4 621c 	str.w	r6, [r4, #540]	; 0x21c
	uhoist_hclose.text = "Close door";
  407ba2:	f8c4 0230 	str.w	r0, [r4, #560]	; 0x230
	uhoist_hclose.enter = &uhoist_hclose_init;
  407ba6:	4e52      	ldr	r6, [pc, #328]	; (407cf0 <menue_util_hoist_init+0x224>)
	uhoist_ersin.text = "ARD mode";
  407ba8:	4852      	ldr	r0, [pc, #328]	; (407cf4 <menue_util_hoist_init+0x228>)
	uhoist_hclose.enter = &uhoist_hclose_init;
  407baa:	f8c4 6244 	str.w	r6, [r4, #580]	; 0x244
	uhoist_ersin.text = "ARD mode";
  407bae:	f8c4 0258 	str.w	r0, [r4, #600]	; 0x258
	uhoist_ersin.enter = &uhoist_ersin_init;
  407bb2:	4e51      	ldr	r6, [pc, #324]	; (407cf8 <menue_util_hoist_init+0x22c>)
	uhoist_mConFB.text = "Main cont FBack";
  407bb4:	4851      	ldr	r0, [pc, #324]	; (407cfc <menue_util_hoist_init+0x230>)
	uhoist_ersin.enter = &uhoist_ersin_init;
  407bb6:	f8c4 626c 	str.w	r6, [r4, #620]	; 0x26c
	uhoist_mConFB.text = "Main cont FBack";
  407bba:	f8c4 0280 	str.w	r0, [r4, #640]	; 0x280
	uhoist_mConFB.enter = &uhoist_mConFB_init;
  407bbe:	4e50      	ldr	r6, [pc, #320]	; (407d00 <menue_util_hoist_init+0x234>)
	uhoist_bkConFB.text = "Brake cont FBack";
  407bc0:	4850      	ldr	r0, [pc, #320]	; (407d04 <menue_util_hoist_init+0x238>)
	uhoist_mConFB.enter = &uhoist_mConFB_init;
  407bc2:	f8c4 6294 	str.w	r6, [r4, #660]	; 0x294
	uhoist_bkConFB.text = "Brake cont FBack";
  407bc6:	f8c4 02a8 	str.w	r0, [r4, #680]	; 0x2a8
	uhoist_bkConFB.enter = &uhoist_bkConFB_init;
  407bca:	4e4f      	ldr	r6, [pc, #316]	; (407d08 <menue_util_hoist_init+0x23c>)
	uhoist_fxConFB.text = "Fx cont FBack";
  407bcc:	484f      	ldr	r0, [pc, #316]	; (407d0c <menue_util_hoist_init+0x240>)
	uhoist_bkConFB.enter = &uhoist_bkConFB_init;
  407bce:	f8c4 62bc 	str.w	r6, [r4, #700]	; 0x2bc
	uhoist_fxConFB.text = "Fx cont FBack";
  407bd2:	f8c4 02d0 	str.w	r0, [r4, #720]	; 0x2d0
	uhoist_fxConFB.enter = &uhoist_fxConFB_init;
  407bd6:	4e4e      	ldr	r6, [pc, #312]	; (407d10 <menue_util_hoist_init+0x244>)
	uhoist_upfl.text = "Up final limit";
  407bd8:	484e      	ldr	r0, [pc, #312]	; (407d14 <menue_util_hoist_init+0x248>)
	uhoist_fxConFB.enter = &uhoist_fxConFB_init;
  407bda:	f8c4 62e4 	str.w	r6, [r4, #740]	; 0x2e4
	uhoist_upfl.text = "Up final limit";
  407bde:	f8c4 02f8 	str.w	r0, [r4, #760]	; 0x2f8
	uhoist_upfl.enter = &uhoist_upfl_init;
  407be2:	4e4d      	ldr	r6, [pc, #308]	; (407d18 <menue_util_hoist_init+0x24c>)
	uhoist_dnfl.text = " Down final limit";
  407be4:	484d      	ldr	r0, [pc, #308]	; (407d1c <menue_util_hoist_init+0x250>)
	uhoist_upfl.enter = &uhoist_upfl_init;
  407be6:	f8c4 630c 	str.w	r6, [r4, #780]	; 0x30c
	uhoist_dnfl.text = " Down final limit";
  407bea:	f8c4 0320 	str.w	r0, [r4, #800]	; 0x320
	uhoist_dnl.enter = &uhoist_dnl_init;
  407bee:	f8df e15c 	ldr.w	lr, [pc, #348]	; 407d4c <menue_util_hoist_init+0x280>
	uhoist_dnfl.enter = &uhoist_dnfl_init;
  407bf2:	4e4b      	ldr	r6, [pc, #300]	; (407d20 <menue_util_hoist_init+0x254>)
	uhoist_upfdl1.text = " Up f_decel lmt1";
  407bf4:	484b      	ldr	r0, [pc, #300]	; (407d24 <menue_util_hoist_init+0x258>)
	uhoist_fw.child = hoist_io_options;
  407bf6:	f8c4 51d8 	str.w	r5, [r4, #472]	; 0x1d8
	uhoist_ow.child = hoist_io_options;
  407bfa:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
	uhoist_hopen.child = hoist_io_options;
  407bfe:	f8c4 5228 	str.w	r5, [r4, #552]	; 0x228
	uhoist_hclose.child = hoist_io_options;
  407c02:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
	uhoist_ersin.child = hoist_io_options;
  407c06:	f8c4 5278 	str.w	r5, [r4, #632]	; 0x278
	uhoist_mConFB.child = hoist_io_options;
  407c0a:	f8c4 52a0 	str.w	r5, [r4, #672]	; 0x2a0
	uhoist_bkConFB.child = hoist_io_options;
  407c0e:	f8c4 52c8 	str.w	r5, [r4, #712]	; 0x2c8
	uhoist_fxConFB.child = hoist_io_options;
  407c12:	f8c4 52f0 	str.w	r5, [r4, #752]	; 0x2f0
	uhoist_upfl.child = hoist_io_options;
  407c16:	f8c4 5318 	str.w	r5, [r4, #792]	; 0x318
	uhoist_dnfl.child = hoist_io_options;
  407c1a:	f8c4 5340 	str.w	r5, [r4, #832]	; 0x340
	uhoist_dnl.enter = &uhoist_dnl_init;
  407c1e:	f8c4 e1a4 	str.w	lr, [r4, #420]	; 0x1a4
	uhoist_dnfl.enter = &uhoist_dnfl_init;
  407c22:	f8c4 6334 	str.w	r6, [r4, #820]	; 0x334
	uhoist_upfdl1.text = " Up f_decel lmt1";
  407c26:	f8c4 0348 	str.w	r0, [r4, #840]	; 0x348
	uhoist_upfdl1.child = hoist_io_options;
  407c2a:	f8c4 5368 	str.w	r5, [r4, #872]	; 0x368
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407c2e:	9700      	str	r7, [sp, #0]
	uhoist_upfdl2.child = hoist_io_options;
  407c30:	f8c4 5390 	str.w	r5, [r4, #912]	; 0x390
	uhoist_dnfdl1.child = hoist_io_options;
  407c34:	f8c4 53b8 	str.w	r5, [r4, #952]	; 0x3b8
	uhoist_dnfdl2.child = hoist_io_options;
  407c38:	f8c4 53e0 	str.w	r5, [r4, #992]	; 0x3e0
	uhoist_upfdl2.enter = &uhoist_upfdl2_init;
  407c3c:	4f3a      	ldr	r7, [pc, #232]	; (407d28 <menue_util_hoist_init+0x25c>)
	uhoist_upfdl2.text = " Up f_decel lmt2";
  407c3e:	4d3b      	ldr	r5, [pc, #236]	; (407d2c <menue_util_hoist_init+0x260>)
	uhoist_upfdl2.enter = &uhoist_upfdl2_init;
  407c40:	f8c4 7384 	str.w	r7, [r4, #900]	; 0x384
	uhoist_upfdl2.text = " Up f_decel lmt2";
  407c44:	f8c4 5370 	str.w	r5, [r4, #880]	; 0x370
	uhoist_dnfdl1.enter = &uhoist_dnfdl1_init;
  407c48:	4f39      	ldr	r7, [pc, #228]	; (407d30 <menue_util_hoist_init+0x264>)
	uhoist_dnfdl1.text = " Down f_decel lmt1";
  407c4a:	4d3a      	ldr	r5, [pc, #232]	; (407d34 <menue_util_hoist_init+0x268>)
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407c4c:	4e3a      	ldr	r6, [pc, #232]	; (407d38 <menue_util_hoist_init+0x26c>)
	uhoist_upfdl1.enter = &uhoist_upfdl1_init;
  407c4e:	f8df e100 	ldr.w	lr, [pc, #256]	; 407d50 <menue_util_hoist_init+0x284>
	uhoist_dnfdl1.text = " Down f_decel lmt1";
  407c52:	f8c4 5398 	str.w	r5, [r4, #920]	; 0x398
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407c56:	4630      	mov	r0, r6
	uhoist_dnfdl1.enter = &uhoist_dnfdl1_init;
  407c58:	f8c4 73ac 	str.w	r7, [r4, #940]	; 0x3ac
	uhoist_dnfdl2.text = " Down f_decel lmt2";
  407c5c:	4d37      	ldr	r5, [pc, #220]	; (407d3c <menue_util_hoist_init+0x270>)
	uhoist_dnfdl2.enter = &uhoist_dnfdl2_init;
  407c5e:	4f38      	ldr	r7, [pc, #224]	; (407d40 <menue_util_hoist_init+0x274>)
	uhoist_dnfdl2.text = " Down f_decel lmt2";
  407c60:	f8c4 53c0 	str.w	r5, [r4, #960]	; 0x3c0
	uhoist_upfdl1.enter = &uhoist_upfdl1_init;
  407c64:	f8c4 e35c 	str.w	lr, [r4, #860]	; 0x35c
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407c68:	4d36      	ldr	r5, [pc, #216]	; (407d44 <menue_util_hoist_init+0x278>)
	uhoist_dnfdl2.enter = &uhoist_dnfdl2_init;
  407c6a:	f8c4 73d4 	str.w	r7, [r4, #980]	; 0x3d4
	fill_menue_list(&menue_util_hoist, opt_util_hoist, OPT_UTIL_HOIST_MAX, 0, 0);
  407c6e:	47a8      	blx	r5

	return &menue_util_hoist;
  407c70:	4630      	mov	r0, r6
  407c72:	b003      	add	sp, #12
  407c74:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407c76:	bf00      	nop
  407c78:	004071fd 	.word	0x004071fd
  407c7c:	204048c8 	.word	0x204048c8
  407c80:	0041b400 	.word	0x0041b400
  407c84:	004079ad 	.word	0x004079ad
  407c88:	004079c5 	.word	0x004079c5
  407c8c:	0041b440 	.word	0x0041b440
  407c90:	0041b424 	.word	0x0041b424
  407c94:	0041b44c 	.word	0x0041b44c
  407c98:	004079e9 	.word	0x004079e9
  407c9c:	0041b45c 	.word	0x0041b45c
  407ca0:	0041b3ec 	.word	0x0041b3ec
  407ca4:	004079a1 	.word	0x004079a1
  407ca8:	004079f5 	.word	0x004079f5
  407cac:	0041b46c 	.word	0x0041b46c
  407cb0:	20404ccc 	.word	0x20404ccc
  407cb4:	004079b9 	.word	0x004079b9
  407cb8:	0041b414 	.word	0x0041b414
  407cbc:	00407a01 	.word	0x00407a01
  407cc0:	0041b47c 	.word	0x0041b47c
  407cc4:	00419878 	.word	0x00419878
  407cc8:	0041b434 	.word	0x0041b434
  407ccc:	004079dd 	.word	0x004079dd
  407cd0:	00407a0d 	.word	0x00407a0d
  407cd4:	0041b490 	.word	0x0041b490
  407cd8:	00407a25 	.word	0x00407a25
  407cdc:	0041b49c 	.word	0x0041b49c
  407ce0:	00407a31 	.word	0x00407a31
  407ce4:	0041b4a8 	.word	0x0041b4a8
  407ce8:	00407a3d 	.word	0x00407a3d
  407cec:	0041b4b4 	.word	0x0041b4b4
  407cf0:	00407a49 	.word	0x00407a49
  407cf4:	0041b4c0 	.word	0x0041b4c0
  407cf8:	00407a55 	.word	0x00407a55
  407cfc:	0041b4cc 	.word	0x0041b4cc
  407d00:	00407a61 	.word	0x00407a61
  407d04:	0041b4dc 	.word	0x0041b4dc
  407d08:	00407a6d 	.word	0x00407a6d
  407d0c:	0041b4f0 	.word	0x0041b4f0
  407d10:	00407a79 	.word	0x00407a79
  407d14:	0041b500 	.word	0x0041b500
  407d18:	00407a85 	.word	0x00407a85
  407d1c:	0041b510 	.word	0x0041b510
  407d20:	00407a91 	.word	0x00407a91
  407d24:	0041b524 	.word	0x0041b524
  407d28:	00407aa9 	.word	0x00407aa9
  407d2c:	0041b538 	.word	0x0041b538
  407d30:	00407ab5 	.word	0x00407ab5
  407d34:	0041b54c 	.word	0x0041b54c
  407d38:	20404cb0 	.word	0x20404cb0
  407d3c:	0041b560 	.word	0x0041b560
  407d40:	00407ac1 	.word	0x00407ac1
  407d44:	0040b0ad 	.word	0x0040b0ad
  407d48:	004079d1 	.word	0x004079d1
  407d4c:	00407a19 	.word	0x00407a19
  407d50:	00407a9d 	.word	0x00407a9d

00407d54 <menue_util_io_init>:
#define uio_input_signal	          (opt_util_ios[0])
#define uio_outputsignal	          (opt_util_ios[1])
#define uio_request_pins	          (opt_util_ios[2])

menue_design_t *menue_util_io_init(void)
{
  407d54:	b530      	push	{r4, r5, lr}
	uio_input_signal.text = "Hoist input signals";
  407d56:	4b0d      	ldr	r3, [pc, #52]	; (407d8c <menue_util_io_init+0x38>)
{
  407d58:	b083      	sub	sp, #12
	uio_input_signal.text = "Hoist input signals";
  407d5a:	4c0d      	ldr	r4, [pc, #52]	; (407d90 <menue_util_io_init+0x3c>)
	uio_input_signal.child = menue_util_hoist_init();
  407d5c:	4d0d      	ldr	r5, [pc, #52]	; (407d94 <menue_util_io_init+0x40>)
	uio_input_signal.text = "Hoist input signals";
  407d5e:	6023      	str	r3, [r4, #0]
	uio_input_signal.child = menue_util_hoist_init();
  407d60:	47a8      	blx	r5
//////////////////////////////////////////////////////////////////////////
	
	uio_outputsignal.text = "Output signals";
  407d62:	4a0d      	ldr	r2, [pc, #52]	; (407d98 <menue_util_io_init+0x44>)
	uio_outputsignal.child = menue_util_output_init();
  407d64:	4b0d      	ldr	r3, [pc, #52]	; (407d9c <menue_util_io_init+0x48>)
	uio_outputsignal.text = "Output signals";
  407d66:	62a2      	str	r2, [r4, #40]	; 0x28
	uio_input_signal.child = menue_util_hoist_init();
  407d68:	6220      	str	r0, [r4, #32]
	uio_outputsignal.child = menue_util_output_init();
  407d6a:	4798      	blx	r3
//////////////////////////////////////////////////////////////////////////
	
	uio_request_pins.text = "Request pins";
  407d6c:	4b0c      	ldr	r3, [pc, #48]	; (407da0 <menue_util_io_init+0x4c>)
	uio_outputsignal.child = menue_util_output_init();
  407d6e:	64a0      	str	r0, [r4, #72]	; 0x48
	uio_request_pins.text = "Request pins";
  407d70:	6523      	str	r3, [r4, #80]	; 0x50
	uio_request_pins.child = menue_util_hoist_init();
  407d72:	47a8      	blx	r5
//////////////////////////////////////////////////////////////////////////

	fill_menue_list(&menue_util_io, opt_util_ios, OPT_UTIL_IO_MAX, 0, 0);
  407d74:	4d0b      	ldr	r5, [pc, #44]	; (407da4 <menue_util_io_init+0x50>)
  407d76:	2300      	movs	r3, #0
	uio_request_pins.child = menue_util_hoist_init();
  407d78:	6720      	str	r0, [r4, #112]	; 0x70
	fill_menue_list(&menue_util_io, opt_util_ios, OPT_UTIL_IO_MAX, 0, 0);
  407d7a:	4621      	mov	r1, r4
  407d7c:	4628      	mov	r0, r5
  407d7e:	9300      	str	r3, [sp, #0]
  407d80:	2203      	movs	r2, #3
  407d82:	4c09      	ldr	r4, [pc, #36]	; (407da8 <menue_util_io_init+0x54>)
  407d84:	47a0      	blx	r4

	return &menue_util_io;	
  407d86:	4628      	mov	r0, r5
  407d88:	b003      	add	sp, #12
  407d8a:	bd30      	pop	{r4, r5, pc}
  407d8c:	0041b574 	.word	0x0041b574
  407d90:	20404cec 	.word	0x20404cec
  407d94:	00407acd 	.word	0x00407acd
  407d98:	0041b588 	.word	0x0041b588
  407d9c:	00407e61 	.word	0x00407e61
  407da0:	0041b598 	.word	0x0041b598
  407da4:	20404cd0 	.word	0x20404cd0
  407da8:	0040b0ad 	.word	0x0040b0ad

00407dac <uoutput_y0_init>:

menue_design_t *output_options;

void uoutput_y0_init(void)
{
	menue_util_outputList_show(0);
  407dac:	2000      	movs	r0, #0
  407dae:	4b01      	ldr	r3, [pc, #4]	; (407db4 <uoutput_y0_init+0x8>)
  407db0:	4718      	bx	r3
  407db2:	bf00      	nop
  407db4:	0040744d 	.word	0x0040744d

00407db8 <uoutput_y1_init>:
}

void uoutput_y1_init(void)
{
	menue_util_outputList_show(1);
  407db8:	2001      	movs	r0, #1
  407dba:	4b01      	ldr	r3, [pc, #4]	; (407dc0 <uoutput_y1_init+0x8>)
  407dbc:	4718      	bx	r3
  407dbe:	bf00      	nop
  407dc0:	0040744d 	.word	0x0040744d

00407dc4 <uoutput_y2_init>:
}

void uoutput_y2_init(void)
{
	menue_util_outputList_show(2);
  407dc4:	2002      	movs	r0, #2
  407dc6:	4b01      	ldr	r3, [pc, #4]	; (407dcc <uoutput_y2_init+0x8>)
  407dc8:	4718      	bx	r3
  407dca:	bf00      	nop
  407dcc:	0040744d 	.word	0x0040744d

00407dd0 <uoutput_y3_init>:
}

void uoutput_y3_init(void)
{
	menue_util_outputList_show(3);
  407dd0:	2003      	movs	r0, #3
  407dd2:	4b01      	ldr	r3, [pc, #4]	; (407dd8 <uoutput_y3_init+0x8>)
  407dd4:	4718      	bx	r3
  407dd6:	bf00      	nop
  407dd8:	0040744d 	.word	0x0040744d

00407ddc <uoutput_y4_init>:
}

void uoutput_y4_init(void)
{
	menue_util_outputList_show(4);
  407ddc:	2004      	movs	r0, #4
  407dde:	4b01      	ldr	r3, [pc, #4]	; (407de4 <uoutput_y4_init+0x8>)
  407de0:	4718      	bx	r3
  407de2:	bf00      	nop
  407de4:	0040744d 	.word	0x0040744d

00407de8 <uoutput_y5_init>:
}

void uoutput_y5_init(void)
{
	menue_util_outputList_show(5);
  407de8:	2005      	movs	r0, #5
  407dea:	4b01      	ldr	r3, [pc, #4]	; (407df0 <uoutput_y5_init+0x8>)
  407dec:	4718      	bx	r3
  407dee:	bf00      	nop
  407df0:	0040744d 	.word	0x0040744d

00407df4 <uoutput_y6_init>:
}

void uoutput_y6_init(void)
{
	menue_util_outputList_show(6);
  407df4:	2006      	movs	r0, #6
  407df6:	4b01      	ldr	r3, [pc, #4]	; (407dfc <uoutput_y6_init+0x8>)
  407df8:	4718      	bx	r3
  407dfa:	bf00      	nop
  407dfc:	0040744d 	.word	0x0040744d

00407e00 <uoutput_y7_init>:
}

void uoutput_y7_init(void)
{
	menue_util_outputList_show(7);
  407e00:	2007      	movs	r0, #7
  407e02:	4b01      	ldr	r3, [pc, #4]	; (407e08 <uoutput_y7_init+0x8>)
  407e04:	4718      	bx	r3
  407e06:	bf00      	nop
  407e08:	0040744d 	.word	0x0040744d

00407e0c <uoutput_y8_init>:
}

void uoutput_y8_init(void)
{
	menue_util_outputList_show(8);
  407e0c:	2008      	movs	r0, #8
  407e0e:	4b01      	ldr	r3, [pc, #4]	; (407e14 <uoutput_y8_init+0x8>)
  407e10:	4718      	bx	r3
  407e12:	bf00      	nop
  407e14:	0040744d 	.word	0x0040744d

00407e18 <uoutput_cy0_init>:
}

void uoutput_cy0_init(void)
{
	menue_util_outputList_show(9);
  407e18:	2009      	movs	r0, #9
  407e1a:	4b01      	ldr	r3, [pc, #4]	; (407e20 <uoutput_cy0_init+0x8>)
  407e1c:	4718      	bx	r3
  407e1e:	bf00      	nop
  407e20:	0040744d 	.word	0x0040744d

00407e24 <uoutput_cy1_init>:
}

void uoutput_cy1_init(void)
{
	menue_util_outputList_show(10);
  407e24:	200a      	movs	r0, #10
  407e26:	4b01      	ldr	r3, [pc, #4]	; (407e2c <uoutput_cy1_init+0x8>)
  407e28:	4718      	bx	r3
  407e2a:	bf00      	nop
  407e2c:	0040744d 	.word	0x0040744d

00407e30 <uoutput_cy2_init>:
}

void uoutput_cy2_init(void)
{
	menue_util_outputList_show(11);
  407e30:	200b      	movs	r0, #11
  407e32:	4b01      	ldr	r3, [pc, #4]	; (407e38 <uoutput_cy2_init+0x8>)
  407e34:	4718      	bx	r3
  407e36:	bf00      	nop
  407e38:	0040744d 	.word	0x0040744d

00407e3c <uoutput_cy3_init>:
}

void uoutput_cy3_init(void)
{
	menue_util_outputList_show(12);
  407e3c:	200c      	movs	r0, #12
  407e3e:	4b01      	ldr	r3, [pc, #4]	; (407e44 <uoutput_cy3_init+0x8>)
  407e40:	4718      	bx	r3
  407e42:	bf00      	nop
  407e44:	0040744d 	.word	0x0040744d

00407e48 <uoutput_cy4_init>:
}

void uoutput_cy4_init(void)
{
	menue_util_outputList_show(13);
  407e48:	200d      	movs	r0, #13
  407e4a:	4b01      	ldr	r3, [pc, #4]	; (407e50 <uoutput_cy4_init+0x8>)
  407e4c:	4718      	bx	r3
  407e4e:	bf00      	nop
  407e50:	0040744d 	.word	0x0040744d

00407e54 <uoutput_cy5_init>:
}

void uoutput_cy5_init(void)
{
	menue_util_outputList_show(14);
  407e54:	200e      	movs	r0, #14
  407e56:	4b01      	ldr	r3, [pc, #4]	; (407e5c <uoutput_cy5_init+0x8>)
  407e58:	4718      	bx	r3
  407e5a:	bf00      	nop
  407e5c:	0040744d 	.word	0x0040744d

00407e60 <menue_util_output_init>:
}



menue_design_t *menue_util_output_init(void)
{
  407e60:	b5f0      	push	{r4, r5, r6, r7, lr}
	output_options = menue_util_outputs_list_init();
  407e62:	4b41      	ldr	r3, [pc, #260]	; (407f68 <menue_util_output_init+0x108>)
{
  407e64:	b083      	sub	sp, #12
	
	uout_y0.text = "Y0";
  407e66:	4c41      	ldr	r4, [pc, #260]	; (407f6c <menue_util_output_init+0x10c>)
	output_options = menue_util_outputs_list_init();
  407e68:	4798      	blx	r3
  407e6a:	4605      	mov	r5, r0
	uout_y0.text = "Y0";
  407e6c:	4840      	ldr	r0, [pc, #256]	; (407f70 <menue_util_output_init+0x110>)
	uout_y0.child = output_options;
	uout_y0.enter = &uoutput_y0_init;
  407e6e:	4e41      	ldr	r6, [pc, #260]	; (407f74 <menue_util_output_init+0x114>)
	uout_cy5.text = "CTB Y5";
	uout_cy5.child = output_options;
	uout_cy5.enter = &uoutput_cy5_init;
	//////////////////////////////////////////////////////////////////////////
		
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407e70:	2700      	movs	r7, #0
	uout_y0.text = "Y0";
  407e72:	6020      	str	r0, [r4, #0]
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407e74:	220f      	movs	r2, #15
	uout_y1.text = "Y1";
  407e76:	4840      	ldr	r0, [pc, #256]	; (407f78 <menue_util_output_init+0x118>)
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407e78:	463b      	mov	r3, r7
	uout_y0.enter = &uoutput_y0_init;
  407e7a:	6166      	str	r6, [r4, #20]
	uout_y1.text = "Y1";
  407e7c:	62a0      	str	r0, [r4, #40]	; 0x28
	uout_y1.enter = &uoutput_y1_init;
  407e7e:	4e3f      	ldr	r6, [pc, #252]	; (407f7c <menue_util_output_init+0x11c>)
	uout_y2.text = "Y2";
  407e80:	483f      	ldr	r0, [pc, #252]	; (407f80 <menue_util_output_init+0x120>)
	uout_y1.enter = &uoutput_y1_init;
  407e82:	63e6      	str	r6, [r4, #60]	; 0x3c
	uout_y2.text = "Y2";
  407e84:	6520      	str	r0, [r4, #80]	; 0x50
	uout_y2.enter = &uoutput_y2_init;
  407e86:	4e3f      	ldr	r6, [pc, #252]	; (407f84 <menue_util_output_init+0x124>)
	uout_y3.text = "Y3";
  407e88:	483f      	ldr	r0, [pc, #252]	; (407f88 <menue_util_output_init+0x128>)
	uout_y2.enter = &uoutput_y2_init;
  407e8a:	6666      	str	r6, [r4, #100]	; 0x64
	uout_y3.text = "Y3";
  407e8c:	67a0      	str	r0, [r4, #120]	; 0x78
	uout_y3.enter = &uoutput_y3_init;
  407e8e:	4e3f      	ldr	r6, [pc, #252]	; (407f8c <menue_util_output_init+0x12c>)
	uout_y4.text = "Y4";
  407e90:	483f      	ldr	r0, [pc, #252]	; (407f90 <menue_util_output_init+0x130>)
	uout_y3.enter = &uoutput_y3_init;
  407e92:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
	uout_y4.text = "Y4";
  407e96:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
	uout_y4.enter = &uoutput_y4_init;
  407e9a:	4e3e      	ldr	r6, [pc, #248]	; (407f94 <menue_util_output_init+0x134>)
	uout_y5.text = "Y5";
  407e9c:	483e      	ldr	r0, [pc, #248]	; (407f98 <menue_util_output_init+0x138>)
	uout_y4.enter = &uoutput_y4_init;
  407e9e:	f8c4 60b4 	str.w	r6, [r4, #180]	; 0xb4
	uout_y5.text = "Y5";
  407ea2:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
	uout_y5.enter = &uoutput_y5_init;
  407ea6:	4e3d      	ldr	r6, [pc, #244]	; (407f9c <menue_util_output_init+0x13c>)
	uout_y6.text = "Y6";
  407ea8:	483d      	ldr	r0, [pc, #244]	; (407fa0 <menue_util_output_init+0x140>)
	uout_y5.enter = &uoutput_y5_init;
  407eaa:	f8c4 60dc 	str.w	r6, [r4, #220]	; 0xdc
	uout_y6.text = "Y6";
  407eae:	f8c4 00f0 	str.w	r0, [r4, #240]	; 0xf0
	uout_y6.enter = &uoutput_y6_init;
  407eb2:	4e3c      	ldr	r6, [pc, #240]	; (407fa4 <menue_util_output_init+0x144>)
	uout_y7.text = "Y7";
  407eb4:	483c      	ldr	r0, [pc, #240]	; (407fa8 <menue_util_output_init+0x148>)
	uout_y6.enter = &uoutput_y6_init;
  407eb6:	f8c4 6104 	str.w	r6, [r4, #260]	; 0x104
	uout_y7.text = "Y7";
  407eba:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
	uout_y7.enter = &uoutput_y7_init;
  407ebe:	4e3b      	ldr	r6, [pc, #236]	; (407fac <menue_util_output_init+0x14c>)
	uout_y8.text = "Y8";
  407ec0:	483b      	ldr	r0, [pc, #236]	; (407fb0 <menue_util_output_init+0x150>)
	uout_y7.enter = &uoutput_y7_init;
  407ec2:	f8c4 612c 	str.w	r6, [r4, #300]	; 0x12c
	uout_y8.text = "Y8";
  407ec6:	f8c4 0140 	str.w	r0, [r4, #320]	; 0x140
	uout_y8.enter = &uoutput_y8_init;
  407eca:	4e3a      	ldr	r6, [pc, #232]	; (407fb4 <menue_util_output_init+0x154>)
	uout_cy0.text = "CTB Y0";
  407ecc:	483a      	ldr	r0, [pc, #232]	; (407fb8 <menue_util_output_init+0x158>)
	uout_y8.enter = &uoutput_y8_init;
  407ece:	f8c4 6154 	str.w	r6, [r4, #340]	; 0x154
	uout_cy0.text = "CTB Y0";
  407ed2:	f8c4 0168 	str.w	r0, [r4, #360]	; 0x168
	output_options = menue_util_outputs_list_init();
  407ed6:	4939      	ldr	r1, [pc, #228]	; (407fbc <menue_util_output_init+0x15c>)
	uout_cy0.enter = &uoutput_cy0_init;
  407ed8:	4e39      	ldr	r6, [pc, #228]	; (407fc0 <menue_util_output_init+0x160>)
	uout_cy1.text = "CTB Y1";
  407eda:	483a      	ldr	r0, [pc, #232]	; (407fc4 <menue_util_output_init+0x164>)
	output_options = menue_util_outputs_list_init();
  407edc:	600d      	str	r5, [r1, #0]
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407ede:	4621      	mov	r1, r4
	uout_y0.child = output_options;
  407ee0:	6225      	str	r5, [r4, #32]
	uout_y1.child = output_options;
  407ee2:	64a5      	str	r5, [r4, #72]	; 0x48
	uout_y2.child = output_options;
  407ee4:	6725      	str	r5, [r4, #112]	; 0x70
	uout_y3.child = output_options;
  407ee6:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
	uout_y4.child = output_options;
  407eea:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
	uout_y5.child = output_options;
  407eee:	f8c4 50e8 	str.w	r5, [r4, #232]	; 0xe8
	uout_y6.child = output_options;
  407ef2:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
	uout_y7.child = output_options;
  407ef6:	f8c4 5138 	str.w	r5, [r4, #312]	; 0x138
	uout_y8.child = output_options;
  407efa:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160
	uout_cy0.child = output_options;
  407efe:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
	uout_cy0.enter = &uoutput_cy0_init;
  407f02:	f8c4 617c 	str.w	r6, [r4, #380]	; 0x17c
	uout_cy1.text = "CTB Y1";
  407f06:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	uout_cy1.child = output_options;
  407f0a:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407f0e:	9700      	str	r7, [sp, #0]
	uout_cy2.child = output_options;
  407f10:	f8c4 51d8 	str.w	r5, [r4, #472]	; 0x1d8
	uout_cy3.child = output_options;
  407f14:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
	uout_cy4.child = output_options;
  407f18:	f8c4 5228 	str.w	r5, [r4, #552]	; 0x228
	uout_cy5.child = output_options;
  407f1c:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
	uout_cy2.enter = &uoutput_cy2_init;
  407f20:	4f29      	ldr	r7, [pc, #164]	; (407fc8 <menue_util_output_init+0x168>)
	uout_cy2.text = "CTB Y2";
  407f22:	4d2a      	ldr	r5, [pc, #168]	; (407fcc <menue_util_output_init+0x16c>)
	uout_cy2.enter = &uoutput_cy2_init;
  407f24:	f8c4 71cc 	str.w	r7, [r4, #460]	; 0x1cc
	uout_cy2.text = "CTB Y2";
  407f28:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
	uout_cy3.enter = &uoutput_cy3_init;
  407f2c:	4f28      	ldr	r7, [pc, #160]	; (407fd0 <menue_util_output_init+0x170>)
	uout_cy3.text = "CTB Y3";
  407f2e:	4d29      	ldr	r5, [pc, #164]	; (407fd4 <menue_util_output_init+0x174>)
	uout_cy3.enter = &uoutput_cy3_init;
  407f30:	f8c4 71f4 	str.w	r7, [r4, #500]	; 0x1f4
	uout_cy3.text = "CTB Y3";
  407f34:	f8c4 51e0 	str.w	r5, [r4, #480]	; 0x1e0
	uout_cy4.enter = &uoutput_cy4_init;
  407f38:	4f27      	ldr	r7, [pc, #156]	; (407fd8 <menue_util_output_init+0x178>)
	uout_cy4.text = "CTB Y4";
  407f3a:	4d28      	ldr	r5, [pc, #160]	; (407fdc <menue_util_output_init+0x17c>)
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407f3c:	4e28      	ldr	r6, [pc, #160]	; (407fe0 <menue_util_output_init+0x180>)
	uout_cy1.enter = &uoutput_cy1_init;
  407f3e:	f8df e0b0 	ldr.w	lr, [pc, #176]	; 407ff0 <menue_util_output_init+0x190>
	uout_cy4.text = "CTB Y4";
  407f42:	f8c4 5208 	str.w	r5, [r4, #520]	; 0x208
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407f46:	4630      	mov	r0, r6
	uout_cy4.enter = &uoutput_cy4_init;
  407f48:	f8c4 721c 	str.w	r7, [r4, #540]	; 0x21c
	uout_cy5.text = "CTB Y5";
  407f4c:	4d25      	ldr	r5, [pc, #148]	; (407fe4 <menue_util_output_init+0x184>)
	uout_cy5.enter = &uoutput_cy5_init;
  407f4e:	4f26      	ldr	r7, [pc, #152]	; (407fe8 <menue_util_output_init+0x188>)
	uout_cy5.text = "CTB Y5";
  407f50:	f8c4 5230 	str.w	r5, [r4, #560]	; 0x230
	uout_cy1.enter = &uoutput_cy1_init;
  407f54:	f8c4 e1a4 	str.w	lr, [r4, #420]	; 0x1a4
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407f58:	4d24      	ldr	r5, [pc, #144]	; (407fec <menue_util_output_init+0x18c>)
	uout_cy5.enter = &uoutput_cy5_init;
  407f5a:	f8c4 7244 	str.w	r7, [r4, #580]	; 0x244
	fill_menue_list(&menue_util_output, opt_util_output, OPT_UTIL_OUTPUT_MAX, 0, 0);
  407f5e:	47a8      	blx	r5

	return &menue_util_output;
  407f60:	4630      	mov	r0, r6
  407f62:	b003      	add	sp, #12
  407f64:	bdf0      	pop	{r4, r5, r6, r7, pc}
  407f66:	bf00      	nop
  407f68:	00407465 	.word	0x00407465
  407f6c:	20404d64 	.word	0x20404d64
  407f70:	0041b5b8 	.word	0x0041b5b8
  407f74:	00407dad 	.word	0x00407dad
  407f78:	0041b5c0 	.word	0x0041b5c0
  407f7c:	00407db9 	.word	0x00407db9
  407f80:	0041b5c8 	.word	0x0041b5c8
  407f84:	00407dc5 	.word	0x00407dc5
  407f88:	0041b5d0 	.word	0x0041b5d0
  407f8c:	00407dd1 	.word	0x00407dd1
  407f90:	0041b5d8 	.word	0x0041b5d8
  407f94:	00407ddd 	.word	0x00407ddd
  407f98:	0041b5e0 	.word	0x0041b5e0
  407f9c:	00407de9 	.word	0x00407de9
  407fa0:	0041b5a8 	.word	0x0041b5a8
  407fa4:	00407df5 	.word	0x00407df5
  407fa8:	0041b5ac 	.word	0x0041b5ac
  407fac:	00407e01 	.word	0x00407e01
  407fb0:	0041b5b0 	.word	0x0041b5b0
  407fb4:	00407e0d 	.word	0x00407e0d
  407fb8:	0041b5b4 	.word	0x0041b5b4
  407fbc:	20404fbc 	.word	0x20404fbc
  407fc0:	00407e19 	.word	0x00407e19
  407fc4:	0041b5bc 	.word	0x0041b5bc
  407fc8:	00407e31 	.word	0x00407e31
  407fcc:	0041b5c4 	.word	0x0041b5c4
  407fd0:	00407e3d 	.word	0x00407e3d
  407fd4:	0041b5cc 	.word	0x0041b5cc
  407fd8:	00407e49 	.word	0x00407e49
  407fdc:	0041b5d4 	.word	0x0041b5d4
  407fe0:	20404fc0 	.word	0x20404fc0
  407fe4:	0041b5dc 	.word	0x0041b5dc
  407fe8:	00407e55 	.word	0x00407e55
  407fec:	0040b0ad 	.word	0x0040b0ad
  407ff0:	00407e25 	.word	0x00407e25

00407ff4 <auto_stop_guard.part.1>:
}

//stop state subs
uByte_t dr_opened=0; //signal door opened and closed
uByte_t auto_stop_guard(void);
uByte_t auto_stop_guard(void)
  407ff4:	b570      	push	{r4, r5, r6, lr}
{
	if(shk==0) return 1;
	if(s_i_err()) return 1; //if there is error preventing elevator moving don't exit stop_state
	if(h_open==1) return 1; //if |<>| pressed open door and don't exit
  407ff6:	4e11      	ldr	r6, [pc, #68]	; (40803c <auto_stop_guard.part.1+0x48>)
  407ff8:	2200      	movs	r2, #0
  407ffa:	4d11      	ldr	r5, [pc, #68]	; (408040 <auto_stop_guard.part.1+0x4c>)
  407ffc:	7ab0      	ldrb	r0, [r6, #10]
  407ffe:	4611      	mov	r1, r2
  408000:	3002      	adds	r0, #2
  408002:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  408006:	47a8      	blx	r5
  408008:	4604      	mov	r4, r0
  40800a:	f896 008e 	ldrb.w	r0, [r6, #142]	; 0x8e
  40800e:	280d      	cmp	r0, #13
  408010:	d911      	bls.n	408036 <auto_stop_guard.part.1+0x42>
  408012:	280f      	cmp	r0, #15
  408014:	f100 000e 	add.w	r0, r0, #14
  408018:	bf8c      	ite	hi
  40801a:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  40801e:	2300      	movls	r3, #0
  408020:	2200      	movs	r2, #0
  408022:	4318      	orrs	r0, r3
  408024:	4611      	mov	r1, r2
  408026:	47a8      	blx	r5
  408028:	4320      	orrs	r0, r4
	return 0; //else exit stop_state
}
  40802a:	f1a0 0001 	sub.w	r0, r0, #1
  40802e:	fab0 f080 	clz	r0, r0
  408032:	0940      	lsrs	r0, r0, #5
  408034:	bd70      	pop	{r4, r5, r6, pc}
	if(h_open==1) return 1; //if |<>| pressed open door and don't exit
  408036:	2300      	movs	r3, #0
  408038:	e7f2      	b.n	408020 <auto_stop_guard.part.1+0x2c>
  40803a:	bf00      	nop
  40803c:	204052b4 	.word	0x204052b4
  408040:	0040d879 	.word	0x0040d879

00408044 <auto_lift_states_monitor>:
{
  408044:	b510      	push	{r4, lr}
	if(INS) ctb_ignore_door_limits(1);
  408046:	4c13      	ldr	r4, [pc, #76]	; (408094 <auto_lift_states_monitor+0x50>)
  408048:	2202      	movs	r2, #2
	else ctb_ignore_door_limits(0);
  40804a:	4b13      	ldr	r3, [pc, #76]	; (408098 <auto_lift_states_monitor+0x54>)
	if(INS) ctb_ignore_door_limits(1);
  40804c:	7821      	ldrb	r1, [r4, #0]
	else ctb_ignore_door_limits(0);
  40804e:	4813      	ldr	r0, [pc, #76]	; (40809c <auto_lift_states_monitor+0x58>)
	if(INS) ctb_ignore_door_limits(1);
  408050:	f011 0101 	ands.w	r1, r1, #1
  408054:	bf18      	it	ne
  408056:	2101      	movne	r1, #1
	else ctb_ignore_door_limits(0);
  408058:	4798      	blx	r3
	if (INS)
  40805a:	7823      	ldrb	r3, [r4, #0]
  40805c:	07d9      	lsls	r1, r3, #31
  40805e:	d40d      	bmi.n	40807c <auto_lift_states_monitor+0x38>
	else if (ARD)
  408060:	079a      	lsls	r2, r3, #30
  408062:	d503      	bpl.n	40806c <auto_lift_states_monitor+0x28>
  408064:	f003 0303 	and.w	r3, r3, #3
  408068:	2b03      	cmp	r3, #3
  40806a:	d107      	bne.n	40807c <auto_lift_states_monitor+0x38>
	else if(dont_record_fault()) req_enable(0);
  40806c:	4b0c      	ldr	r3, [pc, #48]	; (4080a0 <auto_lift_states_monitor+0x5c>)
  40806e:	4798      	blx	r3
  408070:	b958      	cbnz	r0, 40808a <auto_lift_states_monitor+0x46>
	else req_enable(1);
  408072:	2001      	movs	r0, #1
  408074:	4b0b      	ldr	r3, [pc, #44]	; (4080a4 <auto_lift_states_monitor+0x60>)
}
  408076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	else req_enable(1);
  40807a:	4718      	bx	r3
		req_enable(0);
  40807c:	4b09      	ldr	r3, [pc, #36]	; (4080a4 <auto_lift_states_monitor+0x60>)
  40807e:	2000      	movs	r0, #0
  408080:	4798      	blx	r3
		drop_all_req();
  408082:	4b09      	ldr	r3, [pc, #36]	; (4080a8 <auto_lift_states_monitor+0x64>)
}
  408084:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		drop_all_req();
  408088:	4718      	bx	r3
	else if(dont_record_fault()) req_enable(0);
  40808a:	2000      	movs	r0, #0
  40808c:	4b05      	ldr	r3, [pc, #20]	; (4080a4 <auto_lift_states_monitor+0x60>)
}
  40808e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	else if(dont_record_fault()) req_enable(0);
  408092:	4718      	bx	r3
  408094:	204008b2 	.word	0x204008b2
  408098:	0040d879 	.word	0x0040d879
  40809c:	0700000f 	.word	0x0700000f
  4080a0:	004129ad 	.word	0x004129ad
  4080a4:	0040111d 	.word	0x0040111d
  4080a8:	00401079 	.word	0x00401079

004080ac <ctb_automatic_doors_handler>:
{
  4080ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (external_auto)
  4080b0:	4c39      	ldr	r4, [pc, #228]	; (408198 <ctb_automatic_doors_handler+0xec>)
  4080b2:	7863      	ldrb	r3, [r4, #1]
  4080b4:	3b02      	subs	r3, #2
  4080b6:	2b01      	cmp	r3, #1
  4080b8:	d95f      	bls.n	40817a <ctb_automatic_doors_handler+0xce>
  4080ba:	4d38      	ldr	r5, [pc, #224]	; (40819c <ctb_automatic_doors_handler+0xf0>)
	if (INS)
  4080bc:	4f38      	ldr	r7, [pc, #224]	; (4081a0 <ctb_automatic_doors_handler+0xf4>)
  4080be:	783b      	ldrb	r3, [r7, #0]
  4080c0:	07db      	lsls	r3, r3, #31
  4080c2:	d451      	bmi.n	408168 <ctb_automatic_doors_handler+0xbc>
	h_open_set(0);
  4080c4:	7aa0      	ldrb	r0, [r4, #10]
  4080c6:	2200      	movs	r2, #0
	if (ctb_door1_state_closing || ctb_door2_state_closing)
  4080c8:	4e36      	ldr	r6, [pc, #216]	; (4081a4 <ctb_automatic_doors_handler+0xf8>)
	h_open_set(0);
  4080ca:	3002      	adds	r0, #2
  4080cc:	4611      	mov	r1, r2
  4080ce:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  4080d2:	47a8      	blx	r5
	h_close_set(0);
  4080d4:	7aa0      	ldrb	r0, [r4, #10]
  4080d6:	2200      	movs	r2, #0
  4080d8:	3001      	adds	r0, #1
  4080da:	4611      	mov	r1, r2
  4080dc:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  4080e0:	47a8      	blx	r5
	if (ctb_door1_state_closing || ctb_door2_state_closing)
  4080e2:	2000      	movs	r0, #0
  4080e4:	47b0      	blx	r6
  4080e6:	2802      	cmp	r0, #2
  4080e8:	d02a      	beq.n	408140 <ctb_automatic_doors_handler+0x94>
  4080ea:	2001      	movs	r0, #1
  4080ec:	47b0      	blx	r6
  4080ee:	2802      	cmp	r0, #2
  4080f0:	d026      	beq.n	408140 <ctb_automatic_doors_handler+0x94>
	else if (ctb_door1_state_opening || ctb_door2_state_opening)
  4080f2:	2000      	movs	r0, #0
  4080f4:	47b0      	blx	r6
  4080f6:	2803      	cmp	r0, #3
  4080f8:	d003      	beq.n	408102 <ctb_automatic_doors_handler+0x56>
  4080fa:	2001      	movs	r0, #1
  4080fc:	47b0      	blx	r6
  4080fe:	2803      	cmp	r0, #3
  408100:	d12c      	bne.n	40815c <ctb_automatic_doors_handler+0xb0>
		h_open_set(1);
  408102:	7aa0      	ldrb	r0, [r4, #10]
  408104:	2200      	movs	r2, #0
  408106:	2101      	movs	r1, #1
  408108:	3002      	adds	r0, #2
  40810a:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  40810e:	47a8      	blx	r5
		h_close_set(0);
  408110:	7aa0      	ldrb	r0, [r4, #10]
  408112:	2200      	movs	r2, #0
  408114:	3001      	adds	r0, #1
  408116:	4611      	mov	r1, r2
  408118:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  40811c:	47a8      	blx	r5
	if (INS == 0)
  40811e:	7838      	ldrb	r0, [r7, #0]
  408120:	f010 0001 	ands.w	r0, r0, #1
  408124:	d11e      	bne.n	408164 <ctb_automatic_doors_handler+0xb8>
		if (ctb_door1_state_abnormal_feedback)
  408126:	47b0      	blx	r6
  408128:	2804      	cmp	r0, #4
  40812a:	d030      	beq.n	40818e <ctb_automatic_doors_handler+0xe2>
		if (ctb_door2_state_abnormal_feedback)
  40812c:	2001      	movs	r0, #1
  40812e:	47b0      	blx	r6
  408130:	2804      	cmp	r0, #4
  408132:	d117      	bne.n	408164 <ctb_automatic_doors_handler+0xb8>
			bdoor_ab_err_set;
  408134:	4a1c      	ldr	r2, [pc, #112]	; (4081a8 <ctb_automatic_doors_handler+0xfc>)
  408136:	4b1d      	ldr	r3, [pc, #116]	; (4081ac <ctb_automatic_doors_handler+0x100>)
  408138:	7810      	ldrb	r0, [r2, #0]
}
  40813a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			bdoor_ab_err_set;
  40813e:	4718      	bx	r3
		h_open_set(0);
  408140:	7aa0      	ldrb	r0, [r4, #10]
  408142:	2200      	movs	r2, #0
  408144:	3002      	adds	r0, #2
  408146:	4611      	mov	r1, r2
  408148:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  40814c:	47a8      	blx	r5
		h_close_set(1);
  40814e:	7aa0      	ldrb	r0, [r4, #10]
  408150:	2101      	movs	r1, #1
  408152:	2200      	movs	r2, #0
  408154:	4408      	add	r0, r1
  408156:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  40815a:	47a8      	blx	r5
	if (INS == 0)
  40815c:	7838      	ldrb	r0, [r7, #0]
  40815e:	f010 0001 	ands.w	r0, r0, #1
  408162:	d0e0      	beq.n	408126 <ctb_automatic_doors_handler+0x7a>
  408164:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ctb_light_curtain1_ignore(1);
  408168:	2202      	movs	r2, #2
  40816a:	2101      	movs	r1, #1
  40816c:	4810      	ldr	r0, [pc, #64]	; (4081b0 <ctb_automatic_doors_handler+0x104>)
  40816e:	47a8      	blx	r5
		ctb_light_curtain2_ignore(1);
  408170:	2202      	movs	r2, #2
  408172:	2101      	movs	r1, #1
  408174:	480f      	ldr	r0, [pc, #60]	; (4081b4 <ctb_automatic_doors_handler+0x108>)
  408176:	47a8      	blx	r5
  408178:	e7a4      	b.n	4080c4 <ctb_automatic_doors_handler+0x18>
		ctb_activate_door1(1);
  40817a:	2202      	movs	r2, #2
  40817c:	2101      	movs	r1, #1
  40817e:	4d07      	ldr	r5, [pc, #28]	; (40819c <ctb_automatic_doors_handler+0xf0>)
  408180:	480d      	ldr	r0, [pc, #52]	; (4081b8 <ctb_automatic_doors_handler+0x10c>)
  408182:	47a8      	blx	r5
		ctb_activate_door2(0);
  408184:	2202      	movs	r2, #2
  408186:	2100      	movs	r1, #0
  408188:	480c      	ldr	r0, [pc, #48]	; (4081bc <ctb_automatic_doors_handler+0x110>)
  40818a:	47a8      	blx	r5
  40818c:	e796      	b.n	4080bc <ctb_automatic_doors_handler+0x10>
			fdoor_ab_err_set;
  40818e:	4a0c      	ldr	r2, [pc, #48]	; (4081c0 <ctb_automatic_doors_handler+0x114>)
  408190:	4b06      	ldr	r3, [pc, #24]	; (4081ac <ctb_automatic_doors_handler+0x100>)
  408192:	7810      	ldrb	r0, [r2, #0]
  408194:	4798      	blx	r3
  408196:	e7c9      	b.n	40812c <ctb_automatic_doors_handler+0x80>
  408198:	204052b4 	.word	0x204052b4
  40819c:	0040d879 	.word	0x0040d879
  4081a0:	204008b2 	.word	0x204008b2
  4081a4:	0040d861 	.word	0x0040d861
  4081a8:	20400c1e 	.word	0x20400c1e
  4081ac:	0041282d 	.word	0x0041282d
  4081b0:	0700000c 	.word	0x0700000c
  4081b4:	0700000d 	.word	0x0700000d
  4081b8:	07000008 	.word	0x07000008
  4081bc:	07000009 	.word	0x07000009
  4081c0:	20400c30 	.word	0x20400c30

004081c4 <auto_instate>:
	if(state==auto_counter)
  4081c4:	4b03      	ldr	r3, [pc, #12]	; (4081d4 <auto_instate+0x10>)
  4081c6:	681b      	ldr	r3, [r3, #0]
}
  4081c8:	1a18      	subs	r0, r3, r0
  4081ca:	fab0 f080 	clz	r0, r0
  4081ce:	0940      	lsrs	r0, r0, #5
  4081d0:	4770      	bx	lr
  4081d2:	bf00      	nop
  4081d4:	2040001c 	.word	0x2040001c

004081d8 <auto_update_elevator_initilal_values>:
{
  4081d8:	b510      	push	{r4, lr}
	menue_data_manager_update();
  4081da:	4b09      	ldr	r3, [pc, #36]	; (408200 <auto_update_elevator_initilal_values+0x28>)
  4081dc:	4798      	blx	r3
	uint8_t *temp_data_ptr = menue_data_manager_get_CounterData();
  4081de:	4b09      	ldr	r3, [pc, #36]	; (408204 <auto_update_elevator_initilal_values+0x2c>)
  4081e0:	4798      	blx	r3
  4081e2:	4604      	mov	r4, r0
	sel_set(temp_data_ptr[0]);
  4081e4:	4b08      	ldr	r3, [pc, #32]	; (408208 <auto_update_elevator_initilal_values+0x30>)
  4081e6:	7800      	ldrb	r0, [r0, #0]
  4081e8:	4798      	blx	r3
	enc_set_theta(*((int32_t*)&temp_data_ptr[1]));
  4081ea:	f8d4 0001 	ldr.w	r0, [r4, #1]
  4081ee:	4b07      	ldr	r3, [pc, #28]	; (40820c <auto_update_elevator_initilal_values+0x34>)
  4081f0:	17c1      	asrs	r1, r0, #31
  4081f2:	4798      	blx	r3
	toff_counter = (*((int32_t*)&temp_data_ptr[5]));
  4081f4:	f8d4 2005 	ldr.w	r2, [r4, #5]
  4081f8:	4b05      	ldr	r3, [pc, #20]	; (408210 <auto_update_elevator_initilal_values+0x38>)
  4081fa:	601a      	str	r2, [r3, #0]
  4081fc:	bd10      	pop	{r4, pc}
  4081fe:	bf00      	nop
  408200:	00409d01 	.word	0x00409d01
  408204:	00409d19 	.word	0x00409d19
  408208:	00400e31 	.word	0x00400e31
  40820c:	00413a71 	.word	0x00413a71
  408210:	204008f4 	.word	0x204008f4

00408214 <open_doors>:
{
  408214:	b570      	push	{r4, r5, r6, lr}
	m_d1open(1);
  408216:	2101      	movs	r1, #1
  408218:	4c0e      	ldr	r4, [pc, #56]	; (408254 <open_doors+0x40>)
  40821a:	200b      	movs	r0, #11
	ctb_close_door1(0);
  40821c:	4d0e      	ldr	r5, [pc, #56]	; (408258 <open_doors+0x44>)
	m_d1open(1);
  40821e:	47a0      	blx	r4
	m_d1close(0);
  408220:	2100      	movs	r1, #0
  408222:	200a      	movs	r0, #10
  408224:	47a0      	blx	r4
	m_d2open(1);
  408226:	2101      	movs	r1, #1
  408228:	200d      	movs	r0, #13
  40822a:	47a0      	blx	r4
	m_d2close(0);
  40822c:	2100      	movs	r1, #0
  40822e:	200c      	movs	r0, #12
  408230:	47a0      	blx	r4
	m_d3open(1);
  408232:	2101      	movs	r1, #1
  408234:	200f      	movs	r0, #15
  408236:	47a0      	blx	r4
	m_d3close(0);
  408238:	2100      	movs	r1, #0
  40823a:	200e      	movs	r0, #14
  40823c:	47a0      	blx	r4
	ctb_close_door1(0);
  40823e:	2202      	movs	r2, #2
  408240:	2100      	movs	r1, #0
  408242:	4806      	ldr	r0, [pc, #24]	; (40825c <open_doors+0x48>)
  408244:	47a8      	blx	r5
	ctb_close_door2(0);
  408246:	462b      	mov	r3, r5
  408248:	2202      	movs	r2, #2
  40824a:	2100      	movs	r1, #0
  40824c:	4804      	ldr	r0, [pc, #16]	; (408260 <open_doors+0x4c>)
}
  40824e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ctb_close_door2(0);
  408252:	4718      	bx	r3
  408254:	00400941 	.word	0x00400941
  408258:	0040d879 	.word	0x0040d879
  40825c:	0700000a 	.word	0x0700000a
  408260:	0700000b 	.word	0x0700000b

00408264 <close_doors>:
{
  408264:	b570      	push	{r4, r5, r6, lr}
	m_d1open(0);
  408266:	2100      	movs	r1, #0
  408268:	4c0e      	ldr	r4, [pc, #56]	; (4082a4 <close_doors+0x40>)
  40826a:	200b      	movs	r0, #11
	ctb_close_door1(1);
  40826c:	4d0e      	ldr	r5, [pc, #56]	; (4082a8 <close_doors+0x44>)
	m_d1open(0);
  40826e:	47a0      	blx	r4
	m_d1close(1);
  408270:	2101      	movs	r1, #1
  408272:	200a      	movs	r0, #10
  408274:	47a0      	blx	r4
	m_d2open(0);
  408276:	2100      	movs	r1, #0
  408278:	200d      	movs	r0, #13
  40827a:	47a0      	blx	r4
	m_d2close(1);
  40827c:	2101      	movs	r1, #1
  40827e:	200c      	movs	r0, #12
  408280:	47a0      	blx	r4
	m_d3open(0);
  408282:	2100      	movs	r1, #0
  408284:	200f      	movs	r0, #15
  408286:	47a0      	blx	r4
	m_d3close(1);
  408288:	2101      	movs	r1, #1
  40828a:	200e      	movs	r0, #14
  40828c:	47a0      	blx	r4
	ctb_close_door1(1);
  40828e:	2202      	movs	r2, #2
  408290:	2101      	movs	r1, #1
  408292:	4806      	ldr	r0, [pc, #24]	; (4082ac <close_doors+0x48>)
  408294:	47a8      	blx	r5
	ctb_close_door2(1);
  408296:	462b      	mov	r3, r5
  408298:	2202      	movs	r2, #2
  40829a:	2101      	movs	r1, #1
  40829c:	4804      	ldr	r0, [pc, #16]	; (4082b0 <close_doors+0x4c>)
}
  40829e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ctb_close_door2(1);
  4082a2:	4718      	bx	r3
  4082a4:	00400941 	.word	0x00400941
  4082a8:	0040d879 	.word	0x0040d879
  4082ac:	0700000a 	.word	0x0700000a
  4082b0:	0700000b 	.word	0x0700000b

004082b4 <auto_stop_enter>:
uint8_t floor_counter_save = 1;
void auto_stop_enter(void)
{
	auto_counter = auto_stop;
  4082b4:	4a32      	ldr	r2, [pc, #200]	; (408380 <auto_stop_enter+0xcc>)
  4082b6:	2103      	movs	r1, #3
	vfd_estop();
  4082b8:	4b32      	ldr	r3, [pc, #200]	; (408384 <auto_stop_enter+0xd0>)
{
  4082ba:	b570      	push	{r4, r5, r6, lr}
	auto_counter = auto_stop;
  4082bc:	6011      	str	r1, [r2, #0]
	vfd_estop();
  4082be:	4798      	blx	r3
	ersd_stop();
  4082c0:	4b31      	ldr	r3, [pc, #196]	; (408388 <auto_stop_enter+0xd4>)
  4082c2:	4798      	blx	r3
	selfLearn_terminateLearning();
	m_gong(0);
	if (floor_counter_save)
  4082c4:	4c31      	ldr	r4, [pc, #196]	; (40838c <auto_stop_enter+0xd8>)
	selfLearn_terminateLearning();
  4082c6:	4b32      	ldr	r3, [pc, #200]	; (408390 <auto_stop_enter+0xdc>)
  4082c8:	4798      	blx	r3
	m_gong(0);
  4082ca:	4d32      	ldr	r5, [pc, #200]	; (408394 <auto_stop_enter+0xe0>)
  4082cc:	2100      	movs	r1, #0
  4082ce:	2007      	movs	r0, #7
  4082d0:	47a8      	blx	r5
	if (floor_counter_save)
  4082d2:	7823      	ldrb	r3, [r4, #0]
  4082d4:	2b00      	cmp	r3, #0
  4082d6:	d146      	bne.n	408366 <auto_stop_enter+0xb2>
		menue_data_manager_saveCounterData(selector_counter, enc_get_theta(), toff_counter);
		//menue_data_manager_saveCounterData(10, 1000);
		floor_counter_save = 0;
	}
	
	if(!ARDINS) 
  4082d8:	4c2f      	ldr	r4, [pc, #188]	; (408398 <auto_stop_enter+0xe4>)
  4082da:	7823      	ldrb	r3, [r4, #0]
  4082dc:	f003 0303 	and.w	r3, r3, #3
  4082e0:	2b03      	cmp	r3, #3
  4082e2:	d005      	beq.n	4082f0 <auto_stop_enter+0x3c>
	{
		IO_YARD(0);
  4082e4:	2008      	movs	r0, #8
  4082e6:	2100      	movs	r1, #0
  4082e8:	47a8      	blx	r5
		if(ARD && (mstop == 1) ) ersd_allowTo_turn_on();
  4082ea:	7823      	ldrb	r3, [r4, #0]
  4082ec:	0798      	lsls	r0, r3, #30
  4082ee:	d433      	bmi.n	408358 <auto_stop_enter+0xa4>
	}
	
	menue_data_manager_update();
  4082f0:	4b2a      	ldr	r3, [pc, #168]	; (40839c <auto_stop_enter+0xe8>)
  4082f2:	4798      	blx	r3
	set_stop_flash_rate;
  4082f4:	4a2a      	ldr	r2, [pc, #168]	; (4083a0 <auto_stop_enter+0xec>)
  4082f6:	f242 7110 	movw	r1, #10000	; 0x2710
  4082fa:	4b2a      	ldr	r3, [pc, #168]	; (4083a4 <auto_stop_enter+0xf0>)
  4082fc:	6810      	ldr	r0, [r2, #0]
  4082fe:	4798      	blx	r3
	if((!INS) && (!ARD)) stop_idle_reset();
  408300:	7823      	ldrb	r3, [r4, #0]
  408302:	07d9      	lsls	r1, r3, #31
  408304:	d51c      	bpl.n	408340 <auto_stop_enter+0x8c>
	
	if(INS)
	{
		ar_up(0);
  408306:	2100      	movs	r1, #0
  408308:	2004      	movs	r0, #4
  40830a:	47a8      	blx	r5
		ar_dwn(0);
  40830c:	2100      	movs	r1, #0
  40830e:	2005      	movs	r0, #5
  408310:	47a8      	blx	r5
	}
	ctb_force_door_close(0);
  408312:	4c25      	ldr	r4, [pc, #148]	; (4083a8 <auto_stop_enter+0xf4>)
  408314:	2202      	movs	r2, #2
  408316:	2100      	movs	r1, #0
  408318:	4824      	ldr	r0, [pc, #144]	; (4083ac <auto_stop_enter+0xf8>)
  40831a:	47a0      	blx	r4
	march_cam(0);
  40831c:	2100      	movs	r1, #0
  40831e:	2001      	movs	r0, #1
  408320:	47a8      	blx	r5
  408322:	2202      	movs	r2, #2
  408324:	2100      	movs	r1, #0
  408326:	4822      	ldr	r0, [pc, #136]	; (4083b0 <auto_stop_enter+0xfc>)
  408328:	47a0      	blx	r4
	ctb_light_curtain1_ignore(0);
  40832a:	2202      	movs	r2, #2
  40832c:	2100      	movs	r1, #0
  40832e:	4821      	ldr	r0, [pc, #132]	; (4083b4 <auto_stop_enter+0x100>)
  408330:	47a0      	blx	r4
	ctb_light_curtain2_ignore(0);
  408332:	4623      	mov	r3, r4
  408334:	2202      	movs	r2, #2
  408336:	2100      	movs	r1, #0
  408338:	481f      	ldr	r0, [pc, #124]	; (4083b8 <auto_stop_enter+0x104>)
}
  40833a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ctb_light_curtain2_ignore(0);
  40833e:	4718      	bx	r3
	if((!INS) && (!ARD)) stop_idle_reset();
  408340:	079a      	lsls	r2, r3, #30
  408342:	d503      	bpl.n	40834c <auto_stop_enter+0x98>
  408344:	f003 0303 	and.w	r3, r3, #3
  408348:	2b03      	cmp	r3, #3
  40834a:	d1e2      	bne.n	408312 <auto_stop_enter+0x5e>
  40834c:	4b1b      	ldr	r3, [pc, #108]	; (4083bc <auto_stop_enter+0x108>)
  40834e:	4798      	blx	r3
	if(INS)
  408350:	7823      	ldrb	r3, [r4, #0]
  408352:	07db      	lsls	r3, r3, #31
  408354:	d4d7      	bmi.n	408306 <auto_stop_enter+0x52>
  408356:	e7dc      	b.n	408312 <auto_stop_enter+0x5e>
		if(ARD && (mstop == 1) ) ersd_allowTo_turn_on();
  408358:	f003 0303 	and.w	r3, r3, #3
  40835c:	2b03      	cmp	r3, #3
  40835e:	d0c7      	beq.n	4082f0 <auto_stop_enter+0x3c>
  408360:	4b17      	ldr	r3, [pc, #92]	; (4083c0 <auto_stop_enter+0x10c>)
  408362:	4798      	blx	r3
  408364:	e7c4      	b.n	4082f0 <auto_stop_enter+0x3c>
		menue_data_manager_saveCounterData(selector_counter, enc_get_theta(), toff_counter);
  408366:	4a17      	ldr	r2, [pc, #92]	; (4083c4 <auto_stop_enter+0x110>)
  408368:	4b17      	ldr	r3, [pc, #92]	; (4083c8 <auto_stop_enter+0x114>)
  40836a:	7816      	ldrb	r6, [r2, #0]
  40836c:	4798      	blx	r3
  40836e:	4a17      	ldr	r2, [pc, #92]	; (4083cc <auto_stop_enter+0x118>)
  408370:	4601      	mov	r1, r0
  408372:	4b17      	ldr	r3, [pc, #92]	; (4083d0 <auto_stop_enter+0x11c>)
  408374:	4630      	mov	r0, r6
  408376:	6812      	ldr	r2, [r2, #0]
  408378:	4798      	blx	r3
		floor_counter_save = 0;
  40837a:	2300      	movs	r3, #0
  40837c:	7023      	strb	r3, [r4, #0]
  40837e:	e7ab      	b.n	4082d8 <auto_stop_enter+0x24>
  408380:	2040001c 	.word	0x2040001c
  408384:	00417215 	.word	0x00417215
  408388:	00414569 	.word	0x00414569
  40838c:	20400020 	.word	0x20400020
  408390:	00404721 	.word	0x00404721
  408394:	00400941 	.word	0x00400941
  408398:	204008b2 	.word	0x204008b2
  40839c:	00409d01 	.word	0x00409d01
  4083a0:	20400c74 	.word	0x20400c74
  4083a4:	00417411 	.word	0x00417411
  4083a8:	0040d879 	.word	0x0040d879
  4083ac:	0700000e 	.word	0x0700000e
  4083b0:	07000001 	.word	0x07000001
  4083b4:	0700000c 	.word	0x0700000c
  4083b8:	0700000d 	.word	0x0700000d
  4083bc:	0040174d 	.word	0x0040174d
  4083c0:	00414321 	.word	0x00414321
  4083c4:	20400014 	.word	0x20400014
  4083c8:	00413aed 	.word	0x00413aed
  4083cc:	204008f4 	.word	0x204008f4
  4083d0:	00409ddd 	.word	0x00409ddd

004083d4 <auto_reopen_door>:
	if(state==auto_counter)
  4083d4:	4b03      	ldr	r3, [pc, #12]	; (4083e4 <auto_reopen_door+0x10>)
  4083d6:	681b      	ldr	r3, [r3, #0]
  4083d8:	2b05      	cmp	r3, #5
  4083da:	d102      	bne.n	4083e2 <auto_reopen_door+0xe>

void auto_reopen_door(void)
{
	if (auto_instate(auto_idle) == 1)
	{
		cf_press = 1;
  4083dc:	4b02      	ldr	r3, [pc, #8]	; (4083e8 <auto_reopen_door+0x14>)
  4083de:	2201      	movs	r2, #1
  4083e0:	701a      	strb	r2, [r3, #0]
  4083e2:	4770      	bx	lr
  4083e4:	2040001c 	.word	0x2040001c
  4083e8:	204008c0 	.word	0x204008c0

004083ec <auto_idle_enter>:
//Idle state subs
#define ERSC_TOFF_DELAY 250
uint32_t ersc_toff_counter;
void auto_idle_enter(void)
{
	auto_counter=auto_idle;
  4083ec:	4a28      	ldr	r2, [pc, #160]	; (408490 <auto_idle_enter+0xa4>)
  4083ee:	2105      	movs	r1, #5
	idle_camt_reset();
  4083f0:	4b28      	ldr	r3, [pc, #160]	; (408494 <auto_idle_enter+0xa8>)
{
  4083f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	auto_counter=auto_idle;
  4083f6:	6011      	str	r1, [r2, #0]
	idle_camt_reset();
  4083f8:	4798      	blx	r3
	ctb_force_door_close(0);
  4083fa:	4c27      	ldr	r4, [pc, #156]	; (408498 <auto_idle_enter+0xac>)
  4083fc:	2202      	movs	r2, #2
  4083fe:	2100      	movs	r1, #0
  408400:	4826      	ldr	r0, [pc, #152]	; (40849c <auto_idle_enter+0xb0>)
  408402:	47a0      	blx	r4
	IO_YARD(0);
  408404:	4e26      	ldr	r6, [pc, #152]	; (4084a0 <auto_idle_enter+0xb4>)
  408406:	2100      	movs	r1, #0
  408408:	2008      	movs	r0, #8
	m_gong(0);
	if(ARD && (mstop == 1) ) ersd_allowTo_turn_on();
  40840a:	4f26      	ldr	r7, [pc, #152]	; (4084a4 <auto_idle_enter+0xb8>)
	IO_YARD(0);
  40840c:	47b0      	blx	r6
	m_gong(0);
  40840e:	2100      	movs	r1, #0
  408410:	2007      	movs	r0, #7
  408412:	47b0      	blx	r6
	if(ARD && (mstop == 1) ) ersd_allowTo_turn_on();
  408414:	783b      	ldrb	r3, [r7, #0]
  408416:	079a      	lsls	r2, r3, #30
  408418:	d505      	bpl.n	408426 <auto_idle_enter+0x3a>
  40841a:	f003 0303 	and.w	r3, r3, #3
  40841e:	2b03      	cmp	r3, #3
  408420:	d001      	beq.n	408426 <auto_idle_enter+0x3a>
  408422:	4b21      	ldr	r3, [pc, #132]	; (4084a8 <auto_idle_enter+0xbc>)
  408424:	4798      	blx	r3
	ersc_toff_counter = 0;
  408426:	2500      	movs	r5, #0
  408428:	4b20      	ldr	r3, [pc, #128]	; (4084ac <auto_idle_enter+0xc0>)
	cf_press = 0;
	set_stop_flash_rate;
  40842a:	4821      	ldr	r0, [pc, #132]	; (4084b0 <auto_idle_enter+0xc4>)
  40842c:	f242 7110 	movw	r1, #10000	; 0x2710
	cf_press = 0;
  408430:	4a20      	ldr	r2, [pc, #128]	; (4084b4 <auto_idle_enter+0xc8>)
	ersc_toff_counter = 0;
  408432:	601d      	str	r5, [r3, #0]
	set_stop_flash_rate;
  408434:	6800      	ldr	r0, [r0, #0]
  408436:	4b20      	ldr	r3, [pc, #128]	; (4084b8 <auto_idle_enter+0xcc>)
	cf_press = 0;
  408438:	7015      	strb	r5, [r2, #0]
	set_stop_flash_rate;
  40843a:	4798      	blx	r3
	vfd_estop();
  40843c:	4b1f      	ldr	r3, [pc, #124]	; (4084bc <auto_idle_enter+0xd0>)
  40843e:	4798      	blx	r3
	march_cam(0);
  408440:	4629      	mov	r1, r5
  408442:	2001      	movs	r0, #1
  408444:	47b0      	blx	r6
  408446:	4629      	mov	r1, r5
  408448:	2202      	movs	r2, #2
  40844a:	481d      	ldr	r0, [pc, #116]	; (4084c0 <auto_idle_enter+0xd4>)
  40844c:	47a0      	blx	r4
	if(!door_auto_close)
  40844e:	4b1d      	ldr	r3, [pc, #116]	; (4084c4 <auto_idle_enter+0xd8>)
  408450:	785b      	ldrb	r3, [r3, #1]
  408452:	2b02      	cmp	r3, #2
  408454:	d019      	beq.n	40848a <auto_idle_enter+0x9e>
	{
		if(onfloor)
  408456:	4b1c      	ldr	r3, [pc, #112]	; (4084c8 <auto_idle_enter+0xdc>)
  408458:	681b      	ldr	r3, [r3, #0]
  40845a:	b99b      	cbnz	r3, 408484 <auto_idle_enter+0x98>
	{
		close_doors();
	}
		
	
	if(INS)
  40845c:	783b      	ldrb	r3, [r7, #0]
  40845e:	07db      	lsls	r3, r3, #31
  408460:	d505      	bpl.n	40846e <auto_idle_enter+0x82>
	{
		ar_up(0);
  408462:	2100      	movs	r1, #0
  408464:	2004      	movs	r0, #4
  408466:	47b0      	blx	r6
		ar_dwn(0);
  408468:	2100      	movs	r1, #0
  40846a:	2005      	movs	r0, #5
  40846c:	47b0      	blx	r6
	}
	//req_drop_cntr=0;
	ctb_light_curtain1_ignore(0);
  40846e:	2202      	movs	r2, #2
  408470:	2100      	movs	r1, #0
  408472:	4816      	ldr	r0, [pc, #88]	; (4084cc <auto_idle_enter+0xe0>)
  408474:	47a0      	blx	r4
	ctb_light_curtain2_ignore(0);
  408476:	4623      	mov	r3, r4
  408478:	2202      	movs	r2, #2
  40847a:	2100      	movs	r1, #0
  40847c:	4814      	ldr	r0, [pc, #80]	; (4084d0 <auto_idle_enter+0xe4>)
}
  40847e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ctb_light_curtain2_ignore(0);
  408482:	4718      	bx	r3
			open_doors();
  408484:	4b13      	ldr	r3, [pc, #76]	; (4084d4 <auto_idle_enter+0xe8>)
  408486:	4798      	blx	r3
  408488:	e7e8      	b.n	40845c <auto_idle_enter+0x70>
		close_doors();
  40848a:	4b13      	ldr	r3, [pc, #76]	; (4084d8 <auto_idle_enter+0xec>)
  40848c:	4798      	blx	r3
  40848e:	e7e5      	b.n	40845c <auto_idle_enter+0x70>
  408490:	2040001c 	.word	0x2040001c
  408494:	0040175d 	.word	0x0040175d
  408498:	0040d879 	.word	0x0040d879
  40849c:	0700000e 	.word	0x0700000e
  4084a0:	00400941 	.word	0x00400941
  4084a4:	204008b2 	.word	0x204008b2
  4084a8:	00414321 	.word	0x00414321
  4084ac:	20404fe8 	.word	0x20404fe8
  4084b0:	20400c74 	.word	0x20400c74
  4084b4:	204008c0 	.word	0x204008c0
  4084b8:	00417411 	.word	0x00417411
  4084bc:	00417215 	.word	0x00417215
  4084c0:	07000001 	.word	0x07000001
  4084c4:	204052b4 	.word	0x204052b4
  4084c8:	204008d4 	.word	0x204008d4
  4084cc:	0700000c 	.word	0x0700000c
  4084d0:	0700000d 	.word	0x0700000d
  4084d4:	00408215 	.word	0x00408215
  4084d8:	00408265 	.word	0x00408265

004084dc <auto_stop_exit>:
{
  4084dc:	b570      	push	{r4, r5, r6, lr}
	if(s_i_err()) return 1; //if there is error preventing elevator moving don't exit stop_state
  4084de:	4b33      	ldr	r3, [pc, #204]	; (4085ac <auto_stop_exit+0xd0>)
  4084e0:	4798      	blx	r3
  4084e2:	b100      	cbz	r0, 4084e6 <auto_stop_exit+0xa>
  4084e4:	bd70      	pop	{r4, r5, r6, pc}
  4084e6:	4b32      	ldr	r3, [pc, #200]	; (4085b0 <auto_stop_exit+0xd4>)
  4084e8:	4798      	blx	r3
	if(auto_stop_guard())
  4084ea:	2800      	cmp	r0, #0
  4084ec:	d1fa      	bne.n	4084e4 <auto_stop_exit+0x8>
	if((dr_opened && !external_auto )||(INS)||(ARD))
  4084ee:	4a31      	ldr	r2, [pc, #196]	; (4085b4 <auto_stop_exit+0xd8>)
  4084f0:	4c31      	ldr	r4, [pc, #196]	; (4085b8 <auto_stop_exit+0xdc>)
  4084f2:	6813      	ldr	r3, [r2, #0]
  4084f4:	2b00      	cmp	r3, #0
  4084f6:	d036      	beq.n	408566 <auto_stop_exit+0x8a>
  4084f8:	4d30      	ldr	r5, [pc, #192]	; (4085bc <auto_stop_exit+0xe0>)
  4084fa:	786b      	ldrb	r3, [r5, #1]
  4084fc:	3b02      	subs	r3, #2
  4084fe:	2b01      	cmp	r3, #1
  408500:	d931      	bls.n	408566 <auto_stop_exit+0x8a>
  408502:	7823      	ldrb	r3, [r4, #0]
		dr_opened=0;
  408504:	6010      	str	r0, [r2, #0]
	if( (INS) && ((mup == 1) || (mdwn == 1)) ) auto_idle_enter();
  408506:	07da      	lsls	r2, r3, #31
  408508:	d54a      	bpl.n	4085a0 <auto_stop_exit+0xc4>
  40850a:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
  40850e:	280d      	cmp	r0, #13
  408510:	d83e      	bhi.n	408590 <auto_stop_exit+0xb4>
  408512:	2300      	movs	r3, #0
  408514:	2200      	movs	r2, #0
  408516:	4318      	orrs	r0, r3
  408518:	4e29      	ldr	r6, [pc, #164]	; (4085c0 <auto_stop_exit+0xe4>)
  40851a:	4611      	mov	r1, r2
  40851c:	47b0      	blx	r6
  40851e:	2801      	cmp	r0, #1
  408520:	d01d      	beq.n	40855e <auto_stop_exit+0x82>
  408522:	f895 0089 	ldrb.w	r0, [r5, #137]	; 0x89
  408526:	280d      	cmp	r0, #13
  408528:	d93d      	bls.n	4085a6 <auto_stop_exit+0xca>
  40852a:	2810      	cmp	r0, #16
  40852c:	f100 000e 	add.w	r0, r0, #14
  408530:	bf34      	ite	cc
  408532:	2300      	movcc	r3, #0
  408534:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  408538:	2200      	movs	r2, #0
  40853a:	4318      	orrs	r0, r3
  40853c:	4611      	mov	r1, r2
  40853e:	47b0      	blx	r6
  408540:	2801      	cmp	r0, #1
  408542:	d00c      	beq.n	40855e <auto_stop_exit+0x82>
  408544:	7823      	ldrb	r3, [r4, #0]
  408546:	f003 0102 	and.w	r1, r3, #2
	else if ( (ARD) && (ersd_isReady()) ) auto_idle_enter();
  40854a:	2900      	cmp	r1, #0
  40854c:	d0ca      	beq.n	4084e4 <auto_stop_exit+0x8>
  40854e:	f003 0003 	and.w	r0, r3, #3
  408552:	2803      	cmp	r0, #3
  408554:	d0c6      	beq.n	4084e4 <auto_stop_exit+0x8>
  408556:	4b1b      	ldr	r3, [pc, #108]	; (4085c4 <auto_stop_exit+0xe8>)
  408558:	4798      	blx	r3
  40855a:	2800      	cmp	r0, #0
  40855c:	d0c2      	beq.n	4084e4 <auto_stop_exit+0x8>
	if( (INS) && ((mup == 1) || (mdwn == 1)) ) auto_idle_enter();
  40855e:	4b1a      	ldr	r3, [pc, #104]	; (4085c8 <auto_stop_exit+0xec>)
}
  408560:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	if( (INS) && ((mup == 1) || (mdwn == 1)) ) auto_idle_enter();
  408564:	4718      	bx	r3
	if((dr_opened && !external_auto )||(INS)||(ARD))
  408566:	7823      	ldrb	r3, [r4, #0]
  408568:	f013 0501 	ands.w	r5, r3, #1
  40856c:	d109      	bne.n	408582 <auto_stop_exit+0xa6>
  40856e:	f013 0102 	ands.w	r1, r3, #2
  408572:	d0b7      	beq.n	4084e4 <auto_stop_exit+0x8>
  408574:	f003 0003 	and.w	r0, r3, #3
  408578:	2803      	cmp	r0, #3
  40857a:	d0ea      	beq.n	408552 <auto_stop_exit+0x76>
		dr_opened=0;
  40857c:	6015      	str	r5, [r2, #0]
  40857e:	b2c9      	uxtb	r1, r1
  408580:	e7e3      	b.n	40854a <auto_stop_exit+0x6e>
  408582:	4d0e      	ldr	r5, [pc, #56]	; (4085bc <auto_stop_exit+0xe0>)
  408584:	2300      	movs	r3, #0
	if( (INS) && ((mup == 1) || (mdwn == 1)) ) auto_idle_enter();
  408586:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
		dr_opened=0;
  40858a:	6013      	str	r3, [r2, #0]
	if( (INS) && ((mup == 1) || (mdwn == 1)) ) auto_idle_enter();
  40858c:	280d      	cmp	r0, #13
  40858e:	d9c0      	bls.n	408512 <auto_stop_exit+0x36>
  408590:	2810      	cmp	r0, #16
  408592:	f100 000e 	add.w	r0, r0, #14
  408596:	bf34      	ite	cc
  408598:	2300      	movcc	r3, #0
  40859a:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  40859e:	e7b9      	b.n	408514 <auto_stop_exit+0x38>
  4085a0:	f003 0102 	and.w	r1, r3, #2
  4085a4:	e7eb      	b.n	40857e <auto_stop_exit+0xa2>
  4085a6:	2300      	movs	r3, #0
  4085a8:	e7c6      	b.n	408538 <auto_stop_exit+0x5c>
  4085aa:	bf00      	nop
  4085ac:	00400bf9 	.word	0x00400bf9
  4085b0:	00407ff5 	.word	0x00407ff5
  4085b4:	204008c4 	.word	0x204008c4
  4085b8:	204008b2 	.word	0x204008b2
  4085bc:	204052b4 	.word	0x204052b4
  4085c0:	0040d879 	.word	0x0040d879
  4085c4:	00414549 	.word	0x00414549
  4085c8:	004083ed 	.word	0x004083ed

004085cc <auto_stop_exe>:
{
  4085cc:	b570      	push	{r4, r5, r6, lr}
	if ((INS)||(ARD)) light_timer_reset();
  4085ce:	4c35      	ldr	r4, [pc, #212]	; (4086a4 <auto_stop_exe+0xd8>)
  4085d0:	7823      	ldrb	r3, [r4, #0]
  4085d2:	07da      	lsls	r2, r3, #31
  4085d4:	d406      	bmi.n	4085e4 <auto_stop_exe+0x18>
  4085d6:	f013 0f02 	tst.w	r3, #2
  4085da:	f003 0303 	and.w	r3, r3, #3
  4085de:	d038      	beq.n	408652 <auto_stop_exe+0x86>
  4085e0:	2b03      	cmp	r3, #3
  4085e2:	d038      	beq.n	408656 <auto_stop_exe+0x8a>
  4085e4:	4b30      	ldr	r3, [pc, #192]	; (4086a8 <auto_stop_exe+0xdc>)
  4085e6:	4798      	blx	r3
	if(ARDINS) 
  4085e8:	7823      	ldrb	r3, [r4, #0]
  4085ea:	f003 0203 	and.w	r2, r3, #3
  4085ee:	2a03      	cmp	r2, #3
  4085f0:	d031      	beq.n	408656 <auto_stop_exe+0x8a>
	else if(ARD)
  4085f2:	079b      	lsls	r3, r3, #30
  4085f4:	d436      	bmi.n	408664 <auto_stop_exe+0x98>
	if((h_close==1)&&(external_auto)&&!(s_i_err()==1)&&(ctb_light_curtain_fb==0))
  4085f6:	4e2d      	ldr	r6, [pc, #180]	; (4086ac <auto_stop_exe+0xe0>)
  4085f8:	2200      	movs	r2, #0
  4085fa:	4c2d      	ldr	r4, [pc, #180]	; (4086b0 <auto_stop_exe+0xe4>)
  4085fc:	7ab0      	ldrb	r0, [r6, #10]
  4085fe:	4611      	mov	r1, r2
  408600:	3001      	adds	r0, #1
  408602:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  408606:	47a0      	blx	r4
  408608:	4605      	mov	r5, r0
  40860a:	f896 008f 	ldrb.w	r0, [r6, #143]	; 0x8f
  40860e:	280d      	cmp	r0, #13
  408610:	d91d      	bls.n	40864e <auto_stop_exe+0x82>
  408612:	2810      	cmp	r0, #16
  408614:	f100 000e 	add.w	r0, r0, #14
  408618:	bf34      	ite	cc
  40861a:	2300      	movcc	r3, #0
  40861c:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  408620:	2200      	movs	r2, #0
  408622:	4318      	orrs	r0, r3
  408624:	4611      	mov	r1, r2
  408626:	47a0      	blx	r4
  408628:	4328      	orrs	r0, r5
  40862a:	2801      	cmp	r0, #1
  40862c:	d01d      	beq.n	40866a <auto_stop_exe+0x9e>
		else if((shk==1)&&(ctb_light_curtain_fb == 0))//||external_auto) //the door is closed or automatic doors
  40862e:	2202      	movs	r2, #2
  408630:	2100      	movs	r1, #0
  408632:	4820      	ldr	r0, [pc, #128]	; (4086b4 <auto_stop_exe+0xe8>)
  408634:	47a0      	blx	r4
			auto_stop_exit();
  408636:	4c20      	ldr	r4, [pc, #128]	; (4086b8 <auto_stop_exe+0xec>)
		else if((shk==1)&&(ctb_light_curtain_fb == 0))//||external_auto) //the door is closed or automatic doors
  408638:	2800      	cmp	r0, #0
  40863a:	d030      	beq.n	40869e <auto_stop_exe+0xd2>
			if(!onfloor)
  40863c:	4b1f      	ldr	r3, [pc, #124]	; (4086bc <auto_stop_exe+0xf0>)
  40863e:	681b      	ldr	r3, [r3, #0]
  408640:	b33b      	cbz	r3, 408692 <auto_stop_exe+0xc6>
					open_doors();
  408642:	4b1f      	ldr	r3, [pc, #124]	; (4086c0 <auto_stop_exe+0xf4>)
  408644:	4798      	blx	r3
	auto_stop_exit();
  408646:	4623      	mov	r3, r4
}
  408648:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	auto_stop_exit();
  40864c:	4718      	bx	r3
	if((h_close==1)&&(external_auto)&&!(s_i_err()==1)&&(ctb_light_curtain_fb==0))
  40864e:	2300      	movs	r3, #0
  408650:	e7e6      	b.n	408620 <auto_stop_exe+0x54>
	if(ARDINS) 
  408652:	2b03      	cmp	r3, #3
  408654:	d1cf      	bne.n	4085f6 <auto_stop_exe+0x2a>
		IO_YARD(1);
  408656:	2101      	movs	r1, #1
  408658:	2008      	movs	r0, #8
  40865a:	4b1a      	ldr	r3, [pc, #104]	; (4086c4 <auto_stop_exe+0xf8>)
  40865c:	4798      	blx	r3
		ersd_force_turn_off();
  40865e:	4b1a      	ldr	r3, [pc, #104]	; (4086c8 <auto_stop_exe+0xfc>)
  408660:	4798      	blx	r3
  408662:	e7c8      	b.n	4085f6 <auto_stop_exe+0x2a>
		else ersd_allowTo_turn_on();
  408664:	4b19      	ldr	r3, [pc, #100]	; (4086cc <auto_stop_exe+0x100>)
  408666:	4798      	blx	r3
  408668:	e7c5      	b.n	4085f6 <auto_stop_exe+0x2a>
	if((h_close==1)&&(external_auto)&&!(s_i_err()==1)&&(ctb_light_curtain_fb==0))
  40866a:	7873      	ldrb	r3, [r6, #1]
  40866c:	3b02      	subs	r3, #2
  40866e:	2b01      	cmp	r3, #1
  408670:	d8dd      	bhi.n	40862e <auto_stop_exe+0x62>
  408672:	4b17      	ldr	r3, [pc, #92]	; (4086d0 <auto_stop_exe+0x104>)
  408674:	4798      	blx	r3
  408676:	2801      	cmp	r0, #1
  408678:	d0d9      	beq.n	40862e <auto_stop_exe+0x62>
  40867a:	2202      	movs	r2, #2
  40867c:	2100      	movs	r1, #0
  40867e:	480d      	ldr	r0, [pc, #52]	; (4086b4 <auto_stop_exe+0xe8>)
  408680:	47a0      	blx	r4
  408682:	2800      	cmp	r0, #0
  408684:	d1d3      	bne.n	40862e <auto_stop_exe+0x62>
		light_timer_reset();
  408686:	4b08      	ldr	r3, [pc, #32]	; (4086a8 <auto_stop_exe+0xdc>)
  408688:	4798      	blx	r3
		auto_idle_enter();// if |<>| is pressed then goto idle to close auto door
  40868a:	4b12      	ldr	r3, [pc, #72]	; (4086d4 <auto_stop_exe+0x108>)
  40868c:	4798      	blx	r3
  40868e:	4c0a      	ldr	r4, [pc, #40]	; (4086b8 <auto_stop_exe+0xec>)
  408690:	e7d9      	b.n	408646 <auto_stop_exe+0x7a>
					close_doors();
  408692:	4b11      	ldr	r3, [pc, #68]	; (4086d8 <auto_stop_exe+0x10c>)
  408694:	4798      	blx	r3
	auto_stop_exit();
  408696:	4623      	mov	r3, r4
}
  408698:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	auto_stop_exit();
  40869c:	4718      	bx	r3
			auto_stop_exit();
  40869e:	47a0      	blx	r4
  4086a0:	e7cc      	b.n	40863c <auto_stop_exe+0x70>
  4086a2:	bf00      	nop
  4086a4:	204008b2 	.word	0x204008b2
  4086a8:	0040180d 	.word	0x0040180d
  4086ac:	204052b4 	.word	0x204052b4
  4086b0:	0040d879 	.word	0x0040d879
  4086b4:	0b000006 	.word	0x0b000006
  4086b8:	004084dd 	.word	0x004084dd
  4086bc:	204008d4 	.word	0x204008d4
  4086c0:	00408215 	.word	0x00408215
  4086c4:	00400941 	.word	0x00400941
  4086c8:	00414315 	.word	0x00414315
  4086cc:	00414321 	.word	0x00414321
  4086d0:	00400bf9 	.word	0x00400bf9
  4086d4:	004083ed 	.word	0x004083ed
  4086d8:	00408265 	.word	0x00408265

004086dc <auto_idle_exe>:
void auto_idle_exe(void)
{
	if(((device_off == 1)&&(INS==0))||(s_i_err()==1))
  4086dc:	4b88      	ldr	r3, [pc, #544]	; (408900 <auto_idle_exe+0x224>)
  4086de:	681b      	ldr	r3, [r3, #0]
  4086e0:	2b01      	cmp	r3, #1
  4086e2:	f000 80b1 	beq.w	408848 <auto_idle_exe+0x16c>
  4086e6:	4b87      	ldr	r3, [pc, #540]	; (408904 <auto_idle_exe+0x228>)
{
  4086e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if(((device_off == 1)&&(INS==0))||(s_i_err()==1))
  4086ec:	4798      	blx	r3
  4086ee:	2801      	cmp	r0, #1
  4086f0:	f000 80c2 	beq.w	408878 <auto_idle_exe+0x19c>
	{
		auto_stop_enter();
		return;
	}
	if ( (INS) || (ARD) ) light_timer_reset();
  4086f4:	4e84      	ldr	r6, [pc, #528]	; (408908 <auto_idle_exe+0x22c>)
  4086f6:	7833      	ldrb	r3, [r6, #0]
  4086f8:	07d8      	lsls	r0, r3, #31
  4086fa:	d406      	bmi.n	40870a <auto_idle_exe+0x2e>
  4086fc:	0799      	lsls	r1, r3, #30
  4086fe:	d50a      	bpl.n	408716 <auto_idle_exe+0x3a>
  408700:	f003 0303 	and.w	r3, r3, #3
  408704:	2b03      	cmp	r3, #3
  408706:	f000 808a 	beq.w	40881e <auto_idle_exe+0x142>
  40870a:	4b80      	ldr	r3, [pc, #512]	; (40890c <auto_idle_exe+0x230>)
  40870c:	4798      	blx	r3
	if ( (ARD) || (ARDINS))
  40870e:	7833      	ldrb	r3, [r6, #0]
  408710:	079a      	lsls	r2, r3, #30
  408712:	f100 8084 	bmi.w	40881e <auto_idle_exe+0x142>
  408716:	f003 0303 	and.w	r3, r3, #3
  40871a:	2b03      	cmp	r3, #3
  40871c:	d07f      	beq.n	40881e <auto_idle_exe+0x142>
				IO_YARD(1);
				ersd_force_turn_off();
			}
		}
	}
	if(!door_auto_close)
  40871e:	4c7c      	ldr	r4, [pc, #496]	; (408910 <auto_idle_exe+0x234>)
  408720:	7863      	ldrb	r3, [r4, #1]
  408722:	2b02      	cmp	r3, #2
  408724:	f000 80e9 	beq.w	4088fa <auto_idle_exe+0x21e>
	{
		if(onfloor)
  408728:	4b7a      	ldr	r3, [pc, #488]	; (408914 <auto_idle_exe+0x238>)
  40872a:	681b      	ldr	r3, [r3, #0]
  40872c:	2b00      	cmp	r3, #0
  40872e:	f040 80d5 	bne.w	4088dc <auto_idle_exe+0x200>
	}
	else //if the door is auto_close then close at ideal
	{
		close_doors();
	}
	if(((h_open==1)||(ctb_light_curtain_fb)||((cf_press==1)&&(h_close==0)))&&(door_is_auto))
  408732:	7aa0      	ldrb	r0, [r4, #10]
  408734:	2200      	movs	r2, #0
  408736:	4d78      	ldr	r5, [pc, #480]	; (408918 <auto_idle_exe+0x23c>)
  408738:	3002      	adds	r0, #2
  40873a:	4611      	mov	r1, r2
  40873c:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  408740:	47a8      	blx	r5
  408742:	4607      	mov	r7, r0
  408744:	f894 008e 	ldrb.w	r0, [r4, #142]	; 0x8e
  408748:	280d      	cmp	r0, #13
  40874a:	f240 8093 	bls.w	408874 <auto_idle_exe+0x198>
  40874e:	2810      	cmp	r0, #16
  408750:	f100 000e 	add.w	r0, r0, #14
  408754:	bf34      	ite	cc
  408756:	2300      	movcc	r3, #0
  408758:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  40875c:	2200      	movs	r2, #0
  40875e:	4318      	orrs	r0, r3
  408760:	4611      	mov	r1, r2
  408762:	47a8      	blx	r5
  408764:	4338      	orrs	r0, r7
  408766:	2801      	cmp	r0, #1
  408768:	d007      	beq.n	40877a <auto_idle_exe+0x9e>
  40876a:	2202      	movs	r2, #2
  40876c:	2100      	movs	r1, #0
  40876e:	486b      	ldr	r0, [pc, #428]	; (40891c <auto_idle_exe+0x240>)
  408770:	47a8      	blx	r5
  408772:	4607      	mov	r7, r0
  408774:	2800      	cmp	r0, #0
  408776:	f000 808b 	beq.w	408890 <auto_idle_exe+0x1b4>
  40877a:	7863      	ldrb	r3, [r4, #1]
  40877c:	2b00      	cmp	r3, #0
  40877e:	f040 80b2 	bne.w	4088e6 <auto_idle_exe+0x20a>
		{
			auto_idle_exit();
		}
		else if((shk==1))//||(external_auto))
		{
			if((ARD) && (ersd_isReady() == 1))
  408782:	7833      	ldrb	r3, [r6, #0]
  408784:	079f      	lsls	r7, r3, #30
  408786:	d508      	bpl.n	40879a <auto_idle_exe+0xbe>
  408788:	f003 0203 	and.w	r2, r3, #3
  40878c:	2a03      	cmp	r2, #3
  40878e:	d004      	beq.n	40879a <auto_idle_exe+0xbe>
  408790:	4b63      	ldr	r3, [pc, #396]	; (408920 <auto_idle_exe+0x244>)
  408792:	4798      	blx	r3
  408794:	2801      	cmp	r0, #1
  408796:	d03e      	beq.n	408816 <auto_idle_exe+0x13a>
  408798:	7833      	ldrb	r3, [r6, #0]
				if((mstop == 1))//not on floor
				{
					idle_camt_start(); //auto_idle_exit();
				}
			}
			else if((INS) && ((mup==1)||(mdwn==1)))
  40879a:	07d8      	lsls	r0, r3, #31
  40879c:	d55b      	bpl.n	408856 <auto_idle_exe+0x17a>
  40879e:	f894 0088 	ldrb.w	r0, [r4, #136]	; 0x88
  4087a2:	280d      	cmp	r0, #13
  4087a4:	d86c      	bhi.n	408880 <auto_idle_exe+0x1a4>
  4087a6:	2300      	movs	r3, #0
  4087a8:	2200      	movs	r2, #0
  4087aa:	4318      	orrs	r0, r3
  4087ac:	4611      	mov	r1, r2
  4087ae:	47a8      	blx	r5
  4087b0:	2801      	cmp	r0, #1
  4087b2:	d011      	beq.n	4087d8 <auto_idle_exe+0xfc>
  4087b4:	f894 0089 	ldrb.w	r0, [r4, #137]	; 0x89
  4087b8:	280d      	cmp	r0, #13
  4087ba:	f240 8092 	bls.w	4088e2 <auto_idle_exe+0x206>
  4087be:	2810      	cmp	r0, #16
  4087c0:	f100 000e 	add.w	r0, r0, #14
  4087c4:	bf34      	ite	cc
  4087c6:	2300      	movcc	r3, #0
  4087c8:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  4087cc:	2200      	movs	r2, #0
  4087ce:	4318      	orrs	r0, r3
  4087d0:	4611      	mov	r1, r2
  4087d2:	47a8      	blx	r5
  4087d4:	2801      	cmp	r0, #1
  4087d6:	d13e      	bne.n	408856 <auto_idle_exe+0x17a>
			{
				if(!(((mup == 1) && (upfdl0 == 0) && (((mstop == 0) && (upfl == 2)) || (upfl == 0)) ) || ((mdwn ==1 ) && (dnfdl0 == 0) && (((mstop == 0) && (dnfl == 2)) || (dnfl == 0)))))//don't move further than final limits
  4087d8:	f894 0088 	ldrb.w	r0, [r4, #136]	; 0x88
  4087dc:	280d      	cmp	r0, #13
  4087de:	f240 808a 	bls.w	4088f6 <auto_idle_exe+0x21a>
  4087e2:	2810      	cmp	r0, #16
  4087e4:	f100 000e 	add.w	r0, r0, #14
  4087e8:	bf34      	ite	cc
  4087ea:	2300      	movcc	r3, #0
  4087ec:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  4087f0:	2200      	movs	r2, #0
  4087f2:	4318      	orrs	r0, r3
  4087f4:	4611      	mov	r1, r2
  4087f6:	47a8      	blx	r5
  4087f8:	f894 0089 	ldrb.w	r0, [r4, #137]	; 0x89
  4087fc:	280d      	cmp	r0, #13
  4087fe:	d978      	bls.n	4088f2 <auto_idle_exe+0x216>
  408800:	2810      	cmp	r0, #16
  408802:	f100 000e 	add.w	r0, r0, #14
  408806:	bf34      	ite	cc
  408808:	2300      	movcc	r3, #0
  40880a:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  40880e:	2200      	movs	r2, #0
  408810:	4318      	orrs	r0, r3
  408812:	4611      	mov	r1, r2
  408814:	47a8      	blx	r5
					idle_camt_start();//auto_idle_exit();//if mup or mdn then enter maintenance move mode
  408816:	4b43      	ldr	r3, [pc, #268]	; (408924 <auto_idle_exe+0x248>)
			{
				idle_camt_start();//start cam transition timer
			}
		}
	}
}
  408818:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					idle_camt_start();//auto_idle_exit();//if mup or mdn then enter maintenance move mode
  40881c:	4718      	bx	r3
		if( !ersd_isReady() )
  40881e:	4b40      	ldr	r3, [pc, #256]	; (408920 <auto_idle_exe+0x244>)
  408820:	4798      	blx	r3
  408822:	b348      	cbz	r0, 408878 <auto_idle_exe+0x19c>
		else if((mstop == 0) || (INS))
  408824:	7833      	ldrb	r3, [r6, #0]
  408826:	07db      	lsls	r3, r3, #31
  408828:	f57f af79 	bpl.w	40871e <auto_idle_exe+0x42>
			if(++ersc_toff_counter > ERSC_TOFF_DELAY)
  40882c:	4a3e      	ldr	r2, [pc, #248]	; (408928 <auto_idle_exe+0x24c>)
  40882e:	6813      	ldr	r3, [r2, #0]
  408830:	3301      	adds	r3, #1
  408832:	2bfa      	cmp	r3, #250	; 0xfa
  408834:	6013      	str	r3, [r2, #0]
  408836:	f67f af72 	bls.w	40871e <auto_idle_exe+0x42>
				IO_YARD(1);
  40883a:	2101      	movs	r1, #1
  40883c:	2008      	movs	r0, #8
  40883e:	4b3b      	ldr	r3, [pc, #236]	; (40892c <auto_idle_exe+0x250>)
  408840:	4798      	blx	r3
				ersd_force_turn_off();
  408842:	4b3b      	ldr	r3, [pc, #236]	; (408930 <auto_idle_exe+0x254>)
  408844:	4798      	blx	r3
  408846:	e76a      	b.n	40871e <auto_idle_exe+0x42>
	if(((device_off == 1)&&(INS==0))||(s_i_err()==1))
  408848:	4b2f      	ldr	r3, [pc, #188]	; (408908 <auto_idle_exe+0x22c>)
  40884a:	781b      	ldrb	r3, [r3, #0]
  40884c:	07db      	lsls	r3, r3, #31
  40884e:	f53f af4a 	bmi.w	4086e6 <auto_idle_exe+0xa>
		auto_stop_enter();
  408852:	4b38      	ldr	r3, [pc, #224]	; (408934 <auto_idle_exe+0x258>)
  408854:	4718      	bx	r3
			else if((get_scheduled_floor()!=-1)&&(INS==0)&&(ARD==0)&&(ersd_isOff()))// if there is a service in auto mode
  408856:	4b38      	ldr	r3, [pc, #224]	; (408938 <auto_idle_exe+0x25c>)
  408858:	4798      	blx	r3
  40885a:	3001      	adds	r0, #1
  40885c:	d008      	beq.n	408870 <auto_idle_exe+0x194>
  40885e:	7833      	ldrb	r3, [r6, #0]
  408860:	07d9      	lsls	r1, r3, #31
  408862:	d405      	bmi.n	408870 <auto_idle_exe+0x194>
  408864:	079a      	lsls	r2, r3, #30
  408866:	d534      	bpl.n	4088d2 <auto_idle_exe+0x1f6>
  408868:	f003 0303 	and.w	r3, r3, #3
  40886c:	2b03      	cmp	r3, #3
  40886e:	d030      	beq.n	4088d2 <auto_idle_exe+0x1f6>
  408870:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if(((h_open==1)||(ctb_light_curtain_fb)||((cf_press==1)&&(h_close==0)))&&(door_is_auto))
  408874:	2300      	movs	r3, #0
  408876:	e771      	b.n	40875c <auto_idle_exe+0x80>
		auto_stop_enter();
  408878:	4b2e      	ldr	r3, [pc, #184]	; (408934 <auto_idle_exe+0x258>)
}
  40887a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		auto_stop_enter();
  40887e:	4718      	bx	r3
			else if((INS) && ((mup==1)||(mdwn==1)))
  408880:	2810      	cmp	r0, #16
  408882:	f100 000e 	add.w	r0, r0, #14
  408886:	bf34      	ite	cc
  408888:	2300      	movcc	r3, #0
  40888a:	f04f 437a 	movcs.w	r3, #4194304000	; 0xfa000000
  40888e:	e78b      	b.n	4087a8 <auto_idle_exe+0xcc>
	if(((h_open==1)||(ctb_light_curtain_fb)||((cf_press==1)&&(h_close==0)))&&(door_is_auto))
  408890:	4b2a      	ldr	r3, [pc, #168]	; (40893c <auto_idle_exe+0x260>)
  408892:	781b      	ldrb	r3, [r3, #0]
  408894:	2b01      	cmp	r3, #1
  408896:	f47f af74 	bne.w	408782 <auto_idle_exe+0xa6>
  40889a:	7aa0      	ldrb	r0, [r4, #10]
  40889c:	463a      	mov	r2, r7
  40889e:	4639      	mov	r1, r7
  4088a0:	3001      	adds	r0, #1
  4088a2:	f040 7040 	orr.w	r0, r0, #50331648	; 0x3000000
  4088a6:	47a8      	blx	r5
  4088a8:	4680      	mov	r8, r0
  4088aa:	f894 008f 	ldrb.w	r0, [r4, #143]	; 0x8f
  4088ae:	280d      	cmp	r0, #13
  4088b0:	d906      	bls.n	4088c0 <auto_idle_exe+0x1e4>
  4088b2:	2810      	cmp	r0, #16
  4088b4:	f100 000e 	add.w	r0, r0, #14
  4088b8:	bf34      	ite	cc
  4088ba:	2700      	movcc	r7, #0
  4088bc:	f04f 477a 	movcs.w	r7, #4194304000	; 0xfa000000
  4088c0:	2200      	movs	r2, #0
  4088c2:	4338      	orrs	r0, r7
  4088c4:	4611      	mov	r1, r2
  4088c6:	47a8      	blx	r5
  4088c8:	ea58 0300 	orrs.w	r3, r8, r0
  4088cc:	f43f af55 	beq.w	40877a <auto_idle_exe+0x9e>
  4088d0:	e757      	b.n	408782 <auto_idle_exe+0xa6>
			else if((get_scheduled_floor()!=-1)&&(INS==0)&&(ARD==0)&&(ersd_isOff()))// if there is a service in auto mode
  4088d2:	4b1b      	ldr	r3, [pc, #108]	; (408940 <auto_idle_exe+0x264>)
  4088d4:	4798      	blx	r3
  4088d6:	2800      	cmp	r0, #0
  4088d8:	d0ca      	beq.n	408870 <auto_idle_exe+0x194>
  4088da:	e79c      	b.n	408816 <auto_idle_exe+0x13a>
			open_doors();
  4088dc:	4b19      	ldr	r3, [pc, #100]	; (408944 <auto_idle_exe+0x268>)
  4088de:	4798      	blx	r3
  4088e0:	e727      	b.n	408732 <auto_idle_exe+0x56>
			else if((INS) && ((mup==1)||(mdwn==1)))
  4088e2:	2300      	movs	r3, #0
  4088e4:	e772      	b.n	4087cc <auto_idle_exe+0xf0>
		auto_stop_enter();// if |<>| or current floor ex button is pressed then goto stop to open auto door
  4088e6:	4b13      	ldr	r3, [pc, #76]	; (408934 <auto_idle_exe+0x258>)
  4088e8:	4798      	blx	r3
		light_timer_reset();
  4088ea:	4b08      	ldr	r3, [pc, #32]	; (40890c <auto_idle_exe+0x230>)
}
  4088ec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		light_timer_reset();
  4088f0:	4718      	bx	r3
				if(!(((mup == 1) && (upfdl0 == 0) && (((mstop == 0) && (upfl == 2)) || (upfl == 0)) ) || ((mdwn ==1 ) && (dnfdl0 == 0) && (((mstop == 0) && (dnfl == 2)) || (dnfl == 0)))))//don't move further than final limits
  4088f2:	2300      	movs	r3, #0
  4088f4:	e78b      	b.n	40880e <auto_idle_exe+0x132>
  4088f6:	2300      	movs	r3, #0
  4088f8:	e77a      	b.n	4087f0 <auto_idle_exe+0x114>
		close_doors();
  4088fa:	4b13      	ldr	r3, [pc, #76]	; (408948 <auto_idle_exe+0x26c>)
  4088fc:	4798      	blx	r3
  4088fe:	e718      	b.n	408732 <auto_idle_exe+0x56>
  408900:	204008f0 	.word	0x204008f0
  408904:	00400bf9 	.word	0x00400bf9
  408908:	204008b2 	.word	0x204008b2
  40890c:	0040180d 	.word	0x0040180d
  408910:	204052b4 	.word	0x204052b4
  408914:	204008d4 	.word	0x204008d4
  408918:	0040d879 	.word	0x0040d879
  40891c:	0b000006 	.word	0x0b000006
  408920:	00414549 	.word	0x00414549
  408924:	00401801 	.word	0x00401801
  408928:	20404fe8 	.word	0x20404fe8
  40892c:	00400941 	.word	0x00400941
  408930:	00414315 	.word	0x00414315
  408934:	004082b5 	.word	0x004082b5
  408938:	00401625 	.word	0x00401625
  40893c:	204008c0 	.word	0x204008c0
  408940:	00414531 	.word	0x00414531
  408944:	00408215 	.word	0x00408215
  408948:	00408265 	.word	0x00408265

0040894c <march_set>:

//hspd state subs
int8_t lspd_mstp_met = 0, Dstop_speed_sign = 1;
void march_set(void)
{
	march_cam(1);
  40894c:	2101      	movs	r1, #1
{
  40894e:	b570      	push	{r4, r5, r6, lr}
	march_cam(1);
  408950:	4608      	mov	r0, r1
  408952:	4c0d      	ldr	r4, [pc, #52]	; (408988 <march_set+0x3c>)
  408954:	47a0      	blx	r4
  408956:	2202      	movs	r2, #2
  408958:	2101      	movs	r1, #1
  40895a:	4b0c      	ldr	r3, [pc, #48]	; (40898c <march_set+0x40>)
  40895c:	480c      	ldr	r0, [pc, #48]	; (408990 <march_set+0x44>)
  40895e:	4798      	blx	r3
	close_doors();
  408960:	4b0c      	ldr	r3, [pc, #48]	; (408994 <march_set+0x48>)
  408962:	4798      	blx	r3
	if(INS)
  408964:	4b0c      	ldr	r3, [pc, #48]	; (408998 <march_set+0x4c>)
  408966:	781b      	ldrb	r3, [r3, #0]
  408968:	07db      	lsls	r3, r3, #31
  40896a:	d400      	bmi.n	40896e <march_set+0x22>
  40896c:	bd70      	pop	{r4, r5, r6, pc}
	{
		ar_up(direction_up);
  40896e:	4d0b      	ldr	r5, [pc, #44]	; (40899c <march_set+0x50>)
  408970:	2004      	movs	r0, #4
  408972:	7829      	ldrb	r1, [r5, #0]
  408974:	47a0      	blx	r4
		ar_dwn(!direction_up);
  408976:	7829      	ldrb	r1, [r5, #0]
  408978:	2005      	movs	r0, #5
  40897a:	4623      	mov	r3, r4
  40897c:	fab1 f181 	clz	r1, r1
	}

}
  408980:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		ar_dwn(!direction_up);
  408984:	40c1      	lsrs	r1, r0
  408986:	4718      	bx	r3
  408988:	00400941 	.word	0x00400941
  40898c:	0040d879 	.word	0x0040d879
  408990:	07000001 	.word	0x07000001
  408994:	00408265 	.word	0x00408265
  408998:	204008b2 	.word	0x204008b2
  40899c:	20400c66 	.word	0x20400c66

004089a0 <auto_hspd_enter>:
unsigned int fast_cntr=0,fast_cntr_pos=0;
void auto_hspd_enter(void)
{
  4089a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	auto_counter = auto_hspd;
  4089a4:	4b3c      	ldr	r3, [pc, #240]	; (408a98 <auto_hspd_enter+0xf8>)
	//s_move_flag;
	
	ctb_force_door_close(0);
  4089a6:	2100      	movs	r1, #0
	auto_counter = auto_hspd;
  4089a8:	2401      	movs	r4, #1
	ctb_force_door_close(0);
  4089aa:	2202      	movs	r2, #2
  4089ac:	483b      	ldr	r0, [pc, #236]	; (408a9c <auto_hspd_enter+0xfc>)
	set_fast_flash_rate;
	fast_cntr=0;
  4089ae:	460e      	mov	r6, r1
	ctb_force_door_close(0);
  4089b0:	4d3b      	ldr	r5, [pc, #236]	; (408aa0 <auto_hspd_enter+0x100>)
	auto_counter = auto_hspd;
  4089b2:	601c      	str	r4, [r3, #0]
	ctb_force_door_close(0);
  4089b4:	47a8      	blx	r5
	set_fast_flash_rate;
  4089b6:	4b3b      	ldr	r3, [pc, #236]	; (408aa4 <auto_hspd_enter+0x104>)
  4089b8:	f640 11c4 	movw	r1, #2500	; 0x9c4
	fast_cntr_pos = FAST_TIME_OUT;
  4089bc:	4c3a      	ldr	r4, [pc, #232]	; (408aa8 <auto_hspd_enter+0x108>)
	set_fast_flash_rate;
  4089be:	6818      	ldr	r0, [r3, #0]
  4089c0:	4b3a      	ldr	r3, [pc, #232]	; (408aac <auto_hspd_enter+0x10c>)
  4089c2:	4798      	blx	r3
	fast_cntr_pos = FAST_TIME_OUT;
  4089c4:	7923      	ldrb	r3, [r4, #4]
  4089c6:	493a      	ldr	r1, [pc, #232]	; (408ab0 <auto_hspd_enter+0x110>)
  4089c8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	fast_cntr=0;
  4089cc:	4839      	ldr	r0, [pc, #228]	; (408ab4 <auto_hspd_enter+0x114>)
	march_set();
  4089ce:	4a3a      	ldr	r2, [pc, #232]	; (408ab8 <auto_hspd_enter+0x118>)
	fast_cntr_pos = FAST_TIME_OUT;
  4089d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	fast_cntr=0;
  4089d4:	6006      	str	r6, [r0, #0]
	fast_cntr_pos = FAST_TIME_OUT;
  4089d6:	600b      	str	r3, [r1, #0]
	march_set();
  4089d8:	4790      	blx	r2
	m_gong(0);
  4089da:	4b38      	ldr	r3, [pc, #224]	; (408abc <auto_hspd_enter+0x11c>)
  4089dc:	4631      	mov	r1, r6
  4089de:	2007      	movs	r0, #7
  4089e0:	4798      	blx	r3
	lspd_mstp_met = 0; //reset mstop met signal
  4089e2:	4a37      	ldr	r2, [pc, #220]	; (408ac0 <auto_hspd_enter+0x120>)
	if (DIRECT_STOP)
  4089e4:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
	lspd_mstp_met = 0; //reset mstop met signal
  4089e8:	7016      	strb	r6, [r2, #0]
	if (DIRECT_STOP)
  4089ea:	b143      	cbz	r3, 4089fe <auto_hspd_enter+0x5e>
	{
		if(!set_Hspeed_profile()) 
  4089ec:	4b35      	ldr	r3, [pc, #212]	; (408ac4 <auto_hspd_enter+0x124>)
  4089ee:	4798      	blx	r3
  4089f0:	2800      	cmp	r0, #0
  4089f2:	d14c      	bne.n	408a8e <auto_hspd_enter+0xee>
		{
			auto_stop_enter();
  4089f4:	4b34      	ldr	r3, [pc, #208]	; (408ac8 <auto_hspd_enter+0x128>)
  4089f6:	4798      	blx	r3
			drop_all_req();
  4089f8:	4b34      	ldr	r3, [pc, #208]	; (408acc <auto_hspd_enter+0x12c>)
  4089fa:	4798      	blx	r3
  4089fc:	e03a      	b.n	408a74 <auto_hspd_enter+0xd4>
			Dstop_speed_sign = EMCM_get_travel_speed_sign();
		}
	} 
	else
	{
		vfd_set_motion_acc(menue_lift_data_applied.m_acc);
  4089fe:	6c60      	ldr	r0, [r4, #68]	; 0x44
  408a00:	4b33      	ldr	r3, [pc, #204]	; (408ad0 <auto_hspd_enter+0x130>)
  408a02:	4798      	blx	r3
		vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  408a04:	4e33      	ldr	r6, [pc, #204]	; (408ad4 <auto_hspd_enter+0x134>)
  408a06:	6da3      	ldr	r3, [r4, #88]	; 0x58
  408a08:	4a33      	ldr	r2, [pc, #204]	; (408ad8 <auto_hspd_enter+0x138>)
  408a0a:	fb86 1003 	smull	r1, r0, r6, r3
  408a0e:	17db      	asrs	r3, r3, #31
  408a10:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408a14:	4790      	blx	r2
		vfd_set_motion_j2(menue_lift_data_applied.m_corner2/100);
  408a16:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  408a18:	4a30      	ldr	r2, [pc, #192]	; (408adc <auto_hspd_enter+0x13c>)
  408a1a:	fb86 1003 	smull	r1, r0, r6, r3
  408a1e:	17db      	asrs	r3, r3, #31
  408a20:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408a24:	4790      	blx	r2
	if (!direction_up)
  408a26:	4a2e      	ldr	r2, [pc, #184]	; (408ae0 <auto_hspd_enter+0x140>)
	if (menue_lift_data_applied.m_up_dir)
  408a28:	7ae3      	ldrb	r3, [r4, #11]
	if (!direction_up)
  408a2a:	7812      	ldrb	r2, [r2, #0]
		sign *= -1;
  408a2c:	2a00      	cmp	r2, #0
  408a2e:	bf14      	ite	ne
  408a30:	2001      	movne	r0, #1
  408a32:	f04f 30ff 	moveq.w	r0, #4294967295
	if (menue_lift_data_applied.m_up_dir)
  408a36:	bb43      	cbnz	r3, 408a8a <auto_hspd_enter+0xea>
		
		vfd_set_ref_speed(get_speed_sign() * HIGH_SPEED);
  408a38:	4b2a      	ldr	r3, [pc, #168]	; (408ae4 <auto_hspd_enter+0x144>)
  408a3a:	4a2b      	ldr	r2, [pc, #172]	; (408ae8 <auto_hspd_enter+0x148>)
  408a3c:	68de      	ldr	r6, [r3, #12]
  408a3e:	f893 103c 	ldrb.w	r1, [r3, #60]	; 0x3c
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  408a42:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  408a44:	fb06 f401 	mul.w	r4, r6, r1
  408a48:	f8df e088 	ldr.w	lr, [pc, #136]	; 408ad4 <auto_hspd_enter+0x134>
  408a4c:	4927      	ldr	r1, [pc, #156]	; (408aec <auto_hspd_enter+0x14c>)
  408a4e:	fb82 6204 	smull	r6, r2, r2, r4
  408a52:	17e6      	asrs	r6, r4, #31
  408a54:	4422      	add	r2, r4
  408a56:	ebc6 1662 	rsb	r6, r6, r2, asr #5
  408a5a:	fb86 6703 	smull	r6, r7, r6, r3
  408a5e:	0bf3      	lsrs	r3, r6, #15
  408a60:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  408a64:	fb8e 4203 	smull	r4, r2, lr, r3
  408a68:	17db      	asrs	r3, r3, #31
  408a6a:	ebc3 1362 	rsb	r3, r3, r2, asr #5
  408a6e:	fb00 f003 	mul.w	r0, r0, r3
  408a72:	4788      	blx	r1
	}
	ctb_light_curtain1_ignore(1);
  408a74:	2202      	movs	r2, #2
  408a76:	2101      	movs	r1, #1
  408a78:	481d      	ldr	r0, [pc, #116]	; (408af0 <auto_hspd_enter+0x150>)
  408a7a:	47a8      	blx	r5
	ctb_light_curtain2_ignore(1);
  408a7c:	462b      	mov	r3, r5
  408a7e:	2202      	movs	r2, #2
  408a80:	2101      	movs	r1, #1
  408a82:	481c      	ldr	r0, [pc, #112]	; (408af4 <auto_hspd_enter+0x154>)
}
  408a84:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ctb_light_curtain2_ignore(1);
  408a88:	4718      	bx	r3
		sign *= -1;
  408a8a:	4240      	negs	r0, r0
  408a8c:	e7d4      	b.n	408a38 <auto_hspd_enter+0x98>
			Dstop_speed_sign = EMCM_get_travel_speed_sign();
  408a8e:	4b1a      	ldr	r3, [pc, #104]	; (408af8 <auto_hspd_enter+0x158>)
  408a90:	4798      	blx	r3
  408a92:	4b1a      	ldr	r3, [pc, #104]	; (408afc <auto_hspd_enter+0x15c>)
  408a94:	7018      	strb	r0, [r3, #0]
  408a96:	e7ed      	b.n	408a74 <auto_hspd_enter+0xd4>
  408a98:	2040001c 	.word	0x2040001c
  408a9c:	0700000e 	.word	0x0700000e
  408aa0:	0040d879 	.word	0x0040d879
  408aa4:	20400c74 	.word	0x20400c74
  408aa8:	204052b4 	.word	0x204052b4
  408aac:	00417411 	.word	0x00417411
  408ab0:	204008cc 	.word	0x204008cc
  408ab4:	204008c8 	.word	0x204008c8
  408ab8:	0040894d 	.word	0x0040894d
  408abc:	00400941 	.word	0x00400941
  408ac0:	204008d0 	.word	0x204008d0
  408ac4:	00404115 	.word	0x00404115
  408ac8:	004082b5 	.word	0x004082b5
  408acc:	00401079 	.word	0x00401079
  408ad0:	00416f41 	.word	0x00416f41
  408ad4:	51eb851f 	.word	0x51eb851f
  408ad8:	00416f4d 	.word	0x00416f4d
  408adc:	00416f59 	.word	0x00416f59
  408ae0:	20400c66 	.word	0x20400c66
  408ae4:	20404ff0 	.word	0x20404ff0
  408ae8:	88888889 	.word	0x88888889
  408aec:	00416f8d 	.word	0x00416f8d
  408af0:	0700000c 	.word	0x0700000c
  408af4:	0700000d 	.word	0x0700000d
  408af8:	00403fed 	.word	0x00403fed
  408afc:	2040001a 	.word	0x2040001a

00408b00 <auto_lspd_enter>:
}

void auto_lspd_enter(void)
{
	auto_counter = auto_lspd;
	IO_YARD(0);
  408b00:	2100      	movs	r1, #0
	auto_counter = auto_lspd;
  408b02:	4b75      	ldr	r3, [pc, #468]	; (408cd8 <auto_lspd_enter+0x1d8>)
	IO_YARD(0);
  408b04:	2008      	movs	r0, #8
{
  408b06:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	m_gong(0);
	ersd_allowTo_turn_on();
	relevel_counter = 0;
  408b0a:	460c      	mov	r4, r1
	auto_counter = auto_lspd;
  408b0c:	2502      	movs	r5, #2
	IO_YARD(0);
  408b0e:	4e73      	ldr	r6, [pc, #460]	; (408cdc <auto_lspd_enter+0x1dc>)
	auto_counter = auto_lspd;
  408b10:	601d      	str	r5, [r3, #0]
	IO_YARD(0);
  408b12:	47b0      	blx	r6
	m_gong(0);
  408b14:	4621      	mov	r1, r4
  408b16:	2007      	movs	r0, #7
  408b18:	47b0      	blx	r6
	ersd_allowTo_turn_on();
  408b1a:	4b71      	ldr	r3, [pc, #452]	; (408ce0 <auto_lspd_enter+0x1e0>)
  408b1c:	4798      	blx	r3
	prev_lspd_creep = 0;
	set_slow_flash_rate;
  408b1e:	4b71      	ldr	r3, [pc, #452]	; (408ce4 <auto_lspd_enter+0x1e4>)
	prev_lspd_creep = 0;
  408b20:	4a71      	ldr	r2, [pc, #452]	; (408ce8 <auto_lspd_enter+0x1e8>)
	set_slow_flash_rate;
  408b22:	f241 3188 	movw	r1, #5000	; 0x1388
	relevel_counter = 0;
  408b26:	4e71      	ldr	r6, [pc, #452]	; (408cec <auto_lspd_enter+0x1ec>)
	set_slow_flash_rate;
  408b28:	6818      	ldr	r0, [r3, #0]
  408b2a:	4b71      	ldr	r3, [pc, #452]	; (408cf0 <auto_lspd_enter+0x1f0>)
	relevel_counter = 0;
  408b2c:	7034      	strb	r4, [r6, #0]
	prev_lspd_creep = 0;
  408b2e:	7014      	strb	r4, [r2, #0]
	set_slow_flash_rate;
  408b30:	4798      	blx	r3
	//      run_read_tmr =  run_read_tmr_val;
	//      ers_slow_tmr = 60 * 25 * char_ers_slow_tmr;
	//      ers_slow_cntr=0;

	onfloor = 0;
	if(direction_up) stop_delay_counter = menue_lift_data_applied.m_up_stop_delay;
  408b32:	4e70      	ldr	r6, [pc, #448]	; (408cf4 <auto_lspd_enter+0x1f4>)
	ctb_force_door_close(0);
  408b34:	462a      	mov	r2, r5
	slow_cntr=0;
  408b36:	4b70      	ldr	r3, [pc, #448]	; (408cf8 <auto_lspd_enter+0x1f8>)
	ctb_force_door_close(0);
  408b38:	4621      	mov	r1, r4
  408b3a:	4870      	ldr	r0, [pc, #448]	; (408cfc <auto_lspd_enter+0x1fc>)
  408b3c:	4d70      	ldr	r5, [pc, #448]	; (408d00 <auto_lspd_enter+0x200>)
	slow_cntr=0;
  408b3e:	601c      	str	r4, [r3, #0]
	ctb_force_door_close(0);
  408b40:	47a8      	blx	r5
	onfloor = 0;
  408b42:	4a70      	ldr	r2, [pc, #448]	; (408d04 <auto_lspd_enter+0x204>)
	if(direction_up) stop_delay_counter = menue_lift_data_applied.m_up_stop_delay;
  408b44:	7833      	ldrb	r3, [r6, #0]
	onfloor = 0;
  408b46:	6014      	str	r4, [r2, #0]
	if(direction_up) stop_delay_counter = menue_lift_data_applied.m_up_stop_delay;
  408b48:	4c6f      	ldr	r4, [pc, #444]	; (408d08 <auto_lspd_enter+0x208>)
  408b4a:	2b00      	cmp	r3, #0
  408b4c:	d06a      	beq.n	408c24 <auto_lspd_enter+0x124>
  408b4e:	4b6f      	ldr	r3, [pc, #444]	; (408d0c <auto_lspd_enter+0x20c>)
  408b50:	8a62      	ldrh	r2, [r4, #18]
  408b52:	601a      	str	r2, [r3, #0]
	else stop_delay_counter = menue_lift_data_applied.m_down_stop_delay;
	//      if(floor_relevel==1) stop_delay_counter=1;
	march_set();
  408b54:	4b6e      	ldr	r3, [pc, #440]	; (408d10 <auto_lspd_enter+0x210>)
  408b56:	4798      	blx	r3
	if( (INS) && (ARD == 0) )
  408b58:	4b6e      	ldr	r3, [pc, #440]	; (408d14 <auto_lspd_enter+0x214>)
  408b5a:	781b      	ldrb	r3, [r3, #0]
  408b5c:	07d9      	lsls	r1, r3, #31
  408b5e:	d54a      	bpl.n	408bf6 <auto_lspd_enter+0xf6>
  408b60:	079a      	lsls	r2, r3, #30
  408b62:	d503      	bpl.n	408b6c <auto_lspd_enter+0x6c>
  408b64:	f003 0303 	and.w	r3, r3, #3
  408b68:	2b03      	cmp	r3, #3
  408b6a:	d14b      	bne.n	408c04 <auto_lspd_enter+0x104>
	{
		vfd_set_motion_acc(menue_lift_data_applied.m_ins_acc);
  408b6c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
  408b6e:	4b6a      	ldr	r3, [pc, #424]	; (408d18 <auto_lspd_enter+0x218>)
  408b70:	4798      	blx	r3
		vfd_set_motion_j1(menue_lift_data_applied.m_ins_corner/100);
  408b72:	4f6a      	ldr	r7, [pc, #424]	; (408d1c <auto_lspd_enter+0x21c>)
  408b74:	6d63      	ldr	r3, [r4, #84]	; 0x54
  408b76:	4a6a      	ldr	r2, [pc, #424]	; (408d20 <auto_lspd_enter+0x220>)
  408b78:	fb87 1003 	smull	r1, r0, r7, r3
  408b7c:	17db      	asrs	r3, r3, #31
  408b7e:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408b82:	4790      	blx	r2
		vfd_set_motion_j2(menue_lift_data_applied.m_ins_corner/100);
  408b84:	6d63      	ldr	r3, [r4, #84]	; 0x54
  408b86:	4a67      	ldr	r2, [pc, #412]	; (408d24 <auto_lspd_enter+0x224>)
  408b88:	fb87 1003 	smull	r1, r0, r7, r3
  408b8c:	17db      	asrs	r3, r3, #31
  408b8e:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408b92:	4790      	blx	r2
		
		if(enter_Hlearn(direction_up))
  408b94:	7830      	ldrb	r0, [r6, #0]
  408b96:	4b64      	ldr	r3, [pc, #400]	; (408d28 <auto_lspd_enter+0x228>)
  408b98:	4798      	blx	r3
  408b9a:	2800      	cmp	r0, #0
  408b9c:	f000 8088 	beq.w	408cb0 <auto_lspd_enter+0x1b0>
	if (!direction_up)
  408ba0:	7832      	ldrb	r2, [r6, #0]
	if (menue_lift_data_applied.m_up_dir)
  408ba2:	7ae3      	ldrb	r3, [r4, #11]
	int32_t sign = 1;
  408ba4:	2a00      	cmp	r2, #0
  408ba6:	bf0c      	ite	eq
  408ba8:	f04f 30ff 	moveq.w	r0, #4294967295
  408bac:	2001      	movne	r0, #1
	if (menue_lift_data_applied.m_up_dir)
  408bae:	b103      	cbz	r3, 408bb2 <auto_lspd_enter+0xb2>
		sign *= -1;
  408bb0:	4240      	negs	r0, r0
		{
			//selflearn mode
			//setlearn speed.
			vfd_set_ref_speed(get_speed_sign() * INS_SPEED / 2);
  408bb2:	4b5e      	ldr	r3, [pc, #376]	; (408d2c <auto_lspd_enter+0x22c>)
  408bb4:	4a5e      	ldr	r2, [pc, #376]	; (408d30 <auto_lspd_enter+0x230>)
  408bb6:	f893 603c 	ldrb.w	r6, [r3, #60]	; 0x3c
  408bba:	68d9      	ldr	r1, [r3, #12]
  408bbc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  408bbe:	fb01 f106 	mul.w	r1, r1, r6
  408bc2:	4c56      	ldr	r4, [pc, #344]	; (408d1c <auto_lspd_enter+0x21c>)
  408bc4:	fb82 6201 	smull	r6, r2, r2, r1
  408bc8:	17ce      	asrs	r6, r1, #31
  408bca:	440a      	add	r2, r1
  408bcc:	ebc6 1662 	rsb	r6, r6, r2, asr #5
  408bd0:	fb86 6703 	smull	r6, r7, r6, r3
  408bd4:	0bf3      	lsrs	r3, r6, #15
  408bd6:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  408bda:	fb84 1203 	smull	r1, r2, r4, r3
  408bde:	17db      	asrs	r3, r3, #31
  408be0:	ebc3 1362 	rsb	r3, r3, r2, asr #5
  408be4:	fb00 f003 	mul.w	r0, r0, r3
  408be8:	4b52      	ldr	r3, [pc, #328]	; (408d34 <auto_lspd_enter+0x234>)
  408bea:	2800      	cmp	r0, #0
  408bec:	bfb8      	it	lt
  408bee:	3001      	addlt	r0, #1
  408bf0:	1040      	asrs	r0, r0, #1
  408bf2:	4798      	blx	r3
  408bf4:	e00b      	b.n	408c0e <auto_lspd_enter+0x10e>
			//normal INS mode
			vfd_set_ref_speed(get_speed_sign() * INS_SPEED);
		}
		
	}
	else if( (ARD) && (INS == 0) )
  408bf6:	f013 0f02 	tst.w	r3, #2
  408bfa:	f003 0303 	and.w	r3, r3, #3
  408bfe:	d115      	bne.n	408c2c <auto_lspd_enter+0x12c>
		else
		{
			auto_stop_enter();
		}
	}
	else if(ARDINS)
  408c00:	2b03      	cmp	r3, #3
  408c02:	d065      	beq.n	408cd0 <auto_lspd_enter+0x1d0>
		auto_stop_enter();
		return;
	}
	else
	{
		if (DIRECT_STOP)
  408c04:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  408c08:	b1ab      	cbz	r3, 408c36 <auto_lspd_enter+0x136>
		{
			set_correct_atStop();
  408c0a:	4b4b      	ldr	r3, [pc, #300]	; (408d38 <auto_lspd_enter+0x238>)
  408c0c:	4798      	blx	r3
			vfd_set_motion_j2(menue_lift_data_applied.m_corner2/100);
			
			vfd_set_ref_speed(get_speed_sign() * CREEP_SPEED);	
		}
	}
	ctb_light_curtain1_ignore(1);
  408c0e:	2202      	movs	r2, #2
  408c10:	2101      	movs	r1, #1
  408c12:	484a      	ldr	r0, [pc, #296]	; (408d3c <auto_lspd_enter+0x23c>)
  408c14:	47a8      	blx	r5
	ctb_light_curtain2_ignore(1);
  408c16:	462b      	mov	r3, r5
  408c18:	2202      	movs	r2, #2
  408c1a:	2101      	movs	r1, #1
  408c1c:	4848      	ldr	r0, [pc, #288]	; (408d40 <auto_lspd_enter+0x240>)
}
  408c1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ctb_light_curtain2_ignore(1);
  408c22:	4718      	bx	r3
	else stop_delay_counter = menue_lift_data_applied.m_down_stop_delay;
  408c24:	4b39      	ldr	r3, [pc, #228]	; (408d0c <auto_lspd_enter+0x20c>)
  408c26:	8aa2      	ldrh	r2, [r4, #20]
  408c28:	601a      	str	r2, [r3, #0]
  408c2a:	e793      	b.n	408b54 <auto_lspd_enter+0x54>
	else if( (ARD) && (INS == 0) )
  408c2c:	2b03      	cmp	r3, #3
  408c2e:	d04f      	beq.n	408cd0 <auto_lspd_enter+0x1d0>
			ersd_move();
  408c30:	4b44      	ldr	r3, [pc, #272]	; (408d44 <auto_lspd_enter+0x244>)
  408c32:	4798      	blx	r3
		if(ersd_isReady)
  408c34:	e7eb      	b.n	408c0e <auto_lspd_enter+0x10e>
			vfd_set_motion_acc(menue_lift_data_applied.m_dec);
  408c36:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  408c38:	4b37      	ldr	r3, [pc, #220]	; (408d18 <auto_lspd_enter+0x218>)
  408c3a:	4798      	blx	r3
			vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  408c3c:	4f37      	ldr	r7, [pc, #220]	; (408d1c <auto_lspd_enter+0x21c>)
  408c3e:	6da3      	ldr	r3, [r4, #88]	; 0x58
  408c40:	4a37      	ldr	r2, [pc, #220]	; (408d20 <auto_lspd_enter+0x220>)
  408c42:	fb87 1003 	smull	r1, r0, r7, r3
  408c46:	17db      	asrs	r3, r3, #31
  408c48:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408c4c:	4790      	blx	r2
			vfd_set_motion_j2(menue_lift_data_applied.m_corner2/100);
  408c4e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  408c50:	4a34      	ldr	r2, [pc, #208]	; (408d24 <auto_lspd_enter+0x224>)
  408c52:	fb87 1003 	smull	r1, r0, r7, r3
  408c56:	17db      	asrs	r3, r3, #31
  408c58:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408c5c:	4790      	blx	r2
	if (!direction_up)
  408c5e:	7832      	ldrb	r2, [r6, #0]
	if (menue_lift_data_applied.m_up_dir)
  408c60:	7ae3      	ldrb	r3, [r4, #11]
	int32_t sign = 1;
  408c62:	2a00      	cmp	r2, #0
  408c64:	bf0c      	ite	eq
  408c66:	f04f 30ff 	moveq.w	r0, #4294967295
  408c6a:	2001      	movne	r0, #1
	if (menue_lift_data_applied.m_up_dir)
  408c6c:	b9f3      	cbnz	r3, 408cac <auto_lspd_enter+0x1ac>
			vfd_set_ref_speed(get_speed_sign() * CREEP_SPEED);	
  408c6e:	4b2f      	ldr	r3, [pc, #188]	; (408d2c <auto_lspd_enter+0x22c>)
  408c70:	4a2f      	ldr	r2, [pc, #188]	; (408d30 <auto_lspd_enter+0x230>)
  408c72:	f893 103c 	ldrb.w	r1, [r3, #60]	; 0x3c
  408c76:	68de      	ldr	r6, [r3, #12]
  408c78:	6b23      	ldr	r3, [r4, #48]	; 0x30
  408c7a:	fb06 f401 	mul.w	r4, r6, r1
  408c7e:	f8df e09c 	ldr.w	lr, [pc, #156]	; 408d1c <auto_lspd_enter+0x21c>
  408c82:	492c      	ldr	r1, [pc, #176]	; (408d34 <auto_lspd_enter+0x234>)
  408c84:	fb82 6204 	smull	r6, r2, r2, r4
  408c88:	17e6      	asrs	r6, r4, #31
  408c8a:	4422      	add	r2, r4
  408c8c:	ebc6 1662 	rsb	r6, r6, r2, asr #5
  408c90:	fb86 6703 	smull	r6, r7, r6, r3
  408c94:	0bf3      	lsrs	r3, r6, #15
  408c96:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  408c9a:	fb8e 4203 	smull	r4, r2, lr, r3
  408c9e:	17db      	asrs	r3, r3, #31
  408ca0:	ebc3 1362 	rsb	r3, r3, r2, asr #5
  408ca4:	fb00 f003 	mul.w	r0, r0, r3
  408ca8:	4788      	blx	r1
  408caa:	e7b0      	b.n	408c0e <auto_lspd_enter+0x10e>
		sign *= -1;
  408cac:	4240      	negs	r0, r0
  408cae:	e7de      	b.n	408c6e <auto_lspd_enter+0x16e>
	if (!direction_up)
  408cb0:	7832      	ldrb	r2, [r6, #0]
	if (menue_lift_data_applied.m_up_dir)
  408cb2:	7ae3      	ldrb	r3, [r4, #11]
	int32_t sign = 1;
  408cb4:	2a00      	cmp	r2, #0
  408cb6:	bf0c      	ite	eq
  408cb8:	f04f 30ff 	moveq.w	r0, #4294967295
  408cbc:	2001      	movne	r0, #1
	if (menue_lift_data_applied.m_up_dir)
  408cbe:	b103      	cbz	r3, 408cc2 <auto_lspd_enter+0x1c2>
		sign *= -1;
  408cc0:	4240      	negs	r0, r0
			vfd_set_ref_speed(get_speed_sign() * INS_SPEED);
  408cc2:	4b1a      	ldr	r3, [pc, #104]	; (408d2c <auto_lspd_enter+0x22c>)
  408cc4:	4a1a      	ldr	r2, [pc, #104]	; (408d30 <auto_lspd_enter+0x230>)
  408cc6:	f893 103c 	ldrb.w	r1, [r3, #60]	; 0x3c
  408cca:	68de      	ldr	r6, [r3, #12]
  408ccc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  408cce:	e7d4      	b.n	408c7a <auto_lspd_enter+0x17a>
		auto_stop_enter();
  408cd0:	4b1d      	ldr	r3, [pc, #116]	; (408d48 <auto_lspd_enter+0x248>)
}
  408cd2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		auto_stop_enter();
  408cd6:	4718      	bx	r3
  408cd8:	2040001c 	.word	0x2040001c
  408cdc:	00400941 	.word	0x00400941
  408ce0:	00414321 	.word	0x00414321
  408ce4:	20400c74 	.word	0x20400c74
  408ce8:	204008db 	.word	0x204008db
  408cec:	204008dc 	.word	0x204008dc
  408cf0:	00417411 	.word	0x00417411
  408cf4:	20400c66 	.word	0x20400c66
  408cf8:	204008e4 	.word	0x204008e4
  408cfc:	0700000e 	.word	0x0700000e
  408d00:	0040d879 	.word	0x0040d879
  408d04:	204008d4 	.word	0x204008d4
  408d08:	204052b4 	.word	0x204052b4
  408d0c:	20404fdc 	.word	0x20404fdc
  408d10:	0040894d 	.word	0x0040894d
  408d14:	204008b2 	.word	0x204008b2
  408d18:	00416f41 	.word	0x00416f41
  408d1c:	51eb851f 	.word	0x51eb851f
  408d20:	00416f4d 	.word	0x00416f4d
  408d24:	00416f59 	.word	0x00416f59
  408d28:	0040469d 	.word	0x0040469d
  408d2c:	20404ff0 	.word	0x20404ff0
  408d30:	88888889 	.word	0x88888889
  408d34:	00416f8d 	.word	0x00416f8d
  408d38:	00404109 	.word	0x00404109
  408d3c:	0700000c 	.word	0x0700000c
  408d40:	0700000d 	.word	0x0700000d
  408d44:	00414561 	.word	0x00414561
  408d48:	004082b5 	.word	0x004082b5

00408d4c <auto_hspd_exit>:
	temp = get_scheduled_floor();
  408d4c:	4b16      	ldr	r3, [pc, #88]	; (408da8 <auto_hspd_exit+0x5c>)
{
  408d4e:	b570      	push	{r4, r5, r6, lr}
	temp = get_scheduled_floor();
  408d50:	4798      	blx	r3
	if((temp != -1))
  408d52:	1c43      	adds	r3, r0, #1
  408d54:	d024      	beq.n	408da0 <auto_hspd_exit+0x54>
		if(((temp != f_max) && (temp != 0)) || (DIRECT_STOP))
  408d56:	4d15      	ldr	r5, [pc, #84]	; (408dac <auto_hspd_exit+0x60>)
		next_floor = temp;
  408d58:	4c15      	ldr	r4, [pc, #84]	; (408db0 <auto_hspd_exit+0x64>)
		if(((temp != f_max) && (temp != 0)) || (DIRECT_STOP))
  408d5a:	7aab      	ldrb	r3, [r5, #10]
		next_floor = temp;
  408d5c:	7020      	strb	r0, [r4, #0]
		if(((temp != f_max) && (temp != 0)) || (DIRECT_STOP))
  408d5e:	4283      	cmp	r3, r0
  408d60:	d006      	beq.n	408d70 <auto_hspd_exit+0x24>
  408d62:	b128      	cbz	r0, 408d70 <auto_hspd_exit+0x24>
			if(get_current_floor() == next_floor)//we're in the destination floor
  408d64:	4b13      	ldr	r3, [pc, #76]	; (408db4 <auto_hspd_exit+0x68>)
  408d66:	4798      	blx	r3
  408d68:	7823      	ldrb	r3, [r4, #0]
  408d6a:	4298      	cmp	r0, r3
  408d6c:	d009      	beq.n	408d82 <auto_hspd_exit+0x36>
  408d6e:	bd70      	pop	{r4, r5, r6, pc}
		if(((temp != f_max) && (temp != 0)) || (DIRECT_STOP))
  408d70:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
  408d74:	2b00      	cmp	r3, #0
  408d76:	d0fa      	beq.n	408d6e <auto_hspd_exit+0x22>
			if(get_current_floor() == next_floor)//we're in the destination floor
  408d78:	4b0e      	ldr	r3, [pc, #56]	; (408db4 <auto_hspd_exit+0x68>)
  408d7a:	4798      	blx	r3
  408d7c:	7823      	ldrb	r3, [r4, #0]
  408d7e:	4298      	cmp	r0, r3
  408d80:	d1f5      	bne.n	408d6e <auto_hspd_exit+0x22>
				if(infloorzone())
  408d82:	4b0d      	ldr	r3, [pc, #52]	; (408db8 <auto_hspd_exit+0x6c>)
  408d84:	4798      	blx	r3
  408d86:	2800      	cmp	r0, #0
  408d88:	d0f1      	beq.n	408d6e <auto_hspd_exit+0x22>
					if (DIRECT_STOP)
  408d8a:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
  408d8e:	b11b      	cbz	r3, 408d98 <auto_hspd_exit+0x4c>
						if(exit_hspd()) auto_lspd_enter();
  408d90:	4b0a      	ldr	r3, [pc, #40]	; (408dbc <auto_hspd_exit+0x70>)
  408d92:	4798      	blx	r3
  408d94:	2800      	cmp	r0, #0
  408d96:	d0ea      	beq.n	408d6e <auto_hspd_exit+0x22>
  408d98:	4b09      	ldr	r3, [pc, #36]	; (408dc0 <auto_hspd_exit+0x74>)
}
  408d9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						if(exit_hspd()) auto_lspd_enter();
  408d9e:	4718      	bx	r3
		pos_next_floor();	
  408da0:	4b08      	ldr	r3, [pc, #32]	; (408dc4 <auto_hspd_exit+0x78>)
}
  408da2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		pos_next_floor();	
  408da6:	4718      	bx	r3
  408da8:	00401625 	.word	0x00401625
  408dac:	204052b4 	.word	0x204052b4
  408db0:	20404fe0 	.word	0x20404fe0
  408db4:	00400e15 	.word	0x00400e15
  408db8:	00400e21 	.word	0x00400e21
  408dbc:	00403ff9 	.word	0x00403ff9
  408dc0:	00408b01 	.word	0x00408b01
  408dc4:	00400fe9 	.word	0x00400fe9

00408dc8 <auto_hspd_exe>:
{
  408dc8:	b570      	push	{r4, r5, r6, lr}
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  408dca:	4b24      	ldr	r3, [pc, #144]	; (408e5c <auto_hspd_exe+0x94>)
  408dcc:	4798      	blx	r3
  408dce:	2800      	cmp	r0, #0
  408dd0:	d03a      	beq.n	408e48 <auto_hspd_exe+0x80>
	light_timer_reset();
  408dd2:	4b23      	ldr	r3, [pc, #140]	; (408e60 <auto_hspd_exe+0x98>)
  408dd4:	4798      	blx	r3
	IO_YARD(0);
  408dd6:	2100      	movs	r1, #0
  408dd8:	2008      	movs	r0, #8
  408dda:	4b22      	ldr	r3, [pc, #136]	; (408e64 <auto_hspd_exe+0x9c>)
  408ddc:	4798      	blx	r3
	ersd_allowTo_turn_on();
  408dde:	4b22      	ldr	r3, [pc, #136]	; (408e68 <auto_hspd_exe+0xa0>)
  408de0:	4798      	blx	r3
	if((s_i_err()==1))// if there is an immediate stop error then stop
  408de2:	4b22      	ldr	r3, [pc, #136]	; (408e6c <auto_hspd_exe+0xa4>)
  408de4:	4798      	blx	r3
  408de6:	2801      	cmp	r0, #1
  408de8:	d031      	beq.n	408e4e <auto_hspd_exe+0x86>
	if(INS==0)
  408dea:	4c21      	ldr	r4, [pc, #132]	; (408e70 <auto_hspd_exe+0xa8>)
	if((fast_cntr > FAST_TIME_OUT)&&(INS==0))
  408dec:	4d21      	ldr	r5, [pc, #132]	; (408e74 <auto_hspd_exe+0xac>)
	if(INS==0)
  408dee:	7823      	ldrb	r3, [r4, #0]
  408df0:	07da      	lsls	r2, r3, #31
		auto_hspd_exit();
  408df2:	bf54      	ite	pl
  408df4:	4b20      	ldrpl	r3, [pc, #128]	; (408e78 <auto_hspd_exe+0xb0>)
		auto_stop_enter();
  408df6:	4b21      	ldrmi	r3, [pc, #132]	; (408e7c <auto_hspd_exe+0xb4>)
  408df8:	4798      	blx	r3
	if((fast_cntr > FAST_TIME_OUT)&&(INS==0))
  408dfa:	792b      	ldrb	r3, [r5, #4]
  408dfc:	4920      	ldr	r1, [pc, #128]	; (408e80 <auto_hspd_exe+0xb8>)
  408dfe:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  408e02:	680a      	ldr	r2, [r1, #0]
  408e04:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  408e08:	4293      	cmp	r3, r2
  408e0a:	d302      	bcc.n	408e12 <auto_hspd_exe+0x4a>
		fast_cntr++;
  408e0c:	3201      	adds	r2, #1
  408e0e:	600a      	str	r2, [r1, #0]
  408e10:	bd70      	pop	{r4, r5, r6, pc}
	if((fast_cntr > FAST_TIME_OUT)&&(INS==0))
  408e12:	7823      	ldrb	r3, [r4, #0]
  408e14:	07db      	lsls	r3, r3, #31
  408e16:	d4f9      	bmi.n	408e0c <auto_hspd_exe+0x44>
		fastset;
  408e18:	4b1a      	ldr	r3, [pc, #104]	; (408e84 <auto_hspd_exe+0xbc>)
  408e1a:	4c1b      	ldr	r4, [pc, #108]	; (408e88 <auto_hspd_exe+0xc0>)
  408e1c:	7818      	ldrb	r0, [r3, #0]
  408e1e:	47a0      	blx	r4
		drop_all_req();
  408e20:	4b1a      	ldr	r3, [pc, #104]	; (408e8c <auto_hspd_exe+0xc4>)
  408e22:	4798      	blx	r3
		fast_cntr_pos++;
  408e24:	491a      	ldr	r1, [pc, #104]	; (408e90 <auto_hspd_exe+0xc8>)
		if(fast_cntr_pos > FAST_TIME_OUT)
  408e26:	792b      	ldrb	r3, [r5, #4]
		fast_cntr_pos++;
  408e28:	680a      	ldr	r2, [r1, #0]
		if(fast_cntr_pos > FAST_TIME_OUT)
  408e2a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		fast_cntr_pos++;
  408e2e:	3201      	adds	r2, #1
		if(fast_cntr_pos > FAST_TIME_OUT)
  408e30:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		fast_cntr_pos++;
  408e34:	600a      	str	r2, [r1, #0]
		if(fast_cntr_pos > FAST_TIME_OUT)
  408e36:	429a      	cmp	r2, r3
  408e38:	d9ea      	bls.n	408e10 <auto_hspd_exe+0x48>
			slowset;
  408e3a:	4b16      	ldr	r3, [pc, #88]	; (408e94 <auto_hspd_exe+0xcc>)
  408e3c:	7818      	ldrb	r0, [r3, #0]
  408e3e:	47a0      	blx	r4
			auto_stop_enter();
  408e40:	4b0e      	ldr	r3, [pc, #56]	; (408e7c <auto_hspd_exe+0xb4>)
}
  408e42:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			auto_stop_enter();
  408e46:	4718      	bx	r3
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  408e48:	4b0c      	ldr	r3, [pc, #48]	; (408e7c <auto_hspd_exe+0xb4>)
  408e4a:	4798      	blx	r3
  408e4c:	e7c1      	b.n	408dd2 <auto_hspd_exe+0xa>
		auto_stop_enter();
  408e4e:	4b0b      	ldr	r3, [pc, #44]	; (408e7c <auto_hspd_exe+0xb4>)
  408e50:	4798      	blx	r3
		drop_all_req();
  408e52:	4b0e      	ldr	r3, [pc, #56]	; (408e8c <auto_hspd_exe+0xc4>)
}
  408e54:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		drop_all_req();
  408e58:	4718      	bx	r3
  408e5a:	bf00      	nop
  408e5c:	00413241 	.word	0x00413241
  408e60:	0040180d 	.word	0x0040180d
  408e64:	00400941 	.word	0x00400941
  408e68:	00414321 	.word	0x00414321
  408e6c:	00400bf9 	.word	0x00400bf9
  408e70:	204008b2 	.word	0x204008b2
  408e74:	204052b4 	.word	0x204052b4
  408e78:	00408d4d 	.word	0x00408d4d
  408e7c:	004082b5 	.word	0x004082b5
  408e80:	204008c8 	.word	0x204008c8
  408e84:	20400c1b 	.word	0x20400c1b
  408e88:	0041282d 	.word	0x0041282d
  408e8c:	00401079 	.word	0x00401079
  408e90:	204008cc 	.word	0x204008cc
  408e94:	20400c50 	.word	0x20400c50

00408e98 <auto_lspd_exit>:
			}
		}
	}
}
void auto_lspd_exit(void)
{
  408e98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			auto_stopping_enter();
		}
	}
	else if (mstop == 1)
	{
		if (DIRECT_STOP)
  408e9c:	4c2b      	ldr	r4, [pc, #172]	; (408f4c <auto_lspd_exit+0xb4>)
  408e9e:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
  408ea2:	b90b      	cbnz	r3, 408ea8 <auto_lspd_exit+0x10>
  408ea4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		{
			if (vfd_get_ref_speed() == 0)
  408ea8:	4b29      	ldr	r3, [pc, #164]	; (408f50 <auto_lspd_exit+0xb8>)
  408eaa:	4798      	blx	r3
  408eac:	2800      	cmp	r0, #0
  408eae:	d1f9      	bne.n	408ea4 <auto_lspd_exit+0xc>
			{
				if (relevel_counter < RELEVEL_DELAY_DSTOP)
  408eb0:	4a28      	ldr	r2, [pc, #160]	; (408f54 <auto_lspd_exit+0xbc>)
  408eb2:	7813      	ldrb	r3, [r2, #0]
  408eb4:	2b7c      	cmp	r3, #124	; 0x7c
  408eb6:	d93b      	bls.n	408f30 <auto_lspd_exit+0x98>
					set_correct_atStop();
					set_Stop_afterCorrection();
				}
				else
				{
					fixedpt relevel_speed = RELEVEL_SPEED * Dstop_speed_sign;
  408eb8:	4927      	ldr	r1, [pc, #156]	; (408f58 <auto_lspd_exit+0xc0>)
  408eba:	4b28      	ldr	r3, [pc, #160]	; (408f5c <auto_lspd_exit+0xc4>)
  408ebc:	f891 003c 	ldrb.w	r0, [r1, #60]	; 0x3c
  408ec0:	68ca      	ldr	r2, [r1, #12]
  408ec2:	6b61      	ldr	r1, [r4, #52]	; 0x34
  408ec4:	fb02 f200 	mul.w	r2, r2, r0
  408ec8:	4d25      	ldr	r5, [pc, #148]	; (408f60 <auto_lspd_exit+0xc8>)
  408eca:	4e26      	ldr	r6, [pc, #152]	; (408f64 <auto_lspd_exit+0xcc>)
  408ecc:	fb83 0302 	smull	r0, r3, r3, r2
  408ed0:	17d0      	asrs	r0, r2, #31
  408ed2:	f996 6000 	ldrsb.w	r6, [r6]
  408ed6:	4413      	add	r3, r2
					if (lspd_mstp_met) relevel_speed *= -1;
  408ed8:	4a23      	ldr	r2, [pc, #140]	; (408f68 <auto_lspd_exit+0xd0>)
					fixedpt relevel_speed = RELEVEL_SPEED * Dstop_speed_sign;
  408eda:	ebc0 1063 	rsb	r0, r0, r3, asr #5
					if (lspd_mstp_met) relevel_speed *= -1;
  408ede:	f992 7000 	ldrsb.w	r7, [r2]
  408ee2:	fb80 0101 	smull	r0, r1, r0, r1
  408ee6:	0bc3      	lsrs	r3, r0, #15
  408ee8:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
					fixedpt relevel_speed = RELEVEL_SPEED * Dstop_speed_sign;
  408eec:	fb85 1203 	smull	r1, r2, r5, r3
  408ef0:	17dd      	asrs	r5, r3, #31
  408ef2:	ebc5 1562 	rsb	r5, r5, r2, asr #5
  408ef6:	fb06 f505 	mul.w	r5, r6, r5
					if (lspd_mstp_met) relevel_speed *= -1;
  408efa:	b107      	cbz	r7, 408efe <auto_lspd_exit+0x66>
  408efc:	426d      	negs	r5, r5
					vfd_set_motion_acc(menue_lift_data_applied.m_ins_acc);
  408efe:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
  408f00:	4b1a      	ldr	r3, [pc, #104]	; (408f6c <auto_lspd_exit+0xd4>)
  408f02:	4798      	blx	r3
					vfd_set_motion_j1(menue_lift_data_applied.m_ins_corner/100);
  408f04:	4e16      	ldr	r6, [pc, #88]	; (408f60 <auto_lspd_exit+0xc8>)
  408f06:	6d63      	ldr	r3, [r4, #84]	; 0x54
  408f08:	4a19      	ldr	r2, [pc, #100]	; (408f70 <auto_lspd_exit+0xd8>)
  408f0a:	fb86 1003 	smull	r1, r0, r6, r3
  408f0e:	17db      	asrs	r3, r3, #31
  408f10:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408f14:	4790      	blx	r2
					vfd_set_motion_j2(menue_lift_data_applied.m_ins_corner/100);
  408f16:	6d63      	ldr	r3, [r4, #84]	; 0x54
  408f18:	4a16      	ldr	r2, [pc, #88]	; (408f74 <auto_lspd_exit+0xdc>)
  408f1a:	fb86 1003 	smull	r1, r0, r6, r3
  408f1e:	17db      	asrs	r3, r3, #31
  408f20:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  408f24:	4790      	blx	r2
					vfd_set_ref_speed(relevel_speed);
  408f26:	4628      	mov	r0, r5
  408f28:	4b13      	ldr	r3, [pc, #76]	; (408f78 <auto_lspd_exit+0xe0>)
				}
			}
			
		}
	}
}
  408f2a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					vfd_set_ref_speed(relevel_speed);
  408f2e:	4718      	bx	r3
					relevel_counter ++;
  408f30:	3301      	adds	r3, #1
					drop_req(get_current_floor());
  408f32:	4912      	ldr	r1, [pc, #72]	; (408f7c <auto_lspd_exit+0xe4>)
					relevel_counter ++;
  408f34:	7013      	strb	r3, [r2, #0]
					drop_req(get_current_floor());
  408f36:	4788      	blx	r1
  408f38:	4b11      	ldr	r3, [pc, #68]	; (408f80 <auto_lspd_exit+0xe8>)
  408f3a:	b2c0      	uxtb	r0, r0
  408f3c:	4798      	blx	r3
					set_correct_atStop();
  408f3e:	4b11      	ldr	r3, [pc, #68]	; (408f84 <auto_lspd_exit+0xec>)
  408f40:	4798      	blx	r3
					set_Stop_afterCorrection();
  408f42:	4b11      	ldr	r3, [pc, #68]	; (408f88 <auto_lspd_exit+0xf0>)
}
  408f44:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					set_Stop_afterCorrection();
  408f48:	4718      	bx	r3
  408f4a:	bf00      	nop
  408f4c:	204052b4 	.word	0x204052b4
  408f50:	00416989 	.word	0x00416989
  408f54:	204008dc 	.word	0x204008dc
  408f58:	20404ff0 	.word	0x20404ff0
  408f5c:	88888889 	.word	0x88888889
  408f60:	51eb851f 	.word	0x51eb851f
  408f64:	2040001a 	.word	0x2040001a
  408f68:	204008d0 	.word	0x204008d0
  408f6c:	00416f41 	.word	0x00416f41
  408f70:	00416f4d 	.word	0x00416f4d
  408f74:	00416f59 	.word	0x00416f59
  408f78:	00416f8d 	.word	0x00416f8d
  408f7c:	00400e15 	.word	0x00400e15
  408f80:	00401095 	.word	0x00401095
  408f84:	00404109 	.word	0x00404109
  408f88:	004040fd 	.word	0x004040fd

00408f8c <auto_stopping_enter>:

//Stopping state subs
uint32_t auto_stopping_timeout=0;
void auto_stopping_enter(void)
{
  408f8c:	b570      	push	{r4, r5, r6, lr}
	auto_counter = auto_stopping;
	auto_stopping_timeout = 50 * 25;
  408f8e:	4b26      	ldr	r3, [pc, #152]	; (409028 <auto_stopping_enter+0x9c>)
  408f90:	f240 42e2 	movw	r2, #1250	; 0x4e2
	auto_counter = auto_stopping;
  408f94:	2507      	movs	r5, #7
  408f96:	4e25      	ldr	r6, [pc, #148]	; (40902c <auto_stopping_enter+0xa0>)
	IO_YARD(0);
  408f98:	2100      	movs	r1, #0
  408f9a:	2008      	movs	r0, #8
  408f9c:	4c24      	ldr	r4, [pc, #144]	; (409030 <auto_stopping_enter+0xa4>)
	auto_stopping_timeout = 50 * 25;
  408f9e:	601a      	str	r2, [r3, #0]
	auto_counter = auto_stopping;
  408fa0:	6035      	str	r5, [r6, #0]
	IO_YARD(0);
  408fa2:	47a0      	blx	r4
	m_gong(1);
	ersd_allowTo_turn_on();
	if ((INS == 0) && (DIRECT_STOP == 0) )
  408fa4:	4e23      	ldr	r6, [pc, #140]	; (409034 <auto_stopping_enter+0xa8>)
	m_gong(1);
  408fa6:	4628      	mov	r0, r5
  408fa8:	2101      	movs	r1, #1
	if ((INS == 0) && (DIRECT_STOP == 0) )
  408faa:	4d23      	ldr	r5, [pc, #140]	; (409038 <auto_stopping_enter+0xac>)
	m_gong(1);
  408fac:	47a0      	blx	r4
	ersd_allowTo_turn_on();
  408fae:	4b23      	ldr	r3, [pc, #140]	; (40903c <auto_stopping_enter+0xb0>)
  408fb0:	4798      	blx	r3
	if ((INS == 0) && (DIRECT_STOP == 0) )
  408fb2:	7833      	ldrb	r3, [r6, #0]
  408fb4:	07d8      	lsls	r0, r3, #31
  408fb6:	d402      	bmi.n	408fbe <auto_stopping_enter+0x32>
  408fb8:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
  408fbc:	b1fb      	cbz	r3, 408ffe <auto_stopping_enter+0x72>
	{
		vfd_set_motion_acc(menue_lift_data_applied.m_dec);
		vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
		vfd_set_motion_j2(menue_lift_data_applied.m_corner3/100);
	}
	ctb_force_door_close(0);
  408fbe:	2202      	movs	r2, #2
  408fc0:	2100      	movs	r1, #0
  408fc2:	481f      	ldr	r0, [pc, #124]	; (409040 <auto_stopping_enter+0xb4>)
  408fc4:	4c1f      	ldr	r4, [pc, #124]	; (409044 <auto_stopping_enter+0xb8>)
  408fc6:	47a0      	blx	r4
	if((DIRECT_STOP == 0) || (INS == 1)  || (ARD == 1)) vfd_set_ref_speed(0);
  408fc8:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
  408fcc:	b113      	cbz	r3, 408fd4 <auto_stopping_enter+0x48>
  408fce:	7833      	ldrb	r3, [r6, #0]
  408fd0:	07d9      	lsls	r1, r3, #31
  408fd2:	d50d      	bpl.n	408ff0 <auto_stopping_enter+0x64>
  408fd4:	2000      	movs	r0, #0
  408fd6:	4b1c      	ldr	r3, [pc, #112]	; (409048 <auto_stopping_enter+0xbc>)
  408fd8:	4798      	blx	r3
	//distance_regulator_enable();
	ctb_light_curtain1_ignore(1);
  408fda:	2202      	movs	r2, #2
  408fdc:	2101      	movs	r1, #1
  408fde:	481b      	ldr	r0, [pc, #108]	; (40904c <auto_stopping_enter+0xc0>)
  408fe0:	47a0      	blx	r4
	ctb_light_curtain2_ignore(1);
  408fe2:	4623      	mov	r3, r4
  408fe4:	2202      	movs	r2, #2
  408fe6:	2101      	movs	r1, #1
  408fe8:	4819      	ldr	r0, [pc, #100]	; (409050 <auto_stopping_enter+0xc4>)
}
  408fea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ctb_light_curtain2_ignore(1);
  408fee:	4718      	bx	r3
	if((DIRECT_STOP == 0) || (INS == 1)  || (ARD == 1)) vfd_set_ref_speed(0);
  408ff0:	079a      	lsls	r2, r3, #30
  408ff2:	d5f2      	bpl.n	408fda <auto_stopping_enter+0x4e>
  408ff4:	f003 0303 	and.w	r3, r3, #3
  408ff8:	2b03      	cmp	r3, #3
  408ffa:	d1eb      	bne.n	408fd4 <auto_stopping_enter+0x48>
  408ffc:	e7ed      	b.n	408fda <auto_stopping_enter+0x4e>
		vfd_set_motion_acc(menue_lift_data_applied.m_dec);
  408ffe:	6ca8      	ldr	r0, [r5, #72]	; 0x48
  409000:	4b14      	ldr	r3, [pc, #80]	; (409054 <auto_stopping_enter+0xc8>)
  409002:	4798      	blx	r3
		vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  409004:	4c14      	ldr	r4, [pc, #80]	; (409058 <auto_stopping_enter+0xcc>)
  409006:	6dab      	ldr	r3, [r5, #88]	; 0x58
  409008:	4a14      	ldr	r2, [pc, #80]	; (40905c <auto_stopping_enter+0xd0>)
  40900a:	fb84 1003 	smull	r1, r0, r4, r3
  40900e:	17db      	asrs	r3, r3, #31
  409010:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  409014:	4790      	blx	r2
		vfd_set_motion_j2(menue_lift_data_applied.m_corner3/100);
  409016:	6e2b      	ldr	r3, [r5, #96]	; 0x60
  409018:	4a11      	ldr	r2, [pc, #68]	; (409060 <auto_stopping_enter+0xd4>)
  40901a:	fb84 1003 	smull	r1, r0, r4, r3
  40901e:	17db      	asrs	r3, r3, #31
  409020:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  409024:	4790      	blx	r2
  409026:	e7ca      	b.n	408fbe <auto_stopping_enter+0x32>
  409028:	204008b4 	.word	0x204008b4
  40902c:	2040001c 	.word	0x2040001c
  409030:	00400941 	.word	0x00400941
  409034:	204008b2 	.word	0x204008b2
  409038:	204052b4 	.word	0x204052b4
  40903c:	00414321 	.word	0x00414321
  409040:	0700000e 	.word	0x0700000e
  409044:	0040d879 	.word	0x0040d879
  409048:	00416f8d 	.word	0x00416f8d
  40904c:	0700000c 	.word	0x0700000c
  409050:	0700000d 	.word	0x0700000d
  409054:	00416f41 	.word	0x00416f41
  409058:	51eb851f 	.word	0x51eb851f
  40905c:	00416f4d 	.word	0x00416f4d
  409060:	00416f59 	.word	0x00416f59

00409064 <auto_lspd_exe>:
{
  409064:	b510      	push	{r4, lr}
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  409066:	4b38      	ldr	r3, [pc, #224]	; (409148 <auto_lspd_exe+0xe4>)
  409068:	4798      	blx	r3
  40906a:	2800      	cmp	r0, #0
  40906c:	d049      	beq.n	409102 <auto_lspd_exe+0x9e>
	if(ARD)
  40906e:	4c37      	ldr	r4, [pc, #220]	; (40914c <auto_lspd_exe+0xe8>)
	light_timer_reset();
  409070:	4b37      	ldr	r3, [pc, #220]	; (409150 <auto_lspd_exe+0xec>)
  409072:	4798      	blx	r3
	if(ARD)
  409074:	7821      	ldrb	r1, [r4, #0]
  409076:	0788      	lsls	r0, r1, #30
  409078:	d52b      	bpl.n	4090d2 <auto_lspd_exe+0x6e>
  40907a:	f001 0303 	and.w	r3, r1, #3
  40907e:	2b03      	cmp	r3, #3
  409080:	d027      	beq.n	4090d2 <auto_lspd_exe+0x6e>
	if(s_i_err())// if there is an immediate stop error then stop
  409082:	4b34      	ldr	r3, [pc, #208]	; (409154 <auto_lspd_exe+0xf0>)
  409084:	4798      	blx	r3
  409086:	2800      	cmp	r0, #0
  409088:	d135      	bne.n	4090f6 <auto_lspd_exe+0x92>
	if(INS==0)
  40908a:	7823      	ldrb	r3, [r4, #0]
  40908c:	07db      	lsls	r3, r3, #31
  40908e:	d552      	bpl.n	409136 <auto_lspd_exe+0xd2>
		if(direction_up)
  409090:	4b31      	ldr	r3, [pc, #196]	; (409158 <auto_lspd_exe+0xf4>)
  409092:	781b      	ldrb	r3, [r3, #0]
  409094:	2b00      	cmp	r3, #0
  409096:	d138      	bne.n	40910a <auto_lspd_exe+0xa6>
			if(mdwn==0)
  409098:	4c30      	ldr	r4, [pc, #192]	; (40915c <auto_lspd_exe+0xf8>)
  40909a:	f894 0089 	ldrb.w	r0, [r4, #137]	; 0x89
  40909e:	280d      	cmp	r0, #13
  4090a0:	d906      	bls.n	4090b0 <auto_lspd_exe+0x4c>
  4090a2:	280f      	cmp	r0, #15
  4090a4:	f100 000e 	add.w	r0, r0, #14
  4090a8:	bf8c      	ite	hi
  4090aa:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  4090ae:	2300      	movls	r3, #0
			else if(mup==0)
  4090b0:	2200      	movs	r2, #0
  4090b2:	4318      	orrs	r0, r3
  4090b4:	4b2a      	ldr	r3, [pc, #168]	; (409160 <auto_lspd_exe+0xfc>)
  4090b6:	4611      	mov	r1, r2
  4090b8:	4798      	blx	r3
  4090ba:	bb28      	cbnz	r0, 409108 <auto_lspd_exe+0xa4>
				if (menue_lift_data_applied.m_ins_stopping_mode == 0)
  4090bc:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
  4090c0:	2b00      	cmp	r3, #0
  4090c2:	d03c      	beq.n	40913e <auto_lspd_exe+0xda>
					vfd_set_motion_acc(menue_lift_data_applied.m_ins_dec);
  4090c4:	6d20      	ldr	r0, [r4, #80]	; 0x50
  4090c6:	4b27      	ldr	r3, [pc, #156]	; (409164 <auto_lspd_exe+0x100>)
  4090c8:	4798      	blx	r3
					auto_stopping_enter();
  4090ca:	4b27      	ldr	r3, [pc, #156]	; (409168 <auto_lspd_exe+0x104>)
}
  4090cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					auto_stopping_enter();
  4090d0:	4718      	bx	r3
		if((slow_cntr > SLOW_TIME_OUT)&&(INS==0))
  4090d2:	4b22      	ldr	r3, [pc, #136]	; (40915c <auto_lspd_exe+0xf8>)
  4090d4:	4825      	ldr	r0, [pc, #148]	; (40916c <auto_lspd_exe+0x108>)
  4090d6:	78db      	ldrb	r3, [r3, #3]
  4090d8:	6802      	ldr	r2, [r0, #0]
  4090da:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4090de:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4090e2:	4293      	cmp	r3, r2
  4090e4:	d201      	bcs.n	4090ea <auto_lspd_exe+0x86>
  4090e6:	07c9      	lsls	r1, r1, #31
  4090e8:	d520      	bpl.n	40912c <auto_lspd_exe+0xc8>
		slow_cntr++;
  4090ea:	3201      	adds	r2, #1
	if(s_i_err())// if there is an immediate stop error then stop
  4090ec:	4b19      	ldr	r3, [pc, #100]	; (409154 <auto_lspd_exe+0xf0>)
		slow_cntr++;
  4090ee:	6002      	str	r2, [r0, #0]
	if(s_i_err())// if there is an immediate stop error then stop
  4090f0:	4798      	blx	r3
  4090f2:	2800      	cmp	r0, #0
  4090f4:	d0c9      	beq.n	40908a <auto_lspd_exe+0x26>
		auto_stop_enter();
  4090f6:	4b1e      	ldr	r3, [pc, #120]	; (409170 <auto_lspd_exe+0x10c>)
  4090f8:	4798      	blx	r3
		drop_all_req();
  4090fa:	4b1e      	ldr	r3, [pc, #120]	; (409174 <auto_lspd_exe+0x110>)
}
  4090fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		drop_all_req();
  409100:	4718      	bx	r3
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  409102:	4b1b      	ldr	r3, [pc, #108]	; (409170 <auto_lspd_exe+0x10c>)
  409104:	4798      	blx	r3
  409106:	e7b2      	b.n	40906e <auto_lspd_exe+0xa>
  409108:	bd10      	pop	{r4, pc}
			if(selfLearn_exe())
  40910a:	4b1b      	ldr	r3, [pc, #108]	; (409178 <auto_lspd_exe+0x114>)
  40910c:	4798      	blx	r3
  40910e:	2800      	cmp	r0, #0
  409110:	d1fa      	bne.n	409108 <auto_lspd_exe+0xa4>
			else if(mup==0)
  409112:	4c12      	ldr	r4, [pc, #72]	; (40915c <auto_lspd_exe+0xf8>)
  409114:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
  409118:	2b0d      	cmp	r3, #13
  40911a:	d9c9      	bls.n	4090b0 <auto_lspd_exe+0x4c>
  40911c:	2b0f      	cmp	r3, #15
  40911e:	f103 030e 	add.w	r3, r3, #14
  409122:	bf8c      	ite	hi
  409124:	f04f 407a 	movhi.w	r0, #4194304000	; 0xfa000000
  409128:	2000      	movls	r0, #0
  40912a:	e7c1      	b.n	4090b0 <auto_lspd_exe+0x4c>
			slowset;
  40912c:	4a13      	ldr	r2, [pc, #76]	; (40917c <auto_lspd_exe+0x118>)
  40912e:	4b14      	ldr	r3, [pc, #80]	; (409180 <auto_lspd_exe+0x11c>)
  409130:	7810      	ldrb	r0, [r2, #0]
  409132:	4798      	blx	r3
  409134:	e7a5      	b.n	409082 <auto_lspd_exe+0x1e>
			auto_lspd_exit();
  409136:	4b13      	ldr	r3, [pc, #76]	; (409184 <auto_lspd_exe+0x120>)
}
  409138:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			auto_lspd_exit();
  40913c:	4718      	bx	r3
					auto_stop_enter();
  40913e:	4b0c      	ldr	r3, [pc, #48]	; (409170 <auto_lspd_exe+0x10c>)
}
  409140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					auto_stop_enter();
  409144:	4718      	bx	r3
  409146:	bf00      	nop
  409148:	00413241 	.word	0x00413241
  40914c:	204008b2 	.word	0x204008b2
  409150:	0040180d 	.word	0x0040180d
  409154:	00400bf9 	.word	0x00400bf9
  409158:	20400c66 	.word	0x20400c66
  40915c:	204052b4 	.word	0x204052b4
  409160:	0040d879 	.word	0x0040d879
  409164:	00416f41 	.word	0x00416f41
  409168:	00408f8d 	.word	0x00408f8d
  40916c:	204008e4 	.word	0x204008e4
  409170:	004082b5 	.word	0x004082b5
  409174:	00401079 	.word	0x00401079
  409178:	00404a89 	.word	0x00404a89
  40917c:	20400c50 	.word	0x20400c50
  409180:	0041282d 	.word	0x0041282d
  409184:	00408e99 	.word	0x00408e99

00409188 <auto_stopping_exe>:
void auto_stopping_exe(void)
{
  409188:	b510      	push	{r4, lr}
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  40918a:	4b11      	ldr	r3, [pc, #68]	; (4091d0 <auto_stopping_exe+0x48>)
  40918c:	4798      	blx	r3
  40918e:	b1a8      	cbz	r0, 4091bc <auto_stopping_exe+0x34>
	
	if(auto_stopping_timeout-- == 0)
  409190:	4a10      	ldr	r2, [pc, #64]	; (4091d4 <auto_stopping_exe+0x4c>)
  409192:	6813      	ldr	r3, [r2, #0]
  409194:	1e59      	subs	r1, r3, #1
  409196:	6011      	str	r1, [r2, #0]
  409198:	b16b      	cbz	r3, 4091b6 <auto_stopping_exe+0x2e>
	{
		auto_stop_enter();
	}
	light_timer_reset();
  40919a:	4b0f      	ldr	r3, [pc, #60]	; (4091d8 <auto_stopping_exe+0x50>)
  40919c:	4798      	blx	r3
				dnfl_err;
				return;
			}
		}
	}
	if((s_i_err()==1))// if there is an imediate stop error then stop
  40919e:	4b0f      	ldr	r3, [pc, #60]	; (4091dc <auto_stopping_exe+0x54>)
  4091a0:	4798      	blx	r3
  4091a2:	2801      	cmp	r0, #1
  4091a4:	d00d      	beq.n	4091c2 <auto_stopping_exe+0x3a>
	auto_stopping_exit();
	
}
void auto_stopping_exit(void)
{
	if (!vfd_states_isStopping())
  4091a6:	4b0e      	ldr	r3, [pc, #56]	; (4091e0 <auto_stopping_exe+0x58>)
  4091a8:	4798      	blx	r3
  4091aa:	b100      	cbz	r0, 4091ae <auto_stopping_exe+0x26>
  4091ac:	bd10      	pop	{r4, pc}
	{
		auto_stop_enter();
  4091ae:	4b0d      	ldr	r3, [pc, #52]	; (4091e4 <auto_stopping_exe+0x5c>)
}
  4091b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		auto_stop_enter();
  4091b4:	4718      	bx	r3
		auto_stop_enter();
  4091b6:	4b0b      	ldr	r3, [pc, #44]	; (4091e4 <auto_stopping_exe+0x5c>)
  4091b8:	4798      	blx	r3
  4091ba:	e7ee      	b.n	40919a <auto_stopping_exe+0x12>
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  4091bc:	4b09      	ldr	r3, [pc, #36]	; (4091e4 <auto_stopping_exe+0x5c>)
  4091be:	4798      	blx	r3
  4091c0:	e7e6      	b.n	409190 <auto_stopping_exe+0x8>
		auto_stop_enter();
  4091c2:	4b08      	ldr	r3, [pc, #32]	; (4091e4 <auto_stopping_exe+0x5c>)
  4091c4:	4798      	blx	r3
		drop_all_req();
  4091c6:	4b08      	ldr	r3, [pc, #32]	; (4091e8 <auto_stopping_exe+0x60>)
}
  4091c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		drop_all_req();
  4091cc:	4718      	bx	r3
  4091ce:	bf00      	nop
  4091d0:	00413241 	.word	0x00413241
  4091d4:	204008b4 	.word	0x204008b4
  4091d8:	0040180d 	.word	0x0040180d
  4091dc:	00400bf9 	.word	0x00400bf9
  4091e0:	0041637d 	.word	0x0041637d
  4091e4:	004082b5 	.word	0x004082b5
  4091e8:	00401079 	.word	0x00401079

004091ec <auto_camtest_enter>:
uByte_t cam_lock_wait=0;

uByte_t mnt_speed=1;
void auto_camtest_enter(void)
{
	auto_counter = auto_camtest;
  4091ec:	2104      	movs	r1, #4
  4091ee:	4a1d      	ldr	r2, [pc, #116]	; (409264 <auto_camtest_enter+0x78>)
	menue_data_manager_update();
  4091f0:	4b1d      	ldr	r3, [pc, #116]	; (409268 <auto_camtest_enter+0x7c>)
{
  4091f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	IO_YARD(0);
	m_gong(0);
	ersd_allowTo_turn_on();
	
	set_cam_flash_rate;
	sec_dev_counter=0;
  4091f6:	2600      	movs	r6, #0
	floor_counter_save = 1;
  4091f8:	2401      	movs	r4, #1
	auto_counter = auto_camtest;
  4091fa:	6011      	str	r1, [r2, #0]
	menue_data_manager_update();
  4091fc:	4798      	blx	r3
	floor_counter_save = 1;
  4091fe:	4a1b      	ldr	r2, [pc, #108]	; (40926c <auto_camtest_enter+0x80>)
	light_timer_reset();
  409200:	4b1b      	ldr	r3, [pc, #108]	; (409270 <auto_camtest_enter+0x84>)
	floor_counter_save = 1;
  409202:	7014      	strb	r4, [r2, #0]
	light_timer_reset();
  409204:	4798      	blx	r3
	IO_YARD(0);
  409206:	4f1b      	ldr	r7, [pc, #108]	; (409274 <auto_camtest_enter+0x88>)
  409208:	4631      	mov	r1, r6
  40920a:	2008      	movs	r0, #8
	cam_time_counter=0;
	
	vfd_estop();
	march_cam(1);
  40920c:	4d1a      	ldr	r5, [pc, #104]	; (409278 <auto_camtest_enter+0x8c>)
	IO_YARD(0);
  40920e:	47b8      	blx	r7
	m_gong(0);
  409210:	4631      	mov	r1, r6
  409212:	2007      	movs	r0, #7
  409214:	47b8      	blx	r7
	ersd_allowTo_turn_on();
  409216:	4b19      	ldr	r3, [pc, #100]	; (40927c <auto_camtest_enter+0x90>)
  409218:	4798      	blx	r3
	set_cam_flash_rate;
  40921a:	4a19      	ldr	r2, [pc, #100]	; (409280 <auto_camtest_enter+0x94>)
  40921c:	f641 514c 	movw	r1, #7500	; 0x1d4c
  409220:	4b18      	ldr	r3, [pc, #96]	; (409284 <auto_camtest_enter+0x98>)
  409222:	6810      	ldr	r0, [r2, #0]
  409224:	4798      	blx	r3
	cam_time_counter=0;
  409226:	4a18      	ldr	r2, [pc, #96]	; (409288 <auto_camtest_enter+0x9c>)
	sec_dev_counter=0;
  409228:	4918      	ldr	r1, [pc, #96]	; (40928c <auto_camtest_enter+0xa0>)
	vfd_estop();
  40922a:	4b19      	ldr	r3, [pc, #100]	; (409290 <auto_camtest_enter+0xa4>)
	cam_time_counter=0;
  40922c:	6016      	str	r6, [r2, #0]
	sec_dev_counter=0;
  40922e:	600e      	str	r6, [r1, #0]
	vfd_estop();
  409230:	4798      	blx	r3
	march_cam(1);
  409232:	4621      	mov	r1, r4
  409234:	4620      	mov	r0, r4
  409236:	47b8      	blx	r7
  409238:	4621      	mov	r1, r4
  40923a:	2202      	movs	r2, #2
  40923c:	4815      	ldr	r0, [pc, #84]	; (409294 <auto_camtest_enter+0xa8>)
  40923e:	47a8      	blx	r5
	close_doors();
  409240:	4b15      	ldr	r3, [pc, #84]	; (409298 <auto_camtest_enter+0xac>)
  409242:	4798      	blx	r3
	ctb_light_curtain1_ignore(0);
  409244:	4631      	mov	r1, r6
  409246:	2202      	movs	r2, #2
  409248:	4814      	ldr	r0, [pc, #80]	; (40929c <auto_camtest_enter+0xb0>)
  40924a:	47a8      	blx	r5
	ctb_light_curtain2_ignore(0);
  40924c:	4631      	mov	r1, r6
  40924e:	2202      	movs	r2, #2
  409250:	4813      	ldr	r0, [pc, #76]	; (4092a0 <auto_camtest_enter+0xb4>)
  409252:	47a8      	blx	r5
	ctb_force_door_close(1);
  409254:	4621      	mov	r1, r4
  409256:	462b      	mov	r3, r5
  409258:	2202      	movs	r2, #2
  40925a:	4812      	ldr	r0, [pc, #72]	; (4092a4 <auto_camtest_enter+0xb8>)
}
  40925c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ctb_force_door_close(1);
  409260:	4718      	bx	r3
  409262:	bf00      	nop
  409264:	2040001c 	.word	0x2040001c
  409268:	00409d01 	.word	0x00409d01
  40926c:	20400020 	.word	0x20400020
  409270:	0040180d 	.word	0x0040180d
  409274:	00400941 	.word	0x00400941
  409278:	0040d879 	.word	0x0040d879
  40927c:	00414321 	.word	0x00414321
  409280:	20400c74 	.word	0x20400c74
  409284:	00417411 	.word	0x00417411
  409288:	204008bc 	.word	0x204008bc
  40928c:	204008e0 	.word	0x204008e0
  409290:	00417215 	.word	0x00417215
  409294:	07000001 	.word	0x07000001
  409298:	00408265 	.word	0x00408265
  40929c:	0700000c 	.word	0x0700000c
  4092a0:	0700000d 	.word	0x0700000d
  4092a4:	0700000e 	.word	0x0700000e

004092a8 <auto_idle_exit>:
		if( (INS) && ((mup == 0) && (mdwn == 0)) ) auto_stop_enter();
  4092a8:	4b19      	ldr	r3, [pc, #100]	; (409310 <auto_idle_exit+0x68>)
  4092aa:	781b      	ldrb	r3, [r3, #0]
  4092ac:	07da      	lsls	r2, r3, #31
  4092ae:	d521      	bpl.n	4092f4 <auto_idle_exit+0x4c>
{
  4092b0:	b570      	push	{r4, r5, r6, lr}
		if( (INS) && ((mup == 0) && (mdwn == 0)) ) auto_stop_enter();
  4092b2:	4d18      	ldr	r5, [pc, #96]	; (409314 <auto_idle_exit+0x6c>)
  4092b4:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
  4092b8:	280d      	cmp	r0, #13
  4092ba:	d813      	bhi.n	4092e4 <auto_idle_exit+0x3c>
  4092bc:	2300      	movs	r3, #0
  4092be:	2200      	movs	r2, #0
  4092c0:	4318      	orrs	r0, r3
  4092c2:	4c15      	ldr	r4, [pc, #84]	; (409318 <auto_idle_exit+0x70>)
  4092c4:	4611      	mov	r1, r2
  4092c6:	47a0      	blx	r4
  4092c8:	b940      	cbnz	r0, 4092dc <auto_idle_exit+0x34>
  4092ca:	f895 3089 	ldrb.w	r3, [r5, #137]	; 0x89
  4092ce:	2b0d      	cmp	r3, #13
  4092d0:	d812      	bhi.n	4092f8 <auto_idle_exit+0x50>
  4092d2:	2200      	movs	r2, #0
  4092d4:	4318      	orrs	r0, r3
  4092d6:	4611      	mov	r1, r2
  4092d8:	47a0      	blx	r4
  4092da:	b1a8      	cbz	r0, 409308 <auto_idle_exit+0x60>
			auto_camtest_enter();
  4092dc:	4b0f      	ldr	r3, [pc, #60]	; (40931c <auto_idle_exit+0x74>)
}
  4092de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			auto_camtest_enter();
  4092e2:	4718      	bx	r3
		if( (INS) && ((mup == 0) && (mdwn == 0)) ) auto_stop_enter();
  4092e4:	280f      	cmp	r0, #15
  4092e6:	f100 000e 	add.w	r0, r0, #14
  4092ea:	bf8c      	ite	hi
  4092ec:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  4092f0:	2300      	movls	r3, #0
  4092f2:	e7e4      	b.n	4092be <auto_idle_exit+0x16>
			auto_camtest_enter();
  4092f4:	4b09      	ldr	r3, [pc, #36]	; (40931c <auto_idle_exit+0x74>)
  4092f6:	4718      	bx	r3
		if( (INS) && ((mup == 0) && (mdwn == 0)) ) auto_stop_enter();
  4092f8:	2b0f      	cmp	r3, #15
  4092fa:	f103 030e 	add.w	r3, r3, #14
  4092fe:	bf8c      	ite	hi
  409300:	f04f 407a 	movhi.w	r0, #4194304000	; 0xfa000000
  409304:	2000      	movls	r0, #0
  409306:	e7e4      	b.n	4092d2 <auto_idle_exit+0x2a>
  409308:	4b05      	ldr	r3, [pc, #20]	; (409320 <auto_idle_exit+0x78>)
}
  40930a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if( (INS) && ((mup == 0) && (mdwn == 0)) ) auto_stop_enter();
  40930e:	4718      	bx	r3
  409310:	204008b2 	.word	0x204008b2
  409314:	204052b4 	.word	0x204052b4
  409318:	0040d879 	.word	0x0040d879
  40931c:	004091ed 	.word	0x004091ed
  409320:	004082b5 	.word	0x004082b5

00409324 <auto_prespd_enter>:
	else auto_stop_enter();
}

volatile uint16_t pre_spd_counter = 0;
void auto_prespd_enter(void)
{
  409324:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	auto_counter = auto_prespd;
  409328:	4b26      	ldr	r3, [pc, #152]	; (4093c4 <auto_prespd_enter+0xa0>)
  40932a:	2508      	movs	r5, #8
	//s_move_flag;
	ctb_force_door_close(0);
	pre_spd_counter = menue_lift_data_applied.m_pre_spd_time / 40;
  40932c:	4c26      	ldr	r4, [pc, #152]	; (4093c8 <auto_prespd_enter+0xa4>)
	ctb_force_door_close(0);
  40932e:	2202      	movs	r2, #2
  409330:	2100      	movs	r1, #0
  409332:	4826      	ldr	r0, [pc, #152]	; (4093cc <auto_prespd_enter+0xa8>)
  409334:	4e26      	ldr	r6, [pc, #152]	; (4093d0 <auto_prespd_enter+0xac>)
	auto_counter = auto_prespd;
  409336:	601d      	str	r5, [r3, #0]
	ctb_force_door_close(0);
  409338:	47b0      	blx	r6
	pre_spd_counter = menue_lift_data_applied.m_pre_spd_time / 40;
  40933a:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
	set_fast_flash_rate;
  40933e:	f640 11c4 	movw	r1, #2500	; 0x9c4
	pre_spd_counter = menue_lift_data_applied.m_pre_spd_time / 40;
  409342:	4824      	ldr	r0, [pc, #144]	; (4093d4 <auto_prespd_enter+0xb0>)
	set_fast_flash_rate;
  409344:	4a24      	ldr	r2, [pc, #144]	; (4093d8 <auto_prespd_enter+0xb4>)
	pre_spd_counter = menue_lift_data_applied.m_pre_spd_time / 40;
  409346:	fba0 0303 	umull	r0, r3, r0, r3
  40934a:	4f24      	ldr	r7, [pc, #144]	; (4093dc <auto_prespd_enter+0xb8>)
	set_fast_flash_rate;
  40934c:	6810      	ldr	r0, [r2, #0]
	pre_spd_counter = menue_lift_data_applied.m_pre_spd_time / 40;
  40934e:	095b      	lsrs	r3, r3, #5
	set_fast_flash_rate;
  409350:	4a23      	ldr	r2, [pc, #140]	; (4093e0 <auto_prespd_enter+0xbc>)
	march_set();
	m_gong(0);
	lspd_mstp_met = 0; //reset mstop met signal
	
	vfd_set_motion_acc(menue_lift_data_applied.m_acc);
	vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  409352:	4d24      	ldr	r5, [pc, #144]	; (4093e4 <auto_prespd_enter+0xc0>)
	pre_spd_counter = menue_lift_data_applied.m_pre_spd_time / 40;
  409354:	803b      	strh	r3, [r7, #0]
	set_fast_flash_rate;
  409356:	4790      	blx	r2
	march_set();
  409358:	4b23      	ldr	r3, [pc, #140]	; (4093e8 <auto_prespd_enter+0xc4>)
  40935a:	4798      	blx	r3
	m_gong(0);
  40935c:	2100      	movs	r1, #0
  40935e:	2007      	movs	r0, #7
  409360:	4b22      	ldr	r3, [pc, #136]	; (4093ec <auto_prespd_enter+0xc8>)
  409362:	4798      	blx	r3
	lspd_mstp_met = 0; //reset mstop met signal
  409364:	2100      	movs	r1, #0
  409366:	4a22      	ldr	r2, [pc, #136]	; (4093f0 <auto_prespd_enter+0xcc>)
	vfd_set_motion_acc(menue_lift_data_applied.m_acc);
  409368:	6c60      	ldr	r0, [r4, #68]	; 0x44
  40936a:	4b22      	ldr	r3, [pc, #136]	; (4093f4 <auto_prespd_enter+0xd0>)
	lspd_mstp_met = 0; //reset mstop met signal
  40936c:	7011      	strb	r1, [r2, #0]
	vfd_set_motion_acc(menue_lift_data_applied.m_acc);
  40936e:	4798      	blx	r3
	vfd_set_motion_j1(menue_lift_data_applied.m_corner1/100);
  409370:	6da3      	ldr	r3, [r4, #88]	; 0x58
  409372:	4a21      	ldr	r2, [pc, #132]	; (4093f8 <auto_prespd_enter+0xd4>)
  409374:	fb85 1003 	smull	r1, r0, r5, r3
  409378:	17db      	asrs	r3, r3, #31
  40937a:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  40937e:	4790      	blx	r2
	vfd_set_motion_j2(menue_lift_data_applied.m_corner2/100);
  409380:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  409382:	4a1e      	ldr	r2, [pc, #120]	; (4093fc <auto_prespd_enter+0xd8>)
  409384:	fb85 1003 	smull	r1, r0, r5, r3
  409388:	17db      	asrs	r3, r3, #31
  40938a:	ebc3 1060 	rsb	r0, r3, r0, asr #5
  40938e:	4790      	blx	r2
	if (!direction_up)
  409390:	4b1b      	ldr	r3, [pc, #108]	; (409400 <auto_prespd_enter+0xdc>)
	if (menue_lift_data_applied.m_up_dir)
  409392:	7ae2      	ldrb	r2, [r4, #11]
	if (!direction_up)
  409394:	781b      	ldrb	r3, [r3, #0]
		sign *= -1;
  409396:	2b00      	cmp	r3, #0
  409398:	bf14      	ite	ne
  40939a:	2301      	movne	r3, #1
  40939c:	f04f 33ff 	moveq.w	r3, #4294967295
	if (menue_lift_data_applied.m_up_dir)
  4093a0:	b102      	cbz	r2, 4093a4 <auto_prespd_enter+0x80>
		sign *= -1;
  4093a2:	425b      	negs	r3, r3
		
	vfd_set_ref_speed(get_speed_sign() * menue_lift_data_applied.m_pre_speed);
  4093a4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  4093a6:	4a17      	ldr	r2, [pc, #92]	; (409404 <auto_prespd_enter+0xe0>)
  4093a8:	fb00 f003 	mul.w	r0, r0, r3
  4093ac:	4790      	blx	r2
	ctb_light_curtain1_ignore(1);
  4093ae:	2202      	movs	r2, #2
  4093b0:	2101      	movs	r1, #1
  4093b2:	4815      	ldr	r0, [pc, #84]	; (409408 <auto_prespd_enter+0xe4>)
  4093b4:	47b0      	blx	r6
	ctb_light_curtain2_ignore(1);
  4093b6:	4633      	mov	r3, r6
  4093b8:	2202      	movs	r2, #2
  4093ba:	2101      	movs	r1, #1
  4093bc:	4813      	ldr	r0, [pc, #76]	; (40940c <auto_prespd_enter+0xe8>)
}
  4093be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ctb_light_curtain2_ignore(1);
  4093c2:	4718      	bx	r3
  4093c4:	2040001c 	.word	0x2040001c
  4093c8:	204052b4 	.word	0x204052b4
  4093cc:	0700000e 	.word	0x0700000e
  4093d0:	0040d879 	.word	0x0040d879
  4093d4:	cccccccd 	.word	0xcccccccd
  4093d8:	20400c74 	.word	0x20400c74
  4093dc:	204008d8 	.word	0x204008d8
  4093e0:	00417411 	.word	0x00417411
  4093e4:	51eb851f 	.word	0x51eb851f
  4093e8:	0040894d 	.word	0x0040894d
  4093ec:	00400941 	.word	0x00400941
  4093f0:	204008d0 	.word	0x204008d0
  4093f4:	00416f41 	.word	0x00416f41
  4093f8:	00416f4d 	.word	0x00416f4d
  4093fc:	00416f59 	.word	0x00416f59
  409400:	20400c66 	.word	0x20400c66
  409404:	00416f8d 	.word	0x00416f8d
  409408:	0700000c 	.word	0x0700000c
  40940c:	0700000d 	.word	0x0700000d

00409410 <auto_camtest_exit>:
			if(INS == 0) if(++cam_lock_wait<15)
  409410:	4b3f      	ldr	r3, [pc, #252]	; (409510 <auto_camtest_exit+0x100>)
			cam_trial_counter=0;
  409412:	2200      	movs	r2, #0
			if(INS == 0) if(++cam_lock_wait<15)
  409414:	493f      	ldr	r1, [pc, #252]	; (409514 <auto_camtest_exit+0x104>)
{
  409416:	b570      	push	{r4, r5, r6, lr}
			if(INS == 0) if(++cam_lock_wait<15)
  409418:	781b      	ldrb	r3, [r3, #0]
			cam_trial_counter=0;
  40941a:	4c3f      	ldr	r4, [pc, #252]	; (409518 <auto_camtest_exit+0x108>)
			if(INS == 0) if(++cam_lock_wait<15)
  40941c:	f013 0001 	ands.w	r0, r3, #1
			cam_trial_counter=0;
  409420:	6022      	str	r2, [r4, #0]
			if(INS == 0) if(++cam_lock_wait<15)
  409422:	d11c      	bne.n	40945e <auto_camtest_exit+0x4e>
  409424:	680a      	ldr	r2, [r1, #0]
  409426:	3201      	adds	r2, #1
  409428:	2a0e      	cmp	r2, #14
  40942a:	d947      	bls.n	4094bc <auto_camtest_exit+0xac>
			cam_lock_wait=0;
  40942c:	6008      	str	r0, [r1, #0]
			if (ARD)
  40942e:	0799      	lsls	r1, r3, #30
  409430:	d503      	bpl.n	40943a <auto_camtest_exit+0x2a>
  409432:	f003 0303 	and.w	r3, r3, #3
  409436:	2b03      	cmp	r3, #3
  409438:	d146      	bne.n	4094c8 <auto_camtest_exit+0xb8>
				destination = get_scheduled_floor();
  40943a:	4b38      	ldr	r3, [pc, #224]	; (40951c <auto_camtest_exit+0x10c>)
  40943c:	4798      	blx	r3
  40943e:	4605      	mov	r5, r0
				if(destination != -1)
  409440:	3001      	adds	r0, #1
  409442:	d05b      	beq.n	4094fc <auto_camtest_exit+0xec>
					if((infloorzone())&&(destination == get_current_floor()))//check if we're in the destination area
  409444:	4b36      	ldr	r3, [pc, #216]	; (409520 <auto_camtest_exit+0x110>)
  409446:	4798      	blx	r3
  409448:	2800      	cmp	r0, #0
  40944a:	d14c      	bne.n	4094e6 <auto_camtest_exit+0xd6>
						if (/*(menue_drive_data_applied.m_motor_type == 0) && */(menue_lift_data_applied.m_pre_spd_time > 0))
  40944c:	4b35      	ldr	r3, [pc, #212]	; (409524 <auto_camtest_exit+0x114>)
  40944e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
  409452:	2b00      	cmp	r3, #0
  409454:	d043      	beq.n	4094de <auto_camtest_exit+0xce>
							auto_prespd_enter();
  409456:	4b34      	ldr	r3, [pc, #208]	; (409528 <auto_camtest_exit+0x118>)
}
  409458:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
							auto_prespd_enter();
  40945c:	4718      	bx	r3
			cam_lock_wait=0;
  40945e:	600a      	str	r2, [r1, #0]
			if (ARD)
  409460:	079a      	lsls	r2, r3, #30
  409462:	d42d      	bmi.n	4094c0 <auto_camtest_exit+0xb0>
				if(mup==1)
  409464:	4d2f      	ldr	r5, [pc, #188]	; (409524 <auto_camtest_exit+0x114>)
  409466:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
  40946a:	280d      	cmp	r0, #13
  40946c:	d922      	bls.n	4094b4 <auto_camtest_exit+0xa4>
  40946e:	280f      	cmp	r0, #15
  409470:	f100 000e 	add.w	r0, r0, #14
  409474:	bf8c      	ite	hi
  409476:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  40947a:	2300      	movls	r3, #0
  40947c:	2200      	movs	r2, #0
  40947e:	4318      	orrs	r0, r3
  409480:	4c2a      	ldr	r4, [pc, #168]	; (40952c <auto_camtest_exit+0x11c>)
  409482:	4611      	mov	r1, r2
  409484:	47a0      	blx	r4
  409486:	2801      	cmp	r0, #1
  409488:	d032      	beq.n	4094f0 <auto_camtest_exit+0xe0>
				else if(mdwn==1)
  40948a:	f895 0089 	ldrb.w	r0, [r5, #137]	; 0x89
  40948e:	280d      	cmp	r0, #13
  409490:	d912      	bls.n	4094b8 <auto_camtest_exit+0xa8>
  409492:	280f      	cmp	r0, #15
  409494:	f100 000e 	add.w	r0, r0, #14
  409498:	bf8c      	ite	hi
  40949a:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  40949e:	2300      	movls	r3, #0
  4094a0:	2200      	movs	r2, #0
  4094a2:	4318      	orrs	r0, r3
  4094a4:	4611      	mov	r1, r2
  4094a6:	47a0      	blx	r4
  4094a8:	2801      	cmp	r0, #1
  4094aa:	d011      	beq.n	4094d0 <auto_camtest_exit+0xc0>
					auto_stop_enter();
  4094ac:	4b20      	ldr	r3, [pc, #128]	; (409530 <auto_camtest_exit+0x120>)
}
  4094ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					auto_stop_enter();
  4094b2:	4718      	bx	r3
				if(mup==1)
  4094b4:	2300      	movs	r3, #0
  4094b6:	e7e1      	b.n	40947c <auto_camtest_exit+0x6c>
				else if(mdwn==1)
  4094b8:	2300      	movs	r3, #0
  4094ba:	e7f1      	b.n	4094a0 <auto_camtest_exit+0x90>
			if(INS == 0) if(++cam_lock_wait<15)
  4094bc:	600a      	str	r2, [r1, #0]
  4094be:	bd70      	pop	{r4, r5, r6, pc}
			if (ARD)
  4094c0:	f003 0303 	and.w	r3, r3, #3
  4094c4:	2b03      	cmp	r3, #3
  4094c6:	d0cd      	beq.n	409464 <auto_camtest_exit+0x54>
				if(mstop == 1) auto_lspd_enter();
  4094c8:	4b1a      	ldr	r3, [pc, #104]	; (409534 <auto_camtest_exit+0x124>)
}
  4094ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				if(mstop == 1) auto_lspd_enter();
  4094ce:	4718      	bx	r3
					direction_up=0;
  4094d0:	4a19      	ldr	r2, [pc, #100]	; (409538 <auto_camtest_exit+0x128>)
  4094d2:	2100      	movs	r1, #0
					auto_lspd_enter();
  4094d4:	4b17      	ldr	r3, [pc, #92]	; (409534 <auto_camtest_exit+0x124>)
					direction_up=0;
  4094d6:	7011      	strb	r1, [r2, #0]
}
  4094d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					auto_lspd_enter();
  4094dc:	4718      	bx	r3
							auto_hspd_enter();
  4094de:	4b17      	ldr	r3, [pc, #92]	; (40953c <auto_camtest_exit+0x12c>)
}
  4094e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
							auto_hspd_enter();
  4094e4:	4718      	bx	r3
					if((infloorzone())&&(destination == get_current_floor()))//check if we're in the destination area
  4094e6:	4b16      	ldr	r3, [pc, #88]	; (409540 <auto_camtest_exit+0x130>)
  4094e8:	4798      	blx	r3
  4094ea:	42a8      	cmp	r0, r5
  4094ec:	d1ae      	bne.n	40944c <auto_camtest_exit+0x3c>
  4094ee:	e7eb      	b.n	4094c8 <auto_camtest_exit+0xb8>
					direction_up = 1;
  4094f0:	4a11      	ldr	r2, [pc, #68]	; (409538 <auto_camtest_exit+0x128>)
					auto_lspd_enter();
  4094f2:	4b10      	ldr	r3, [pc, #64]	; (409534 <auto_camtest_exit+0x124>)
					direction_up = 1;
  4094f4:	7010      	strb	r0, [r2, #0]
}
  4094f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					auto_lspd_enter();
  4094fa:	4718      	bx	r3
					cam_time_counter=0;
  4094fc:	2300      	movs	r3, #0
  4094fe:	4811      	ldr	r0, [pc, #68]	; (409544 <auto_camtest_exit+0x134>)
					sec_dev_counter=0;
  409500:	4911      	ldr	r1, [pc, #68]	; (409548 <auto_camtest_exit+0x138>)
					cam_time_counter=0;
  409502:	6003      	str	r3, [r0, #0]
					cam_trial_counter=0;
  409504:	6023      	str	r3, [r4, #0]
					sec_dev_counter=0;
  409506:	600b      	str	r3, [r1, #0]
					auto_stop_enter();
  409508:	4a09      	ldr	r2, [pc, #36]	; (409530 <auto_camtest_exit+0x120>)
}
  40950a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					auto_stop_enter();
  40950e:	4710      	bx	r2
  409510:	204008b2 	.word	0x204008b2
  409514:	204008b8 	.word	0x204008b8
  409518:	20404fe4 	.word	0x20404fe4
  40951c:	00401625 	.word	0x00401625
  409520:	00400e21 	.word	0x00400e21
  409524:	204052b4 	.word	0x204052b4
  409528:	00409325 	.word	0x00409325
  40952c:	0040d879 	.word	0x0040d879
  409530:	004082b5 	.word	0x004082b5
  409534:	00408b01 	.word	0x00408b01
  409538:	20400c66 	.word	0x20400c66
  40953c:	004089a1 	.word	0x004089a1
  409540:	00400e15 	.word	0x00400e15
  409544:	204008bc 	.word	0x204008bc
  409548:	204008e0 	.word	0x204008e0

0040954c <auto_camtest_exe>:
{
  40954c:	b570      	push	{r4, r5, r6, lr}
	light_timer_reset();
  40954e:	4b25      	ldr	r3, [pc, #148]	; (4095e4 <auto_camtest_exe+0x98>)
  409550:	4798      	blx	r3
	if((s_i_err()==1))// if there is an immediate stop error then stop
  409552:	4b25      	ldr	r3, [pc, #148]	; (4095e8 <auto_camtest_exe+0x9c>)
  409554:	4798      	blx	r3
  409556:	2801      	cmp	r0, #1
  409558:	d03d      	beq.n	4095d6 <auto_camtest_exe+0x8a>
	if(INS)
  40955a:	4b24      	ldr	r3, [pc, #144]	; (4095ec <auto_camtest_exe+0xa0>)
  40955c:	781b      	ldrb	r3, [r3, #0]
  40955e:	07da      	lsls	r2, r3, #31
  409560:	d524      	bpl.n	4095ac <auto_camtest_exe+0x60>
		if(!((mup==1)||(mdwn==1)))
  409562:	4d23      	ldr	r5, [pc, #140]	; (4095f0 <auto_camtest_exe+0xa4>)
  409564:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
  409568:	280d      	cmp	r0, #13
  40956a:	d92a      	bls.n	4095c2 <auto_camtest_exe+0x76>
  40956c:	280f      	cmp	r0, #15
  40956e:	f100 000e 	add.w	r0, r0, #14
  409572:	bf8c      	ite	hi
  409574:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  409578:	2300      	movls	r3, #0
  40957a:	2200      	movs	r2, #0
  40957c:	4318      	orrs	r0, r3
  40957e:	4c1d      	ldr	r4, [pc, #116]	; (4095f4 <auto_camtest_exe+0xa8>)
  409580:	4611      	mov	r1, r2
  409582:	47a0      	blx	r4
  409584:	2801      	cmp	r0, #1
  409586:	d011      	beq.n	4095ac <auto_camtest_exe+0x60>
  409588:	f895 0089 	ldrb.w	r0, [r5, #137]	; 0x89
  40958c:	280d      	cmp	r0, #13
  40958e:	d81a      	bhi.n	4095c6 <auto_camtest_exe+0x7a>
  409590:	2300      	movs	r3, #0
  409592:	2200      	movs	r2, #0
  409594:	4318      	orrs	r0, r3
  409596:	4611      	mov	r1, r2
  409598:	47a0      	blx	r4
  40959a:	2801      	cmp	r0, #1
  40959c:	d006      	beq.n	4095ac <auto_camtest_exe+0x60>
			cam_trial_counter=0;
  40959e:	4a16      	ldr	r2, [pc, #88]	; (4095f8 <auto_camtest_exe+0xac>)
  4095a0:	2100      	movs	r1, #0
			auto_stop_enter();
  4095a2:	4b16      	ldr	r3, [pc, #88]	; (4095fc <auto_camtest_exe+0xb0>)
			cam_trial_counter=0;
  4095a4:	6011      	str	r1, [r2, #0]
}
  4095a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			auto_stop_enter();
  4095aa:	4718      	bx	r3
		if(++sec_dev_counter >= AUTO_STATE_UPDATE_SEC)
  4095ac:	4a14      	ldr	r2, [pc, #80]	; (409600 <auto_camtest_exe+0xb4>)
  4095ae:	6813      	ldr	r3, [r2, #0]
  4095b0:	3301      	adds	r3, #1
  4095b2:	2b18      	cmp	r3, #24
			sec_dev_counter=0;
  4095b4:	bf88      	it	hi
  4095b6:	2300      	movhi	r3, #0
  4095b8:	6013      	str	r3, [r2, #0]
	auto_camtest_exit();
  4095ba:	4b12      	ldr	r3, [pc, #72]	; (409604 <auto_camtest_exe+0xb8>)
}
  4095bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	auto_camtest_exit();
  4095c0:	4718      	bx	r3
		if(!((mup==1)||(mdwn==1)))
  4095c2:	2300      	movs	r3, #0
  4095c4:	e7d9      	b.n	40957a <auto_camtest_exe+0x2e>
  4095c6:	280f      	cmp	r0, #15
  4095c8:	f100 000e 	add.w	r0, r0, #14
  4095cc:	bf8c      	ite	hi
  4095ce:	f04f 437a 	movhi.w	r3, #4194304000	; 0xfa000000
  4095d2:	2300      	movls	r3, #0
  4095d4:	e7dd      	b.n	409592 <auto_camtest_exe+0x46>
		auto_stop_enter();
  4095d6:	4b09      	ldr	r3, [pc, #36]	; (4095fc <auto_camtest_exe+0xb0>)
  4095d8:	4798      	blx	r3
		drop_all_req();
  4095da:	4b0b      	ldr	r3, [pc, #44]	; (409608 <auto_camtest_exe+0xbc>)
}
  4095dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		drop_all_req();
  4095e0:	4718      	bx	r3
  4095e2:	bf00      	nop
  4095e4:	0040180d 	.word	0x0040180d
  4095e8:	00400bf9 	.word	0x00400bf9
  4095ec:	204008b2 	.word	0x204008b2
  4095f0:	204052b4 	.word	0x204052b4
  4095f4:	0040d879 	.word	0x0040d879
  4095f8:	20404fe4 	.word	0x20404fe4
  4095fc:	004082b5 	.word	0x004082b5
  409600:	204008e0 	.word	0x204008e0
  409604:	00409411 	.word	0x00409411
  409608:	00401079 	.word	0x00401079

0040960c <auto_prespd_exit>:
		auto_stop_enter();
	}

}
void auto_prespd_exit(void)
{
  40960c:	b510      	push	{r4, lr}
	if (pre_spd_counter > 0)
  40960e:	4c08      	ldr	r4, [pc, #32]	; (409630 <auto_prespd_exit+0x24>)
  409610:	8823      	ldrh	r3, [r4, #0]
  409612:	b29b      	uxth	r3, r3
  409614:	b143      	cbz	r3, 409628 <auto_prespd_exit+0x1c>
	{
		if(vfd_states_allowedtomove()) pre_spd_counter--;
  409616:	4b07      	ldr	r3, [pc, #28]	; (409634 <auto_prespd_exit+0x28>)
  409618:	4798      	blx	r3
  40961a:	b120      	cbz	r0, 409626 <auto_prespd_exit+0x1a>
  40961c:	8823      	ldrh	r3, [r4, #0]
  40961e:	3b01      	subs	r3, #1
  409620:	b29b      	uxth	r3, r3
  409622:	8023      	strh	r3, [r4, #0]
  409624:	bd10      	pop	{r4, pc}
  409626:	bd10      	pop	{r4, pc}
	} 
	else
	{
		auto_hspd_enter();
  409628:	4b03      	ldr	r3, [pc, #12]	; (409638 <auto_prespd_exit+0x2c>)
	}
  40962a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		auto_hspd_enter();
  40962e:	4718      	bx	r3
  409630:	204008d8 	.word	0x204008d8
  409634:	00416305 	.word	0x00416305
  409638:	004089a1 	.word	0x004089a1

0040963c <auto_prespd_exe>:
{
  40963c:	b510      	push	{r4, lr}
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  40963e:	4b12      	ldr	r3, [pc, #72]	; (409688 <auto_prespd_exe+0x4c>)
  409640:	4798      	blx	r3
  409642:	b1b8      	cbz	r0, 409674 <auto_prespd_exe+0x38>
	light_timer_reset();
  409644:	4b11      	ldr	r3, [pc, #68]	; (40968c <auto_prespd_exe+0x50>)
  409646:	4798      	blx	r3
	IO_YARD(0);
  409648:	2100      	movs	r1, #0
  40964a:	2008      	movs	r0, #8
  40964c:	4b10      	ldr	r3, [pc, #64]	; (409690 <auto_prespd_exe+0x54>)
  40964e:	4798      	blx	r3
	ersd_allowTo_turn_on();
  409650:	4b10      	ldr	r3, [pc, #64]	; (409694 <auto_prespd_exe+0x58>)
  409652:	4798      	blx	r3
	if((s_i_err() == 1))// if there is an immediate stop error then stop
  409654:	4b10      	ldr	r3, [pc, #64]	; (409698 <auto_prespd_exe+0x5c>)
  409656:	4798      	blx	r3
  409658:	2801      	cmp	r0, #1
  40965a:	d00e      	beq.n	40967a <auto_prespd_exe+0x3e>
	if(INS==0)
  40965c:	4b0f      	ldr	r3, [pc, #60]	; (40969c <auto_prespd_exe+0x60>)
  40965e:	781b      	ldrb	r3, [r3, #0]
  409660:	07db      	lsls	r3, r3, #31
  409662:	d503      	bpl.n	40966c <auto_prespd_exe+0x30>
		auto_stop_enter();
  409664:	4b0e      	ldr	r3, [pc, #56]	; (4096a0 <auto_prespd_exe+0x64>)
}
  409666:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		auto_stop_enter();
  40966a:	4718      	bx	r3
		auto_prespd_exit();
  40966c:	4b0d      	ldr	r3, [pc, #52]	; (4096a4 <auto_prespd_exe+0x68>)
}
  40966e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		auto_prespd_exit();
  409672:	4718      	bx	r3
	if(! vfd_enable_isEnabled()) auto_stop_enter();
  409674:	4b0a      	ldr	r3, [pc, #40]	; (4096a0 <auto_prespd_exe+0x64>)
  409676:	4798      	blx	r3
  409678:	e7e4      	b.n	409644 <auto_prespd_exe+0x8>
		auto_stop_enter();
  40967a:	4b09      	ldr	r3, [pc, #36]	; (4096a0 <auto_prespd_exe+0x64>)
  40967c:	4798      	blx	r3
		drop_all_req();
  40967e:	4b0a      	ldr	r3, [pc, #40]	; (4096a8 <auto_prespd_exe+0x6c>)
}
  409680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		drop_all_req();
  409684:	4718      	bx	r3
  409686:	bf00      	nop
  409688:	00413241 	.word	0x00413241
  40968c:	0040180d 	.word	0x0040180d
  409690:	00400941 	.word	0x00400941
  409694:	00414321 	.word	0x00414321
  409698:	00400bf9 	.word	0x00400bf9
  40969c:	204008b2 	.word	0x204008b2
  4096a0:	004082b5 	.word	0x004082b5
  4096a4:	0040960d 	.word	0x0040960d
  4096a8:	00401079 	.word	0x00401079

004096ac <auto_update>:
	selector_count();
  4096ac:	4b1a      	ldr	r3, [pc, #104]	; (409718 <auto_update+0x6c>)
{
  4096ae:	b570      	push	{r4, r5, r6, lr}
	selector_count();
  4096b0:	4798      	blx	r3
	switch (auto_counter)
  4096b2:	4b1a      	ldr	r3, [pc, #104]	; (40971c <auto_update+0x70>)
  4096b4:	681b      	ldr	r3, [r3, #0]
  4096b6:	3b01      	subs	r3, #1
  4096b8:	2b07      	cmp	r3, #7
  4096ba:	d807      	bhi.n	4096cc <auto_update+0x20>
  4096bc:	e8df f003 	tbb	[pc, r3]
  4096c0:	221f041c 	.word	0x221f041c
  4096c4:	28190625 	.word	0x28190625
		auto_lspd_exe();
  4096c8:	4b15      	ldr	r3, [pc, #84]	; (409720 <auto_update+0x74>)
  4096ca:	4798      	blx	r3
	if((prev_auto_state != auto_state) || ARDINS) auto_stop_enter();
  4096cc:	4c15      	ldr	r4, [pc, #84]	; (409724 <auto_update+0x78>)
	if(mnt == 1) auto_state |= 1;
  4096ce:	2201      	movs	r2, #1
  4096d0:	4d15      	ldr	r5, [pc, #84]	; (409728 <auto_update+0x7c>)
	if((prev_auto_state != auto_state) || ARDINS) auto_stop_enter();
  4096d2:	7823      	ldrb	r3, [r4, #0]
	if(mnt == 1) auto_state |= 1;
  4096d4:	702a      	strb	r2, [r5, #0]
	if((prev_auto_state != auto_state) || ARDINS) auto_stop_enter();
  4096d6:	4293      	cmp	r3, r2
  4096d8:	d002      	beq.n	4096e0 <auto_update+0x34>
  4096da:	4b14      	ldr	r3, [pc, #80]	; (40972c <auto_update+0x80>)
  4096dc:	4798      	blx	r3
  4096de:	782b      	ldrb	r3, [r5, #0]
	direction_limits_check();
  4096e0:	4a13      	ldr	r2, [pc, #76]	; (409730 <auto_update+0x84>)
	prev_auto_state = auto_state;
  4096e2:	7023      	strb	r3, [r4, #0]
	direction_limits_check();
  4096e4:	4790      	blx	r2
	auto_lift_states_monitor();
  4096e6:	4b13      	ldr	r3, [pc, #76]	; (409734 <auto_update+0x88>)
  4096e8:	4798      	blx	r3
	ctb_automatic_doors_handler();
  4096ea:	4b13      	ldr	r3, [pc, #76]	; (409738 <auto_update+0x8c>)
}
  4096ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ctb_automatic_doors_handler();
  4096f0:	4718      	bx	r3
		auto_stopping_exe();
  4096f2:	4b12      	ldr	r3, [pc, #72]	; (40973c <auto_update+0x90>)
  4096f4:	4798      	blx	r3
		break;
  4096f6:	e7e9      	b.n	4096cc <auto_update+0x20>
		auto_hspd_exe();
  4096f8:	4b11      	ldr	r3, [pc, #68]	; (409740 <auto_update+0x94>)
  4096fa:	4798      	blx	r3
		break;
  4096fc:	e7e6      	b.n	4096cc <auto_update+0x20>
		auto_stop_exe();
  4096fe:	4b11      	ldr	r3, [pc, #68]	; (409744 <auto_update+0x98>)
  409700:	4798      	blx	r3
		break;
  409702:	e7e3      	b.n	4096cc <auto_update+0x20>
		auto_camtest_exe();
  409704:	4b10      	ldr	r3, [pc, #64]	; (409748 <auto_update+0x9c>)
  409706:	4798      	blx	r3
		break;
  409708:	e7e0      	b.n	4096cc <auto_update+0x20>
		auto_idle_exe();
  40970a:	4b10      	ldr	r3, [pc, #64]	; (40974c <auto_update+0xa0>)
  40970c:	4798      	blx	r3
		break;
  40970e:	e7dd      	b.n	4096cc <auto_update+0x20>
		auto_prespd_exe();
  409710:	4b0f      	ldr	r3, [pc, #60]	; (409750 <auto_update+0xa4>)
  409712:	4798      	blx	r3
		break;
  409714:	e7da      	b.n	4096cc <auto_update+0x20>
  409716:	bf00      	nop
  409718:	00400e65 	.word	0x00400e65
  40971c:	2040001c 	.word	0x2040001c
  409720:	00409065 	.word	0x00409065
  409724:	204008da 	.word	0x204008da
  409728:	204008b2 	.word	0x204008b2
  40972c:	004082b5 	.word	0x004082b5
  409730:	00400efd 	.word	0x00400efd
  409734:	00408045 	.word	0x00408045
  409738:	004080ad 	.word	0x004080ad
  40973c:	00409189 	.word	0x00409189
  409740:	00408dc9 	.word	0x00408dc9
  409744:	004085cd 	.word	0x004085cd
  409748:	0040954d 	.word	0x0040954d
  40974c:	004086dd 	.word	0x004086dd
  409750:	0040963d 	.word	0x0040963d

00409754 <arctan2>:

fixedpt arctan2(fixedpt x, fixedpt y)
{
	fixedpt ang, ang_offset;
	
	if((x == 0) && (y == 0)) return 0; //invalid arguments
  409754:	b910      	cbnz	r0, 40975c <arctan2+0x8>
  409756:	b909      	cbnz	r1, 40975c <arctan2+0x8>
  409758:	2000      	movs	r0, #0
  40975a:	4770      	bx	lr
{
  40975c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	
	if (fixedpt_abs(x) >= fixedpt_abs(y))
  409760:	ea80 74e0 	eor.w	r4, r0, r0, asr #31
  409764:	4606      	mov	r6, r0
  409766:	ea81 75e1 	eor.w	r5, r1, r1, asr #31
  40976a:	460f      	mov	r7, r1
  40976c:	eba4 74e0 	sub.w	r4, r4, r0, asr #31
  409770:	eba5 75e1 	sub.w	r5, r5, r1, asr #31
  409774:	42ac      	cmp	r4, r5
  409776:	db1c      	blt.n	4097b2 <arctan2+0x5e>
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  409778:	17eb      	asrs	r3, r5, #31
  40977a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 409854 <arctan2+0x100>
  40977e:	03e8      	lsls	r0, r5, #15
  409780:	4622      	mov	r2, r4
  409782:	03d9      	lsls	r1, r3, #15
  409784:	17e3      	asrs	r3, r4, #31
  409786:	ea41 4155 	orr.w	r1, r1, r5, lsr #17
  40978a:	47c0      	blx	r8
	x *= 200;
  40978c:	23c8      	movs	r3, #200	; 0xc8
  40978e:	fb03 f000 	mul.w	r0, r3, r0
	if(x > fixedpt_rconst(200)) x = fixedpt_rconst(200);
  409792:	f5b0 0fc8 	cmp.w	r0, #6553600	; 0x640000
  409796:	dd3b      	ble.n	409810 <arctan2+0xbc>
	ang	= atan_lut[xreal];
  409798:	4b2d      	ldr	r3, [pc, #180]	; (409850 <arctan2+0xfc>)
  40979a:	f8d3 3320 	ldr.w	r3, [r3, #800]	; 0x320
{
  40979e:	2000      	movs	r0, #0
	else
	{
		ang = acotan45(fixedpt_div(fixedpt_abs(x), fixedpt_abs(y)));
	}
	
	if((y >= 0) && (x < 0))
  4097a0:	2f00      	cmp	r7, #0
	ang += fixedpt_mul((angp1 - ang), x);
  4097a2:	4418      	add	r0, r3
	if((y >= 0) && (x < 0))
  4097a4:	db2b      	blt.n	4097fe <arctan2+0xaa>
  4097a6:	2e00      	cmp	r6, #0
  4097a8:	da29      	bge.n	4097fe <arctan2+0xaa>
	{
		//1st quad
		ang = fixedpt_rconst(180) - ang;
  4097aa:	f5c0 00b4 	rsb	r0, r0, #5898240	; 0x5a0000
  4097ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4097b2:	17e3      	asrs	r3, r4, #31
  4097b4:	f8df 809c 	ldr.w	r8, [pc, #156]	; 409854 <arctan2+0x100>
  4097b8:	03e0      	lsls	r0, r4, #15
  4097ba:	462a      	mov	r2, r5
  4097bc:	03d9      	lsls	r1, r3, #15
  4097be:	17eb      	asrs	r3, r5, #31
  4097c0:	ea41 4154 	orr.w	r1, r1, r4, lsr #17
  4097c4:	47c0      	blx	r8
	x *= 200;
  4097c6:	23c8      	movs	r3, #200	; 0xc8
  4097c8:	fb03 f000 	mul.w	r0, r3, r0
	if(x > fixedpt_rconst(200)) x = fixedpt_rconst(200);
  4097cc:	f5b0 0fc8 	cmp.w	r0, #6553600	; 0x640000
  4097d0:	dc30      	bgt.n	409834 <arctan2+0xe0>
	uint32_t xreal = fixedpt_toint(x);
  4097d2:	13c2      	asrs	r2, r0, #15
	ang	= atan_lut[xreal];
  4097d4:	491e      	ldr	r1, [pc, #120]	; (409850 <arctan2+0xfc>)
	x = fixedpt_fracpart(x);
  4097d6:	f3c0 000e 	ubfx	r0, r0, #0, #15
	if(xreal < 200) angp1 = atan_lut[xreal + 1];
  4097da:	2ac7      	cmp	r2, #199	; 0xc7
	ang	= atan_lut[xreal];
  4097dc:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
	if(xreal < 200) angp1 = atan_lut[xreal + 1];
  4097e0:	d82b      	bhi.n	40983a <arctan2+0xe6>
  4097e2:	3201      	adds	r2, #1
  4097e4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  4097e8:	1ad2      	subs	r2, r2, r3
  4097ea:	fb82 0100 	smull	r0, r1, r2, r0
  4097ee:	0bc0      	lsrs	r0, r0, #15
  4097f0:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
	ang += fixedpt_mul((angp1 - ang), x);
  4097f4:	4403      	add	r3, r0
	if((y >= 0) && (x < 0))
  4097f6:	2f00      	cmp	r7, #0
	return fixedpt_rconst(90) - atan45(x);
  4097f8:	f5c3 1034 	rsb	r0, r3, #2949120	; 0x2d0000
	if((y >= 0) && (x < 0))
  4097fc:	dad3      	bge.n	4097a6 <arctan2+0x52>
	}
	else if((y < 0) && (x <= 0))
  4097fe:	2e00      	cmp	r6, #0
  409800:	ea4f 77d7 	mov.w	r7, r7, lsr #31
  409804:	dc1b      	bgt.n	40983e <arctan2+0xea>
  409806:	b1d7      	cbz	r7, 40983e <arctan2+0xea>
	{
		//3nd quad
		ang  += fixedpt_rconst(180);
  409808:	f500 00b4 	add.w	r0, r0, #5898240	; 0x5a0000
  40980c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint32_t xreal = fixedpt_toint(x);
  409810:	13c2      	asrs	r2, r0, #15
	ang	= atan_lut[xreal];
  409812:	490f      	ldr	r1, [pc, #60]	; (409850 <arctan2+0xfc>)
	x = fixedpt_fracpart(x);
  409814:	f3c0 000e 	ubfx	r0, r0, #0, #15
	if(xreal < 200) angp1 = atan_lut[xreal + 1];
  409818:	2ac7      	cmp	r2, #199	; 0xc7
	ang	= atan_lut[xreal];
  40981a:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
	if(xreal < 200) angp1 = atan_lut[xreal + 1];
  40981e:	d8be      	bhi.n	40979e <arctan2+0x4a>
  409820:	3201      	adds	r2, #1
  409822:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  409826:	1ad2      	subs	r2, r2, r3
  409828:	fb82 0100 	smull	r0, r1, r2, r0
  40982c:	0bc0      	lsrs	r0, r0, #15
  40982e:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
  409832:	e7b5      	b.n	4097a0 <arctan2+0x4c>
	ang	= atan_lut[xreal];
  409834:	4b06      	ldr	r3, [pc, #24]	; (409850 <arctan2+0xfc>)
  409836:	f8d3 3320 	ldr.w	r3, [r3, #800]	; 0x320
{
  40983a:	2000      	movs	r0, #0
  40983c:	e7da      	b.n	4097f4 <arctan2+0xa0>
	}
	else if((y < 0) && (x > 0))
  40983e:	2e00      	cmp	r6, #0
  409840:	dd04      	ble.n	40984c <arctan2+0xf8>
  409842:	b11f      	cbz	r7, 40984c <arctan2+0xf8>
	{
		//4rd quad
		ang = fixedpt_rconst(360) - ang;
  409844:	f5c0 0034 	rsb	r0, r0, #11796480	; 0xb40000
  409848:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	
	return ang;
  40984c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409850:	20400024 	.word	0x20400024
  409854:	0041905d 	.word	0x0041905d

00409858 <com_sin>:
};

float com_sin(float val)
{
	uint32_t indx = val * 200;
	if (val >= 1) return 0;
  409858:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
{
  40985c:	ee07 0a90 	vmov	s15, r0
	if (val >= 1) return 0;
  409860:	eef4 7ac7 	vcmpe.f32	s15, s14
  409864:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  409868:	db01      	blt.n	40986e <com_sin+0x16>
  40986a:	2000      	movs	r0, #0
	return compsin_lup_table[indx];
  40986c:	4770      	bx	lr
	uint32_t indx = val * 200;
  40986e:	ed9f 7a06 	vldr	s14, [pc, #24]	; 409888 <com_sin+0x30>
	return compsin_lup_table[indx];
  409872:	4b06      	ldr	r3, [pc, #24]	; (40988c <com_sin+0x34>)
	uint32_t indx = val * 200;
  409874:	ee67 7a87 	vmul.f32	s15, s15, s14
  409878:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	return compsin_lup_table[indx];
  40987c:	ee17 2a90 	vmov	r2, s15
  409880:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  409884:	6818      	ldr	r0, [r3, #0]
  409886:	4770      	bx	lr
  409888:	43480000 	.word	0x43480000
  40988c:	0041b5e4 	.word	0x0041b5e4

00409890 <menue_data_manager_drive_update>:
uint8_t				menue_drive_encoder_tune  = 0;
uint8_t				menue_drive_motor_tune    = 0;

/*uint8_t test_arr_save[SIZE_TO_STORE];*/
void menue_data_manager_drive_update(void)
{
  409890:	b508      	push	{r3, lr}
	memcpy(&menue_drive_data_applied, &menue_drive_data_setup, sizeof(menue_drive_data_t));
  409892:	22f8      	movs	r2, #248	; 0xf8
  409894:	4902      	ldr	r1, [pc, #8]	; (4098a0 <menue_data_manager_drive_update+0x10>)
  409896:	4b03      	ldr	r3, [pc, #12]	; (4098a4 <menue_data_manager_drive_update+0x14>)
  409898:	4803      	ldr	r0, [pc, #12]	; (4098a8 <menue_data_manager_drive_update+0x18>)
  40989a:	4798      	blx	r3
  40989c:	bd08      	pop	{r3, pc}
  40989e:	bf00      	nop
  4098a0:	204050e8 	.word	0x204050e8
  4098a4:	00419609 	.word	0x00419609
  4098a8:	20404ff0 	.word	0x20404ff0

004098ac <menue_data_manager_drive_load>:
}


uint32_t menue_data_manager_drive_load(uint32_t offset_add)
{
  4098ac:	b538      	push	{r3, r4, r5, lr}
  4098ae:	4604      	mov	r4, r0
	//menue_data_manager_drive_restore();
	//menue_data_manager_drive_update();
	//return;
	at24cxx_dynamic_sch_read_array(0, offset_add, sizeof(menue_drive_data_t), &menue_drive_data_setup);
  4098b0:	4b04      	ldr	r3, [pc, #16]	; (4098c4 <menue_data_manager_drive_load+0x18>)
  4098b2:	22f8      	movs	r2, #248	; 0xf8
  4098b4:	4d04      	ldr	r5, [pc, #16]	; (4098c8 <menue_data_manager_drive_load+0x1c>)
  4098b6:	4621      	mov	r1, r4
  4098b8:	2000      	movs	r0, #0
  4098ba:	47a8      	blx	r5
	return offset_add + sizeof(menue_drive_data_t);
}
  4098bc:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
  4098c0:	bd38      	pop	{r3, r4, r5, pc}
  4098c2:	bf00      	nop
  4098c4:	204050e8 	.word	0x204050e8
  4098c8:	0040ac6d 	.word	0x0040ac6d

004098cc <menue_data_manager_drive_save>:
uint32_t menue_data_manager_drive_save(uint32_t offset_add)
{
  4098cc:	b538      	push	{r3, r4, r5, lr}
  4098ce:	4604      	mov	r4, r0
	at24cxx_dynamic_sch_write_array(0, offset_add, sizeof(menue_drive_data_t), &menue_drive_data_setup);
  4098d0:	4b04      	ldr	r3, [pc, #16]	; (4098e4 <menue_data_manager_drive_save+0x18>)
  4098d2:	22f8      	movs	r2, #248	; 0xf8
  4098d4:	4d04      	ldr	r5, [pc, #16]	; (4098e8 <menue_data_manager_drive_save+0x1c>)
  4098d6:	4621      	mov	r1, r4
  4098d8:	2000      	movs	r0, #0
  4098da:	47a8      	blx	r5
	return offset_add + sizeof(menue_drive_data_t);
}
  4098dc:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
  4098e0:	bd38      	pop	{r3, r4, r5, pc}
  4098e2:	bf00      	nop
  4098e4:	204050e8 	.word	0x204050e8
  4098e8:	0040ac1d 	.word	0x0040ac1d

004098ec <menue_data_manager_drive_restore>:
}

void menue_data_manager_drive_restore(void)
{
//__________________________vector parameters_________________________________
	menue_drive_data_setup.m_ACRD_i = ((307916.2924f) / 100); 
  4098ec:	4b61      	ldr	r3, [pc, #388]	; (409a74 <menue_data_manager_drive_restore+0x188>)
	menue_drive_data_setup.m_ASR_highs_i = (0.8f);
	menue_drive_data_setup.m_ASR_highs_p = (35.0f);
	menue_drive_data_setup.m_ASR_lows_i = (0.6f);
	menue_drive_data_setup.m_ASR_lows_p = (40.0f);
	menue_drive_data_setup.m_ASR_zs_i = (100.8f);
	menue_drive_data_setup.m_ASR_zs_p = (10.0f);
  4098ee:	4962      	ldr	r1, [pc, #392]	; (409a78 <menue_data_manager_drive_restore+0x18c>)
	menue_drive_data_setup.m_control_mode = 0;
	menue_drive_data_setup.m_max_freq = fixedpt_rconst(50.0);
	menue_drive_data_setup.m_motor_leakage_inductance = (43.1f * sqrt3);
	menue_drive_data_setup.m_motor_LD = (60);
	menue_drive_data_setup.m_motor_LQ = (80);
	menue_drive_data_setup.m_motor_magnetizing_inductance = (24.0f);
  4098f0:	4a62      	ldr	r2, [pc, #392]	; (409a7c <menue_data_manager_drive_restore+0x190>)
	menue_drive_data_setup.m_APR_zs_eso = (5.0f);
  4098f2:	4863      	ldr	r0, [pc, #396]	; (409a80 <menue_data_manager_drive_restore+0x194>)
	menue_drive_data_setup.m_motor_noload_current = (2.1f);
	menue_drive_data_setup.m_motor_rated_current = fixedpt_rconst(25.0);
	menue_drive_data_setup.m_motor_rated_freq = fixedpt_rconst(50.0);
	menue_drive_data_setup.m_motor_rated_pfactor = (82.0f);
	menue_drive_data_setup.m_motor_rated_power = (7.5f);
  4098f4:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 409ae4 <menue_data_manager_drive_restore+0x1f8>
{
  4098f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	menue_drive_data_setup.m_ASR_highs_p = (35.0f);
  4098fc:	4f61      	ldr	r7, [pc, #388]	; (409a84 <menue_data_manager_drive_restore+0x198>)
	menue_drive_data_setup.m_motor_rated_speed = fixedpt_rconst(1444);
	menue_drive_data_setup.m_motor_rated_voltage = fixedpt_rconst(380);
  4098fe:	f44f 083e 	mov.w	r8, #12451840	; 0xbe0000
	menue_drive_data_setup.m_ASR_lows_i = (0.6f);
  409902:	4e61      	ldr	r6, [pc, #388]	; (409a88 <menue_data_manager_drive_restore+0x19c>)
////////////////////////////////// encoder parameters ////////////////////////////////////////
	menue_drive_data_setup.m_encoder_p_count = 2048;
	menue_drive_data_setup.m_encoder_type = 0;
	menue_drive_data_setup.m_pg_direction = 0;
	menue_drive_data_setup.m_pole_pos_offset = (50.65);
	menue_drive_data_setup.m_encoder_search_current = 75;
  409904:	f04f 094b 	mov.w	r9, #75	; 0x4b
	menue_drive_data_setup.m_ASR_highs_p = (35.0f);
  409908:	649f      	str	r7, [r3, #72]	; 0x48
	menue_drive_data_setup.m_ASR_lows_p = (40.0f);
  40990a:	4f60      	ldr	r7, [pc, #384]	; (409a8c <menue_data_manager_drive_restore+0x1a0>)
	menue_drive_data_setup.m_ASR_lows_i = (0.6f);
  40990c:	645e      	str	r6, [r3, #68]	; 0x44
	menue_drive_data_setup.m_speed_dev = (30);
  40990e:	261e      	movs	r6, #30
	menue_drive_data_setup.m_ASR_lows_p = (40.0f);
  409910:	641f      	str	r7, [r3, #64]	; 0x40
	menue_drive_data_setup.m_ASR_zs_i = (100.8f);
  409912:	4f5f      	ldr	r7, [pc, #380]	; (409a90 <menue_data_manager_drive_restore+0x1a4>)
	menue_drive_data_setup.m_ASR_zs_p = (10.0f);
  409914:	6599      	str	r1, [r3, #88]	; 0x58
	menue_drive_data_setup.m_carier_freq = 4;
  409916:	2104      	movs	r1, #4
	menue_drive_data_setup.m_ASR_zs_i = (100.8f);
  409918:	65df      	str	r7, [r3, #92]	; 0x5c
	menue_drive_data_setup.m_APR_zs_p = (0.0f);
  40991a:	2700      	movs	r7, #0
	menue_drive_data_setup.m_speed_dev = (30);
  40991c:	f8a3 608e 	strh.w	r6, [r3, #142]	; 0x8e
	menue_drive_data_setup.m_motor_rated_current = fixedpt_rconst(25.0);
  409920:	f44f 2648 	mov.w	r6, #819200	; 0xc8000
	menue_drive_data_setup.m_APR_zs_p = (0.0f);
  409924:	661f      	str	r7, [r3, #96]	; 0x60
	menue_drive_data_setup.m_motor_leakage_inductance = (43.1f * sqrt3);
  409926:	4f5b      	ldr	r7, [pc, #364]	; (409a94 <menue_data_manager_drive_restore+0x1a8>)
	menue_drive_data_setup.m_ASR_highs_i = (0.8f);
  409928:	4c5b      	ldr	r4, [pc, #364]	; (409a98 <menue_data_manager_drive_restore+0x1ac>)
	menue_drive_data_setup.m_motor_leakage_inductance = (43.1f * sqrt3);
  40992a:	625f      	str	r7, [r3, #36]	; 0x24
	menue_drive_data_setup.m_motor_LD = (60);
  40992c:	4f5b      	ldr	r7, [pc, #364]	; (409a9c <menue_data_manager_drive_restore+0x1b0>)
	menue_drive_data_setup.m_ACR_bandwidth = (20);
  40992e:	4d5c      	ldr	r5, [pc, #368]	; (409aa0 <menue_data_manager_drive_restore+0x1b4>)
	menue_drive_data_setup.m_motor_LD = (60);
  409930:	629f      	str	r7, [r3, #40]	; 0x28
	menue_drive_data_setup.m_motor_noload_current = (2.1f);
  409932:	4f5c      	ldr	r7, [pc, #368]	; (409aa4 <menue_data_manager_drive_restore+0x1b8>)
	menue_drive_data_setup.m_ASR_highs_i = (0.8f);
  409934:	64dc      	str	r4, [r3, #76]	; 0x4c
	menue_drive_data_setup.m_ASR_sw_lw_point = (1.0f);
  409936:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
	menue_drive_data_setup.m_motor_noload_current = (2.1f);
  40993a:	635f      	str	r7, [r3, #52]	; 0x34
	menue_drive_data_setup.m_motor_rated_pfactor = (82.0f);
  40993c:	4f5a      	ldr	r7, [pc, #360]	; (409aa8 <menue_data_manager_drive_restore+0x1bc>)
	menue_drive_data_setup.m_carier_freq = 4;
  40993e:	f883 10c4 	strb.w	r1, [r3, #196]	; 0xc4
	menue_drive_data_setup.m_tourque_decay = (250);
  409942:	21fa      	movs	r1, #250	; 0xfa
	menue_drive_data_setup.m_motor_rated_pfactor = (82.0f);
  409944:	619f      	str	r7, [r3, #24]
	menue_drive_data_setup.m_ACRD_i = ((307916.2924f) / 100); 
  409946:	4f59      	ldr	r7, [pc, #356]	; (409aac <menue_data_manager_drive_restore+0x1c0>)
	menue_drive_data_setup.m_motor_magnetizing_inductance = (24.0f);
  409948:	631a      	str	r2, [r3, #48]	; 0x30
	menue_drive_data_setup.m_control_mode = 0;
  40994a:	2200      	movs	r2, #0
	menue_drive_data_setup.m_ACRD_i = ((307916.2924f) / 100); 
  40994c:	675f      	str	r7, [r3, #116]	; 0x74
	menue_drive_data_setup.m_ACRQ_i = ((307916.2924f) / 100);
  40994e:	67df      	str	r7, [r3, #124]	; 0x7c
	menue_drive_data_setup.m_ACRD_p = ((2166.442294f)); 
  409950:	4f57      	ldr	r7, [pc, #348]	; (409ab0 <menue_data_manager_drive_restore+0x1c4>)
	menue_drive_data_setup.m_motor_rated_current = fixedpt_rconst(25.0);
  409952:	615e      	str	r6, [r3, #20]
	menue_drive_data_setup.m_max_freq = fixedpt_rconst(50.0);
  409954:	f44f 16c8 	mov.w	r6, #1638400	; 0x190000
	menue_drive_data_setup.m_ACRD_p = ((2166.442294f)); 
  409958:	671f      	str	r7, [r3, #112]	; 0x70
	menue_drive_data_setup.m_ACRQ_p = ((2166.442294f));
  40995a:	679f      	str	r7, [r3, #120]	; 0x78
	menue_drive_data_setup.m_ACR_bandwidth_zs = (80);
  40995c:	4f55      	ldr	r7, [pc, #340]	; (409ab4 <menue_data_manager_drive_restore+0x1c8>)
	menue_drive_data_setup.m_ACR_bandwidth = (20);
  40995e:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
	menue_drive_data_setup.m_motor_rated_power = (7.5f);
  409962:	f8c3 c004 	str.w	ip, [r3, #4]
	menue_drive_data_setup.m_encoder_p_count = 2048;
  409966:	f44f 6c00 	mov.w	ip, #2048	; 0x800
	menue_drive_data_setup.m_APR_zs_eso = (5.0f);
  40996a:	6658      	str	r0, [r3, #100]	; 0x64
	menue_drive_data_setup.m_ASR_sw_hi_point = (5.0);
  40996c:	6698      	str	r0, [r3, #104]	; 0x68
	menue_drive_data_setup.m_ASR_speed_band = (5);
  40996e:	6518      	str	r0, [r3, #80]	; 0x50
	menue_drive_data_setup.m_APR_level_p = (5.0);
  409970:	6558      	str	r0, [r3, #84]	; 0x54
	menue_drive_data_setup.m_enc_filter_low = (1);
	menue_drive_data_setup.m_enc_filter_high = (1);
//////////////////////////////////V/F parameters////////////////////////////////////////
	menue_drive_data_setup.m_vmin			=	fixedpt_rconst(15.0f);
  409972:	f44f 20f0 	mov.w	r0, #491520	; 0x78000
	menue_drive_data_setup.m_ACR_bandwidth_zs = (80);
  409976:	f8c3 7084 	str.w	r7, [r3, #132]	; 0x84
	menue_drive_data_setup.m_motor_LQ = (80);
  40997a:	62df      	str	r7, [r3, #44]	; 0x2c
	menue_drive_data_setup.m_ASR_sw_lw_point = (1.0f);
  40997c:	66dc      	str	r4, [r3, #108]	; 0x6c
	menue_drive_data_setup.m_tourque_decay = (250);
  40997e:	f8a3 108c 	strh.w	r1, [r3, #140]	; 0x8c
	menue_drive_data_setup.m_control_mode = 0;
  409982:	f883 20c5 	strb.w	r2, [r3, #197]	; 0xc5
	menue_drive_data_setup.m_max_freq = fixedpt_rconst(50.0);
  409986:	f8c3 60c0 	str.w	r6, [r3, #192]	; 0xc0
	menue_drive_data_setup.m_motor_rated_freq = fixedpt_rconst(50.0);
  40998a:	609e      	str	r6, [r3, #8]
	menue_drive_data_setup.m_fmin			=	fixedpt_rconst(1.5f);
  40998c:	f44f 4640 	mov.w	r6, #49152	; 0xc000
	menue_drive_data_setup.m_tboost			=	fixedpt_rconst(150.00);
	menue_drive_data_setup.m_break_freq		=	fixedpt_rconst(3);
	menue_drive_data_setup.m_break_voltage	=	fixedpt_rconst(20);
	
//////////////////////////////////Brake delays////////////////////////////////////////
	menue_drive_data_setup.m_dcbreak_delay = 250;
  409990:	f8a3 10cc 	strh.w	r1, [r3, #204]	; 0xcc
	menue_drive_data_setup.m_brake_release_delay = 250;
  409994:	f8a3 10c6 	strh.w	r1, [r3, #198]	; 0xc6
	menue_drive_data_setup.m_brake_hold_delay = 250;
  409998:	f8a3 10c8 	strh.w	r1, [r3, #200]	; 0xc8
	menue_drive_data_setup.m_motor_rotor_resistance = (2.2f);
  40999c:	4946      	ldr	r1, [pc, #280]	; (409ab8 <menue_data_manager_drive_restore+0x1cc>)
	menue_drive_data_setup.m_motor_rated_speed = fixedpt_rconst(1444);
  40999e:	4f47      	ldr	r7, [pc, #284]	; (409abc <menue_data_manager_drive_restore+0x1d0>)
	menue_drive_data_setup.m_motor_rotor_resistance = (2.2f);
  4099a0:	6219      	str	r1, [r3, #32]
	menue_drive_data_setup.m_motor_stator_resistance = (5.125 * sqrt3);
  4099a2:	4947      	ldr	r1, [pc, #284]	; (409ac0 <menue_data_manager_drive_restore+0x1d4>)
	menue_drive_data_setup.m_motor_rated_speed = fixedpt_rconst(1444);
  4099a4:	60df      	str	r7, [r3, #12]
	menue_drive_data_setup.m_vm				=	fixedpt_rconst(30.0f);
  4099a6:	f44f 2770 	mov.w	r7, #983040	; 0xf0000
	menue_drive_data_setup.m_motor_stator_resistance = (5.125 * sqrt3);
  4099aa:	61d9      	str	r1, [r3, #28]
	menue_drive_data_setup.m_motor_BEMF = (2.65558068887f);
  4099ac:	4945      	ldr	r1, [pc, #276]	; (409ac4 <menue_data_manager_drive_restore+0x1d8>)
	menue_drive_data_setup.m_motor_type = 0;
  4099ae:	701a      	strb	r2, [r3, #0]
	menue_drive_data_setup.m_encoder_type = 0;
  4099b0:	f883 20ac 	strb.w	r2, [r3, #172]	; 0xac
	menue_drive_data_setup.m_pg_direction = 0;
  4099b4:	f883 20ad 	strb.w	r2, [r3, #173]	; 0xad
	
//////////////////////////////////Phase fail////////////////////////////////////////
	menue_drive_data_setup.m_input_phase_fail = 1;
	
////////////////////////////Overload//////////////////////////////////////////////
	menue_drive_data_setup.m_overload_type = 0;
  4099b8:	f883 20cf 	strb.w	r2, [r3, #207]	; 0xcf
	menue_drive_data_setup.m_overload_time = 60;
	menue_drive_data_setup.m_overload_value = fixedpt_rconst(100);
////////////////////////////ARD//////////////////////////////////////////////
	menue_drive_data_setup.m_ard_type = 0;
  4099bc:	f883 20d8 	strb.w	r2, [r3, #216]	; 0xd8
	menue_drive_data_setup.m_fm				=	fixedpt_rconst(5.0f);
  4099c0:	f44f 3220 	mov.w	r2, #163840	; 0x28000
	menue_drive_data_setup.m_enc_filter_low = (1);
  4099c4:	f8c3 40b8 	str.w	r4, [r3, #184]	; 0xb8
	menue_drive_data_setup.m_enc_filter_high = (1);
  4099c8:	f8c3 40bc 	str.w	r4, [r3, #188]	; 0xbc
	menue_drive_data_setup.m_break_freq		=	fixedpt_rconst(3);
  4099cc:	f44f 34c0 	mov.w	r4, #98304	; 0x18000
	menue_drive_data_setup.m_motor_BEMF = (2.65558068887f);
  4099d0:	6399      	str	r1, [r3, #56]	; 0x38
	menue_drive_data_setup.m_pole_pos_offset = (50.65);
  4099d2:	493d      	ldr	r1, [pc, #244]	; (409ac8 <menue_data_manager_drive_restore+0x1dc>)
	menue_drive_data_setup.m_fmin			=	fixedpt_rconst(1.5f);
  4099d4:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
	menue_drive_data_setup.m_ard_current_max = 2.5;
////////////////////////////Mech data//////////////////////////////////////////////
	menue_drive_data_setup.m_mech_sheave_dia = 210;
  4099d8:	26d2      	movs	r6, #210	; 0xd2
	menue_drive_data_setup.m_vm				=	fixedpt_rconst(30.0f);
  4099da:	f8c3 7098 	str.w	r7, [r3, #152]	; 0x98
	menue_drive_data_setup.m_overload_value = fixedpt_rconst(100);
  4099de:	f44f 1748 	mov.w	r7, #3276800	; 0x320000
	menue_drive_data_setup.m_fm				=	fixedpt_rconst(5.0f);
  4099e2:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
	menue_drive_data_setup.m_motor_pole_pair_count = 2;
  4099e6:	2202      	movs	r2, #2
	menue_drive_data_setup.m_ard_current_max = 2.5;
  4099e8:	f8df e0fc 	ldr.w	lr, [pc, #252]	; 409ae8 <menue_data_manager_drive_restore+0x1fc>
	menue_drive_data_setup.m_motor_rated_voltage = fixedpt_rconst(380);
  4099ec:	f8c3 8010 	str.w	r8, [r3, #16]
	menue_drive_data_setup.m_motor_move_delay = 550;
  4099f0:	f240 2826 	movw	r8, #550	; 0x226
	menue_drive_data_setup.m_encoder_p_count = 2048;
  4099f4:	f8a3 c0ae 	strh.w	ip, [r3, #174]	; 0xae
	menue_drive_data_setup.m_tboost			=	fixedpt_rconst(150.00);
  4099f8:	f44f 0c96 	mov.w	ip, #4915200	; 0x4b0000
	menue_drive_data_setup.m_vmin			=	fixedpt_rconst(15.0f);
  4099fc:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	menue_drive_data_setup.m_break_voltage	=	fixedpt_rconst(20);
  409a00:	f44f 2020 	mov.w	r0, #655360	; 0xa0000
	menue_drive_data_setup.m_pole_pos_offset = (50.65);
  409a04:	f8c3 10b4 	str.w	r1, [r3, #180]	; 0xb4
	menue_drive_data_setup.m_overload_time = 60;
  409a08:	213c      	movs	r1, #60	; 0x3c
	menue_drive_data_setup.m_break_freq		=	fixedpt_rconst(3);
  409a0a:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
	menue_drive_data_setup.m_input_phase_fail = 1;
  409a0e:	2401      	movs	r4, #1
	menue_drive_data_setup.m_overload_value = fixedpt_rconst(100);
  409a10:	f8c3 70d4 	str.w	r7, [r3, #212]	; 0xd4
	menue_drive_data_setup.m_ard_current_max = 2.5;
  409a14:	f8c3 e0dc 	str.w	lr, [r3, #220]	; 0xdc
	menue_drive_data_setup.m_mech_sheave_dia = 210;
  409a18:	f8a3 60e0 	strh.w	r6, [r3, #224]	; 0xe0
	menue_drive_data_setup.m_mech_sus_ratio = 2;
	menue_drive_data_setup.m_mech_motor_inertia = 0.15;
  409a1c:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 409aec <menue_data_manager_drive_restore+0x200>
	menue_drive_data_setup.m_motor_pole_pair_count = 2;
  409a20:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
	menue_drive_data_setup.m_mech_sus_ratio = 2;
  409a24:	f883 20e2 	strb.w	r2, [r3, #226]	; 0xe2
	menue_drive_data_setup.m_mech_counter_weight = 650;
	menue_drive_data_setup.m_mech_cabin_weight = 650;
	menue_drive_data_setup.m_mech_payload_weight = 400;
  409a28:	4f28      	ldr	r7, [pc, #160]	; (409acc <menue_data_manager_drive_restore+0x1e0>)
	menue_drive_data_setup.m_mech_counter_weight = 650;
  409a2a:	4a29      	ldr	r2, [pc, #164]	; (409ad0 <menue_data_manager_drive_restore+0x1e4>)
	menue_drive_data_setup.m_mech_inertia = 20;
	
	menue_drive_data_newdata_flag = 1;
  409a2c:	4e29      	ldr	r6, [pc, #164]	; (409ad4 <menue_data_manager_drive_restore+0x1e8>)
	menue_drive_data_setup.m_encoder_search_current = 75;
  409a2e:	f883 90b0 	strb.w	r9, [r3, #176]	; 0xb0
	menue_drive_data_setup.m_break_voltage	=	fixedpt_rconst(20);
  409a32:	f8c3 00a4 	str.w	r0, [r3, #164]	; 0xa4
	
	enc_set_theta(0);
  409a36:	2000      	movs	r0, #0
	menue_drive_data_setup.m_motor_move_delay = 550;
  409a38:	f8a3 80ca 	strh.w	r8, [r3, #202]	; 0xca
	menue_drive_data_setup.m_overload_time = 60;
  409a3c:	f883 10d0 	strb.w	r1, [r3, #208]	; 0xd0
	enc_set_theta(0);
  409a40:	2100      	movs	r1, #0
	menue_drive_data_setup.m_tboost			=	fixedpt_rconst(150.00);
  409a42:	f8c3 c0a8 	str.w	ip, [r3, #168]	; 0xa8
	menue_drive_data_setup.m_input_phase_fail = 1;
  409a46:	f883 40ce 	strb.w	r4, [r3, #206]	; 0xce
	menue_drive_data_setup.m_mech_inertia = 20;
  409a4a:	f8c3 50f4 	str.w	r5, [r3, #244]	; 0xf4
	enc_set_theta(0);
  409a4e:	4d22      	ldr	r5, [pc, #136]	; (409ad8 <menue_data_manager_drive_restore+0x1ec>)
	menue_drive_data_setup.m_mech_motor_inertia = 0.15;
  409a50:	f8c3 e0e4 	str.w	lr, [r3, #228]	; 0xe4
	menue_drive_data_setup.m_mech_payload_weight = 400;
  409a54:	f8c3 70f0 	str.w	r7, [r3, #240]	; 0xf0
	menue_drive_data_newdata_flag = 1;
  409a58:	7034      	strb	r4, [r6, #0]
	menue_drive_data_setup.m_mech_counter_weight = 650;
  409a5a:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
	menue_drive_data_setup.m_mech_cabin_weight = 650;
  409a5e:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
	enc_set_theta(0);
  409a62:	47a8      	blx	r5
	pop_ups_add("Drive set restored!", 1000);
  409a64:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409a68:	481c      	ldr	r0, [pc, #112]	; (409adc <menue_data_manager_drive_restore+0x1f0>)
  409a6a:	4b1d      	ldr	r3, [pc, #116]	; (409ae0 <menue_data_manager_drive_restore+0x1f4>)
  409a6c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	pop_ups_add("Drive set restored!", 1000);
  409a70:	4718      	bx	r3
  409a72:	bf00      	nop
  409a74:	204050e8 	.word	0x204050e8
  409a78:	41200000 	.word	0x41200000
  409a7c:	41c00000 	.word	0x41c00000
  409a80:	40a00000 	.word	0x40a00000
  409a84:	420c0000 	.word	0x420c0000
  409a88:	3f19999a 	.word	0x3f19999a
  409a8c:	42200000 	.word	0x42200000
  409a90:	42c9999a 	.word	0x42c9999a
  409a94:	42954d83 	.word	0x42954d83
  409a98:	3f4ccccd 	.word	0x3f4ccccd
  409a9c:	42700000 	.word	0x42700000
  409aa0:	41a00000 	.word	0x41a00000
  409aa4:	40066666 	.word	0x40066666
  409aa8:	42a40000 	.word	0x42a40000
  409aac:	4540729b 	.word	0x4540729b
  409ab0:	45076714 	.word	0x45076714
  409ab4:	42a00000 	.word	0x42a00000
  409ab8:	400ccccd 	.word	0x400ccccd
  409abc:	02d20000 	.word	0x02d20000
  409ac0:	410e0736 	.word	0x410e0736
  409ac4:	4029f509 	.word	0x4029f509
  409ac8:	424a999a 	.word	0x424a999a
  409acc:	43c80000 	.word	0x43c80000
  409ad0:	44228000 	.word	0x44228000
  409ad4:	20404fec 	.word	0x20404fec
  409ad8:	00413a71 	.word	0x00413a71
  409adc:	0041b904 	.word	0x0041b904
  409ae0:	0040c065 	.word	0x0040c065
  409ae4:	40f00000 	.word	0x40f00000
  409ae8:	40200000 	.word	0x40200000
  409aec:	3e19999a 	.word	0x3e19999a

00409af0 <menue_data_manager_lift_update>:
uint8_t menue_lift_data_newdata_flag = 0;
uint8_t menue_lift_data_startSelfLrn = 0;
#include <pop_ups.h>
 
void menue_data_manager_lift_update(void)
{
  409af0:	b508      	push	{r3, lr}
	memcpy(&menue_lift_data_applied, &menue_lift_data_setup, sizeof(menue_lift_data_t));	
  409af2:	22d4      	movs	r2, #212	; 0xd4
  409af4:	4902      	ldr	r1, [pc, #8]	; (409b00 <menue_data_manager_lift_update+0x10>)
  409af6:	4b03      	ldr	r3, [pc, #12]	; (409b04 <menue_data_manager_lift_update+0x14>)
  409af8:	4803      	ldr	r0, [pc, #12]	; (409b08 <menue_data_manager_lift_update+0x18>)
  409afa:	4798      	blx	r3
  409afc:	bd08      	pop	{r3, pc}
  409afe:	bf00      	nop
  409b00:	204051e0 	.word	0x204051e0
  409b04:	00419609 	.word	0x00419609
  409b08:	204052b4 	.word	0x204052b4

00409b0c <menue_data_manager_lift_load>:
}

uint32_t menue_data_manager_lift_load(uint32_t offset_add)
{
  409b0c:	b538      	push	{r3, r4, r5, lr}
  409b0e:	4604      	mov	r4, r0
	//menue_data_manager_lift_restore();
	//menue_data_manager_lift_update();
	//return;
	at24cxx_dynamic_sch_read_array(0, offset_add, sizeof(menue_lift_data_t), &menue_lift_data_setup);
  409b10:	4b04      	ldr	r3, [pc, #16]	; (409b24 <menue_data_manager_lift_load+0x18>)
  409b12:	22d4      	movs	r2, #212	; 0xd4
  409b14:	4d04      	ldr	r5, [pc, #16]	; (409b28 <menue_data_manager_lift_load+0x1c>)
  409b16:	4621      	mov	r1, r4
  409b18:	2000      	movs	r0, #0
  409b1a:	47a8      	blx	r5
	return offset_add + sizeof(menue_lift_data_t); 
}
  409b1c:	f104 00d4 	add.w	r0, r4, #212	; 0xd4
  409b20:	bd38      	pop	{r3, r4, r5, pc}
  409b22:	bf00      	nop
  409b24:	204051e0 	.word	0x204051e0
  409b28:	0040ac6d 	.word	0x0040ac6d

00409b2c <menue_data_manager_lift_Hinfo_load>:

uint32_t menue_data_manager_lift_Hinfo_load(uint32_t offset_add)
{
  409b2c:	b538      	push	{r3, r4, r5, lr}
  409b2e:	4604      	mov	r4, r0
	at24cxx_dynamic_sch_read_array(0, offset_add, sizeof(hoist_info_t), &hoist_info);
  409b30:	4b04      	ldr	r3, [pc, #16]	; (409b44 <menue_data_manager_lift_Hinfo_load+0x18>)
  409b32:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
  409b36:	4d04      	ldr	r5, [pc, #16]	; (409b48 <menue_data_manager_lift_Hinfo_load+0x1c>)
  409b38:	4621      	mov	r1, r4
  409b3a:	2000      	movs	r0, #0
  409b3c:	47a8      	blx	r5
	return offset_add + sizeof(hoist_info_t);
}
  409b3e:	f504 70d0 	add.w	r0, r4, #416	; 0x1a0
  409b42:	bd38      	pop	{r3, r4, r5, pc}
  409b44:	20400c80 	.word	0x20400c80
  409b48:	0040ac6d 	.word	0x0040ac6d

00409b4c <menue_data_manager_lift_save_nomsg>:
{
	at24cxx_dynamic_sch_write_array(0, offset_add, sizeof(menue_lift_data_t), &menue_lift_data_setup);
	return offset_add + sizeof(menue_lift_data_t);
}
uint32_t menue_data_manager_lift_save_nomsg(uint32_t offset_add)
{
  409b4c:	b538      	push	{r3, r4, r5, lr}
  409b4e:	4604      	mov	r4, r0
	at24cxx_dynamic_sch_write_array(0, offset_add, sizeof(menue_lift_data_t), &menue_lift_data_setup);
  409b50:	4b04      	ldr	r3, [pc, #16]	; (409b64 <menue_data_manager_lift_save_nomsg+0x18>)
  409b52:	22d4      	movs	r2, #212	; 0xd4
  409b54:	4d04      	ldr	r5, [pc, #16]	; (409b68 <menue_data_manager_lift_save_nomsg+0x1c>)
  409b56:	4621      	mov	r1, r4
  409b58:	2000      	movs	r0, #0
  409b5a:	47a8      	blx	r5
	return offset_add + sizeof(menue_lift_data_t);
}
  409b5c:	f104 00d4 	add.w	r0, r4, #212	; 0xd4
  409b60:	bd38      	pop	{r3, r4, r5, pc}
  409b62:	bf00      	nop
  409b64:	204051e0 	.word	0x204051e0
  409b68:	0040ac1d 	.word	0x0040ac1d

00409b6c <menue_data_manager_lift_save>:
  409b6c:	4b00      	ldr	r3, [pc, #0]	; (409b70 <menue_data_manager_lift_save+0x4>)
  409b6e:	4718      	bx	r3
  409b70:	00409b4d 	.word	0x00409b4d

00409b74 <menue_data_manager_lift_Hinfo_save>:

uint32_t menue_data_manager_lift_Hinfo_save(uint32_t offset_add)
{
  409b74:	b538      	push	{r3, r4, r5, lr}
  409b76:	4604      	mov	r4, r0
	at24cxx_dynamic_sch_write_array(0, offset_add, sizeof(hoist_info_t), &hoist_info);
  409b78:	4b04      	ldr	r3, [pc, #16]	; (409b8c <menue_data_manager_lift_Hinfo_save+0x18>)
  409b7a:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
  409b7e:	4d04      	ldr	r5, [pc, #16]	; (409b90 <menue_data_manager_lift_Hinfo_save+0x1c>)
  409b80:	4621      	mov	r1, r4
  409b82:	2000      	movs	r0, #0
  409b84:	47a8      	blx	r5
	return offset_add + sizeof(hoist_info_t);
}
  409b86:	f504 70d0 	add.w	r0, r4, #416	; 0x1a0
  409b8a:	bd38      	pop	{r3, r4, r5, pc}
  409b8c:	20400c80 	.word	0x20400c80
  409b90:	0040ac1d 	.word	0x0040ac1d

00409b94 <menue_data_manager_lift_getSize>:

uint32_t menue_data_manager_lift_getSize(uint32_t offset_add)
{
	return offset_add + sizeof(menue_lift_data_t);
}
  409b94:	30d4      	adds	r0, #212	; 0xd4
  409b96:	4770      	bx	lr

00409b98 <menue_data_manager_lift_restore>:

void menue_data_manager_lift_restore(void)
{
  409b98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	menue_lift_data_setup.m_cam_time = 8;
	menue_lift_data_setup.m_cam_trials = 2;
	menue_lift_data_setup.m_collection = 1;
	menue_lift_data_setup.m_cont_dis_technique = 0;
	menue_lift_data_setup.m_display_type = 0;
	menue_lift_data_setup.m_door_type = 3;
  409b9c:	2203      	movs	r2, #3
	menue_lift_data_setup.m_cam_time = 8;
  409b9e:	4c52      	ldr	r4, [pc, #328]	; (409ce8 <menue_data_manager_lift_restore+0x150>)
  409ba0:	2508      	movs	r5, #8
	menue_lift_data_setup.m_down_stop_delay = 4;
	menue_lift_data_setup.m_ers_stop_delay = 4;
	menue_lift_data_setup.m_ers_stop_time = 4;
	menue_lift_data_setup.m_ers_toff_delay = 20;
  409ba2:	2314      	movs	r3, #20
	menue_lift_data_setup.m_ers_ldir_delay = 1;
	menue_lift_data_setup.m_ers_ldir_test_time = 1;
	menue_lift_data_setup.m_fast_time = 40;
  409ba4:	2728      	movs	r7, #40	; 0x28
	menue_lift_data_setup.m_floor_count = 6;
  409ba6:	2606      	movs	r6, #6
	menue_lift_data_setup.m_light_time = 15;
	menue_lift_data_setup.m_parking_time = 0;
	menue_lift_data_setup.m_req_ext_dis = 0xFFFFFFFF;
	menue_lift_data_setup.m_req_int_dis = 0xFFFFFFFF;
	menue_lift_data_setup.m_slow_time = 15;
	menue_lift_data_setup.m_stop_wait_time = 7;
  409ba8:	2007      	movs	r0, #7
	menue_lift_data_setup.m_cam_time = 8;
  409baa:	7165      	strb	r5, [r4, #5]
	menue_lift_data_setup.m_door_type = 3;
  409bac:	7062      	strb	r2, [r4, #1]
	menue_lift_data_setup.m_unit_out = 0;
	menue_lift_data_setup.m_up_dir = 1;
	menue_lift_data_setup.m_up_stop_delay = 5;
  409bae:	2505      	movs	r5, #5
	menue_lift_data_setup.m_req_pin_config = 1;
/////////////////////////////hoist info/////////////////////////////////////////////
	menue_lift_data_setup.m_lift_speed = fixedpt_rconst(1);
	menue_lift_data_setup.m_stop_plate_length = 150;
  409bb0:	2296      	movs	r2, #150	; 0x96
	menue_lift_data_setup.m_ers_toff_delay = 20;
  409bb2:	82e3      	strh	r3, [r4, #22]
	menue_lift_data_setup.m_fast_time = 40;
  409bb4:	7127      	strb	r7, [r4, #4]
	menue_lift_data_setup.m_creep_distance = fixedpt_rconst(0.04);
  409bb6:	f240 531f 	movw	r3, #1311	; 0x51f
	menue_lift_data_setup.m_direct_stop = 0;
//////////////////////////////////////////////////////////////////////////
	menue_lift_data_setup.m_high_speed = fixedpt_rconst(100.0);
  409bba:	f44f 1748 	mov.w	r7, #3276800	; 0x320000
	menue_lift_data_setup.m_floor_count = 6;
  409bbe:	72a6      	strb	r6, [r4, #10]
	menue_lift_data_setup.m_stop_wait_time = 7;
  409bc0:	71a0      	strb	r0, [r4, #6]
	menue_lift_data_setup.m_medium_speed = fixedpt_rconst(60.0);
  409bc2:	f44f 16f0 	mov.w	r6, #1966080	; 0x1e0000
	menue_lift_data_setup.m_creep_speed = fixedpt_rconst(10.0);
  409bc6:	f44f 20a0 	mov.w	r0, #327680	; 0x50000
	menue_lift_data_setup.m_cont_dis_technique = 0;
  409bca:	2100      	movs	r1, #0
	menue_lift_data_setup.m_light_time = 15;
  409bcc:	f04f 0e0f 	mov.w	lr, #15
	menue_lift_data_setup.m_up_stop_delay = 5;
  409bd0:	8265      	strh	r5, [r4, #18]
	menue_lift_data_setup.m_stop_plate_length = 150;
  409bd2:	f884 2078 	strb.w	r2, [r4, #120]	; 0x78
	menue_lift_data_setup.m_cam_trials = 2;
  409bd6:	2502      	movs	r5, #2
	menue_lift_data_setup.m_collection = 1;
  409bd8:	2201      	movs	r2, #1
	menue_lift_data_setup.m_creep_distance = fixedpt_rconst(0.04);
  409bda:	67e3      	str	r3, [r4, #124]	; 0x7c
	menue_lift_data_setup.m_high_speed = fixedpt_rconst(100.0);
  409bdc:	62a7      	str	r7, [r4, #40]	; 0x28
	menue_lift_data_setup.m_down_stop_delay = 4;
  409bde:	2304      	movs	r3, #4
	menue_lift_data_setup.m_req_ext_dis = 0xFFFFFFFF;
  409be0:	f04f 37ff 	mov.w	r7, #4294967295
	menue_lift_data_setup.m_medium_speed = fixedpt_rconst(60.0);
  409be4:	62e6      	str	r6, [r4, #44]	; 0x2c
	menue_lift_data_setup.m_creep_speed = fixedpt_rconst(10.0);
  409be6:	6320      	str	r0, [r4, #48]	; 0x30
	menue_lift_data_setup.m_lift_speed = fixedpt_rconst(1);
  409be8:	f44f 4600 	mov.w	r6, #32768	; 0x8000
	menue_lift_data_setup.m_relevel_speed = fixedpt_rconst(20.0);
  409bec:	f44f 2020 	mov.w	r0, #655360	; 0xa0000
	menue_lift_data_setup.m_ins_speed = fixedpt_rconst(30.0);
  409bf0:	f44f 2870 	mov.w	r8, #983040	; 0xf0000
	menue_lift_data_setup.m_collection = 1;
  409bf4:	70a2      	strb	r2, [r4, #2]
	menue_lift_data_setup.m_pre_speed = fixedpt_rconst(2.0);
	menue_lift_data_setup.m_pre_spd_time = 1000;
  409bf6:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
	menue_lift_data_setup.m_ers_ldir_delay = 1;
  409bfa:	8362      	strh	r2, [r4, #26]
	menue_lift_data_setup.m_ers_ldir_test_time = 1;
  409bfc:	83a2      	strh	r2, [r4, #28]
	menue_lift_data_setup.m_up_dir = 1;
  409bfe:	72e2      	strb	r2, [r4, #11]
	menue_lift_data_setup.m_req_pin_config = 1;
  409c00:	7262      	strb	r2, [r4, #9]
	menue_lift_data_setup.m_cont_dis_technique = 0;
  409c02:	f884 10c2 	strb.w	r1, [r4, #194]	; 0xc2
	menue_lift_data_setup.m_display_type = 0;
  409c06:	7021      	strb	r1, [r4, #0]
	menue_lift_data_setup.m_parking_time = 0;
  409c08:	8221      	strh	r1, [r4, #16]
	menue_lift_data_setup.m_unit_out = 0;
  409c0a:	81e1      	strh	r1, [r4, #14]
	menue_lift_data_setup.m_direct_stop = 0;
  409c0c:	f884 1080 	strb.w	r1, [r4, #128]	; 0x80
	menue_lift_data_setup.m_down_stop_delay = 4;
  409c10:	82a3      	strh	r3, [r4, #20]
	menue_lift_data_setup.m_ers_stop_delay = 4;
  409c12:	8323      	strh	r3, [r4, #24]
	menue_lift_data_setup.m_ers_stop_time = 4;
  409c14:	83e3      	strh	r3, [r4, #30]
	menue_lift_data_setup.day = 1;
	menue_lift_data_setup.hour = 0;
	menue_lift_data_setup.minute = 0;
	menue_lift_data_setup.second = 0;
//////////////////////////////////////////////////////////////////////////
	for (i=0; i<13; i++)
  409c16:	460b      	mov	r3, r1
	menue_lift_data_setup.m_light_time = 15;
  409c18:	f884 e007 	strb.w	lr, [r4, #7]
	menue_lift_data_setup.m_slow_time = 15;
  409c1c:	f884 e003 	strb.w	lr, [r4, #3]
	menue_lift_data_setup.m_pre_speed = fixedpt_rconst(2.0);
  409c20:	f44f 3e80 	mov.w	lr, #65536	; 0x10000
	menue_lift_data_setup.m_req_ext_dis = 0xFFFFFFFF;
  409c24:	6267      	str	r7, [r4, #36]	; 0x24
	menue_lift_data_setup.m_req_int_dis = 0xFFFFFFFF;
  409c26:	6227      	str	r7, [r4, #32]
	menue_lift_data_setup.m_dec = fixedpt_rconst(2.5);	
  409c28:	f44f 37a0 	mov.w	r7, #81920	; 0x14000
	menue_lift_data_setup.m_lift_speed = fixedpt_rconst(1);
  409c2c:	6766      	str	r6, [r4, #116]	; 0x74
	menue_lift_data_setup.m_cam_trials = 2;
  409c2e:	7225      	strb	r5, [r4, #8]
	menue_lift_data_setup.m_relevel_speed = fixedpt_rconst(20.0);
  409c30:	6360      	str	r0, [r4, #52]	; 0x34
	menue_lift_data_setup.m_ins_speed = fixedpt_rconst(30.0);
  409c32:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
	menue_lift_data_setup.m_ins_dec = fixedpt_rconst(0.8);
  409c36:	f246 6866 	movw	r8, #26214	; 0x6666
	menue_lift_data_setup.m_ins_corner = fixedpt_rconst(20.0);
  409c3a:	6560      	str	r0, [r4, #84]	; 0x54
	menue_lift_data_setup.m_corner1 = fixedpt_rconst(20.0);
  409c3c:	65a0      	str	r0, [r4, #88]	; 0x58
	menue_lift_data_setup.m_corner2 = fixedpt_rconst(20.0);
  409c3e:	65e0      	str	r0, [r4, #92]	; 0x5c
	menue_lift_data_setup.m_corner3 = fixedpt_rconst(20.0);
  409c40:	6620      	str	r0, [r4, #96]	; 0x60
	menue_lift_data_setup.year = 2019;
  409c42:	f240 70e3 	movw	r0, #2019	; 0x7e3
	menue_lift_data_setup.m_ins_stopping_mode = 1;
  409c46:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
	menue_lift_data_setup.m_ARDAccDec = fixedpt_rconst(1.0);
  409c4a:	66e6      	str	r6, [r4, #108]	; 0x6c
	menue_lift_data_setup.m_ARDspeed = fixedpt_rconst(3.0);
  409c4c:	f44f 36c0 	mov.w	r6, #98304	; 0x18000
	menue_lift_data_setup.m_ARDJerk = fixedpt_rconst(0.0);
  409c50:	6721      	str	r1, [r4, #112]	; 0x70
	menue_lift_data_setup.set_password = 0;
  409c52:	f8a4 10d0 	strh.w	r1, [r4, #208]	; 0xd0
	menue_lift_data_setup.month = 1;
  409c56:	f884 20c4 	strb.w	r2, [r4, #196]	; 0xc4
	menue_lift_data_setup.day = 1;
  409c5a:	f884 20c3 	strb.w	r2, [r4, #195]	; 0xc3
  409c5e:	f104 0280 	add.w	r2, r4, #128	; 0x80
	menue_lift_data_setup.hour = 0;
  409c62:	f884 10c5 	strb.w	r1, [r4, #197]	; 0xc5
	menue_lift_data_setup.minute = 0;
  409c66:	f884 10c6 	strb.w	r1, [r4, #198]	; 0xc6
	menue_lift_data_setup.second = 0;
  409c6a:	f884 10c7 	strb.w	r1, [r4, #199]	; 0xc7
	menue_lift_data_setup.m_acc = fixedpt_rconst(1.8);
  409c6e:	f24e 6166 	movw	r1, #58982	; 0xe666
	menue_lift_data_setup.services = 2;
  409c72:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
	menue_lift_data_setup.m_pre_speed = fixedpt_rconst(2.0);
  409c76:	f8c4 e03c 	str.w	lr, [r4, #60]	; 0x3c
	menue_lift_data_setup.m_pre_spd_time = 1000;
  409c7a:	f8a4 c040 	strh.w	ip, [r4, #64]	; 0x40
	menue_lift_data_setup.m_dec = fixedpt_rconst(2.5);	
  409c7e:	64a7      	str	r7, [r4, #72]	; 0x48
	menue_lift_data_setup.m_ins_dec = fixedpt_rconst(0.8);
  409c80:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
	menue_lift_data_setup.m_ARDspeed = fixedpt_rconst(3.0);
  409c84:	66a6      	str	r6, [r4, #104]	; 0x68
	menue_lift_data_setup.year = 2019;
  409c86:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
	menue_lift_data_setup.m_acc = fixedpt_rconst(1.8);
  409c8a:	6461      	str	r1, [r4, #68]	; 0x44
	menue_lift_data_setup.m_ins_acc = fixedpt_rconst(1.8);
  409c8c:	64e1      	str	r1, [r4, #76]	; 0x4c
	{
		//hoist addressing
		menue_lift_data_setup.m_hoist[i] = i;
  409c8e:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (i=0; i<13; i++)
  409c92:	3301      	adds	r3, #1
  409c94:	2b0d      	cmp	r3, #13
  409c96:	d1fa      	bne.n	409c8e <menue_data_manager_lift_restore+0xf6>
  409c98:	4a14      	ldr	r2, [pc, #80]	; (409cec <menue_data_manager_lift_restore+0x154>)
	}
	for (i=13; i<25; i++)
	{
		//hoist addressing
		menue_lift_data_setup.m_hoist[i] = 30;
  409c9a:	211e      	movs	r1, #30
  409c9c:	f102 030c 	add.w	r3, r2, #12
  409ca0:	f802 1f01 	strb.w	r1, [r2, #1]!
	for (i=13; i<25; i++)
  409ca4:	429a      	cmp	r2, r3
  409ca6:	d1fb      	bne.n	409ca0 <menue_data_manager_lift_restore+0x108>
  409ca8:	2300      	movs	r3, #0
	}
	
	for (i=0; i<24; i++)
	{
		//reset floor display
		menue_lift_data_setup.floor_display[i] = i;
  409caa:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (i=0; i<24; i++)
  409cae:	3301      	adds	r3, #1
  409cb0:	2b18      	cmp	r3, #24
  409cb2:	d1fa      	bne.n	409caa <menue_data_manager_lift_restore+0x112>
  409cb4:	4a0e      	ldr	r2, [pc, #56]	; (409cf0 <menue_data_manager_lift_restore+0x158>)
  409cb6:	2300      	movs	r3, #0
	}
	for (i=0; i<8; i++)
	{
		menue_lift_data_setup.m_outputs[i] = i;
  409cb8:	f802 3b01 	strb.w	r3, [r2], #1
	for (i=0; i<8; i++)
  409cbc:	3301      	adds	r3, #1
  409cbe:	2b08      	cmp	r3, #8
  409cc0:	d1fa      	bne.n	409cb8 <menue_data_manager_lift_restore+0x120>
	}
	menue_lift_data_setup.m_outputs[0] = 7; //brake
  409cc2:	2307      	movs	r3, #7
	menue_lift_data_setup.m_outputs[2] = 0;//light
  409cc4:	2700      	movs	r7, #0
	menue_lift_data_setup.m_outputs[7] = 2;//gong
  409cc6:	2602      	movs	r6, #2
	
	menue_lift_data_newdata_flag = 1;
  409cc8:	2501      	movs	r5, #1
  409cca:	4a0a      	ldr	r2, [pc, #40]	; (409cf4 <menue_data_manager_lift_restore+0x15c>)
	pop_ups_add("Lift set restored!", 1000);
  409ccc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
	menue_lift_data_setup.m_outputs[0] = 7; //brake
  409cd0:	f884 30b2 	strb.w	r3, [r4, #178]	; 0xb2
	menue_lift_data_setup.m_outputs[2] = 0;//light
  409cd4:	f884 70b4 	strb.w	r7, [r4, #180]	; 0xb4
	menue_lift_data_setup.m_outputs[7] = 2;//gong
  409cd8:	f884 60b9 	strb.w	r6, [r4, #185]	; 0xb9
	menue_lift_data_newdata_flag = 1;
  409cdc:	7015      	strb	r5, [r2, #0]
	pop_ups_add("Lift set restored!", 1000);
  409cde:	4806      	ldr	r0, [pc, #24]	; (409cf8 <menue_data_manager_lift_restore+0x160>)
  409ce0:	4b06      	ldr	r3, [pc, #24]	; (409cfc <menue_data_manager_lift_restore+0x164>)
  409ce2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	pop_ups_add("Lift set restored!", 1000);
  409ce6:	4718      	bx	r3
  409ce8:	204051e0 	.word	0x204051e0
  409cec:	2040526d 	.word	0x2040526d
  409cf0:	20405292 	.word	0x20405292
  409cf4:	204008ea 	.word	0x204008ea
  409cf8:	0041b918 	.word	0x0041b918
  409cfc:	0040c065 	.word	0x0040c065

00409d00 <menue_data_manager_update>:
#include <pop_ups.h>

uint8_t counter_info[9];

void menue_data_manager_update(void)
{
  409d00:	b510      	push	{r4, lr}
	menue_data_manager_lift_update();
  409d02:	4b03      	ldr	r3, [pc, #12]	; (409d10 <menue_data_manager_update+0x10>)
  409d04:	4798      	blx	r3
	menue_data_manager_drive_update();
  409d06:	4b03      	ldr	r3, [pc, #12]	; (409d14 <menue_data_manager_update+0x14>)
}
  409d08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	menue_data_manager_drive_update();
  409d0c:	4718      	bx	r3
  409d0e:	bf00      	nop
  409d10:	00409af1 	.word	0x00409af1
  409d14:	00409891 	.word	0x00409891

00409d18 <menue_data_manager_get_CounterData>:
}

uint8_t* menue_data_manager_get_CounterData (void)
{
	return &counter_info[0];
}
  409d18:	4800      	ldr	r0, [pc, #0]	; (409d1c <menue_data_manager_get_CounterData+0x4>)
  409d1a:	4770      	bx	lr
  409d1c:	20405388 	.word	0x20405388

00409d20 <menue_data_manager_load>:
void menue_data_manager_load (void)
{
  409d20:	b510      	push	{r4, lr}
	menue_data_manager_lift_Hinfo_load(EEPROM_MEM_HINFO_SAVE_OFFSET);
  409d22:	4b09      	ldr	r3, [pc, #36]	; (409d48 <menue_data_manager_load+0x28>)
  409d24:	2009      	movs	r0, #9
  409d26:	4798      	blx	r3
	uint32_t men_data_add = menue_data_manager_lift_load(EEPROM_MEM_SAVE_OFFSET);
  409d28:	4b08      	ldr	r3, [pc, #32]	; (409d4c <menue_data_manager_load+0x2c>)
  409d2a:	f240 10a9 	movw	r0, #425	; 0x1a9
	at24cxx_dynamic_sch_read_array(0, 0, 9, &counter_info[0]);
  409d2e:	4c08      	ldr	r4, [pc, #32]	; (409d50 <menue_data_manager_load+0x30>)
	uint32_t men_data_add = menue_data_manager_lift_load(EEPROM_MEM_SAVE_OFFSET);
  409d30:	4798      	blx	r3
	men_data_add = men_data_add = menue_data_manager_drive_load(men_data_add);
  409d32:	4b08      	ldr	r3, [pc, #32]	; (409d54 <menue_data_manager_load+0x34>)
  409d34:	4798      	blx	r3
	at24cxx_dynamic_sch_read_array(0, 0, 9, &counter_info[0]);
  409d36:	2100      	movs	r1, #0
  409d38:	46a4      	mov	ip, r4
  409d3a:	4b07      	ldr	r3, [pc, #28]	; (409d58 <menue_data_manager_load+0x38>)
  409d3c:	2209      	movs	r2, #9
  409d3e:	4608      	mov	r0, r1
	menue_data_manager_CounterDataLoad();
	//men_data_add++;
}
  409d40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	at24cxx_dynamic_sch_read_array(0, 0, 9, &counter_info[0]);
  409d44:	4760      	bx	ip
  409d46:	bf00      	nop
  409d48:	00409b2d 	.word	0x00409b2d
  409d4c:	00409b0d 	.word	0x00409b0d
  409d50:	0040ac6d 	.word	0x0040ac6d
  409d54:	004098ad 	.word	0x004098ad
  409d58:	20405388 	.word	0x20405388

00409d5c <menue_data_manager_save>:

void menue_data_manager_save (void)
{
  409d5c:	b510      	push	{r4, lr}
	menue_data_manager_lift_Hinfo_save(EEPROM_MEM_HINFO_SAVE_OFFSET);
  409d5e:	4b08      	ldr	r3, [pc, #32]	; (409d80 <menue_data_manager_save+0x24>)
  409d60:	2009      	movs	r0, #9
  409d62:	4798      	blx	r3
	uint32_t men_data_add = menue_data_manager_lift_save(EEPROM_MEM_SAVE_OFFSET);
  409d64:	4b07      	ldr	r3, [pc, #28]	; (409d84 <menue_data_manager_save+0x28>)
  409d66:	f240 10a9 	movw	r0, #425	; 0x1a9
  409d6a:	4798      	blx	r3
	men_data_add = menue_data_manager_drive_save(men_data_add);
  409d6c:	4b06      	ldr	r3, [pc, #24]	; (409d88 <menue_data_manager_save+0x2c>)
  409d6e:	4798      	blx	r3
	pop_ups_add("Data saved", 1000);
  409d70:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409d74:	4805      	ldr	r0, [pc, #20]	; (409d8c <menue_data_manager_save+0x30>)
  409d76:	4b06      	ldr	r3, [pc, #24]	; (409d90 <menue_data_manager_save+0x34>)
}
  409d78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pop_ups_add("Data saved", 1000);
  409d7c:	4718      	bx	r3
  409d7e:	bf00      	nop
  409d80:	00409b75 	.word	0x00409b75
  409d84:	00409b6d 	.word	0x00409b6d
  409d88:	004098cd 	.word	0x004098cd
  409d8c:	0041b958 	.word	0x0041b958
  409d90:	0040c065 	.word	0x0040c065

00409d94 <menue_data_manager_hoist_save>:

void menue_data_manager_hoist_save(void)
{
  409d94:	b510      	push	{r4, lr}
	menue_data_manager_lift_Hinfo_save(EEPROM_MEM_HINFO_SAVE_OFFSET);
  409d96:	4b05      	ldr	r3, [pc, #20]	; (409dac <menue_data_manager_hoist_save+0x18>)
  409d98:	2009      	movs	r0, #9
  409d9a:	4798      	blx	r3
	pop_ups_add("Hoist data saved!", 1000);
  409d9c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409da0:	4803      	ldr	r0, [pc, #12]	; (409db0 <menue_data_manager_hoist_save+0x1c>)
  409da2:	4b04      	ldr	r3, [pc, #16]	; (409db4 <menue_data_manager_hoist_save+0x20>)
}
  409da4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pop_ups_add("Hoist data saved!", 1000);
  409da8:	4718      	bx	r3
  409daa:	bf00      	nop
  409dac:	00409b75 	.word	0x00409b75
  409db0:	0041b92c 	.word	0x0041b92c
  409db4:	0040c065 	.word	0x0040c065

00409db8 <menue_data_manager_saveLift>:

void menue_data_manager_saveLift (void)
{
  409db8:	b510      	push	{r4, lr}
	uint32_t men_data_add = menue_data_manager_lift_save(EEPROM_MEM_SAVE_OFFSET);
  409dba:	4b05      	ldr	r3, [pc, #20]	; (409dd0 <menue_data_manager_saveLift+0x18>)
  409dbc:	f240 10a9 	movw	r0, #425	; 0x1a9
  409dc0:	4798      	blx	r3
	pop_ups_add("Lift data saved!", 1000);
  409dc2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409dc6:	4803      	ldr	r0, [pc, #12]	; (409dd4 <menue_data_manager_saveLift+0x1c>)
  409dc8:	4b03      	ldr	r3, [pc, #12]	; (409dd8 <menue_data_manager_saveLift+0x20>)
}
  409dca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pop_ups_add("Lift data saved!", 1000);
  409dce:	4718      	bx	r3
  409dd0:	00409b6d 	.word	0x00409b6d
  409dd4:	0041b978 	.word	0x0041b978
  409dd8:	0040c065 	.word	0x0040c065

00409ddc <menue_data_manager_saveCounterData>:

void menue_data_manager_saveCounterData (uint8_t Selector_data, int32_t encoder_value, uint32_t s_counter)
{
  409ddc:	b430      	push	{r4, r5}
	counter_info[0] = Selector_data;
  409dde:	4c07      	ldr	r4, [pc, #28]	; (409dfc <menue_data_manager_saveCounterData+0x20>)
	int32_t *enc_pointer = (int32_t)&counter_info[1];
	uint32_t *p_s_counter = (uint32_t)&counter_info[5];
	*enc_pointer = encoder_value;
	*p_s_counter = s_counter;
	at24cxx_dynamic_sch_write_array(0, 0, 9, &counter_info[0]);
  409de0:	4d07      	ldr	r5, [pc, #28]	; (409e00 <menue_data_manager_saveCounterData+0x24>)
	*enc_pointer = encoder_value;
  409de2:	f8c4 1001 	str.w	r1, [r4, #1]
	at24cxx_dynamic_sch_write_array(0, 0, 9, &counter_info[0]);
  409de6:	2100      	movs	r1, #0
	counter_info[0] = Selector_data;
  409de8:	7020      	strb	r0, [r4, #0]
	at24cxx_dynamic_sch_write_array(0, 0, 9, &counter_info[0]);
  409dea:	4623      	mov	r3, r4
	*p_s_counter = s_counter;
  409dec:	f8c4 2005 	str.w	r2, [r4, #5]
	at24cxx_dynamic_sch_write_array(0, 0, 9, &counter_info[0]);
  409df0:	46ac      	mov	ip, r5
  409df2:	4608      	mov	r0, r1
  409df4:	2209      	movs	r2, #9
}
  409df6:	bc30      	pop	{r4, r5}
	at24cxx_dynamic_sch_write_array(0, 0, 9, &counter_info[0]);
  409df8:	4760      	bx	ip
  409dfa:	bf00      	nop
  409dfc:	20405388 	.word	0x20405388
  409e00:	0040ac1d 	.word	0x0040ac1d

00409e04 <menue_data_manager_saveDrive>:

void menue_data_manager_saveDrive (void)
{
  409e04:	b510      	push	{r4, lr}
	uint32_t men_data_add = menue_data_manager_lift_getSize(EEPROM_MEM_SAVE_OFFSET);
  409e06:	4b06      	ldr	r3, [pc, #24]	; (409e20 <menue_data_manager_saveDrive+0x1c>)
  409e08:	f240 10a9 	movw	r0, #425	; 0x1a9
  409e0c:	4798      	blx	r3
	men_data_add = menue_data_manager_drive_save(men_data_add);
  409e0e:	4b05      	ldr	r3, [pc, #20]	; (409e24 <menue_data_manager_saveDrive+0x20>)
  409e10:	4798      	blx	r3
	pop_ups_add("Drive data saved!", 1000);
  409e12:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409e16:	4804      	ldr	r0, [pc, #16]	; (409e28 <menue_data_manager_saveDrive+0x24>)
  409e18:	4b04      	ldr	r3, [pc, #16]	; (409e2c <menue_data_manager_saveDrive+0x28>)
}
  409e1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pop_ups_add("Drive data saved!", 1000);
  409e1e:	4718      	bx	r3
  409e20:	00409b95 	.word	0x00409b95
  409e24:	004098cd 	.word	0x004098cd
  409e28:	0041b964 	.word	0x0041b964
  409e2c:	0040c065 	.word	0x0040c065

00409e30 <menue_data_manager_restore>:

void menue_data_manager_restore (void)
{
  409e30:	b510      	push	{r4, lr}
	menue_data_manager_lift_restore();
  409e32:	4b06      	ldr	r3, [pc, #24]	; (409e4c <menue_data_manager_restore+0x1c>)
  409e34:	4798      	blx	r3
	menue_data_manager_drive_restore();
  409e36:	4b06      	ldr	r3, [pc, #24]	; (409e50 <menue_data_manager_restore+0x20>)
  409e38:	4798      	blx	r3
	Hoist_init();
  409e3a:	4b06      	ldr	r3, [pc, #24]	; (409e54 <menue_data_manager_restore+0x24>)
  409e3c:	4798      	blx	r3
	pop_ups_add("Factory set restored!", 1000);
  409e3e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409e42:	4805      	ldr	r0, [pc, #20]	; (409e58 <menue_data_manager_restore+0x28>)
  409e44:	4b05      	ldr	r3, [pc, #20]	; (409e5c <menue_data_manager_restore+0x2c>)
  409e46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pop_ups_add("Factory set restored!", 1000);
  409e4a:	4718      	bx	r3
  409e4c:	00409b99 	.word	0x00409b99
  409e50:	004098ed 	.word	0x004098ed
  409e54:	004045e1 	.word	0x004045e1
  409e58:	0041b940 	.word	0x0041b940
  409e5c:	0040c065 	.word	0x0040c065

00409e60 <mb_port_xdmac_configure_write>:

/** XDMAC channel configuration. */
xdmac_channel_config_t xdmac_tx_cfg, xdmac_rx_cfg;

void mb_port_xdmac_configure_write(Usart *p_usart, char *line, uint32_t lenght, uint32_t xdmac_channel, uint32_t xdmac_id)
{
  409e60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  409e64:	9c06      	ldr	r4, [sp, #24]
  409e66:	461d      	mov	r5, r3
	xdmac->XDMAC_CHID[channel_num].XDMAC_CNDC = config;
  409e68:	4e11      	ldr	r6, [pc, #68]	; (409eb0 <mb_port_xdmac_configure_write+0x50>)

	/* Initialize channel config for transmitter */
	xdmac_tx_cfg.mbr_ubc = lenght;

	xdmac_tx_cfg.mbr_sa = (uint32_t)line;
	xdmac_tx_cfg.mbr_da = (uint32_t)&p_usart->US_THR;
  409e6a:	301c      	adds	r0, #28
	XDMAC_CC_DWIDTH_BYTE|
	XDMAC_CC_SIF_AHB_IF0 |
	XDMAC_CC_DIF_AHB_IF1 |
	XDMAC_CC_SAM_INCREMENTED_AM |
	XDMAC_CC_DAM_FIXED_AM |
	XDMAC_CC_PERID(xdmac_id); // TODO dynamic id generation based on puart
  409e6c:	0623      	lsls	r3, r4, #24
	XDMAC_CC_DAM_FIXED_AM |
  409e6e:	4f11      	ldr	r7, [pc, #68]	; (409eb4 <mb_port_xdmac_configure_write+0x54>)
	xdmac_tx_cfg.mbr_ubc = lenght;
  409e70:	4c11      	ldr	r4, [pc, #68]	; (409eb8 <mb_port_xdmac_configure_write+0x58>)
  409e72:	eb06 1885 	add.w	r8, r6, r5, lsl #6
	XDMAC_CC_PERID(xdmac_id); // TODO dynamic id generation based on puart
  409e76:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
	xdmac_tx_cfg.mbr_da = (uint32_t)&p_usart->US_THR;
  409e7a:	60a0      	str	r0, [r4, #8]
	xdmac_tx_cfg.mbr_ds =  0;
	xdmac_tx_cfg.mbr_sus = 0;
	xdmac_tx_cfg.mbr_dus = 0;

	xdmac_channel_set_descriptor_control(XDMAC, xdmac_channel, 0);
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_tx_cfg);
  409e7c:	4630      	mov	r0, r6
	XDMAC_CC_DAM_FIXED_AM |
  409e7e:	431f      	orrs	r7, r3
	xdmac_tx_cfg.mbr_bc =  0;
  409e80:	2300      	movs	r3, #0
	xdmac_tx_cfg.mbr_ubc = lenght;
  409e82:	6022      	str	r2, [r4, #0]
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_tx_cfg);
  409e84:	4622      	mov	r2, r4
	xdmac_tx_cfg.mbr_sa = (uint32_t)line;
  409e86:	6061      	str	r1, [r4, #4]
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_tx_cfg);
  409e88:	4629      	mov	r1, r5
	xdmac_tx_cfg.mbr_bc =  0;
  409e8a:	6123      	str	r3, [r4, #16]
	xdmac_tx_cfg.mbr_ds =  0;
  409e8c:	6163      	str	r3, [r4, #20]
	xdmac_tx_cfg.mbr_sus = 0;
  409e8e:	61a3      	str	r3, [r4, #24]
	xdmac_tx_cfg.mbr_dus = 0;
  409e90:	61e3      	str	r3, [r4, #28]
	xdmac_tx_cfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |
  409e92:	60e7      	str	r7, [r4, #12]
  409e94:	f8c8 306c 	str.w	r3, [r8, #108]	; 0x6c
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_tx_cfg);
  409e98:	4b08      	ldr	r3, [pc, #32]	; (409ebc <mb_port_xdmac_configure_write+0x5c>)
  409e9a:	4798      	blx	r3
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  409e9c:	2301      	movs	r3, #1
	xdmac->XDMAC_GIE = ( XDMAC_GIE_IE0 << channel_num) ;
  409e9e:	fa03 f505 	lsl.w	r5, r3, r5
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  409ea2:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
	xdmac->XDMAC_GIE = ( XDMAC_GIE_IE0 << channel_num) ;
  409ea6:	60f5      	str	r5, [r6, #12]

	
	xdmac_channel_enable_interrupt(XDMAC, xdmac_channel, xdmaint);
	xdmac_enable_interrupt(XDMAC, xdmac_channel);
	//xdmac_channel_enable(XDMAC, xdmac_channel);
	XDMAC->XDMAC_GE = (XDMAC_GE_EN0 << xdmac_channel);
  409ea8:	61f5      	str	r5, [r6, #28]
  409eaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409eae:	bf00      	nop
  409eb0:	40078000 	.word	0x40078000
  409eb4:	00014011 	.word	0x00014011
  409eb8:	204053b4 	.word	0x204053b4
  409ebc:	004006d1 	.word	0x004006d1

00409ec0 <mb_port_xdmac_configure_read>:
	//NVIC_EnableIRQ(XDMAC_IRQn);

}

void mb_port_xdmac_configure_read(Usart *p_usart, char *line, uint32_t lenght, uint32_t xdmac_channel, uint32_t xdmac_id)
{
  409ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  409ec2:	9c06      	ldr	r4, [sp, #24]
  409ec4:	461d      	mov	r5, r3

	/* Initialize channel config for receiver */
	xdmac_rx_cfg.mbr_ubc = lenght;

	xdmac_rx_cfg.mbr_da = (uint32_t)line;
	dummy_read = p_usart->US_RHR; //read any remaining bytes in RHR
  409ec6:	4686      	mov	lr, r0
	XDMAC_CC_CSIZE_CHK_1 |
	XDMAC_CC_DWIDTH_BYTE|
	XDMAC_CC_SIF_AHB_IF1 |
	XDMAC_CC_DIF_AHB_IF0 |
	XDMAC_CC_SAM_FIXED_AM |
	XDMAC_CC_DAM_INCREMENTED_AM |
  409ec8:	4812      	ldr	r0, [pc, #72]	; (409f14 <mb_port_xdmac_configure_read+0x54>)
	XDMAC_CC_PERID(xdmac_id); // TODO dynamic id generation based on puart
  409eca:	0623      	lsls	r3, r4, #24
	xdmac_rx_cfg.mbr_bc =   0;
	xdmac_tx_cfg.mbr_ds =   0;
	xdmac_rx_cfg.mbr_sus =  0;
	xdmac_rx_cfg.mbr_dus =  0;

	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_rx_cfg);
  409ecc:	4f12      	ldr	r7, [pc, #72]	; (409f18 <mb_port_xdmac_configure_read+0x58>)
	xdmac_rx_cfg.mbr_ubc = lenght;
  409ece:	4c13      	ldr	r4, [pc, #76]	; (409f1c <mb_port_xdmac_configure_read+0x5c>)
	XDMAC_CC_PERID(xdmac_id); // TODO dynamic id generation based on puart
  409ed0:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
	dummy_read = p_usart->US_RHR; //read any remaining bytes in RHR
  409ed4:	f85e 6f18 	ldr.w	r6, [lr, #24]!
	xdmac_tx_cfg.mbr_ds =   0;
  409ed8:	f8df c048 	ldr.w	ip, [pc, #72]	; 409f24 <mb_port_xdmac_configure_read+0x64>
	xdmac_rx_cfg.mbr_bc =   0;
  409edc:	2600      	movs	r6, #0
	XDMAC_CC_DAM_INCREMENTED_AM |
  409ede:	4318      	orrs	r0, r3
	xdmac_rx_cfg.mbr_ubc = lenght;
  409ee0:	6022      	str	r2, [r4, #0]
	xdmac_rx_cfg.mbr_da = (uint32_t)line;
  409ee2:	60a1      	str	r1, [r4, #8]
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_rx_cfg);
  409ee4:	4622      	mov	r2, r4
  409ee6:	4629      	mov	r1, r5
	xdmac_rx_cfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |
  409ee8:	60e0      	str	r0, [r4, #12]
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_rx_cfg);
  409eea:	4b0d      	ldr	r3, [pc, #52]	; (409f20 <mb_port_xdmac_configure_read+0x60>)
  409eec:	4638      	mov	r0, r7
	xdmac_rx_cfg.mbr_sa = (uint32_t)&p_usart->US_RHR;
  409eee:	f8c4 e004 	str.w	lr, [r4, #4]
	xdmac_rx_cfg.mbr_bc =   0;
  409ef2:	6126      	str	r6, [r4, #16]
	xdmac_rx_cfg.mbr_sus =  0;
  409ef4:	61a6      	str	r6, [r4, #24]
	xdmac_rx_cfg.mbr_dus =  0;
  409ef6:	61e6      	str	r6, [r4, #28]
	xdmac_tx_cfg.mbr_ds =   0;
  409ef8:	f8cc 6014 	str.w	r6, [ip, #20]
	xdmac_configure_transfer(XDMAC, xdmac_channel, &xdmac_rx_cfg);
  409efc:	4798      	blx	r3
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  409efe:	2201      	movs	r2, #1
	xdmac->XDMAC_CHID[channel_num].XDMAC_CNDC = config;
  409f00:	eb07 1385 	add.w	r3, r7, r5, lsl #6

	xdmac_channel_set_descriptor_control(XDMAC, xdmac_channel, 0);

	xdmac_channel_enable_interrupt(XDMAC, xdmac_channel, xdmaint);
	//xdmac_channel_enable(XDMAC, xdmac_channel);
	XDMAC->XDMAC_GE = (XDMAC_GE_EN0 << xdmac_channel);
  409f04:	fa02 f505 	lsl.w	r5, r2, r5
  409f08:	66de      	str	r6, [r3, #108]	; 0x6c
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  409f0a:	651a      	str	r2, [r3, #80]	; 0x50
  409f0c:	61fd      	str	r5, [r7, #28]
	xdmac->XDMAC_GIE = ( XDMAC_GIE_IE0 << channel_num) ;
  409f0e:	60fd      	str	r5, [r7, #12]
  409f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  409f12:	bf00      	nop
  409f14:	00042001 	.word	0x00042001
  409f18:	40078000 	.word	0x40078000
  409f1c:	20405394 	.word	0x20405394
  409f20:	004006d1 	.word	0x004006d1
  409f24:	204053b4 	.word	0x204053b4

00409f28 <mb_port_init>:
	//NVIC_SetPriority( XDMAC_IRQn ,1);
	//NVIC_EnableIRQ(XDMAC_IRQn);

}
void mb_port_init(uint32_t usart_id, const sam_usart_opt_t *c_opt_usart, Usart *p_usart)
{
  409f28:	b530      	push	{r4, r5, lr}
  409f2a:	4614      	mov	r4, r2
  409f2c:	460d      	mov	r5, r1
  409f2e:	b083      	sub	sp, #12
	pmc_enable_periph_clk(usart_id);
  409f30:	4b23      	ldr	r3, [pc, #140]	; (409fc0 <mb_port_init+0x98>)
  409f32:	4798      	blx	r3
	usart_init_rs485(p_usart, c_opt_usart, 150000000);
  409f34:	4629      	mov	r1, r5
  409f36:	4a23      	ldr	r2, [pc, #140]	; (409fc4 <mb_port_init+0x9c>)
  409f38:	4620      	mov	r0, r4
  409f3a:	4b23      	ldr	r3, [pc, #140]	; (409fc8 <mb_port_init+0xa0>)
  409f3c:	4798      	blx	r3

	usart_enable_tx(p_usart);
  409f3e:	4620      	mov	r0, r4
  409f40:	4b22      	ldr	r3, [pc, #136]	; (409fcc <mb_port_init+0xa4>)
  409f42:	4798      	blx	r3
	usart_enable_rx(p_usart);
  409f44:	4620      	mov	r0, r4
  409f46:	4b22      	ldr	r3, [pc, #136]	; (409fd0 <mb_port_init+0xa8>)
  409f48:	4798      	blx	r3
	usart_lin_disable_pdc_mode(p_usart);
  409f4a:	4620      	mov	r0, r4
  409f4c:	4b21      	ldr	r3, [pc, #132]	; (409fd4 <mb_port_init+0xac>)
  409f4e:	4798      	blx	r3
	usart_set_rx_timeout(p_usart, MB_FRAME_TO);
  409f50:	4b21      	ldr	r3, [pc, #132]	; (409fd8 <mb_port_init+0xb0>)
  409f52:	4620      	mov	r0, r4
  409f54:	2124      	movs	r1, #36	; 0x24
  409f56:	4798      	blx	r3
	if(p_usart == USART0) //SAME70 PIO multiplexing
  409f58:	4b20      	ldr	r3, [pc, #128]	; (409fdc <mb_port_init+0xb4>)
  409f5a:	429c      	cmp	r4, r3
  409f5c:	d021      	beq.n	409fa2 <mb_port_init+0x7a>
		pio_set_peripheral(PIOB, PIO_PERIPH_C, PIO_PB1);
#ifdef _SERIAL_DRIVE
		pio_set_peripheral(PIOB, PIO_PERIPH_C, PIO_PB3);
#endif
	}
	else if(p_usart == USART1) //SAME70 PIO multiplexing
  409f5e:	4b20      	ldr	r3, [pc, #128]	; (409fe0 <mb_port_init+0xb8>)
  409f60:	429c      	cmp	r4, r3
  409f62:	d001      	beq.n	409f68 <mb_port_init+0x40>
		
		pio_set_output(PIOB, PIO_PB4, HIGH, DISABLE, ENABLE);
		pio_set_peripheral(PIOB, PIO_PERIPH_D, PIO_PB4);
	}
	
}
  409f64:	b003      	add	sp, #12
  409f66:	bd30      	pop	{r4, r5, pc}
		pio_set_peripheral(PIOA, PIO_PERIPH_A, PIO_PA24);
  409f68:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  409f6c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  409f70:	481c      	ldr	r0, [pc, #112]	; (409fe4 <mb_port_init+0xbc>)
  409f72:	4c1d      	ldr	r4, [pc, #116]	; (409fe8 <mb_port_init+0xc0>)
  409f74:	47a0      	blx	r4
		pio_set_peripheral(PIOA, PIO_PERIPH_A, PIO_PA21);
  409f76:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  409f7a:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  409f7e:	4819      	ldr	r0, [pc, #100]	; (409fe4 <mb_port_init+0xbc>)
  409f80:	47a0      	blx	r4
		pio_set_output(PIOB, PIO_PB4, HIGH, DISABLE, ENABLE);
  409f82:	2201      	movs	r2, #1
  409f84:	2110      	movs	r1, #16
  409f86:	2300      	movs	r3, #0
  409f88:	9200      	str	r2, [sp, #0]
  409f8a:	4818      	ldr	r0, [pc, #96]	; (409fec <mb_port_init+0xc4>)
  409f8c:	4d18      	ldr	r5, [pc, #96]	; (409ff0 <mb_port_init+0xc8>)
  409f8e:	47a8      	blx	r5
		pio_set_peripheral(PIOB, PIO_PERIPH_D, PIO_PB4);
  409f90:	2210      	movs	r2, #16
  409f92:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  409f96:	4815      	ldr	r0, [pc, #84]	; (409fec <mb_port_init+0xc4>)
  409f98:	4623      	mov	r3, r4
}
  409f9a:	b003      	add	sp, #12
  409f9c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		pio_set_peripheral(PIOB, PIO_PERIPH_D, PIO_PB4);
  409fa0:	4718      	bx	r3
		pio_set_peripheral(PIOB, PIO_PERIPH_C, PIO_PB0);
  409fa2:	2201      	movs	r2, #1
  409fa4:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  409fa8:	4810      	ldr	r0, [pc, #64]	; (409fec <mb_port_init+0xc4>)
  409faa:	4c0f      	ldr	r4, [pc, #60]	; (409fe8 <mb_port_init+0xc0>)
  409fac:	47a0      	blx	r4
		pio_set_peripheral(PIOB, PIO_PERIPH_C, PIO_PB1);
  409fae:	2202      	movs	r2, #2
  409fb0:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  409fb4:	480d      	ldr	r0, [pc, #52]	; (409fec <mb_port_init+0xc4>)
  409fb6:	47a0      	blx	r4
		pio_set_peripheral(PIOB, PIO_PERIPH_C, PIO_PB3);
  409fb8:	2208      	movs	r2, #8
  409fba:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  409fbe:	e7ea      	b.n	409f96 <mb_port_init+0x6e>
  409fc0:	00417a25 	.word	0x00417a25
  409fc4:	08f0d180 	.word	0x08f0d180
  409fc8:	0041255d 	.word	0x0041255d
  409fcc:	00412645 	.word	0x00412645
  409fd0:	0041264d 	.word	0x0041264d
  409fd4:	00412639 	.word	0x00412639
  409fd8:	00412655 	.word	0x00412655
  409fdc:	40024000 	.word	0x40024000
  409fe0:	40028000 	.word	0x40028000
  409fe4:	400e0e00 	.word	0x400e0e00
  409fe8:	00417445 	.word	0x00417445
  409fec:	400e1000 	.word	0x400e1000
  409ff0:	00417515 	.word	0x00417515

00409ff4 <port_usart_write_pda_line>:

#define PORT_USART_NOT_READY 0
#define PORT_USART_PDA_SUCESS 1
uint32_t port_usart_write_pda_line(Usart *p_usart, char *line, uint32_t lenght)
{
  409ff4:	b570      	push	{r4, r5, r6, lr}
	//if(!(p_usart->UART_SR & UART_SR_TXRDY)) return PORT_USART_NOT_READY;
	
	if (p_usart == USART0)
  409ff6:	4c11      	ldr	r4, [pc, #68]	; (40a03c <port_usart_write_pda_line+0x48>)
{
  409ff8:	b082      	sub	sp, #8
	if (p_usart == USART0)
  409ffa:	42a0      	cmp	r0, r4
  409ffc:	d015      	beq.n	40a02a <port_usart_write_pda_line+0x36>
		//disable transfer
		mb_port_disable_xdmac(MB_XDMAC_CH_TX0);
		//enable transfer
		mb_port_xdmac_configure_write(p_usart, line, lenght, MB_XDMAC_CH_TX0, MB_DMAC_ID_TX0);
	}
	else if (p_usart == USART1)
  409ffe:	4c10      	ldr	r4, [pc, #64]	; (40a040 <port_usart_write_pda_line+0x4c>)
  40a000:	42a0      	cmp	r0, r4
  40a002:	d002      	beq.n	40a00a <port_usart_write_pda_line+0x16>
		mb_port_disable_xdmac(MB_XDMAC_CH_TX1);
		//enable transfer
		mb_port_xdmac_configure_write(p_usart, line, lenght, MB_XDMAC_CH_TX1, MB_DMAC_ID_TX1);	
	}
	return PORT_USART_PDA_SUCESS;
}
  40a004:	2001      	movs	r0, #1
  40a006:	b002      	add	sp, #8
  40a008:	bd70      	pop	{r4, r5, r6, pc}
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a00a:	2301      	movs	r3, #1
  40a00c:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  40a010:	2540      	movs	r5, #64	; 0x40
		mb_port_xdmac_configure_write(p_usart, line, lenght, MB_XDMAC_CH_TX1, MB_DMAC_ID_TX1);	
  40a012:	2609      	movs	r6, #9
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a014:	f8c4 31d4 	str.w	r3, [r4, #468]	; 0x1d4
  40a018:	2306      	movs	r3, #6
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  40a01a:	6225      	str	r5, [r4, #32]
	xdmac->XDMAC_GID = (XDMAC_GID_ID0 << channel_num);
  40a01c:	6125      	str	r5, [r4, #16]
  40a01e:	4c09      	ldr	r4, [pc, #36]	; (40a044 <port_usart_write_pda_line+0x50>)
  40a020:	9600      	str	r6, [sp, #0]
  40a022:	47a0      	blx	r4
}
  40a024:	2001      	movs	r0, #1
  40a026:	b002      	add	sp, #8
  40a028:	bd70      	pop	{r4, r5, r6, pc}
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a02a:	2301      	movs	r3, #1
  40a02c:	f504 24a8 	add.w	r4, r4, #344064	; 0x54000
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  40a030:	2510      	movs	r5, #16
		mb_port_xdmac_configure_write(p_usart, line, lenght, MB_XDMAC_CH_TX0, MB_DMAC_ID_TX0);
  40a032:	2607      	movs	r6, #7
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a034:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
  40a038:	2304      	movs	r3, #4
  40a03a:	e7ee      	b.n	40a01a <port_usart_write_pda_line+0x26>
  40a03c:	40024000 	.word	0x40024000
  40a040:	40028000 	.word	0x40028000
  40a044:	00409e61 	.word	0x00409e61

0040a048 <port_usart_set_rx_pda_buff>:
uint32_t port_usart_set_rx_pda_buff(Usart *p_usart, char *line, uint32_t lenght)
{
  40a048:	b570      	push	{r4, r5, r6, lr}
	if (p_usart == USART0)
  40a04a:	4c11      	ldr	r4, [pc, #68]	; (40a090 <port_usart_set_rx_pda_buff+0x48>)
{
  40a04c:	b082      	sub	sp, #8
	if (p_usart == USART0)
  40a04e:	42a0      	cmp	r0, r4
  40a050:	d015      	beq.n	40a07e <port_usart_set_rx_pda_buff+0x36>
		//disable transfer
		mb_port_disable_xdmac(MB_XDMAC_CH_RX0);
		//enable transfer
		mb_port_xdmac_configure_read(p_usart, line, lenght, MB_XDMAC_CH_RX0, MB_DMAC_ID_RX0);
	}
	else if (p_usart == USART1)
  40a052:	4c10      	ldr	r4, [pc, #64]	; (40a094 <port_usart_set_rx_pda_buff+0x4c>)
  40a054:	42a0      	cmp	r0, r4
  40a056:	d002      	beq.n	40a05e <port_usart_set_rx_pda_buff+0x16>
		//enable transfer
		mb_port_xdmac_configure_read(p_usart, line, lenght, MB_XDMAC_CH_RX1, MB_DMAC_ID_RX1);
	}
	return PORT_USART_PDA_SUCESS;
		
}
  40a058:	2001      	movs	r0, #1
  40a05a:	b002      	add	sp, #8
  40a05c:	bd70      	pop	{r4, r5, r6, pc}
  40a05e:	2301      	movs	r3, #1
  40a060:	f504 24a0 	add.w	r4, r4, #327680	; 0x50000
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  40a064:	2580      	movs	r5, #128	; 0x80
		mb_port_xdmac_configure_read(p_usart, line, lenght, MB_XDMAC_CH_RX1, MB_DMAC_ID_RX1);
  40a066:	260a      	movs	r6, #10
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a068:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214
  40a06c:	2307      	movs	r3, #7
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  40a06e:	6225      	str	r5, [r4, #32]
	xdmac->XDMAC_GID = (XDMAC_GID_ID0 << channel_num);
  40a070:	6125      	str	r5, [r4, #16]
  40a072:	4c09      	ldr	r4, [pc, #36]	; (40a098 <port_usart_set_rx_pda_buff+0x50>)
  40a074:	9600      	str	r6, [sp, #0]
  40a076:	47a0      	blx	r4
}
  40a078:	2001      	movs	r0, #1
  40a07a:	b002      	add	sp, #8
  40a07c:	bd70      	pop	{r4, r5, r6, pc}
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a07e:	2301      	movs	r3, #1
  40a080:	f504 24a8 	add.w	r4, r4, #344064	; 0x54000
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  40a084:	2520      	movs	r5, #32
		mb_port_xdmac_configure_read(p_usart, line, lenght, MB_XDMAC_CH_RX0, MB_DMAC_ID_RX0);
  40a086:	2608      	movs	r6, #8
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  40a088:	f8c4 3194 	str.w	r3, [r4, #404]	; 0x194
  40a08c:	2305      	movs	r3, #5
  40a08e:	e7ee      	b.n	40a06e <port_usart_set_rx_pda_buff+0x26>
  40a090:	40024000 	.word	0x40024000
  40a094:	40028000 	.word	0x40028000
  40a098:	00409ec1 	.word	0x00409ec1

0040a09c <mb_functions_master_check_res>:
#include <mb_rdireg.h>



uint32_t mb_functions_master_check_res(mb_operation_t *mb_passed_instance)
{
  40a09c:	b510      	push	{r4, lr}
	uint8_t *buffer = &mb_passed_instance->mb_channel_read_frame_buff[1] , count = mb_passed_instance->mb_rx_buffer_count;
	
	if (mb_passed_instance->reply_sub)
  40a09e:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
  40a0a0:	4604      	mov	r4, r0
	if (mb_passed_instance->reply_sub)
  40a0a2:	b113      	cbz	r3, 40a0aa <mb_functions_master_check_res+0xe>
	{
		mb_passed_instance->reply_sub(mb_passed_instance->mb_channel_read_frame_buff[0]);
  40a0a4:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
  40a0a8:	4798      	blx	r3
  40a0aa:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
  40a0ae:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	}
	
	if ((*buffer & 0x7F) == 0x06)
  40a0b2:	2b06      	cmp	r3, #6
  40a0b4:	d00b      	beq.n	40a0ce <mb_functions_master_check_res+0x32>
	{
		//response to write holding reg
		return mb_write_hreg_master_slave_res(mb_passed_instance);
	}
	else if ((*buffer & 0x7F) == 0x10)
  40a0b6:	2b10      	cmp	r3, #16
  40a0b8:	d00e      	beq.n	40a0d8 <mb_functions_master_check_res+0x3c>
	{
		//response to write multiple holding reg
		return mb_write_mhreg_master_slave_res(mb_passed_instance);
	}
	else if ((*buffer & 0x7F) == 0x03)
  40a0ba:	2b03      	cmp	r3, #3
  40a0bc:	d011      	beq.n	40a0e2 <mb_functions_master_check_res+0x46>
	{
		//response to read holding reg
		return mb_read_hreg_master_slave_res(mb_passed_instance);
	}
	else if ((*buffer & 0x7F) == 0x04)
  40a0be:	2b04      	cmp	r3, #4
  40a0c0:	d000      	beq.n	40a0c4 <mb_functions_master_check_res+0x28>
	{
		//response to read input registers
		return mb_read_ireg_master_slave_res(mb_passed_instance);
	}
  40a0c2:	bd10      	pop	{r4, pc}
		return mb_read_ireg_master_slave_res(mb_passed_instance);
  40a0c4:	4620      	mov	r0, r4
  40a0c6:	4b09      	ldr	r3, [pc, #36]	; (40a0ec <mb_functions_master_check_res+0x50>)
  40a0c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return mb_read_ireg_master_slave_res(mb_passed_instance);
  40a0cc:	4718      	bx	r3
		return mb_write_hreg_master_slave_res(mb_passed_instance);
  40a0ce:	4620      	mov	r0, r4
  40a0d0:	4b07      	ldr	r3, [pc, #28]	; (40a0f0 <mb_functions_master_check_res+0x54>)
  40a0d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return mb_write_hreg_master_slave_res(mb_passed_instance);
  40a0d6:	4718      	bx	r3
		return mb_write_mhreg_master_slave_res(mb_passed_instance);
  40a0d8:	4620      	mov	r0, r4
  40a0da:	4b06      	ldr	r3, [pc, #24]	; (40a0f4 <mb_functions_master_check_res+0x58>)
  40a0dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return mb_write_mhreg_master_slave_res(mb_passed_instance);
  40a0e0:	4718      	bx	r3
		return mb_read_hreg_master_slave_res(mb_passed_instance);
  40a0e2:	4620      	mov	r0, r4
  40a0e4:	4b04      	ldr	r3, [pc, #16]	; (40a0f8 <mb_functions_master_check_res+0x5c>)
  40a0e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return mb_read_hreg_master_slave_res(mb_passed_instance);
  40a0ea:	4718      	bx	r3
  40a0ec:	0040a191 	.word	0x0040a191
  40a0f0:	0040a375 	.word	0x0040a375
  40a0f4:	0040a3ed 	.word	0x0040a3ed
  40a0f8:	0040a11d 	.word	0x0040a11d

0040a0fc <mb_read_hreg>:
 */ 
#include <mb_rdhreg.h>


void mb_read_hreg(uint8_t *buff, uint8_t *buff_count, uint16_t start_add, uint16_t data_count)
{
  40a0fc:	b4f0      	push	{r4, r5, r6, r7}
	//add the function code read H register
	*buff++ = 0x03;
  40a0fe:	2503      	movs	r5, #3
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a100:	0a17      	lsrs	r7, r2, #8
	*buff++ = *((uint8_t *)&start_add);
	*buff++ = *(((uint8_t *)&data_count)+1);
	*buff++ = *((uint8_t *)&data_count);
	*buff_count = 5;
  40a102:	2405      	movs	r4, #5
	*buff++ = *(((uint8_t *)&data_count)+1);
  40a104:	0a1e      	lsrs	r6, r3, #8
{
  40a106:	b082      	sub	sp, #8
	*buff++ = *((uint8_t *)&start_add);
  40a108:	7082      	strb	r2, [r0, #2]
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a10a:	7047      	strb	r7, [r0, #1]
	*buff++ = *((uint8_t *)&data_count);
  40a10c:	7103      	strb	r3, [r0, #4]
	*buff++ = *(((uint8_t *)&data_count)+1);
  40a10e:	70c6      	strb	r6, [r0, #3]
	*buff++ = 0x03;
  40a110:	7005      	strb	r5, [r0, #0]
	*buff_count = 5;
  40a112:	700c      	strb	r4, [r1, #0]
}
  40a114:	b002      	add	sp, #8
  40a116:	bcf0      	pop	{r4, r5, r6, r7}
  40a118:	4770      	bx	lr
  40a11a:	bf00      	nop

0040a11c <mb_read_hreg_master_slave_res>:
uint32_t mb_read_hreg_master_slave_res(mb_operation_t *mb_passed_instance)
{
	uint8_t *buffer = &mb_passed_instance->mb_channel_read_frame_buff[1] , count = mb_passed_instance->mb_rx_buffer_count;
	uint16_t *store_data_buff = mb_passed_instance->mb_buff;
	uint8_t save_buffer_data_count = mb_passed_instance->buff_size;
	if (*buffer++ & 0x80)
  40a11c:	f990 3036 	ldrsb.w	r3, [r0, #54]	; 0x36
  40a120:	2b00      	cmp	r3, #0
  40a122:	db20      	blt.n	40a166 <mb_read_hreg_master_slave_res+0x4a>
	uint16_t *store_data_buff = mb_passed_instance->mb_buff;
  40a124:	6842      	ldr	r2, [r0, #4]
		return 0;
	}
	else
	{
		//normal response
		if(store_data_buff)
  40a126:	b302      	cbz	r2, 40a16a <mb_read_hreg_master_slave_res+0x4e>
{
  40a128:	b410      	push	{r4}
		{
			//there is a buffer to store data to
			if(((*buffer)/2) < save_buffer_data_count) save_buffer_data_count = (*buffer) / 2; //get the least buffer count as not to go beyond the buffer boundries
  40a12a:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
	uint8_t save_buffer_data_count = mb_passed_instance->buff_size;
  40a12e:	7c41      	ldrb	r1, [r0, #17]
  40a130:	085b      	lsrs	r3, r3, #1
  40a132:	428b      	cmp	r3, r1
  40a134:	bf28      	it	cs
  40a136:	460b      	movcs	r3, r1
			buffer++;
			while(save_buffer_data_count--)
  40a138:	1e5c      	subs	r4, r3, #1
  40a13a:	b2e4      	uxtb	r4, r4
  40a13c:	b17b      	cbz	r3, 40a15e <mb_read_hreg_master_slave_res+0x42>
  40a13e:	eb02 0444 	add.w	r4, r2, r4, lsl #1
  40a142:	303a      	adds	r0, #58	; 0x3a
  40a144:	3a02      	subs	r2, #2
			{
				//starting saving data
				*store_data_buff = (*buffer++) << 8;
  40a146:	f810 3c02 	ldrb.w	r3, [r0, #-2]
  40a14a:	3002      	adds	r0, #2
  40a14c:	021b      	lsls	r3, r3, #8
  40a14e:	8053      	strh	r3, [r2, #2]
				(*store_data_buff++) += *buffer++;
  40a150:	f810 1c03 	ldrb.w	r1, [r0, #-3]
  40a154:	440b      	add	r3, r1
  40a156:	f822 3f02 	strh.w	r3, [r2, #2]!
			while(save_buffer_data_count--)
  40a15a:	42a2      	cmp	r2, r4
  40a15c:	d1f3      	bne.n	40a146 <mb_read_hreg_master_slave_res+0x2a>
			}
		}
		return 1;
  40a15e:	2001      	movs	r0, #1
	}
	
  40a160:	f85d 4b04 	ldr.w	r4, [sp], #4
  40a164:	4770      	bx	lr
		return 0;
  40a166:	2000      	movs	r0, #0
  40a168:	4770      	bx	lr
		return 1;
  40a16a:	2001      	movs	r0, #1
  40a16c:	4770      	bx	lr
  40a16e:	bf00      	nop

0040a170 <mb_read_ireg>:
 *  Author: ahmed
 */ 
#include <mb_rdireg.h>

void mb_read_ireg(uint8_t *buff, uint8_t *buff_count, uint16_t start_add, uint16_t data_count)
{
  40a170:	b4f0      	push	{r4, r5, r6, r7}
	//add the function code read H register
	*buff++ = 0x04;
  40a172:	2504      	movs	r5, #4
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a174:	0a17      	lsrs	r7, r2, #8
	*buff++ = *((uint8_t *)&start_add);
	*buff++ = *(((uint8_t *)&data_count)+1);
	*buff++ = *((uint8_t *)&data_count);
	*buff_count = 5;
  40a176:	2405      	movs	r4, #5
	*buff++ = *(((uint8_t *)&data_count)+1);
  40a178:	0a1e      	lsrs	r6, r3, #8
{
  40a17a:	b082      	sub	sp, #8
	*buff++ = *((uint8_t *)&start_add);
  40a17c:	7082      	strb	r2, [r0, #2]
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a17e:	7047      	strb	r7, [r0, #1]
	*buff++ = *((uint8_t *)&data_count);
  40a180:	7103      	strb	r3, [r0, #4]
	*buff++ = *(((uint8_t *)&data_count)+1);
  40a182:	70c6      	strb	r6, [r0, #3]
	*buff++ = 0x04;
  40a184:	7005      	strb	r5, [r0, #0]
	*buff_count = 5;
  40a186:	700c      	strb	r4, [r1, #0]
}
  40a188:	b002      	add	sp, #8
  40a18a:	bcf0      	pop	{r4, r5, r6, r7}
  40a18c:	4770      	bx	lr
  40a18e:	bf00      	nop

0040a190 <mb_read_ireg_master_slave_res>:
uint32_t mb_read_ireg_master_slave_res(mb_operation_t *mb_passed_instance)
{
	uint8_t *buffer = &mb_passed_instance->mb_channel_read_frame_buff[1] , count = mb_passed_instance->mb_rx_buffer_count;
	uint16_t *store_data_buff = mb_passed_instance->mb_buff;
	uint8_t save_buffer_data_count = mb_passed_instance->buff_size;
	if (*buffer++ & 0x80)
  40a190:	f990 3036 	ldrsb.w	r3, [r0, #54]	; 0x36
  40a194:	2b00      	cmp	r3, #0
  40a196:	db20      	blt.n	40a1da <mb_read_ireg_master_slave_res+0x4a>
	uint16_t *store_data_buff = mb_passed_instance->mb_buff;
  40a198:	6842      	ldr	r2, [r0, #4]
		return 0;
	}
	else
	{
		//normal response
		if(store_data_buff)
  40a19a:	b302      	cbz	r2, 40a1de <mb_read_ireg_master_slave_res+0x4e>
{
  40a19c:	b410      	push	{r4}
		{
			//there is a buffer to store data to
			if(((*buffer)/2) < save_buffer_data_count) save_buffer_data_count = (*buffer) / 2; //get the least buffer count as not to go beyond the buffer boundries
  40a19e:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
	uint8_t save_buffer_data_count = mb_passed_instance->buff_size;
  40a1a2:	7c41      	ldrb	r1, [r0, #17]
  40a1a4:	085b      	lsrs	r3, r3, #1
  40a1a6:	428b      	cmp	r3, r1
  40a1a8:	bf28      	it	cs
  40a1aa:	460b      	movcs	r3, r1
			buffer++;
			while(save_buffer_data_count--)
  40a1ac:	1e5c      	subs	r4, r3, #1
  40a1ae:	b2e4      	uxtb	r4, r4
  40a1b0:	b17b      	cbz	r3, 40a1d2 <mb_read_ireg_master_slave_res+0x42>
  40a1b2:	eb02 0444 	add.w	r4, r2, r4, lsl #1
  40a1b6:	303a      	adds	r0, #58	; 0x3a
  40a1b8:	3a02      	subs	r2, #2
			{
				//starting saving data
				*store_data_buff = (*buffer++) << 8;
  40a1ba:	f810 3c02 	ldrb.w	r3, [r0, #-2]
  40a1be:	3002      	adds	r0, #2
  40a1c0:	021b      	lsls	r3, r3, #8
  40a1c2:	8053      	strh	r3, [r2, #2]
				(*store_data_buff++) += *buffer++;
  40a1c4:	f810 1c03 	ldrb.w	r1, [r0, #-3]
  40a1c8:	440b      	add	r3, r1
  40a1ca:	f822 3f02 	strh.w	r3, [r2, #2]!
			while(save_buffer_data_count--)
  40a1ce:	42a2      	cmp	r2, r4
  40a1d0:	d1f3      	bne.n	40a1ba <mb_read_ireg_master_slave_res+0x2a>
			}
		}
		return 1;
  40a1d2:	2001      	movs	r0, #1
	}
  40a1d4:	f85d 4b04 	ldr.w	r4, [sp], #4
  40a1d8:	4770      	bx	lr
		return 0;
  40a1da:	2000      	movs	r0, #0
  40a1dc:	4770      	bx	lr
		return 1;
  40a1de:	2001      	movs	r0, #1
  40a1e0:	4770      	bx	lr
  40a1e2:	bf00      	nop

0040a1e4 <mb_states_master_waiting_for_reply_handler>:
#include <mb_functions.h>

#define REPLY_TO_READY_TOUT (0)

void mb_states_master_waiting_for_reply_handler(void)
{
  40a1e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40a1e6:	4c19      	ldr	r4, [pc, #100]	; (40a24c <mb_states_master_waiting_for_reply_handler+0x68>)
	uint32_t i;
	for (i=0; i<MB_CHANNEL_COUNT; i++)
  40a1e8:	2500      	movs	r5, #0
				}
				else
				{
					//unexpected slave response
					//ignore the frame and continue waiting
					port_usart_set_rx_pda_buff(mb_instance[i].mb_usart, mb_instance[i].mb_channel_read_frame_buff, MB_FRAME_BUFF_MAX + 3); //reset pda buffer
  40a1ea:	4f19      	ldr	r7, [pc, #100]	; (40a250 <mb_states_master_waiting_for_reply_handler+0x6c>)
					usart_start_rx_timeout(mb_instance[i].mb_usart); //start timeout after receiving the first char
  40a1ec:	4e19      	ldr	r6, [pc, #100]	; (40a254 <mb_states_master_waiting_for_reply_handler+0x70>)
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_REPLY_WAIT)
  40a1ee:	f814 3c27 	ldrb.w	r3, [r4, #-39]
  40a1f2:	2b03      	cmp	r3, #3
  40a1f4:	d004      	beq.n	40a200 <mb_states_master_waiting_for_reply_handler+0x1c>
	for (i=0; i<MB_CHANNEL_COUNT; i++)
  40a1f6:	3501      	adds	r5, #1
  40a1f8:	3468      	adds	r4, #104	; 0x68
  40a1fa:	2d02      	cmp	r5, #2
  40a1fc:	d1f7      	bne.n	40a1ee <mb_states_master_waiting_for_reply_handler+0xa>
  40a1fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if(mb_instance[i].mb_usart->US_CSR & US_CSR_TIMEOUT)
  40a200:	f8d4 0023 	ldr.w	r0, [r4, #35]	; 0x23
					port_usart_set_rx_pda_buff(mb_instance[i].mb_usart, mb_instance[i].mb_channel_read_frame_buff, MB_FRAME_BUFF_MAX + 3); //reset pda buffer
  40a204:	4621      	mov	r1, r4
  40a206:	2221      	movs	r2, #33	; 0x21
			if(mb_instance[i].mb_usart->US_CSR & US_CSR_TIMEOUT)
  40a208:	6943      	ldr	r3, [r0, #20]
  40a20a:	05db      	lsls	r3, r3, #23
  40a20c:	d508      	bpl.n	40a220 <mb_states_master_waiting_for_reply_handler+0x3c>
				if (mb_instance[i].mb_channel_frame_buff[0] == mb_instance[i].mb_channel_read_frame_buff[0])
  40a20e:	f814 ec21 	ldrb.w	lr, [r4, #-33]
  40a212:	7823      	ldrb	r3, [r4, #0]
  40a214:	459e      	cmp	lr, r3
  40a216:	d012      	beq.n	40a23e <mb_states_master_waiting_for_reply_handler+0x5a>
					port_usart_set_rx_pda_buff(mb_instance[i].mb_usart, mb_instance[i].mb_channel_read_frame_buff, MB_FRAME_BUFF_MAX + 3); //reset pda buffer
  40a218:	47b8      	blx	r7
					usart_start_rx_timeout(mb_instance[i].mb_usart); //start timeout after receiving the first char
  40a21a:	f8d4 0023 	ldr.w	r0, [r4, #35]	; 0x23
  40a21e:	47b0      	blx	r6
				}
			}
			if(--mb_instance[i].mb_timer_counter == 0)
  40a220:	f834 3c2d 	ldrh.w	r3, [r4, #-45]
  40a224:	3b01      	subs	r3, #1
  40a226:	b29b      	uxth	r3, r3
  40a228:	f824 3c2d 	strh.w	r3, [r4, #-45]
  40a22c:	2b00      	cmp	r3, #0
  40a22e:	d1e2      	bne.n	40a1f6 <mb_states_master_waiting_for_reply_handler+0x12>
			{
				//timeout has passed and no response
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_NOREPLY_ERROR;
  40a230:	4a09      	ldr	r2, [pc, #36]	; (40a258 <mb_states_master_waiting_for_reply_handler+0x74>)
  40a232:	2168      	movs	r1, #104	; 0x68
  40a234:	2304      	movs	r3, #4
  40a236:	fb01 2505 	mla	r5, r1, r5, r2
  40a23a:	73ab      	strb	r3, [r5, #14]
				return;
  40a23c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					mb_instance[i].mb_machine_state = MB_MACHINE_STATE_PROCESS_REPLY;
  40a23e:	4906      	ldr	r1, [pc, #24]	; (40a258 <mb_states_master_waiting_for_reply_handler+0x74>)
  40a240:	2368      	movs	r3, #104	; 0x68
  40a242:	2207      	movs	r2, #7
  40a244:	fb03 1505 	mla	r5, r3, r5, r1
  40a248:	73aa      	strb	r2, [r5, #14]
					return;
  40a24a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40a24c:	20405409 	.word	0x20405409
  40a250:	0040a049 	.word	0x0040a049
  40a254:	00412661 	.word	0x00412661
  40a258:	204053d4 	.word	0x204053d4

0040a25c <mb_states_master_process_reply_handler>:
	}
	
}

void mb_states_master_process_reply_handler(void)
{
  40a25c:	b510      	push	{r4, lr}
	uint32_t i;
	for (i=0; i<MB_CHANNEL_COUNT; i++)
	{
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_PROCESS_REPLY)
  40a25e:	4c1b      	ldr	r4, [pc, #108]	; (40a2cc <mb_states_master_process_reply_handler+0x70>)
  40a260:	7ba3      	ldrb	r3, [r4, #14]
  40a262:	2b07      	cmp	r3, #7
  40a264:	d004      	beq.n	40a270 <mb_states_master_process_reply_handler+0x14>
  40a266:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
  40a26a:	2b07      	cmp	r3, #7
  40a26c:	d013      	beq.n	40a296 <mb_states_master_process_reply_handler+0x3a>
  40a26e:	bd10      	pop	{r4, pc}
		{
			//check for crc_error
			mb_instance[i].mb_rx_buffer_count = mb_instance[i].mb_channel_read_frame_buff[2] + 3;
  40a270:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
  40a274:	4621      	mov	r1, r4
			if(mb_check_crc(mb_instance[i].mb_channel_read_frame_buff, &mb_instance[i].mb_rx_buffer_count))
  40a276:	f104 0035 	add.w	r0, r4, #53	; 0x35
  40a27a:	4a15      	ldr	r2, [pc, #84]	; (40a2d0 <mb_states_master_process_reply_handler+0x74>)
			mb_instance[i].mb_rx_buffer_count = mb_instance[i].mb_channel_read_frame_buff[2] + 3;
  40a27c:	3303      	adds	r3, #3
  40a27e:	f801 3f13 	strb.w	r3, [r1, #19]!
			if(mb_check_crc(mb_instance[i].mb_channel_read_frame_buff, &mb_instance[i].mb_rx_buffer_count))
  40a282:	4790      	blx	r2
  40a284:	b9c8      	cbnz	r0, 40a2ba <mb_states_master_process_reply_handler+0x5e>
			{
				mb_functions_master_check_res(&mb_instance[i]);
			}
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a286:	2308      	movs	r3, #8
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a288:	2200      	movs	r2, #0
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a28a:	73a3      	strb	r3, [r4, #14]
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_PROCESS_REPLY)
  40a28c:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a290:	6622      	str	r2, [r4, #96]	; 0x60
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_PROCESS_REPLY)
  40a292:	2b07      	cmp	r3, #7
  40a294:	d1eb      	bne.n	40a26e <mb_states_master_process_reply_handler+0x12>
			mb_instance[i].mb_rx_buffer_count = mb_instance[i].mb_channel_read_frame_buff[2] + 3;
  40a296:	f894 309f 	ldrb.w	r3, [r4, #159]	; 0x9f
			if(mb_check_crc(mb_instance[i].mb_channel_read_frame_buff, &mb_instance[i].mb_rx_buffer_count))
  40a29a:	490e      	ldr	r1, [pc, #56]	; (40a2d4 <mb_states_master_process_reply_handler+0x78>)
			mb_instance[i].mb_rx_buffer_count = mb_instance[i].mb_channel_read_frame_buff[2] + 3;
  40a29c:	3303      	adds	r3, #3
			if(mb_check_crc(mb_instance[i].mb_channel_read_frame_buff, &mb_instance[i].mb_rx_buffer_count))
  40a29e:	4a0c      	ldr	r2, [pc, #48]	; (40a2d0 <mb_states_master_process_reply_handler+0x74>)
  40a2a0:	f101 0022 	add.w	r0, r1, #34	; 0x22
			mb_instance[i].mb_rx_buffer_count = mb_instance[i].mb_channel_read_frame_buff[2] + 3;
  40a2a4:	f884 307b 	strb.w	r3, [r4, #123]	; 0x7b
			if(mb_check_crc(mb_instance[i].mb_channel_read_frame_buff, &mb_instance[i].mb_rx_buffer_count))
  40a2a8:	4790      	blx	r2
  40a2aa:	b950      	cbnz	r0, 40a2c2 <mb_states_master_process_reply_handler+0x66>
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a2ac:	2200      	movs	r2, #0
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a2ae:	2308      	movs	r3, #8
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a2b0:	f8c4 20c8 	str.w	r2, [r4, #200]	; 0xc8
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a2b4:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
  40a2b8:	bd10      	pop	{r4, pc}
				mb_functions_master_check_res(&mb_instance[i]);
  40a2ba:	4620      	mov	r0, r4
  40a2bc:	4b06      	ldr	r3, [pc, #24]	; (40a2d8 <mb_states_master_process_reply_handler+0x7c>)
  40a2be:	4798      	blx	r3
  40a2c0:	e7e1      	b.n	40a286 <mb_states_master_process_reply_handler+0x2a>
  40a2c2:	4b05      	ldr	r3, [pc, #20]	; (40a2d8 <mb_states_master_process_reply_handler+0x7c>)
  40a2c4:	4805      	ldr	r0, [pc, #20]	; (40a2dc <mb_states_master_process_reply_handler+0x80>)
  40a2c6:	4798      	blx	r3
  40a2c8:	e7f0      	b.n	40a2ac <mb_states_master_process_reply_handler+0x50>
  40a2ca:	bf00      	nop
  40a2cc:	204053d4 	.word	0x204053d4
  40a2d0:	0040a44d 	.word	0x0040a44d
  40a2d4:	2040544f 	.word	0x2040544f
  40a2d8:	0040a09d 	.word	0x0040a09d
  40a2dc:	2040543c 	.word	0x2040543c

0040a2e0 <mb_states_master_process_noreply_handler>:
void mb_states_master_process_noreply_handler(void)
{
	uint32_t i;
	for (i=0; i<MB_CHANNEL_COUNT; i++)
	{
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_NOREPLY_ERROR)
  40a2e0:	4b0b      	ldr	r3, [pc, #44]	; (40a310 <mb_states_master_process_noreply_handler+0x30>)
  40a2e2:	7b9a      	ldrb	r2, [r3, #14]
  40a2e4:	2a04      	cmp	r2, #4
  40a2e6:	d004      	beq.n	40a2f2 <mb_states_master_process_noreply_handler+0x12>
  40a2e8:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
  40a2ec:	2a04      	cmp	r2, #4
  40a2ee:	d008      	beq.n	40a302 <mb_states_master_process_noreply_handler+0x22>
  40a2f0:	4770      	bx	lr
		{
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a2f2:	2208      	movs	r2, #8
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a2f4:	2100      	movs	r1, #0
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a2f6:	739a      	strb	r2, [r3, #14]
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_NOREPLY_ERROR)
  40a2f8:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a2fc:	6619      	str	r1, [r3, #96]	; 0x60
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_NOREPLY_ERROR)
  40a2fe:	2a04      	cmp	r2, #4
  40a300:	d1f6      	bne.n	40a2f0 <mb_states_master_process_noreply_handler+0x10>
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a302:	2100      	movs	r1, #0
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a304:	2208      	movs	r2, #8
			mb_instance[i].reply_to_ready_counter = REPLY_TO_READY_TOUT;
  40a306:	f8c3 10c8 	str.w	r1, [r3, #200]	; 0xc8
			mb_instance[i].mb_machine_state = MB_MACHINE_STATE_WAIT_TO_READY;
  40a30a:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
  40a30e:	4770      	bx	lr
  40a310:	204053d4 	.word	0x204053d4

0040a314 <mb_states_master_delay_to_ready>:
void mb_states_master_delay_to_ready(void)
{
	uint32_t i;
	for (i=0; i<MB_CHANNEL_COUNT; i++)
	{
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_WAIT_TO_READY)
  40a314:	4b0e      	ldr	r3, [pc, #56]	; (40a350 <mb_states_master_delay_to_ready+0x3c>)
  40a316:	7b9a      	ldrb	r2, [r3, #14]
  40a318:	2a08      	cmp	r2, #8
  40a31a:	d004      	beq.n	40a326 <mb_states_master_delay_to_ready+0x12>
  40a31c:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
  40a320:	2a08      	cmp	r2, #8
  40a322:	d008      	beq.n	40a336 <mb_states_master_delay_to_ready+0x22>
  40a324:	4770      	bx	lr
		{
			if (mb_instance[i].reply_to_ready_counter > 0) mb_instance[i].reply_to_ready_counter--;
  40a326:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  40a328:	b17a      	cbz	r2, 40a34a <mb_states_master_delay_to_ready+0x36>
  40a32a:	3a01      	subs	r2, #1
  40a32c:	661a      	str	r2, [r3, #96]	; 0x60
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_WAIT_TO_READY)
  40a32e:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
  40a332:	2a08      	cmp	r2, #8
  40a334:	d1f6      	bne.n	40a324 <mb_states_master_delay_to_ready+0x10>
			if (mb_instance[i].reply_to_ready_counter > 0) mb_instance[i].reply_to_ready_counter--;
  40a336:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
  40a33a:	b11a      	cbz	r2, 40a344 <mb_states_master_delay_to_ready+0x30>
  40a33c:	3a01      	subs	r2, #1
  40a33e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
  40a342:	4770      	bx	lr
			else mb_instance[i].mb_machine_state = MB_MACHINE_STATE_READY_TO_LOAD;
  40a344:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
  40a348:	4770      	bx	lr
  40a34a:	739a      	strb	r2, [r3, #14]
  40a34c:	e7e6      	b.n	40a31c <mb_states_master_delay_to_ready+0x8>
  40a34e:	bf00      	nop
  40a350:	204053d4 	.word	0x204053d4

0040a354 <mb_write_hreg>:
#include <mb_wrhreg.h>
#include <asf.h>

//volatile uint8_t tempdata;
void mb_write_hreg(uint8_t *buff, uint8_t *buff_count,uint16_t start_add, uint16_t data)
{
  40a354:	b4f0      	push	{r4, r5, r6, r7}
	//add the function code
	*buff++ = 0x06;
  40a356:	2506      	movs	r5, #6
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a358:	0a17      	lsrs	r7, r2, #8
	*buff++ = *((uint8_t *)&start_add);
	*buff++ = *(((uint8_t *)&data)+1);
	*buff++ = *((uint8_t *)&data);
	*buff_count = 5;	
  40a35a:	2405      	movs	r4, #5
	*buff++ = *(((uint8_t *)&data)+1);
  40a35c:	0a1e      	lsrs	r6, r3, #8
{
  40a35e:	b082      	sub	sp, #8
	*buff++ = *((uint8_t *)&start_add);
  40a360:	7082      	strb	r2, [r0, #2]
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a362:	7047      	strb	r7, [r0, #1]
	*buff++ = *((uint8_t *)&data);
  40a364:	7103      	strb	r3, [r0, #4]
	*buff++ = *(((uint8_t *)&data)+1);
  40a366:	70c6      	strb	r6, [r0, #3]
	*buff++ = 0x06;
  40a368:	7005      	strb	r5, [r0, #0]
	*buff_count = 5;	
  40a36a:	700c      	strb	r4, [r1, #0]
}
  40a36c:	b002      	add	sp, #8
  40a36e:	bcf0      	pop	{r4, r5, r6, r7}
  40a370:	4770      	bx	lr
  40a372:	bf00      	nop

0040a374 <mb_write_hreg_master_slave_res>:

uint32_t mb_write_hreg_master_slave_res(mb_operation_t *mb_passed_instance)
{
	uint8_t *buffer = &mb_passed_instance->mb_channel_read_frame_buff[1] , count = mb_passed_instance->mb_rx_buffer_count;
	
	if (*buffer & 0x80)
  40a374:	f990 0036 	ldrsb.w	r0, [r0, #54]	; 0x36
	{
		//normal response
		return 1;
	}
	
  40a378:	43c0      	mvns	r0, r0
  40a37a:	0fc0      	lsrs	r0, r0, #31
  40a37c:	4770      	bx	lr
  40a37e:	bf00      	nop

0040a380 <mb_write_mhreg>:
 *  Author: ahmed
 */ 
#include <mb_wrmhreg.h>

void mb_write_mhreg(uint8_t *buff, uint8_t *buff_count,uint16_t start_add, uint16_t data_count, uint16_t *data)
{
  40a380:	b5f0      	push	{r4, r5, r6, r7, lr}
	*buff++ = *(((uint8_t *)&data_count)+1);
	*buff++ = *((uint8_t *)&data_count);
	*buff++ = data_count<<1;
	*buff_count = 6;
	
    while(data_count--)
  40a382:	1e5c      	subs	r4, r3, #1
{
  40a384:	b083      	sub	sp, #12
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a386:	ea4f 2c12 	mov.w	ip, r2, lsr #8
	*buff++ = *((uint8_t *)&start_add);
  40a38a:	7082      	strb	r2, [r0, #2]
	*buff++ = *(((uint8_t *)&data_count)+1);
  40a38c:	0a1f      	lsrs	r7, r3, #8
	*buff++ = *((uint8_t *)&data_count);
  40a38e:	7103      	strb	r3, [r0, #4]
	*buff++ = data_count<<1;
  40a390:	005e      	lsls	r6, r3, #1
  40a392:	461d      	mov	r5, r3
	*buff++ = 0x10;
  40a394:	f04f 0e10 	mov.w	lr, #16
    while(data_count--)
  40a398:	b2a3      	uxth	r3, r4
{
  40a39a:	f8ad 2006 	strh.w	r2, [sp, #6]
	*buff_count = 6;
  40a39e:	2206      	movs	r2, #6
	*buff++ = *(((uint8_t *)&start_add)+1);
  40a3a0:	f880 c001 	strb.w	ip, [r0, #1]
	*buff++ = 0x10;
  40a3a4:	f880 e000 	strb.w	lr, [r0]
	*buff++ = data_count<<1;
  40a3a8:	1884      	adds	r4, r0, r2
	*buff++ = *(((uint8_t *)&data_count)+1);
  40a3aa:	70c7      	strb	r7, [r0, #3]
	*buff++ = data_count<<1;
  40a3ac:	7146      	strb	r6, [r0, #5]
    while(data_count--)
  40a3ae:	f8ad 3004 	strh.w	r3, [sp, #4]
	*buff_count = 6;
  40a3b2:	700a      	strb	r2, [r1, #0]
    while(data_count--)
  40a3b4:	b1c5      	cbz	r5, 40a3e8 <mb_write_mhreg+0x68>
  40a3b6:	1c9a      	adds	r2, r3, #2
  40a3b8:	9b08      	ldr	r3, [sp, #32]
  40a3ba:	3008      	adds	r0, #8
  40a3bc:	3302      	adds	r3, #2
  40a3be:	eb04 0442 	add.w	r4, r4, r2, lsl #1
    {
	    *buff++ = *(((uint8_t *)data)+1);
  40a3c2:	f813 2c01 	ldrb.w	r2, [r3, #-1]
  40a3c6:	3002      	adds	r0, #2
  40a3c8:	3302      	adds	r3, #2
  40a3ca:	f800 2c04 	strb.w	r2, [r0, #-4]
		(*buff_count)++;
  40a3ce:	780a      	ldrb	r2, [r1, #0]
  40a3d0:	3201      	adds	r2, #1
  40a3d2:	700a      	strb	r2, [r1, #0]
	    *buff++ = *((uint8_t *)data);
  40a3d4:	f813 2c04 	ldrb.w	r2, [r3, #-4]
  40a3d8:	f800 2c03 	strb.w	r2, [r0, #-3]
    while(data_count--)
  40a3dc:	42a0      	cmp	r0, r4
		(*buff_count)++;
  40a3de:	780a      	ldrb	r2, [r1, #0]
  40a3e0:	f102 0201 	add.w	r2, r2, #1
  40a3e4:	700a      	strb	r2, [r1, #0]
    while(data_count--)
  40a3e6:	d1ec      	bne.n	40a3c2 <mb_write_mhreg+0x42>
		data++;
    }

}
  40a3e8:	b003      	add	sp, #12
  40a3ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

0040a3ec <mb_write_mhreg_master_slave_res>:

uint32_t mb_write_mhreg_master_slave_res(mb_operation_t *mb_passed_instance)
{
	uint8_t *buffer = &mb_passed_instance->mb_channel_read_frame_buff[1] , count = mb_passed_instance->mb_rx_buffer_count;
	
	if (*buffer & 0x80)
  40a3ec:	f990 0036 	ldrsb.w	r0, [r0, #54]	; 0x36
	{
		//normal response
		return 1;
	}
		
}
  40a3f0:	43c0      	mvns	r0, r0
  40a3f2:	0fc0      	lsrs	r0, r0, #31
  40a3f4:	4770      	bx	lr
  40a3f6:	bf00      	nop

0040a3f8 <mb_add_crc>:
    0x41, 0x81, 0x80, 0x40
};

void mb_add_crc( uint8_t *buffer, uint8_t *size )
{
    uint8_t *ucCRCHi = &(buffer[*size + 1]);
  40a3f8:	780a      	ldrb	r2, [r1, #0]
    uint8_t *ucCRCLo = &(buffer[*size]);
    int iIndex ;
	uint8_t frame_size = *size;
	uint8_t *frame_buffer = buffer;
	
	*ucCRCHi = 0xFF;
  40a3fa:	23ff      	movs	r3, #255	; 0xff
{
  40a3fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t *ucCRCHi = &(buffer[*size + 1]);
  40a3fe:	1c54      	adds	r4, r2, #1
    uint8_t *ucCRCLo = &(buffer[*size]);
  40a400:	1885      	adds	r5, r0, r2
	*ucCRCHi = 0xFF;
  40a402:	5503      	strb	r3, [r0, r4]
    uint8_t *ucCRCHi = &(buffer[*size + 1]);
  40a404:	1907      	adds	r7, r0, r4
	*ucCRCLo = 0xFF;
  40a406:	5483      	strb	r3, [r0, r2]
    
    while( frame_size-- )
  40a408:	b1ba      	cbz	r2, 40a43a <mb_add_crc+0x42>
  40a40a:	1e56      	subs	r6, r2, #1
  40a40c:	5d04      	ldrb	r4, [r0, r4]
  40a40e:	f8df c034 	ldr.w	ip, [pc, #52]	; 40a444 <mb_add_crc+0x4c>
  40a412:	b2f6      	uxtb	r6, r6
  40a414:	f8df e030 	ldr.w	lr, [pc, #48]	; 40a448 <mb_add_crc+0x50>
  40a418:	4406      	add	r6, r0
  40a41a:	3801      	subs	r0, #1
  40a41c:	e000      	b.n	40a420 <mb_add_crc+0x28>
  40a41e:	782b      	ldrb	r3, [r5, #0]
    {
        iIndex = *ucCRCLo ^ *( frame_buffer++ );
  40a420:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  40a424:	4053      	eors	r3, r2
    while( frame_size-- )
  40a426:	4286      	cmp	r6, r0
        *ucCRCLo = ( uint8_t )( *ucCRCHi ^ aucCRCHi[iIndex] );
  40a428:	f81c 2003 	ldrb.w	r2, [ip, r3]
  40a42c:	ea82 0204 	eor.w	r2, r2, r4
        *ucCRCHi = aucCRCLo[iIndex];
  40a430:	f81e 4003 	ldrb.w	r4, [lr, r3]
        *ucCRCLo = ( uint8_t )( *ucCRCHi ^ aucCRCHi[iIndex] );
  40a434:	702a      	strb	r2, [r5, #0]
        *ucCRCHi = aucCRCLo[iIndex];
  40a436:	703c      	strb	r4, [r7, #0]
    while( frame_size-- )
  40a438:	d1f1      	bne.n	40a41e <mb_add_crc+0x26>
    }
	*size += 2;
  40a43a:	780b      	ldrb	r3, [r1, #0]
  40a43c:	3302      	adds	r3, #2
  40a43e:	700b      	strb	r3, [r1, #0]
}
  40a440:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40a442:	bf00      	nop
  40a444:	0041b98c 	.word	0x0041b98c
  40a448:	0041ba8c 	.word	0x0041ba8c

0040a44c <mb_check_crc>:

uint32_t mb_check_crc( uint8_t *buffer, uint8_t *size )
{
  40a44c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	volatile uint8_t ucCRCHi = 0xFF;
	volatile uint8_t ucCRCLo = 0xFF;
	int iIndex ;
	//*size -= 2;
	uint8_t frame_size = *size;
  40a450:	f891 8000 	ldrb.w	r8, [r1]
{
  40a454:	b083      	sub	sp, #12
	volatile uint8_t ucCRCHi = 0xFF;
  40a456:	23ff      	movs	r3, #255	; 0xff
	uint8_t *frame_buffer = buffer;
		
	while( frame_size-- )
  40a458:	f108 39ff 	add.w	r9, r8, #4294967295
	volatile uint8_t ucCRCHi = 0xFF;
  40a45c:	f88d 3006 	strb.w	r3, [sp, #6]
	while( frame_size-- )
  40a460:	fa5f f989 	uxtb.w	r9, r9
	volatile uint8_t ucCRCLo = 0xFF;
  40a464:	f88d 3007 	strb.w	r3, [sp, #7]
	while( frame_size-- )
  40a468:	f1b8 0f00 	cmp.w	r8, #0
  40a46c:	d017      	beq.n	40a49e <mb_check_crc+0x52>
  40a46e:	1e44      	subs	r4, r0, #1
  40a470:	eb00 0c09 	add.w	ip, r0, r9
  40a474:	f8df e058 	ldr.w	lr, [pc, #88]	; 40a4d0 <mb_check_crc+0x84>
  40a478:	4f14      	ldr	r7, [pc, #80]	; (40a4cc <mb_check_crc+0x80>)
	{
		iIndex = ucCRCLo ^ *( frame_buffer++ );
  40a47a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  40a47e:	f814 5f01 	ldrb.w	r5, [r4, #1]!
		ucCRCLo = ( uint8_t )( ucCRCHi ^ aucCRCHi[iIndex] );
  40a482:	f89d 2006 	ldrb.w	r2, [sp, #6]
		iIndex = ucCRCLo ^ *( frame_buffer++ );
  40a486:	406b      	eors	r3, r5
	while( frame_size-- )
  40a488:	4564      	cmp	r4, ip
		ucCRCLo = ( uint8_t )( ucCRCHi ^ aucCRCHi[iIndex] );
  40a48a:	f81e 6003 	ldrb.w	r6, [lr, r3]
		ucCRCHi = aucCRCLo[iIndex];
  40a48e:	5cfd      	ldrb	r5, [r7, r3]
		ucCRCLo = ( uint8_t )( ucCRCHi ^ aucCRCHi[iIndex] );
  40a490:	ea82 0306 	eor.w	r3, r2, r6
  40a494:	f88d 3007 	strb.w	r3, [sp, #7]
		ucCRCHi = aucCRCLo[iIndex];
  40a498:	f88d 5006 	strb.w	r5, [sp, #6]
	while( frame_size-- )
  40a49c:	d1ed      	bne.n	40a47a <mb_check_crc+0x2e>
	}
	if ((ucCRCHi == buffer[*size + 1]) && (ucCRCLo == buffer[*size]))
  40a49e:	eb00 0308 	add.w	r3, r0, r8
  40a4a2:	f89d 2006 	ldrb.w	r2, [sp, #6]
  40a4a6:	785b      	ldrb	r3, [r3, #1]
  40a4a8:	4293      	cmp	r3, r2
  40a4aa:	d003      	beq.n	40a4b4 <mb_check_crc+0x68>
		//buffer++;
		return 1;
	} 
	else
	{
		return 0;
  40a4ac:	2000      	movs	r0, #0
	}
  40a4ae:	b003      	add	sp, #12
  40a4b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if ((ucCRCHi == buffer[*size + 1]) && (ucCRCLo == buffer[*size]))
  40a4b4:	f810 2008 	ldrb.w	r2, [r0, r8]
  40a4b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
  40a4bc:	429a      	cmp	r2, r3
  40a4be:	d1f5      	bne.n	40a4ac <mb_check_crc+0x60>
		return 1;
  40a4c0:	2001      	movs	r0, #1
		*size -= 1;
  40a4c2:	f881 9000 	strb.w	r9, [r1]
  40a4c6:	b003      	add	sp, #12
  40a4c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40a4cc:	0041ba8c 	.word	0x0041ba8c
  40a4d0:	0041b98c 	.word	0x0041b98c

0040a4d4 <mb_dispatch>:
	mb_states_master_process_noreply_handler();
	mb_states_master_delay_to_ready();
	mb_load_handler();
}
void mb_dispatch(void)
{
  40a4d4:	b530      	push	{r4, r5, lr}
	uint32_t i;
	for (i=0; i<MB_CHANNEL_COUNT; i++)
	{
		if(mb_instance[i].buff_size > 0)
  40a4d6:	4c5a      	ldr	r4, [pc, #360]	; (40a640 <mb_dispatch+0x16c>)
{
  40a4d8:	b083      	sub	sp, #12
		if(mb_instance[i].buff_size > 0)
  40a4da:	7c63      	ldrb	r3, [r4, #17]
  40a4dc:	b113      	cbz	r3, 40a4e4 <mb_dispatch+0x10>
		{
			if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_IDLE)
  40a4de:	7ba2      	ldrb	r2, [r4, #14]
  40a4e0:	2a01      	cmp	r2, #1
  40a4e2:	d035      	beq.n	40a550 <mb_dispatch+0x7c>
		if(mb_instance[i].buff_size > 0)
  40a4e4:	f894 3079 	ldrb.w	r3, [r4, #121]	; 0x79
  40a4e8:	b11b      	cbz	r3, 40a4f2 <mb_dispatch+0x1e>
			if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_IDLE)
  40a4ea:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
  40a4ee:	2a01      	cmp	r2, #1
  40a4f0:	d001      	beq.n	40a4f6 <mb_dispatch+0x22>
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_REPLY_WAIT;
				mb_instance[i].mb_timer_counter = mb_instance[i].mb_wait_reply_timer_value; //load timer with timeout reply val.
			}
		}
	}
}
  40a4f2:	b003      	add	sp, #12
  40a4f4:	bd30      	pop	{r4, r5, pc}
			if (!(mb_instance[i].mb_channel_status&MB_CHANNEL_STATUS_DSENT) && (mb_instance[i].mb_channel_status&MB_CHANNEL_STATUS_OK))//data ready to be sent
  40a4f6:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
  40a4fa:	0751      	lsls	r1, r2, #29
  40a4fc:	d4f9      	bmi.n	40a4f2 <mb_dispatch+0x1e>
  40a4fe:	07d2      	lsls	r2, r2, #31
  40a500:	d5f7      	bpl.n	40a4f2 <mb_dispatch+0x1e>
				if (mb_instance[i].entry_type == WR_HREG)
  40a502:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
  40a506:	2a01      	cmp	r2, #1
  40a508:	d059      	beq.n	40a5be <mb_dispatch+0xea>
				else if (mb_instance[i].entry_type == RD_HREG)
  40a50a:	2a02      	cmp	r2, #2
  40a50c:	d073      	beq.n	40a5f6 <mb_dispatch+0x122>
				else if (mb_instance[i].entry_type == RD_IREG)
  40a50e:	2a03      	cmp	r2, #3
  40a510:	d07f      	beq.n	40a612 <mb_dispatch+0x13e>
				port_usart_write_pda_line(mb_instance[i].mb_usart, mb_instance[i].mb_channel_frame_buff, mb_instance[i].mb_frame_buff_count);
  40a512:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
  40a516:	494b      	ldr	r1, [pc, #300]	; (40a644 <mb_dispatch+0x170>)
  40a518:	4b4b      	ldr	r3, [pc, #300]	; (40a648 <mb_dispatch+0x174>)
  40a51a:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  40a51e:	4798      	blx	r3
				port_usart_set_rx_pda_buff(mb_instance[i].mb_usart, mb_instance[i].mb_channel_read_frame_buff, MB_FRAME_BUFF_MAX + 3);
  40a520:	2221      	movs	r2, #33	; 0x21
  40a522:	494a      	ldr	r1, [pc, #296]	; (40a64c <mb_dispatch+0x178>)
  40a524:	4b4a      	ldr	r3, [pc, #296]	; (40a650 <mb_dispatch+0x17c>)
  40a526:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  40a52a:	4798      	blx	r3
				usart_start_rx_timeout(mb_instance[i].mb_usart); //start timeout after receiving the first char
  40a52c:	4b49      	ldr	r3, [pc, #292]	; (40a654 <mb_dispatch+0x180>)
  40a52e:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  40a532:	4798      	blx	r3
				mb_instance[i].mb_channel_status |= MB_CHANNEL_STATUS_DSENT; //send the data
  40a534:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_REPLY_WAIT;
  40a538:	2103      	movs	r1, #3
				mb_instance[i].mb_timer_counter = mb_instance[i].mb_wait_reply_timer_value; //load timer with timeout reply val.
  40a53a:	f8b4 2074 	ldrh.w	r2, [r4, #116]	; 0x74
				mb_instance[i].mb_channel_status |= MB_CHANNEL_STATUS_DSENT; //send the data
  40a53e:	f043 0304 	orr.w	r3, r3, #4
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_REPLY_WAIT;
  40a542:	f884 1076 	strb.w	r1, [r4, #118]	; 0x76
				mb_instance[i].mb_channel_status |= MB_CHANNEL_STATUS_DSENT; //send the data
  40a546:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
				mb_instance[i].mb_timer_counter = mb_instance[i].mb_wait_reply_timer_value; //load timer with timeout reply val.
  40a54a:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
}
  40a54e:	e7d0      	b.n	40a4f2 <mb_dispatch+0x1e>
			if (!(mb_instance[i].mb_channel_status&MB_CHANNEL_STATUS_DSENT) && (mb_instance[i].mb_channel_status&MB_CHANNEL_STATUS_OK))//data ready to be sent
  40a550:	6de2      	ldr	r2, [r4, #92]	; 0x5c
  40a552:	0755      	lsls	r5, r2, #29
  40a554:	d4c6      	bmi.n	40a4e4 <mb_dispatch+0x10>
  40a556:	07d0      	lsls	r0, r2, #31
  40a558:	d5c4      	bpl.n	40a4e4 <mb_dispatch+0x10>
				if (mb_instance[i].entry_type == WR_HREG)
  40a55a:	7822      	ldrb	r2, [r4, #0]
  40a55c:	2a01      	cmp	r2, #1
  40a55e:	d019      	beq.n	40a594 <mb_dispatch+0xc0>
				else if (mb_instance[i].entry_type == RD_HREG)
  40a560:	2a02      	cmp	r2, #2
  40a562:	d040      	beq.n	40a5e6 <mb_dispatch+0x112>
				else if (mb_instance[i].entry_type == RD_IREG)
  40a564:	2a03      	cmp	r2, #3
  40a566:	d04d      	beq.n	40a604 <mb_dispatch+0x130>
				port_usart_write_pda_line(mb_instance[i].mb_usart, mb_instance[i].mb_channel_frame_buff, mb_instance[i].mb_frame_buff_count);
  40a568:	7c22      	ldrb	r2, [r4, #16]
  40a56a:	493b      	ldr	r1, [pc, #236]	; (40a658 <mb_dispatch+0x184>)
  40a56c:	4b36      	ldr	r3, [pc, #216]	; (40a648 <mb_dispatch+0x174>)
  40a56e:	6da0      	ldr	r0, [r4, #88]	; 0x58
  40a570:	4798      	blx	r3
				port_usart_set_rx_pda_buff(mb_instance[i].mb_usart, mb_instance[i].mb_channel_read_frame_buff, MB_FRAME_BUFF_MAX + 3);
  40a572:	2221      	movs	r2, #33	; 0x21
  40a574:	4939      	ldr	r1, [pc, #228]	; (40a65c <mb_dispatch+0x188>)
  40a576:	4b36      	ldr	r3, [pc, #216]	; (40a650 <mb_dispatch+0x17c>)
  40a578:	6da0      	ldr	r0, [r4, #88]	; 0x58
  40a57a:	4798      	blx	r3
				usart_start_rx_timeout(mb_instance[i].mb_usart); //start timeout after receiving the first char
  40a57c:	4b35      	ldr	r3, [pc, #212]	; (40a654 <mb_dispatch+0x180>)
  40a57e:	6da0      	ldr	r0, [r4, #88]	; 0x58
  40a580:	4798      	blx	r3
				mb_instance[i].mb_channel_status |= MB_CHANNEL_STATUS_DSENT; //send the data
  40a582:	6de3      	ldr	r3, [r4, #92]	; 0x5c
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_REPLY_WAIT;
  40a584:	2103      	movs	r1, #3
				mb_instance[i].mb_timer_counter = mb_instance[i].mb_wait_reply_timer_value; //load timer with timeout reply val.
  40a586:	89a2      	ldrh	r2, [r4, #12]
				mb_instance[i].mb_channel_status |= MB_CHANNEL_STATUS_DSENT; //send the data
  40a588:	f043 0304 	orr.w	r3, r3, #4
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_REPLY_WAIT;
  40a58c:	73a1      	strb	r1, [r4, #14]
				mb_instance[i].mb_channel_status |= MB_CHANNEL_STATUS_DSENT; //send the data
  40a58e:	65e3      	str	r3, [r4, #92]	; 0x5c
				mb_instance[i].mb_timer_counter = mb_instance[i].mb_wait_reply_timer_value; //load timer with timeout reply val.
  40a590:	8122      	strh	r2, [r4, #8]
  40a592:	e7a7      	b.n	40a4e4 <mb_dispatch+0x10>
					if (mb_instance[i].buff_size == 1)
  40a594:	2b01      	cmp	r3, #1
  40a596:	d042      	beq.n	40a61e <mb_dispatch+0x14a>
						mb_write_mhreg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].buff_size, &mb_instance[i].mb_buff[0]);
  40a598:	6865      	ldr	r5, [r4, #4]
  40a59a:	f104 0110 	add.w	r1, r4, #16
  40a59e:	7be2      	ldrb	r2, [r4, #15]
  40a5a0:	f104 0015 	add.w	r0, r4, #21
  40a5a4:	9500      	str	r5, [sp, #0]
  40a5a6:	4d2e      	ldr	r5, [pc, #184]	; (40a660 <mb_dispatch+0x18c>)
  40a5a8:	47a8      	blx	r5
						mb_instance[i].mb_frame_buff_count++;
  40a5aa:	7c23      	ldrb	r3, [r4, #16]
  40a5ac:	4621      	mov	r1, r4
						mb_add_crc(mb_instance[i].mb_channel_frame_buff, &mb_instance[i].mb_frame_buff_count);
  40a5ae:	f104 0014 	add.w	r0, r4, #20
  40a5b2:	4a2c      	ldr	r2, [pc, #176]	; (40a664 <mb_dispatch+0x190>)
						mb_instance[i].mb_frame_buff_count++;
  40a5b4:	3301      	adds	r3, #1
  40a5b6:	f801 3f10 	strb.w	r3, [r1, #16]!
						mb_add_crc(mb_instance[i].mb_channel_frame_buff, &mb_instance[i].mb_frame_buff_count);
  40a5ba:	4790      	blx	r2
  40a5bc:	e7d4      	b.n	40a568 <mb_dispatch+0x94>
					if (mb_instance[i].buff_size == 1)
  40a5be:	2b01      	cmp	r3, #1
  40a5c0:	d036      	beq.n	40a630 <mb_dispatch+0x15c>
						mb_write_mhreg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].buff_size, &mb_instance[i].mb_buff[0]);
  40a5c2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  40a5c4:	4928      	ldr	r1, [pc, #160]	; (40a668 <mb_dispatch+0x194>)
  40a5c6:	9000      	str	r0, [sp, #0]
  40a5c8:	f894 2077 	ldrb.w	r2, [r4, #119]	; 0x77
  40a5cc:	1d48      	adds	r0, r1, #5
  40a5ce:	4d24      	ldr	r5, [pc, #144]	; (40a660 <mb_dispatch+0x18c>)
  40a5d0:	47a8      	blx	r5
					mb_instance[i].mb_frame_buff_count++;
  40a5d2:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
					mb_add_crc(mb_instance[i].mb_channel_frame_buff, &mb_instance[i].mb_frame_buff_count);
  40a5d6:	4924      	ldr	r1, [pc, #144]	; (40a668 <mb_dispatch+0x194>)
					mb_instance[i].mb_frame_buff_count++;
  40a5d8:	3301      	adds	r3, #1
					mb_add_crc(mb_instance[i].mb_channel_frame_buff, &mb_instance[i].mb_frame_buff_count);
  40a5da:	4a22      	ldr	r2, [pc, #136]	; (40a664 <mb_dispatch+0x190>)
  40a5dc:	1d08      	adds	r0, r1, #4
					mb_instance[i].mb_frame_buff_count++;
  40a5de:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
					mb_add_crc(mb_instance[i].mb_channel_frame_buff, &mb_instance[i].mb_frame_buff_count);
  40a5e2:	4790      	blx	r2
  40a5e4:	e795      	b.n	40a512 <mb_dispatch+0x3e>
					mb_read_hreg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].buff_size);
  40a5e6:	7be2      	ldrb	r2, [r4, #15]
  40a5e8:	f104 0110 	add.w	r1, r4, #16
  40a5ec:	f104 0015 	add.w	r0, r4, #21
  40a5f0:	4d1e      	ldr	r5, [pc, #120]	; (40a66c <mb_dispatch+0x198>)
						mb_write_hreg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].mb_buff[0]);
  40a5f2:	47a8      	blx	r5
  40a5f4:	e7d9      	b.n	40a5aa <mb_dispatch+0xd6>
					mb_read_hreg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].buff_size);
  40a5f6:	491c      	ldr	r1, [pc, #112]	; (40a668 <mb_dispatch+0x194>)
  40a5f8:	f894 2077 	ldrb.w	r2, [r4, #119]	; 0x77
  40a5fc:	1d48      	adds	r0, r1, #5
  40a5fe:	4d1b      	ldr	r5, [pc, #108]	; (40a66c <mb_dispatch+0x198>)
					mb_read_ireg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].buff_size);
  40a600:	47a8      	blx	r5
  40a602:	e7e6      	b.n	40a5d2 <mb_dispatch+0xfe>
  40a604:	7be2      	ldrb	r2, [r4, #15]
  40a606:	f104 0110 	add.w	r1, r4, #16
  40a60a:	f104 0015 	add.w	r0, r4, #21
  40a60e:	4d18      	ldr	r5, [pc, #96]	; (40a670 <mb_dispatch+0x19c>)
  40a610:	e7ef      	b.n	40a5f2 <mb_dispatch+0x11e>
  40a612:	4915      	ldr	r1, [pc, #84]	; (40a668 <mb_dispatch+0x194>)
  40a614:	f894 2077 	ldrb.w	r2, [r4, #119]	; 0x77
  40a618:	1d48      	adds	r0, r1, #5
  40a61a:	4d15      	ldr	r5, [pc, #84]	; (40a670 <mb_dispatch+0x19c>)
  40a61c:	e7f0      	b.n	40a600 <mb_dispatch+0x12c>
						mb_write_hreg(&mb_instance[i].mb_channel_frame_buff[1], &mb_instance[i].mb_frame_buff_count, mb_instance[i].mb_start_add, mb_instance[i].mb_buff[0]);
  40a61e:	6863      	ldr	r3, [r4, #4]
  40a620:	f104 0110 	add.w	r1, r4, #16
  40a624:	7be2      	ldrb	r2, [r4, #15]
  40a626:	f104 0015 	add.w	r0, r4, #21
  40a62a:	881b      	ldrh	r3, [r3, #0]
  40a62c:	4d11      	ldr	r5, [pc, #68]	; (40a674 <mb_dispatch+0x1a0>)
  40a62e:	e7e0      	b.n	40a5f2 <mb_dispatch+0x11e>
  40a630:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  40a632:	490d      	ldr	r1, [pc, #52]	; (40a668 <mb_dispatch+0x194>)
  40a634:	881b      	ldrh	r3, [r3, #0]
  40a636:	1d48      	adds	r0, r1, #5
  40a638:	f894 2077 	ldrb.w	r2, [r4, #119]	; 0x77
  40a63c:	4d0d      	ldr	r5, [pc, #52]	; (40a674 <mb_dispatch+0x1a0>)
  40a63e:	e7df      	b.n	40a600 <mb_dispatch+0x12c>
  40a640:	204053d4 	.word	0x204053d4
  40a644:	20405450 	.word	0x20405450
  40a648:	00409ff5 	.word	0x00409ff5
  40a64c:	20405471 	.word	0x20405471
  40a650:	0040a049 	.word	0x0040a049
  40a654:	00412661 	.word	0x00412661
  40a658:	204053e8 	.word	0x204053e8
  40a65c:	20405409 	.word	0x20405409
  40a660:	0040a381 	.word	0x0040a381
  40a664:	0040a3f9 	.word	0x0040a3f9
  40a668:	2040544c 	.word	0x2040544c
  40a66c:	0040a0fd 	.word	0x0040a0fd
  40a670:	0040a171 	.word	0x0040a171
  40a674:	0040a355 	.word	0x0040a355

0040a678 <mb_handler>:
{
  40a678:	b510      	push	{r4, lr}
	mb_dispatch();
  40a67a:	4b07      	ldr	r3, [pc, #28]	; (40a698 <mb_handler+0x20>)
  40a67c:	4798      	blx	r3
	mb_states_master_waiting_for_reply_handler();
  40a67e:	4b07      	ldr	r3, [pc, #28]	; (40a69c <mb_handler+0x24>)
  40a680:	4798      	blx	r3
	mb_states_master_process_reply_handler();
  40a682:	4b07      	ldr	r3, [pc, #28]	; (40a6a0 <mb_handler+0x28>)
  40a684:	4798      	blx	r3
	mb_states_master_process_noreply_handler();
  40a686:	4b07      	ldr	r3, [pc, #28]	; (40a6a4 <mb_handler+0x2c>)
  40a688:	4798      	blx	r3
	mb_states_master_delay_to_ready();
  40a68a:	4b07      	ldr	r3, [pc, #28]	; (40a6a8 <mb_handler+0x30>)
  40a68c:	4798      	blx	r3
	mb_load_handler();
  40a68e:	4b07      	ldr	r3, [pc, #28]	; (40a6ac <mb_handler+0x34>)
}
  40a690:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mb_load_handler();
  40a694:	4718      	bx	r3
  40a696:	bf00      	nop
  40a698:	0040a4d5 	.word	0x0040a4d5
  40a69c:	0040a1e5 	.word	0x0040a1e5
  40a6a0:	0040a25d 	.word	0x0040a25d
  40a6a4:	0040a2e1 	.word	0x0040a2e1
  40a6a8:	0040a315 	.word	0x0040a315
  40a6ac:	0040a7e9 	.word	0x0040a7e9

0040a6b0 <mb_init>:
void mb_init(void)
{
	uint32_t i;
	for (i=0; i<MB_CHANNEL_COUNT; i++)
	{
		mb_instance[i].entry_type = MB_NONE;
  40a6b0:	4b09      	ldr	r3, [pc, #36]	; (40a6d8 <mb_init+0x28>)
  40a6b2:	2200      	movs	r2, #0
		mb_instance[i].channel_enabled = 0; //disable all channels
		mb_instance[i].mb_usart = 0; // assign empty usart
		mb_instance[i].mb_channel_status = 0;
		mb_instance[i].mb_machine_state = MB_MACHINE_STATE_READY_TO_LOAD;
	}
	mb_transaction_init();
  40a6b4:	4909      	ldr	r1, [pc, #36]	; (40a6dc <mb_init+0x2c>)
		mb_instance[i].entry_type = MB_NONE;
  40a6b6:	701a      	strb	r2, [r3, #0]
		mb_instance[i].channel_enabled = 0; //disable all channels
  40a6b8:	749a      	strb	r2, [r3, #18]
		mb_instance[i].mb_usart = 0; // assign empty usart
  40a6ba:	659a      	str	r2, [r3, #88]	; 0x58
		mb_instance[i].mb_channel_status = 0;
  40a6bc:	65da      	str	r2, [r3, #92]	; 0x5c
		mb_instance[i].mb_machine_state = MB_MACHINE_STATE_READY_TO_LOAD;
  40a6be:	739a      	strb	r2, [r3, #14]
		mb_instance[i].entry_type = MB_NONE;
  40a6c0:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		mb_instance[i].channel_enabled = 0; //disable all channels
  40a6c4:	f883 207a 	strb.w	r2, [r3, #122]	; 0x7a
		mb_instance[i].mb_usart = 0; // assign empty usart
  40a6c8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		mb_instance[i].mb_channel_status = 0;
  40a6cc:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		mb_instance[i].mb_machine_state = MB_MACHINE_STATE_READY_TO_LOAD;
  40a6d0:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
	mb_transaction_init();
  40a6d4:	4708      	bx	r1
  40a6d6:	bf00      	nop
  40a6d8:	204053d4 	.word	0x204053d4
  40a6dc:	0040a745 	.word	0x0040a745

0040a6e0 <mb_channel_init>:
}

void mb_channel_init(uint32_t mb_channel_no, Usart *mb_usart, sam_usart_opt_t *usart_setting, uint32_t usart_id, uint32_t ch_master, uint16_t turn_around_val, uint32_t reply_timeout_val)
{
	if(mb_channel_no >= MB_CHANNEL_COUNT) return 0;//error
  40a6e0:	2801      	cmp	r0, #1
{
  40a6e2:	b5f0      	push	{r4, r5, r6, r7, lr}
  40a6e4:	9e05      	ldr	r6, [sp, #20]
  40a6e6:	f8bd e018 	ldrh.w	lr, [sp, #24]
  40a6ea:	9f07      	ldr	r7, [sp, #28]
	if(mb_channel_no >= MB_CHANNEL_COUNT) return 0;//error
  40a6ec:	d900      	bls.n	40a6f0 <mb_channel_init+0x10>
  40a6ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
	
	mb_instance[mb_channel_no].mb_usart = mb_usart;
  40a6f0:	2468      	movs	r4, #104	; 0x68
  40a6f2:	4615      	mov	r5, r2
  40a6f4:	4a0d      	ldr	r2, [pc, #52]	; (40a72c <mb_channel_init+0x4c>)
	mb_instance[mb_channel_no].channel_enabled = 1;
  40a6f6:	f04f 0c01 	mov.w	ip, #1
	mb_instance[mb_channel_no].mb_usart = mb_usart;
  40a6fa:	fb04 2200 	mla	r2, r4, r0, r2
	mb_instance[mb_channel_no].buff_size = 0;
  40a6fe:	2400      	movs	r4, #0
	mb_instance[mb_channel_no].mb_usart = mb_usart;
  40a700:	6591      	str	r1, [r2, #88]	; 0x58
	mb_instance[mb_channel_no].mb_buff = 0;
	mb_instance[mb_channel_no].mb_channel_status = MB_CHANNEL_STATUS_OK; //set status ok
	mb_instance[mb_channel_no].mb_turnaround_timer_value = turn_around_val;
  40a702:	f8a2 e00a 	strh.w	lr, [r2, #10]
	mb_instance[mb_channel_no].mb_wait_reply_timer_value = reply_timeout_val;
  40a706:	8197      	strh	r7, [r2, #12]
	mb_instance[mb_channel_no].channel_enabled = 1;
  40a708:	f882 c012 	strb.w	ip, [r2, #18]
	mb_instance[mb_channel_no].mb_channel_status = MB_CHANNEL_STATUS_OK; //set status ok
  40a70c:	f8c2 c05c 	str.w	ip, [r2, #92]	; 0x5c
	mb_instance[mb_channel_no].buff_size = 0;
  40a710:	7454      	strb	r4, [r2, #17]
	mb_instance[mb_channel_no].mb_buff = 0;
  40a712:	6054      	str	r4, [r2, #4]
	mb_instance[mb_channel_no].reply_sub = 0;
  40a714:	6654      	str	r4, [r2, #100]	; 0x64
	if(ch_master) mb_instance[mb_channel_no].mb_channel_status |= MB_CHANNEL_STATUS_Master; //set status ok
  40a716:	b10e      	cbz	r6, 40a71c <mb_channel_init+0x3c>
  40a718:	2003      	movs	r0, #3
  40a71a:	65d0      	str	r0, [r2, #92]	; 0x5c
	mb_port_init(usart_id, usart_setting, mb_usart);
  40a71c:	460a      	mov	r2, r1
  40a71e:	4618      	mov	r0, r3
  40a720:	4629      	mov	r1, r5
  40a722:	4b03      	ldr	r3, [pc, #12]	; (40a730 <mb_channel_init+0x50>)
}
  40a724:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	mb_port_init(usart_id, usart_setting, mb_usart);
  40a728:	4718      	bx	r3
  40a72a:	bf00      	nop
  40a72c:	204053d4 	.word	0x204053d4
  40a730:	00409f29 	.word	0x00409f29

0040a734 <mb_chanel_add_reply_sub>:
	else return 0;
}

void mb_chanel_add_reply_sub(uint32_t mb_channel_no, void (*reply_sub)(uint32_t slave_add))
{
	mb_instance[mb_channel_no].reply_sub = reply_sub;
  40a734:	4a02      	ldr	r2, [pc, #8]	; (40a740 <mb_chanel_add_reply_sub+0xc>)
  40a736:	2368      	movs	r3, #104	; 0x68
  40a738:	fb03 2000 	mla	r0, r3, r0, r2
  40a73c:	6641      	str	r1, [r0, #100]	; 0x64
  40a73e:	4770      	bx	lr
  40a740:	204053d4 	.word	0x204053d4

0040a744 <mb_transaction_init>:
void mb_transaction_init(void)
{
	uint32_t i;
	for(i=0; i<MODBUS_TRANSACTION_BUFFER_MAX; i++)
	{
		transactions_buffers[i].transaction_empty = 1;
  40a744:	4b06      	ldr	r3, [pc, #24]	; (40a760 <mb_transaction_init+0x1c>)
  40a746:	2201      	movs	r2, #1
		//empty all transaction buffer	
	}
	for (i=0; i<MB_CHANNEL_COUNT; i++)
	{
		mb_channel_transaction_pending_count[i]=0;
  40a748:	4906      	ldr	r1, [pc, #24]	; (40a764 <mb_transaction_init+0x20>)
  40a74a:	2000      	movs	r0, #0
		transactions_buffers[i].transaction_empty = 1;
  40a74c:	741a      	strb	r2, [r3, #16]
  40a74e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  40a752:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  40a756:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		mb_channel_transaction_pending_count[i]=0;
  40a75a:	7008      	strb	r0, [r1, #0]
  40a75c:	7048      	strb	r0, [r1, #1]
  40a75e:	4770      	bx	lr
  40a760:	204054a8 	.word	0x204054a8
  40a764:	204054a4 	.word	0x204054a4

0040a768 <mb_add_transaction>:


uint32_t mb_add_transaction(uint32_t mb_channel, modbus_transaction_t *transaction)
{
	uint32_t i;
	if(mb_channel >= MB_CHANNEL_COUNT) return MB_ADD_TRANSACTION_NO_SUCH_CHANNEL;
  40a768:	2801      	cmp	r0, #1
  40a76a:	d901      	bls.n	40a770 <mb_add_transaction+0x8>
  40a76c:	2003      	movs	r0, #3
  40a76e:	4770      	bx	lr
  40a770:	4603      	mov	r3, r0
	else if(mb_instance[mb_channel].channel_enabled == 0) return MB_ADD_TRANSACTION_CHANNEL_IS_NOT_INITIALIZED;
  40a772:	2268      	movs	r2, #104	; 0x68
  40a774:	4819      	ldr	r0, [pc, #100]	; (40a7dc <mb_add_transaction+0x74>)
  40a776:	fb02 0203 	mla	r2, r2, r3, r0
  40a77a:	7c92      	ldrb	r2, [r2, #18]
  40a77c:	b90a      	cbnz	r2, 40a782 <mb_add_transaction+0x1a>
  40a77e:	2004      	movs	r0, #4
  40a780:	4770      	bx	lr
{
  40a782:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (mb_channel_transaction_pending_count[mb_channel] >= (MODBUS_TRANSACTION_BUFFER_MAX / MB_CHANNEL_COUNT) ) return MB_ADD_TRANSACTION_BUFF_FULL;
  40a784:	4e16      	ldr	r6, [pc, #88]	; (40a7e0 <mb_add_transaction+0x78>)
  40a786:	5cf2      	ldrb	r2, [r6, r3]
  40a788:	2a01      	cmp	r2, #1
  40a78a:	d901      	bls.n	40a790 <mb_add_transaction+0x28>
  40a78c:	2002      	movs	r0, #2
			return MB_ADD_TRANSACTION_SUCCESS;
		}
	}
	
	return MB_ADD_TRANSACTION_BUFF_FULL;		
}
  40a78e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40a790:	4f14      	ldr	r7, [pc, #80]	; (40a7e4 <mb_add_transaction+0x7c>)
	if (mb_channel_transaction_pending_count[mb_channel] >= (MODBUS_TRANSACTION_BUFFER_MAX / MB_CHANNEL_COUNT) ) return MB_ADD_TRANSACTION_BUFF_FULL;
  40a792:	2400      	movs	r4, #0
  40a794:	463d      	mov	r5, r7
		if(transactions_buffers[i].transaction_empty == 1)
  40a796:	7c28      	ldrb	r0, [r5, #16]
  40a798:	3514      	adds	r5, #20
  40a79a:	2801      	cmp	r0, #1
  40a79c:	d003      	beq.n	40a7a6 <mb_add_transaction+0x3e>
	for(i=0; i<MODBUS_TRANSACTION_BUFFER_MAX; i++)
  40a79e:	3401      	adds	r4, #1
  40a7a0:	2c04      	cmp	r4, #4
  40a7a2:	d1f8      	bne.n	40a796 <mb_add_transaction+0x2e>
  40a7a4:	e7f2      	b.n	40a78c <mb_add_transaction+0x24>
			transactions_buffers[i].transaction_empty = 0;
  40a7a6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  40a7aa:	f04f 0e00 	mov.w	lr, #0
			mb_channel_transaction_pending_count[mb_channel]++; //increment the channel buffer count
  40a7ae:	3201      	adds	r2, #1
			transactions_buffers[i].transaction_empty = 0;
  40a7b0:	00a4      	lsls	r4, r4, #2
  40a7b2:	193d      	adds	r5, r7, r4
			transactions_buffers[i].mb_channel = mb_channel;
  40a7b4:	73ab      	strb	r3, [r5, #14]
			transactions_buffers[i].transaction_empty = 0;
  40a7b6:	f885 e010 	strb.w	lr, [r5, #16]
			transactions_buffers[i].entry_type = transaction->entry_type;
  40a7ba:	f891 c000 	ldrb.w	ip, [r1]
			mb_channel_transaction_pending_count[mb_channel]++; //increment the channel buffer count
  40a7be:	54f2      	strb	r2, [r6, r3]
			transactions_buffers[i].entry_type = transaction->entry_type;
  40a7c0:	f807 c004 	strb.w	ip, [r7, r4]
			transactions_buffers[i].buff_size = transaction->buff_size;
  40a7c4:	7a4b      	ldrb	r3, [r1, #9]
  40a7c6:	736b      	strb	r3, [r5, #13]
			transactions_buffers[i].mb_data_buff = transaction->data_buff;
  40a7c8:	684b      	ldr	r3, [r1, #4]
  40a7ca:	60ab      	str	r3, [r5, #8]
			transactions_buffers[i].mb_start_add = transaction->start_add;
  40a7cc:	7a0b      	ldrb	r3, [r1, #8]
  40a7ce:	732b      	strb	r3, [r5, #12]
			transactions_buffers[i].slave_add = transaction->slave_add;
  40a7d0:	7a8b      	ldrb	r3, [r1, #10]
			transactions_buffers[i].time_lapse = 0;
  40a7d2:	f8c5 e004 	str.w	lr, [r5, #4]
			transactions_buffers[i].slave_add = transaction->slave_add;
  40a7d6:	73eb      	strb	r3, [r5, #15]
			return MB_ADD_TRANSACTION_SUCCESS;
  40a7d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40a7da:	bf00      	nop
  40a7dc:	204053d4 	.word	0x204053d4
  40a7e0:	204054a4 	.word	0x204054a4
  40a7e4:	204054a8 	.word	0x204054a8

0040a7e8 <mb_load_handler>:
void mb_load_handler(void)
{
  40a7e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40a7ec:	4c30      	ldr	r4, [pc, #192]	; (40a8b0 <mb_load_handler+0xc8>)
  40a7ee:	f104 0150 	add.w	r1, r4, #80	; 0x50
  40a7f2:	4626      	mov	r6, r4
  40a7f4:	4623      	mov	r3, r4
	uint32_t i,j, selected_buffer, largest_buffer_time_lapse;
	
	for (j=0; j<MODBUS_TRANSACTION_BUFFER_MAX; j++)
	{
		if (!(transactions_buffers[j].transaction_empty))
  40a7f6:	7c1a      	ldrb	r2, [r3, #16]
  40a7f8:	b92a      	cbnz	r2, 40a806 <mb_load_handler+0x1e>
		{
			//increment time lapse
			if(transactions_buffers[j].time_lapse < 0xFFFFFFFF) transactions_buffers[j].time_lapse++;
  40a7fa:	685a      	ldr	r2, [r3, #4]
  40a7fc:	1c50      	adds	r0, r2, #1
  40a7fe:	f102 0201 	add.w	r2, r2, #1
  40a802:	bf18      	it	ne
  40a804:	605a      	strne	r2, [r3, #4]
  40a806:	3314      	adds	r3, #20
	for (j=0; j<MODBUS_TRANSACTION_BUFFER_MAX; j++)
  40a808:	428b      	cmp	r3, r1
  40a80a:	d1f4      	bne.n	40a7f6 <mb_load_handler+0xe>
  40a80c:	4929      	ldr	r1, [pc, #164]	; (40a8b4 <mb_load_handler+0xcc>)
  40a80e:	2200      	movs	r2, #0
  40a810:	4b29      	ldr	r3, [pc, #164]	; (40a8b8 <mb_load_handler+0xd0>)
				mb_instance[i].entry_type = transactions_buffers[selected_buffer].entry_type;
				mb_instance[i].buff_size = transactions_buffers[selected_buffer].buff_size;
				mb_instance[i].mb_start_add = transactions_buffers[selected_buffer].mb_start_add;
				mb_instance[i].mb_channel_frame_buff[0] = transactions_buffers[selected_buffer].slave_add;
				mb_instance[i].mb_buff = transactions_buffers[selected_buffer].mb_data_buff;
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_IDLE;
  40a812:	f04f 0c01 	mov.w	ip, #1
		if(mb_channel_transaction_pending_count[i] == 0) continue; //if there is no data pending exit
  40a816:	7808      	ldrb	r0, [r1, #0]
  40a818:	b120      	cbz	r0, 40a824 <mb_load_handler+0x3c>
		if (mb_instance[i].mb_machine_state == MB_MACHINE_STATE_READY_TO_LOAD)
  40a81a:	7b9d      	ldrb	r5, [r3, #14]
  40a81c:	b915      	cbnz	r5, 40a824 <mb_load_handler+0x3c>
		if (mb_instance[i].channel_enabled == 1)//modbus channel is enable
  40a81e:	7c9f      	ldrb	r7, [r3, #18]
  40a820:	2f01      	cmp	r7, #1
  40a822:	d006      	beq.n	40a832 <mb_load_handler+0x4a>
	for (i=0; i<MB_CHANNEL_COUNT; i++)
  40a824:	3201      	adds	r2, #1
  40a826:	3101      	adds	r1, #1
  40a828:	3368      	adds	r3, #104	; 0x68
  40a82a:	2a02      	cmp	r2, #2
  40a82c:	d1f3      	bne.n	40a816 <mb_load_handler+0x2e>
				mb_channel_transaction_pending_count[i]--; //decrement the channel buffer count
			}
		} 
	}
		
  40a82e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40a832:	4627      	mov	r7, r4
  40a834:	f04f 39ff 	mov.w	r9, #4294967295
  40a838:	46ae      	mov	lr, r5
				if (transactions_buffers[j].buff_size > 0)//there is data in this buffer space
  40a83a:	f897 800d 	ldrb.w	r8, [r7, #13]
  40a83e:	f1b8 0f00 	cmp.w	r8, #0
  40a842:	d003      	beq.n	40a84c <mb_load_handler+0x64>
				if (transactions_buffers[j].mb_channel == i) //same channel data found
  40a844:	f897 800e 	ldrb.w	r8, [r7, #14]
  40a848:	4590      	cmp	r8, r2
  40a84a:	d025      	beq.n	40a898 <mb_load_handler+0xb0>
			for (j=0; j<MODBUS_TRANSACTION_BUFFER_MAX; j++)
  40a84c:	f10e 0e01 	add.w	lr, lr, #1
  40a850:	3714      	adds	r7, #20
  40a852:	f1be 0f04 	cmp.w	lr, #4
  40a856:	d1f0      	bne.n	40a83a <mb_load_handler+0x52>
			if (selected_buffer != 0xFFFFFFFF)
  40a858:	f1b9 3fff 	cmp.w	r9, #4294967295
  40a85c:	d0e2      	beq.n	40a824 <mb_load_handler+0x3c>
				mb_instance[i].entry_type = transactions_buffers[selected_buffer].entry_type;
  40a85e:	eb09 0989 	add.w	r9, r9, r9, lsl #2
				mb_instance[i].mb_channel_status &= MB_CHANNEL_STATUS_OK|MB_CHANNEL_STATUS_Master;
  40a862:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
				mb_channel_transaction_pending_count[i]--; //decrement the channel buffer count
  40a864:	3801      	subs	r0, #1
				mb_instance[i].mb_machine_state = MB_MACHINE_STATE_IDLE;
  40a866:	f883 c00e 	strb.w	ip, [r3, #14]
				mb_instance[i].entry_type = transactions_buffers[selected_buffer].entry_type;
  40a86a:	eb06 0789 	add.w	r7, r6, r9, lsl #2
  40a86e:	f816 e029 	ldrb.w	lr, [r6, r9, lsl #2]
				mb_instance[i].mb_channel_status &= MB_CHANNEL_STATUS_OK|MB_CHANNEL_STATUS_Master;
  40a872:	f005 0503 	and.w	r5, r5, #3
				mb_channel_transaction_pending_count[i]--; //decrement the channel buffer count
  40a876:	7008      	strb	r0, [r1, #0]
				mb_instance[i].buff_size = transactions_buffers[selected_buffer].buff_size;
  40a878:	7b78      	ldrb	r0, [r7, #13]
				mb_instance[i].entry_type = transactions_buffers[selected_buffer].entry_type;
  40a87a:	f883 e000 	strb.w	lr, [r3]
				mb_instance[i].mb_channel_status &= MB_CHANNEL_STATUS_OK|MB_CHANNEL_STATUS_Master;
  40a87e:	65dd      	str	r5, [r3, #92]	; 0x5c
				mb_instance[i].mb_start_add = transactions_buffers[selected_buffer].mb_start_add;
  40a880:	f897 e00c 	ldrb.w	lr, [r7, #12]
				mb_instance[i].buff_size = transactions_buffers[selected_buffer].buff_size;
  40a884:	7458      	strb	r0, [r3, #17]
				mb_instance[i].mb_channel_frame_buff[0] = transactions_buffers[selected_buffer].slave_add;
  40a886:	7bfd      	ldrb	r5, [r7, #15]
				mb_instance[i].mb_buff = transactions_buffers[selected_buffer].mb_data_buff;
  40a888:	68b8      	ldr	r0, [r7, #8]
				transactions_buffers[selected_buffer].transaction_empty = 1;
  40a88a:	f887 c010 	strb.w	ip, [r7, #16]
				mb_instance[i].mb_start_add = transactions_buffers[selected_buffer].mb_start_add;
  40a88e:	f883 e00f 	strb.w	lr, [r3, #15]
				mb_instance[i].mb_channel_frame_buff[0] = transactions_buffers[selected_buffer].slave_add;
  40a892:	751d      	strb	r5, [r3, #20]
				mb_instance[i].mb_buff = transactions_buffers[selected_buffer].mb_data_buff;
  40a894:	6058      	str	r0, [r3, #4]
  40a896:	e7c5      	b.n	40a824 <mb_load_handler+0x3c>
				if (!(transactions_buffers[j].transaction_empty))
  40a898:	f897 8010 	ldrb.w	r8, [r7, #16]
  40a89c:	f1b8 0f00 	cmp.w	r8, #0
  40a8a0:	d1d4      	bne.n	40a84c <mb_load_handler+0x64>
					if(transactions_buffers[j].time_lapse >= largest_buffer_time_lapse)
  40a8a2:	f8d7 8004 	ldr.w	r8, [r7, #4]
  40a8a6:	45a8      	cmp	r8, r5
  40a8a8:	d3d0      	bcc.n	40a84c <mb_load_handler+0x64>
  40a8aa:	4645      	mov	r5, r8
  40a8ac:	46f1      	mov	r9, lr
  40a8ae:	e7cd      	b.n	40a84c <mb_load_handler+0x64>
  40a8b0:	204054a8 	.word	0x204054a8
  40a8b4:	204054a4 	.word	0x204054a4
  40a8b8:	204053d4 	.word	0x204053d4

0040a8bc <reg_pi_change_gains>:
	regulator->imemory += val / regulator->kic;
}

void reg_pi_change_gains(float kpc, float kic, struct pi_t *regulator)
{
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8bc:	edd2 6a01 	vldr	s13, [r2, #4]
{
  40a8c0:	ee07 1a10 	vmov	s14, r1
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8c4:	edd2 7a03 	vldr	s15, [r2, #12]
	regulator->kic = kic;
	regulator->kpc = kpc;
  40a8c8:	6010      	str	r0, [r2, #0]
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8ca:	ee67 7aa6 	vmul.f32	s15, s15, s13
	regulator->kic = kic;
  40a8ce:	6051      	str	r1, [r2, #4]
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8d0:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40a8d4:	edc2 6a03 	vstr	s13, [r2, #12]
  40a8d8:	4770      	bx	lr
  40a8da:	bf00      	nop

0040a8dc <reg_pi_change_ki>:
}

void reg_pi_change_ki(float kic, struct pi_t *regulator)
{
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8dc:	edd1 6a01 	vldr	s13, [r1, #4]
{
  40a8e0:	ee07 0a10 	vmov	s14, r0
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8e4:	edd1 7a03 	vldr	s15, [r1, #12]
	regulator->kic = kic;
  40a8e8:	6048      	str	r0, [r1, #4]
	regulator->imemory = regulator->imemory * regulator->kic / kic;
  40a8ea:	ee67 7aa6 	vmul.f32	s15, s15, s13
  40a8ee:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40a8f2:	edc1 6a03 	vstr	s13, [r1, #12]
  40a8f6:	4770      	bx	lr

0040a8f8 <reg_pi_change_kp>:
}

void reg_pi_change_kp(float kpc, struct pi_t *regulator)
{
	regulator->kpc = kpc;
  40a8f8:	6008      	str	r0, [r1, #0]
  40a8fa:	4770      	bx	lr

0040a8fc <reg_pi_init>:
}

void reg_pi_init(float kpc, float kic, struct pi_t *regulator)
{
  40a8fc:	ee07 1a90 	vmov	s15, r1
	regulator->imemory = 0;
  40a900:	2300      	movs	r3, #0
	regulator->kic = kic;
  40a902:	6051      	str	r1, [r2, #4]
	if (kic == 0) kic = 1;
  40a904:	eef5 7a40 	vcmp.f32	s15, #0.0
	regulator->imemory = 0;
  40a908:	60d3      	str	r3, [r2, #12]
	if (kic == 0) kic = 1;
  40a90a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40a90e:	d105      	bne.n	40a91c <reg_pi_init+0x20>
  40a910:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
	regulator->ksc = kic * 10;
	regulator->kpc = kpc;
  40a914:	6010      	str	r0, [r2, #0]
	regulator->ksc = kic * 10;
  40a916:	edc2 7a02 	vstr	s15, [r2, #8]
	regulator->kpc = kpc;
  40a91a:	4770      	bx	lr
  40a91c:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
  40a920:	6010      	str	r0, [r2, #0]
  40a922:	ee67 7a87 	vmul.f32	s15, s15, s14
	regulator->ksc = kic * 10;
  40a926:	edc2 7a02 	vstr	s15, [r2, #8]
	regulator->kpc = kpc;
  40a92a:	4770      	bx	lr

0040a92c <reg_pi_reset_memory>:
}

void reg_pi_reset_memory(struct pi_t *regulator)
{
	regulator->imemory = 0;
  40a92c:	2300      	movs	r3, #0
  40a92e:	60c3      	str	r3, [r0, #12]
  40a930:	4770      	bx	lr
  40a932:	bf00      	nop

0040a934 <reg_pi_exe>:
// 	}
// 	return reg_out;
//}

float reg_pi_exe(float sat_limit, float err, float ff, float reg_tsample, struct pi_t *regulator)
{
  40a934:	b410      	push	{r4}
  40a936:	9c01      	ldr	r4, [sp, #4]
  40a938:	ee07 1a10 	vmov	s14, r1
	float reg_out, correction, ff_kp_contributiona, ks, temp_memory = regulator->imemory;
	
	temp_memory += (reg_tsample * err); //integrate controller
	
	reg_out = (temp_memory * regulator->kic);
	ff_kp_contributiona = (regulator->kpc * err) + ff;
  40a93c:	ee04 2a90 	vmov	s9, r2
	temp_memory += (reg_tsample * err); //integrate controller
  40a940:	ee05 3a10 	vmov	s10, r3
	ff_kp_contributiona = (regulator->kpc * err) + ff;
  40a944:	edd4 7a00 	vldr	s15, [r4]
{
  40a948:	ee05 0a90 	vmov	s11, r0
	float reg_out, correction, ff_kp_contributiona, ks, temp_memory = regulator->imemory;
  40a94c:	edd4 6a03 	vldr	s13, [r4, #12]
	ff_kp_contributiona = (regulator->kpc * err) + ff;
  40a950:	eee7 4a27 	vfma.f32	s9, s14, s15
	temp_memory += (reg_tsample * err); //integrate controller
  40a954:	eeb0 6a66 	vmov.f32	s12, s13
  40a958:	eea5 6a07 	vfma.f32	s12, s10, s14
	//ff_kp_contributiona = 0;
	reg_out += ff_kp_contributiona;
  40a95c:	ed94 5a01 	vldr	s10, [r4, #4]
	ff_kp_contributiona = (regulator->kpc * err) + ff;
  40a960:	eef0 7a64 	vmov.f32	s15, s9
	reg_out += ff_kp_contributiona;
  40a964:	eee6 7a05 	vfma.f32	s15, s12, s10
	
	if (fixedpt_abs(reg_out) > sat_limit)
  40a968:	eeb0 5ae7 	vabs.f32	s10, s15
  40a96c:	eeb4 5ae5 	vcmpe.f32	s10, s11
  40a970:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40a974:	dd1c      	ble.n	40a9b0 <reg_pi_exe+0x7c>
	{
		correction = reg_sign(reg_out)*sat_limit - reg_out;
  40a976:	eef5 7ac0 	vcmpe.f32	s15, #0.0
		//if(regulator->kic != 0)
		//temp_memory += correction / regulator->ksc; // decrease integrator memory (anti windup)
		if( (reg_out * err) > 0 ) temp_memory -= (reg_tsample * err); //stop integration if output saturates
  40a97a:	ee27 7a27 	vmul.f32	s14, s14, s15
		correction = reg_sign(reg_out)*sat_limit - reg_out;
  40a97e:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
  40a982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40a986:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
	temp_memory += (reg_tsample * err); //integrate controller
  40a98a:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
		correction = reg_sign(reg_out)*sat_limit - reg_out;
  40a98e:	bf58      	it	pl
  40a990:	eef0 7a45 	vmovpl.f32	s15, s10
	temp_memory += (reg_tsample * err); //integrate controller
  40a994:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		correction = reg_sign(reg_out)*sat_limit - reg_out;
  40a998:	ee67 7aa5 	vmul.f32	s15, s15, s11
	temp_memory += (reg_tsample * err); //integrate controller
  40a99c:	bfd8      	it	le
  40a99e:	eef0 6a46 	vmovle.f32	s13, s12
		regulator->imemory = temp_memory;
		return reg_sign(reg_out)*sat_limit;
	}
	regulator->imemory = temp_memory;
	return reg_out;
  40a9a2:	ee17 0a90 	vmov	r0, s15
		regulator->imemory = temp_memory;
  40a9a6:	edc4 6a03 	vstr	s13, [r4, #12]
  40a9aa:	f85d 4b04 	ldr.w	r4, [sp], #4
  40a9ae:	4770      	bx	lr
	regulator->imemory = temp_memory;
  40a9b0:	ed84 6a03 	vstr	s12, [r4, #12]
  40a9b4:	ee17 0a90 	vmov	r0, s15
  40a9b8:	f85d 4b04 	ldr.w	r4, [sp], #4
  40a9bc:	4770      	bx	lr
  40a9be:	bf00      	nop

0040a9c0 <d_twi_reset_state>:
//tick handler for the twi task
//check the statues of the twi module(s) and write/read data if it is pending

void d_twi_reset_state(uint32_t twi_instance)
{
	twi_status[twi_instance].state = DYNAMIC_TWI_IDLE;	
  40a9c0:	4b02      	ldr	r3, [pc, #8]	; (40a9cc <d_twi_reset_state+0xc>)
  40a9c2:	2200      	movs	r2, #0
  40a9c4:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
  40a9c8:	4770      	bx	lr
  40a9ca:	bf00      	nop
  40a9cc:	204054f8 	.word	0x204054f8

0040a9d0 <d_twi_get_state>:
}

uint32_t d_twi_get_state(uint32_t twi_instance)
{
	return twi_status[twi_instance].state;
  40a9d0:	4b01      	ldr	r3, [pc, #4]	; (40a9d8 <d_twi_get_state+0x8>)
}
  40a9d2:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
  40a9d6:	4770      	bx	lr
  40a9d8:	204054f8 	.word	0x204054f8

0040a9dc <d_twi_handler>:
  40a9dc:	4770      	bx	lr
  40a9de:	bf00      	nop

0040a9e0 <dtwi_init>:
	}*/
	
}

void dtwi_init(void)
{
  40a9e0:	4770      	bx	lr
  40a9e2:	bf00      	nop

0040a9e4 <at24macxx_write_continous_modified>:
 * \return AT24MAC_WRITE_SUCCESS if single byte was written, AT24MAC_WRITE_FAIL
 * otherwise.
 */
uint32_t at24macxx_write_continous_modified(uint32_t u32_start_address,
											uint16_t u16_length, uint8_t const *p_wr_buffer)
{
  40a9e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40a9e8:	b086      	sub	sp, #24
  40a9ea:	4604      	mov	r4, r0
	twihs_package_t twihs_package;

	/* Configure the data packet to be transmitted */
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
  40a9ec:	2050      	movs	r0, #80	; 0x50
	uint8_t data = 0, retval;
  40a9ee:	2300      	movs	r3, #0
	twihs_package->buffer = &data;
  40a9f0:	f10d 0e03 	add.w	lr, sp, #3
	twihs_package->length = 1;
  40a9f4:	2501      	movs	r5, #1
{
  40a9f6:	460f      	mov	r7, r1
	twihs_package.chip = BOARD_AT24MAC_ADDRESS;
  40a9f8:	f88d 0014 	strb.w	r0, [sp, #20]
	retval = twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, twihs_package);
  40a9fc:	a901      	add	r1, sp, #4
  40a9fe:	4813      	ldr	r0, [pc, #76]	; (40aa4c <at24macxx_write_continous_modified+0x68>)
  40aa00:	4e13      	ldr	r6, [pc, #76]	; (40aa50 <at24macxx_write_continous_modified+0x6c>)
{
  40aa02:	4690      	mov	r8, r2
	at24mac_build_word_address(twihs_package.addr, u32_start_address);
  40aa04:	f88d 4005 	strb.w	r4, [sp, #5]
  40aa08:	0a24      	lsrs	r4, r4, #8
	uint8_t data = 0, retval;
  40aa0a:	f88d 3003 	strb.w	r3, [sp, #3]
	twihs_package->addr[0] = 0;
  40aa0e:	f88d 3004 	strb.w	r3, [sp, #4]
	twihs_package->addr_length = 0;
  40aa12:	9302      	str	r3, [sp, #8]
	twihs_package->buffer = &data;
  40aa14:	f8cd e00c 	str.w	lr, [sp, #12]
	twihs_package->length = 1;
  40aa18:	9504      	str	r5, [sp, #16]
	retval = twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, twihs_package);
  40aa1a:	47b0      	blx	r6
	twihs_package->addr_length = addr_length;
  40aa1c:	2302      	movs	r3, #2
	twihs_package.addr_length = AT24MAC_MEM_ADDR_LEN;
	twihs_package.buffer = p_wr_buffer;
	twihs_package.length = u16_length;

	if (at24macxx_acknowledge_check(&twihs_package))
  40aa1e:	f010 0fff 	tst.w	r0, #255	; 0xff
	twihs_package->buffer = buffer;
  40aa22:	f8cd 800c 	str.w	r8, [sp, #12]
	at24mac_build_word_address(twihs_package.addr, u32_start_address);
  40aa26:	f88d 4004 	strb.w	r4, [sp, #4]
	twihs_package.length = u16_length;
  40aa2a:	9704      	str	r7, [sp, #16]
	twihs_package->addr_length = addr_length;
  40aa2c:	9302      	str	r3, [sp, #8]
	if (at24macxx_acknowledge_check(&twihs_package))
  40aa2e:	d003      	beq.n	40aa38 <at24macxx_write_continous_modified+0x54>
	{
		return AT24MAC_WRITE_FAIL;
  40aa30:	4628      	mov	r0, r5
		return AT24MAC_WRITE_FAIL;
	}
	//at24macxx_acknowledge_polling(&twihs_package);

	return AT24MAC_WRITE_SUCCESS;
}
  40aa32:	b006      	add	sp, #24
  40aa34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (twihs_master_write(BOARD_AT24MAC_TWIHS_INSTANCE, &twihs_package) != TWIHS_SUCCESS) {
  40aa38:	a901      	add	r1, sp, #4
  40aa3a:	4804      	ldr	r0, [pc, #16]	; (40aa4c <at24macxx_write_continous_modified+0x68>)
  40aa3c:	47b0      	blx	r6
  40aa3e:	3000      	adds	r0, #0
  40aa40:	bf18      	it	ne
  40aa42:	2001      	movne	r0, #1
}
  40aa44:	b006      	add	sp, #24
  40aa46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40aa4a:	bf00      	nop
  40aa4c:	40018000 	.word	0x40018000
  40aa50:	00412415 	.word	0x00412415

0040aa54 <at24cxx_dynamic_rw_exe>:
	uint8_t *p_wr_buffer;	
	uint32_t u32_m_start_address, dyn_ret, chunk_ret;
	uint16_t u16_m_length;
	for(i=0; i<1; i++)
	{
		if (at24cxx_instance[i].at24cxx_dynamic_state == AT24CXX_DYNAMIC_HANDLER_WRITE)
  40aa54:	4b42      	ldr	r3, [pc, #264]	; (40ab60 <at24cxx_dynamic_rw_exe+0x10c>)
{
  40aa56:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (at24cxx_instance[i].at24cxx_dynamic_state == AT24CXX_DYNAMIC_HANDLER_WRITE)
  40aa5a:	781a      	ldrb	r2, [r3, #0]
  40aa5c:	2a01      	cmp	r2, #1
  40aa5e:	d003      	beq.n	40aa68 <at24cxx_dynamic_rw_exe+0x14>
					at24cxx_d_datasent = 1;
				}
				
			}
		}
		else if (at24cxx_instance[i].at24cxx_dynamic_state == AT24CXX_DYNAMIC_HANDLER_READ)
  40aa60:	2a02      	cmp	r2, #2
  40aa62:	d02b      	beq.n	40aabc <at24cxx_dynamic_rw_exe+0x68>
  40aa64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			chunk_ret = get_chunks(at24cxx_instance[i].u32_start_address, at24cxx_instance[i].u16_length,
  40aa68:	891c      	ldrh	r4, [r3, #8]
		uint8_t n, uint32_t *u32_m_start_address, uint16_t *u16_m_length, uint8_t **p_wr_buffer)
{
	uint32_t start_page_add;
	int32_t last_chunk_size_offset;
	
	if(u16_length==0)
  40aa6a:	2c00      	cmp	r4, #0
  40aa6c:	d0fa      	beq.n	40aa64 <at24cxx_dynamic_rw_exe+0x10>
			chunk_ret = get_chunks(at24cxx_instance[i].u32_start_address, at24cxx_instance[i].u16_length,
  40aa6e:	f893 e010 	ldrb.w	lr, [r3, #16]
			p_wr_buffer = at24cxx_instance[i].p_buffer;
  40aa72:	68df      	ldr	r7, [r3, #12]
			chunk_ret = get_chunks(at24cxx_instance[i].u32_start_address, at24cxx_instance[i].u16_length,
  40aa74:	685a      	ldr	r2, [r3, #4]
	{
		//return error
		return AT24CXX_DYNAMICS_CHUNKS_ERROR;
	}
	start_page_add = (u32_start_address & ~AT24CXX_DYNAMICS_PAGE_MASK);
	if (n==0)
  40aa76:	f1be 0f00 	cmp.w	lr, #0
  40aa7a:	d037      	beq.n	40aaec <at24cxx_dynamic_rw_exe+0x98>
		*u16_m_length = AT24CXX_DYNAMICS_PAGE_SIZE - (u32_start_address & AT24CXX_DYNAMICS_PAGE_MASK);
	}
	else
	{
		//subsequent chunks
		*u32_m_start_address = n * AT24CXX_DYNAMICS_PAGE_SIZE + start_page_add;
  40aa7c:	ea4f 114e 	mov.w	r1, lr, lsl #5
		/*if(n==1) */*p_wr_buffer+= n * AT24CXX_DYNAMICS_PAGE_SIZE - (u32_start_address & AT24CXX_DYNAMICS_PAGE_MASK);
  40aa80:	f002 051f 	and.w	r5, r2, #31
	start_page_add = (u32_start_address & ~AT24CXX_DYNAMICS_PAGE_MASK);
  40aa84:	f022 061f 	bic.w	r6, r2, #31
		/*if(n==1) */*p_wr_buffer+= n * AT24CXX_DYNAMICS_PAGE_SIZE - (u32_start_address & AT24CXX_DYNAMICS_PAGE_MASK);
  40aa88:	2020      	movs	r0, #32
  40aa8a:	1b4d      	subs	r5, r1, r5
		*u32_m_start_address = n * AT24CXX_DYNAMICS_PAGE_SIZE + start_page_add;
  40aa8c:	440e      	add	r6, r1
		//else *p_wr_buffer+= n * AT24CXX_DYNAMICS_PAGE_SIZE;
		*u16_m_length = AT24CXX_DYNAMICS_PAGE_SIZE;
  40aa8e:	4601      	mov	r1, r0
		/*if(n==1) */*p_wr_buffer+= n * AT24CXX_DYNAMICS_PAGE_SIZE - (u32_start_address & AT24CXX_DYNAMICS_PAGE_MASK);
  40aa90:	442f      	add	r7, r5
	}
	last_chunk_size_offset = (*u32_m_start_address + *u16_m_length) - (u32_start_address + u16_length);
  40aa92:	4414      	add	r4, r2
  40aa94:	1b04      	subs	r4, r0, r4
  40aa96:	19a0      	adds	r0, r4, r6
	if((last_chunk_size_offset < AT24CXX_DYNAMICS_PAGE_SIZE) && (last_chunk_size_offset >= 0))
  40aa98:	281f      	cmp	r0, #31
  40aa9a:	d92f      	bls.n	40aafc <at24cxx_dynamic_rw_exe+0xa8>
	{
		*u16_m_length -= last_chunk_size_offset;
		return AT24CXX_DYNAMICS_CHUNKS_END;	
	}
	else if(last_chunk_size_offset > 0){
  40aa9c:	2800      	cmp	r0, #0
  40aa9e:	dce1      	bgt.n	40aa64 <at24cxx_dynamic_rw_exe+0x10>
				if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40aaa0:	4c30      	ldr	r4, [pc, #192]	; (40ab64 <at24cxx_dynamic_rw_exe+0x110>)
  40aaa2:	7822      	ldrb	r2, [r4, #0]
  40aaa4:	2a01      	cmp	r2, #1
  40aaa6:	d049      	beq.n	40ab3c <at24cxx_dynamic_rw_exe+0xe8>
				dyn_ret = at24macxx_write_continous_modified(u32_m_start_address, u16_m_length, p_wr_buffer);
  40aaa8:	463a      	mov	r2, r7
  40aaaa:	4630      	mov	r0, r6
  40aaac:	4b2e      	ldr	r3, [pc, #184]	; (40ab68 <at24cxx_dynamic_rw_exe+0x114>)
  40aaae:	4798      	blx	r3
				if(dyn_ret == AT24C_WRITE_SUCCESS) 
  40aab0:	2800      	cmp	r0, #0
  40aab2:	d1d7      	bne.n	40aa64 <at24cxx_dynamic_rw_exe+0x10>
					at24cxx_d_datasent = 1; 
  40aab4:	2301      	movs	r3, #1
  40aab6:	7023      	strb	r3, [r4, #0]
  40aab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40aabc:	4c29      	ldr	r4, [pc, #164]	; (40ab64 <at24cxx_dynamic_rw_exe+0x110>)
			p_wr_buffer = at24cxx_instance[i].p_buffer;
  40aabe:	68df      	ldr	r7, [r3, #12]
			if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40aac0:	7820      	ldrb	r0, [r4, #0]
			u32_m_start_address = at24cxx_instance[i].u32_start_address;
  40aac2:	685d      	ldr	r5, [r3, #4]
			if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40aac4:	2801      	cmp	r0, #1
			u16_m_length = at24cxx_instance[i].u16_length;
  40aac6:	891e      	ldrh	r6, [r3, #8]
			if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40aac8:	d02f      	beq.n	40ab2a <at24cxx_dynamic_rw_exe+0xd6>
			else if((d_twi_get_state(i) == DYNAMIC_TWI_SBUSY) && (at24cxx_d_datasent == 1))
  40aaca:	2000      	movs	r0, #0
  40aacc:	4b27      	ldr	r3, [pc, #156]	; (40ab6c <at24cxx_dynamic_rw_exe+0x118>)
  40aace:	4798      	blx	r3
  40aad0:	2803      	cmp	r0, #3
  40aad2:	d102      	bne.n	40aada <at24cxx_dynamic_rw_exe+0x86>
  40aad4:	7823      	ldrb	r3, [r4, #0]
  40aad6:	2b01      	cmp	r3, #1
  40aad8:	d03b      	beq.n	40ab52 <at24cxx_dynamic_rw_exe+0xfe>
			dyn_ret = at24macxx_read_continuous(u32_m_start_address, u16_m_length, p_wr_buffer);
  40aada:	463a      	mov	r2, r7
  40aadc:	4631      	mov	r1, r6
  40aade:	4628      	mov	r0, r5
  40aae0:	4b23      	ldr	r3, [pc, #140]	; (40ab70 <at24cxx_dynamic_rw_exe+0x11c>)
  40aae2:	4798      	blx	r3
			if(dyn_ret == AT24C_READ_SUCCESS)
  40aae4:	2800      	cmp	r0, #0
  40aae6:	d0e5      	beq.n	40aab4 <at24cxx_dynamic_rw_exe+0x60>
  40aae8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*u16_m_length = AT24CXX_DYNAMICS_PAGE_SIZE - (u32_start_address & AT24CXX_DYNAMICS_PAGE_MASK);
  40aaec:	f002 011f 	and.w	r1, r2, #31
		*u32_m_start_address = u32_start_address;
  40aaf0:	4616      	mov	r6, r2
		*u16_m_length = AT24CXX_DYNAMICS_PAGE_SIZE - (u32_start_address & AT24CXX_DYNAMICS_PAGE_MASK);
  40aaf2:	f1c1 0020 	rsb	r0, r1, #32
  40aaf6:	b281      	uxth	r1, r0
  40aaf8:	4608      	mov	r0, r1
  40aafa:	e7ca      	b.n	40aa92 <at24cxx_dynamic_rw_exe+0x3e>
				if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40aafc:	4c19      	ldr	r4, [pc, #100]	; (40ab64 <at24cxx_dynamic_rw_exe+0x110>)
		*u16_m_length -= last_chunk_size_offset;
  40aafe:	1a08      	subs	r0, r1, r0
				if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40ab00:	7822      	ldrb	r2, [r4, #0]
		*u16_m_length -= last_chunk_size_offset;
  40ab02:	b285      	uxth	r5, r0
				if(1/*(d_twi_get_state(i) == DYNAMIC_TWI_TCOM)*/ && (at24cxx_d_datasent == 1))
  40ab04:	2a01      	cmp	r2, #1
  40ab06:	d010      	beq.n	40ab2a <at24cxx_dynamic_rw_exe+0xd6>
				else if((d_twi_get_state(i) == DYNAMIC_TWI_SBUSY) && (at24cxx_d_datasent == 1))
  40ab08:	2000      	movs	r0, #0
  40ab0a:	4b18      	ldr	r3, [pc, #96]	; (40ab6c <at24cxx_dynamic_rw_exe+0x118>)
  40ab0c:	4798      	blx	r3
  40ab0e:	2803      	cmp	r0, #3
  40ab10:	d102      	bne.n	40ab18 <at24cxx_dynamic_rw_exe+0xc4>
  40ab12:	7823      	ldrb	r3, [r4, #0]
  40ab14:	2b01      	cmp	r3, #1
  40ab16:	d01c      	beq.n	40ab52 <at24cxx_dynamic_rw_exe+0xfe>
				dyn_ret = at24macxx_write_continuous(u32_m_start_address, u16_m_length, p_wr_buffer);
  40ab18:	463a      	mov	r2, r7
  40ab1a:	4629      	mov	r1, r5
  40ab1c:	4630      	mov	r0, r6
  40ab1e:	4b15      	ldr	r3, [pc, #84]	; (40ab74 <at24cxx_dynamic_rw_exe+0x120>)
  40ab20:	4798      	blx	r3
				if(dyn_ret == AT24C_WRITE_SUCCESS)
  40ab22:	2800      	cmp	r0, #0
  40ab24:	d0c6      	beq.n	40aab4 <at24cxx_dynamic_rw_exe+0x60>
  40ab26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					at24cxx_instance[i].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_IDLE;
  40ab2a:	2200      	movs	r2, #0
					d_twi_reset_state(i);
  40ab2c:	4912      	ldr	r1, [pc, #72]	; (40ab78 <at24cxx_dynamic_rw_exe+0x124>)
					at24cxx_instance[i].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_IDLE;
  40ab2e:	701a      	strb	r2, [r3, #0]
					d_twi_reset_state(i);
  40ab30:	4610      	mov	r0, r2
					at24cxx_instance[i].n = 0;
  40ab32:	741a      	strb	r2, [r3, #16]
					at24cxx_d_datasent = 0;
  40ab34:	7022      	strb	r2, [r4, #0]
}
  40ab36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					d_twi_reset_state(i);
  40ab3a:	4708      	bx	r1
					at24cxx_d_datasent = 0;
  40ab3c:	2200      	movs	r2, #0
					at24cxx_instance[i].n++;
  40ab3e:	f10e 0e01 	add.w	lr, lr, #1
					d_twi_reset_state(i);
  40ab42:	490d      	ldr	r1, [pc, #52]	; (40ab78 <at24cxx_dynamic_rw_exe+0x124>)
					at24cxx_instance[i].n++;
  40ab44:	f883 e010 	strb.w	lr, [r3, #16]
					d_twi_reset_state(i);
  40ab48:	4610      	mov	r0, r2
					at24cxx_d_datasent = 0;
  40ab4a:	7022      	strb	r2, [r4, #0]
}
  40ab4c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					d_twi_reset_state(i);
  40ab50:	4708      	bx	r1
					at24cxx_d_datasent = 0;
  40ab52:	2300      	movs	r3, #0
					d_twi_reset_state(i);
  40ab54:	4a08      	ldr	r2, [pc, #32]	; (40ab78 <at24cxx_dynamic_rw_exe+0x124>)
					at24cxx_d_datasent = 0;
  40ab56:	7023      	strb	r3, [r4, #0]
					d_twi_reset_state(i);
  40ab58:	4618      	mov	r0, r3
}
  40ab5a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					d_twi_reset_state(i);
  40ab5e:	4710      	bx	r2
  40ab60:	20405508 	.word	0x20405508
  40ab64:	204008ec 	.word	0x204008ec
  40ab68:	0040a9e5 	.word	0x0040a9e5
  40ab6c:	0040a9d1 	.word	0x0040a9d1
  40ab70:	00400521 	.word	0x00400521
  40ab74:	004004f1 	.word	0x004004f1
  40ab78:	0040a9c1 	.word	0x0040a9c1

0040ab7c <at24cxx_dynamic_handler>:
{
  40ab7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (at24cxx_dynamic_SCHarray_count == 0)
  40ab7e:	4c22      	ldr	r4, [pc, #136]	; (40ac08 <at24cxx_dynamic_handler+0x8c>)
	at24cxx_dynamic_rw_exe();
  40ab80:	4b22      	ldr	r3, [pc, #136]	; (40ac0c <at24cxx_dynamic_handler+0x90>)
  40ab82:	4798      	blx	r3
	if (at24cxx_dynamic_SCHarray_count == 0)
  40ab84:	7820      	ldrb	r0, [r4, #0]
  40ab86:	2800      	cmp	r0, #0
  40ab88:	d033      	beq.n	40abf2 <at24cxx_dynamic_handler+0x76>
	uint32_t i = at24cxx_dynamic_SCHarray_read_ptr;
  40ab8a:	4e21      	ldr	r6, [pc, #132]	; (40ac10 <at24cxx_dynamic_handler+0x94>)
	if (p_arr->u8_rw == 1)
  40ab8c:	4921      	ldr	r1, [pc, #132]	; (40ac14 <at24cxx_dynamic_handler+0x98>)
	uint32_t i = at24cxx_dynamic_SCHarray_read_ptr;
  40ab8e:	7833      	ldrb	r3, [r6, #0]
	i++;
  40ab90:	3301      	adds	r3, #1
	if(i >= AT24CXX_DYNAMIC_SCH_ARR_MAX) i = 0;
  40ab92:	2b14      	cmp	r3, #20
  40ab94:	bf28      	it	cs
  40ab96:	2300      	movcs	r3, #0
	if (p_arr->u8_rw == 1)
  40ab98:	011a      	lsls	r2, r3, #4
  40ab9a:	5c8d      	ldrb	r5, [r1, r2]
  40ab9c:	440a      	add	r2, r1
  40ab9e:	2d01      	cmp	r5, #1
  40aba0:	d01c      	beq.n	40abdc <at24cxx_dynamic_handler+0x60>
		if(at24cxx_dynamic_write_array(p_arr->u8_twi_instance, p_arr->u32_start_address, p_arr->u16_length, p_arr->p_buffer) == AT24CXX_DYNAMIC_OK)
  40aba2:	7851      	ldrb	r1, [r2, #1]


uint32_t at24cxx_dynamic_write_array(uint32_t u32_twi_instance, uint32_t u32_start_address,
	uint16_t u16_length, uint8_t *p_wr_buffer)
{
	if(at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state != AT24CXX_DYNAMIC_HANDLER_IDLE)
  40aba4:	4d1c      	ldr	r5, [pc, #112]	; (40ac18 <at24cxx_dynamic_handler+0x9c>)
  40aba6:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40abaa:	0089      	lsls	r1, r1, #2
  40abac:	f815 e001 	ldrb.w	lr, [r5, r1]
  40abb0:	186f      	adds	r7, r5, r1
  40abb2:	f1be 0f00 	cmp.w	lr, #0
  40abb6:	d11c      	bne.n	40abf2 <at24cxx_dynamic_handler+0x76>
			at24cxx_dynamic_SCHarray_count--;
  40abb8:	f100 3cff 	add.w	ip, r0, #4294967295
		return AT24CXX_DYNAMIC_BUSSY;	
	at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_WRITE;
	at24cxx_instance[u32_twi_instance].p_buffer = p_wr_buffer;
	at24cxx_instance[u32_twi_instance].u16_length = u16_length;
	at24cxx_instance[u32_twi_instance].u32_start_address = u32_start_address;
	at24cxx_instance[u32_twi_instance].n = 0;	
  40abbc:	f887 e010 	strb.w	lr, [r7, #16]
		if(at24cxx_dynamic_write_array(p_arr->u8_twi_instance, p_arr->u32_start_address, p_arr->u16_length, p_arr->p_buffer) == AT24CXX_DYNAMIC_OK)
  40abc0:	6850      	ldr	r0, [r2, #4]
	at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_WRITE;
  40abc2:	f04f 0e01 	mov.w	lr, #1
		if(at24cxx_dynamic_write_array(p_arr->u8_twi_instance, p_arr->u32_start_address, p_arr->u16_length, p_arr->p_buffer) == AT24CXX_DYNAMIC_OK)
  40abc6:	6078      	str	r0, [r7, #4]
  40abc8:	8910      	ldrh	r0, [r2, #8]
  40abca:	68d2      	ldr	r2, [r2, #12]
			at24cxx_dynamic_SCHarray_count--;
  40abcc:	f884 c000 	strb.w	ip, [r4]
			at24cxx_dynamic_SCHarray_read_ptr = at24cxx_dynamic_sch_get_next_rdptr();
  40abd0:	7033      	strb	r3, [r6, #0]
	at24cxx_instance[u32_twi_instance].u16_length = u16_length;
  40abd2:	8138      	strh	r0, [r7, #8]
	at24cxx_instance[u32_twi_instance].p_buffer = p_wr_buffer;
  40abd4:	60fa      	str	r2, [r7, #12]
	at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_WRITE;
  40abd6:	f805 e001 	strb.w	lr, [r5, r1]
  40abda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if(at24cxx_dynamic_read_array(p_arr->u8_twi_instance, p_arr->u32_start_address, p_arr->u16_length, p_arr->p_buffer) == AT24CXX_DYNAMIC_OK)
  40abdc:	7851      	ldrb	r1, [r2, #1]
	return AT24CXX_DYNAMIC_OK;
}
uint32_t at24cxx_dynamic_read_array(uint32_t u32_twi_instance, uint32_t u32_start_address,
uint16_t u16_length, uint8_t *p_rd_buffer)
{
	if(at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state != AT24CXX_DYNAMIC_HANDLER_IDLE)
  40abde:	4d0e      	ldr	r5, [pc, #56]	; (40ac18 <at24cxx_dynamic_handler+0x9c>)
  40abe0:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40abe4:	0089      	lsls	r1, r1, #2
  40abe6:	f815 e001 	ldrb.w	lr, [r5, r1]
  40abea:	186f      	adds	r7, r5, r1
  40abec:	f1be 0f00 	cmp.w	lr, #0
  40abf0:	d000      	beq.n	40abf4 <at24cxx_dynamic_handler+0x78>
  40abf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			at24cxx_dynamic_SCHarray_count--;
  40abf4:	f100 3cff 	add.w	ip, r0, #4294967295
		if(at24cxx_dynamic_read_array(p_arr->u8_twi_instance, p_arr->u32_start_address, p_arr->u16_length, p_arr->p_buffer) == AT24CXX_DYNAMIC_OK)
  40abf8:	6850      	ldr	r0, [r2, #4]
		return AT24CXX_DYNAMIC_BUSSY;
	at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_READ;
	at24cxx_instance[u32_twi_instance].p_buffer = p_rd_buffer;
	at24cxx_instance[u32_twi_instance].u16_length = u16_length;
	at24cxx_instance[u32_twi_instance].u32_start_address = u32_start_address;
	at24cxx_instance[u32_twi_instance].n = 0;
  40abfa:	f887 e010 	strb.w	lr, [r7, #16]
	at24cxx_instance[u32_twi_instance].at24cxx_dynamic_state = AT24CXX_DYNAMIC_HANDLER_READ;
  40abfe:	f04f 0e02 	mov.w	lr, #2
		if(at24cxx_dynamic_read_array(p_arr->u8_twi_instance, p_arr->u32_start_address, p_arr->u16_length, p_arr->p_buffer) == AT24CXX_DYNAMIC_OK)
  40ac02:	6078      	str	r0, [r7, #4]
  40ac04:	e7e0      	b.n	40abc8 <at24cxx_dynamic_handler+0x4c>
  40ac06:	bf00      	nop
  40ac08:	204008ed 	.word	0x204008ed
  40ac0c:	0040aa55 	.word	0x0040aa55
  40ac10:	204008ee 	.word	0x204008ee
  40ac14:	20405530 	.word	0x20405530
  40ac18:	20405508 	.word	0x20405508

0040ac1c <at24cxx_dynamic_sch_write_array>:



uint32_t at24cxx_dynamic_sch_write_array(uint32_t u32_twi_instance, uint32_t u32_start_address,
uint16_t u16_length, uint8_t *p_wr_buffer)
{
  40ac1c:	b4f0      	push	{r4, r5, r6, r7}
	if(at24cxx_dynamic_SCHarray_count < AT24CXX_DYNAMIC_SCH_ARR_MAX)
  40ac1e:	4e10      	ldr	r6, [pc, #64]	; (40ac60 <at24cxx_dynamic_sch_write_array+0x44>)
  40ac20:	7834      	ldrb	r4, [r6, #0]
  40ac22:	2c13      	cmp	r4, #19
  40ac24:	d815      	bhi.n	40ac52 <at24cxx_dynamic_sch_write_array+0x36>
  40ac26:	4607      	mov	r7, r0
	uint32_t i = at24cxx_dynamic_SCHarray_write_ptr;
  40ac28:	480e      	ldr	r0, [pc, #56]	; (40ac64 <at24cxx_dynamic_sch_write_array+0x48>)
		at24cxx_dynamic_SCHarray_count++;
  40ac2a:	1c65      	adds	r5, r4, #1
	uint32_t i = at24cxx_dynamic_SCHarray_write_ptr;
  40ac2c:	7804      	ldrb	r4, [r0, #0]
		at24cxx_dynamic_SCHarray_count++;
  40ac2e:	7035      	strb	r5, [r6, #0]
		i++;
  40ac30:	3401      	adds	r4, #1
		if(i >= AT24CXX_DYNAMIC_SCH_ARR_MAX) i = 0;	
  40ac32:	2c13      	cmp	r4, #19
  40ac34:	d810      	bhi.n	40ac58 <at24cxx_dynamic_sch_write_array+0x3c>
  40ac36:	b2e5      	uxtb	r5, r4
		return 0; // no place in the buffer to write an array
	}
	at24cxx_dynamic_SCHarray_t *arr_ptr;
	arr_ptr = &at24cxx_dynamic_SCHarray_buff[at24cxx_dynamic_SCHarray_write_ptr];
	
	arr_ptr->u8_rw = 0;
  40ac38:	0124      	lsls	r4, r4, #4
  40ac3a:	4e0b      	ldr	r6, [pc, #44]	; (40ac68 <at24cxx_dynamic_sch_write_array+0x4c>)
		at24cxx_dynamic_SCHarray_write_ptr = i;
  40ac3c:	7005      	strb	r5, [r0, #0]
	arr_ptr->u8_rw = 0;
  40ac3e:	2000      	movs	r0, #0
  40ac40:	1935      	adds	r5, r6, r4
  40ac42:	5530      	strb	r0, [r6, r4]
	arr_ptr->u8_twi_instance = u32_twi_instance;
	arr_ptr->u32_start_address = u32_start_address;
	arr_ptr->u16_length = u16_length;
	arr_ptr->p_buffer = p_wr_buffer;
	
	return 1;	
  40ac44:	2001      	movs	r0, #1
	arr_ptr->u8_twi_instance = u32_twi_instance;
  40ac46:	706f      	strb	r7, [r5, #1]
	arr_ptr->u32_start_address = u32_start_address;
  40ac48:	6069      	str	r1, [r5, #4]
	arr_ptr->u16_length = u16_length;
  40ac4a:	812a      	strh	r2, [r5, #8]
	arr_ptr->p_buffer = p_wr_buffer;
  40ac4c:	60eb      	str	r3, [r5, #12]
}
  40ac4e:	bcf0      	pop	{r4, r5, r6, r7}
  40ac50:	4770      	bx	lr
		return 0; // no place in the buffer to write an array
  40ac52:	2000      	movs	r0, #0
}
  40ac54:	bcf0      	pop	{r4, r5, r6, r7}
  40ac56:	4770      	bx	lr
		if(i >= AT24CXX_DYNAMIC_SCH_ARR_MAX) i = 0;	
  40ac58:	2500      	movs	r5, #0
  40ac5a:	462c      	mov	r4, r5
  40ac5c:	e7ec      	b.n	40ac38 <at24cxx_dynamic_sch_write_array+0x1c>
  40ac5e:	bf00      	nop
  40ac60:	204008ed 	.word	0x204008ed
  40ac64:	204008ef 	.word	0x204008ef
  40ac68:	20405530 	.word	0x20405530

0040ac6c <at24cxx_dynamic_sch_read_array>:

uint32_t at24cxx_dynamic_sch_read_array(uint32_t u32_twi_instance, uint32_t u32_start_address,
uint16_t u16_length, uint8_t *p_rd_buffer)
{
  40ac6c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(at24cxx_dynamic_SCHarray_count < AT24CXX_DYNAMIC_SCH_ARR_MAX)
  40ac6e:	4e10      	ldr	r6, [pc, #64]	; (40acb0 <at24cxx_dynamic_sch_read_array+0x44>)
  40ac70:	7834      	ldrb	r4, [r6, #0]
  40ac72:	2c13      	cmp	r4, #19
  40ac74:	d817      	bhi.n	40aca6 <at24cxx_dynamic_sch_read_array+0x3a>
	uint32_t i = at24cxx_dynamic_SCHarray_write_ptr;
  40ac76:	f8df e040 	ldr.w	lr, [pc, #64]	; 40acb8 <at24cxx_dynamic_sch_read_array+0x4c>
		at24cxx_dynamic_SCHarray_count++;
  40ac7a:	1c65      	adds	r5, r4, #1
  40ac7c:	4607      	mov	r7, r0
	uint32_t i = at24cxx_dynamic_SCHarray_write_ptr;
  40ac7e:	f89e 4000 	ldrb.w	r4, [lr]
		at24cxx_dynamic_SCHarray_count++;
  40ac82:	7035      	strb	r5, [r6, #0]
		i++;
  40ac84:	3401      	adds	r4, #1
		if(i >= AT24CXX_DYNAMIC_SCH_ARR_MAX) i = 0;	
  40ac86:	2c13      	cmp	r4, #19
  40ac88:	d80f      	bhi.n	40acaa <at24cxx_dynamic_sch_read_array+0x3e>
  40ac8a:	b2e5      	uxtb	r5, r4
	if(at24cxx_dynamic_sch_wrbuff_full()) return 0; // no place in the buffer to read an array
	at24cxx_dynamic_SCHarray_t *arr_ptr;
	arr_ptr = &at24cxx_dynamic_SCHarray_buff[at24cxx_dynamic_SCHarray_write_ptr];
	
	arr_ptr->u8_rw = 1;
  40ac8c:	0124      	lsls	r4, r4, #4
  40ac8e:	4809      	ldr	r0, [pc, #36]	; (40acb4 <at24cxx_dynamic_sch_read_array+0x48>)
		at24cxx_dynamic_SCHarray_write_ptr = i;
  40ac90:	f88e 5000 	strb.w	r5, [lr]
	arr_ptr->u8_rw = 1;
  40ac94:	2501      	movs	r5, #1
  40ac96:	1906      	adds	r6, r0, r4
  40ac98:	5505      	strb	r5, [r0, r4]
	arr_ptr->u8_twi_instance = u32_twi_instance;
	arr_ptr->u32_start_address = u32_start_address;
	arr_ptr->u16_length = u16_length;
	arr_ptr->p_buffer = p_rd_buffer;
	
	return 1;
  40ac9a:	4628      	mov	r0, r5
	arr_ptr->u8_twi_instance = u32_twi_instance;
  40ac9c:	7077      	strb	r7, [r6, #1]
	arr_ptr->u32_start_address = u32_start_address;
  40ac9e:	6071      	str	r1, [r6, #4]
	arr_ptr->u16_length = u16_length;
  40aca0:	8132      	strh	r2, [r6, #8]
	arr_ptr->p_buffer = p_rd_buffer;
  40aca2:	60f3      	str	r3, [r6, #12]
	return 1;
  40aca4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(at24cxx_dynamic_sch_wrbuff_full()) return 0; // no place in the buffer to read an array
  40aca6:	2000      	movs	r0, #0
  40aca8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(i >= AT24CXX_DYNAMIC_SCH_ARR_MAX) i = 0;	
  40acaa:	2500      	movs	r5, #0
  40acac:	462c      	mov	r4, r5
  40acae:	e7ed      	b.n	40ac8c <at24cxx_dynamic_sch_read_array+0x20>
  40acb0:	204008ed 	.word	0x204008ed
  40acb4:	20405530 	.word	0x20405530
  40acb8:	204008ef 	.word	0x204008ef

0040acbc <con_toff_save_date>:

uint32_t device_off = 0, toff_counter = 0;

void con_toff_save_date(uint32_t year, uint32_t month, uint32_t day)
{
	menue_lift_data_setup.year = year;
  40acbc:	4b03      	ldr	r3, [pc, #12]	; (40accc <con_toff_save_date+0x10>)
  40acbe:	f8c3 00c8 	str.w	r0, [r3, #200]	; 0xc8
	menue_lift_data_setup.month = month;
  40acc2:	f883 10c4 	strb.w	r1, [r3, #196]	; 0xc4
	menue_lift_data_setup.day = day;
  40acc6:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
  40acca:	4770      	bx	lr
  40accc:	204051e0 	.word	0x204051e0

0040acd0 <con_toff_save_time>:
}

void con_toff_save_time(uint32_t hour, uint32_t min, uint32_t sec)
{
	menue_lift_data_setup.hour = hour;
  40acd0:	4b03      	ldr	r3, [pc, #12]	; (40ace0 <con_toff_save_time+0x10>)
  40acd2:	f883 00c5 	strb.w	r0, [r3, #197]	; 0xc5
	menue_lift_data_setup.minute = min;
  40acd6:	f883 10c6 	strb.w	r1, [r3, #198]	; 0xc6
	menue_lift_data_setup.second = sec;
  40acda:	f883 20c7 	strb.w	r2, [r3, #199]	; 0xc7
  40acde:	4770      	bx	lr
  40ace0:	204051e0 	.word	0x204051e0

0040ace4 <con_toff_get_date>:
}

void con_toff_get_date(uint32_t *year, uint32_t *month, uint32_t *day)
{
	*year = menue_lift_data_setup.year;
  40ace4:	4b06      	ldr	r3, [pc, #24]	; (40ad00 <con_toff_get_date+0x1c>)
{
  40ace6:	b410      	push	{r4}
	*year = menue_lift_data_setup.year;
  40ace8:	f8d3 40c8 	ldr.w	r4, [r3, #200]	; 0xc8
  40acec:	6004      	str	r4, [r0, #0]
	*month = menue_lift_data_setup.month;
  40acee:	f893 00c4 	ldrb.w	r0, [r3, #196]	; 0xc4
	*day = menue_lift_data_setup.day;
}
  40acf2:	f85d 4b04 	ldr.w	r4, [sp], #4
	*month = menue_lift_data_setup.month;
  40acf6:	6008      	str	r0, [r1, #0]
	*day = menue_lift_data_setup.day;
  40acf8:	f893 30c3 	ldrb.w	r3, [r3, #195]	; 0xc3
  40acfc:	6013      	str	r3, [r2, #0]
}
  40acfe:	4770      	bx	lr
  40ad00:	204051e0 	.word	0x204051e0

0040ad04 <con_toff_get_time>:

void con_toff_get_time(uint32_t *hour, uint32_t *min, uint32_t *sec)
{
	*hour = menue_lift_data_setup.hour;
  40ad04:	4b06      	ldr	r3, [pc, #24]	; (40ad20 <con_toff_get_time+0x1c>)
{
  40ad06:	b410      	push	{r4}
	*hour = menue_lift_data_setup.hour;
  40ad08:	f893 40c5 	ldrb.w	r4, [r3, #197]	; 0xc5
  40ad0c:	6004      	str	r4, [r0, #0]
	*min = menue_lift_data_setup.minute;
  40ad0e:	f893 00c6 	ldrb.w	r0, [r3, #198]	; 0xc6
	*sec = menue_lift_data_setup.second;
}
  40ad12:	f85d 4b04 	ldr.w	r4, [sp], #4
	*min = menue_lift_data_setup.minute;
  40ad16:	6008      	str	r0, [r1, #0]
	*sec = menue_lift_data_setup.second;
  40ad18:	f893 30c7 	ldrb.w	r3, [r3, #199]	; 0xc7
  40ad1c:	6013      	str	r3, [r2, #0]
}
  40ad1e:	4770      	bx	lr
  40ad20:	204051e0 	.word	0x204051e0

0040ad24 <con_toff_comp_time>:
	}
	return 0;
}

uint32_t con_toff_comp_time(void)
{
  40ad24:	b530      	push	{r4, r5, lr}
	uint32_t year, month, day, hour, min, sec;
	rtc_get_date(RTC, &year, &month, &day, 0);
  40ad26:	2400      	movs	r4, #0
{
  40ad28:	b089      	sub	sp, #36	; 0x24
	rtc_get_date(RTC, &year, &month, &day, 0);
  40ad2a:	4819      	ldr	r0, [pc, #100]	; (40ad90 <con_toff_comp_time+0x6c>)
  40ad2c:	ab04      	add	r3, sp, #16
  40ad2e:	aa03      	add	r2, sp, #12
  40ad30:	a902      	add	r1, sp, #8
  40ad32:	4d18      	ldr	r5, [pc, #96]	; (40ad94 <con_toff_comp_time+0x70>)
  40ad34:	9400      	str	r4, [sp, #0]
  40ad36:	47a8      	blx	r5
	rtc_get_time(RTC, &hour, &min, &sec);
  40ad38:	ab07      	add	r3, sp, #28
  40ad3a:	aa06      	add	r2, sp, #24
  40ad3c:	a905      	add	r1, sp, #20
  40ad3e:	4814      	ldr	r0, [pc, #80]	; (40ad90 <con_toff_comp_time+0x6c>)
  40ad40:	4d15      	ldr	r5, [pc, #84]	; (40ad98 <con_toff_comp_time+0x74>)
  40ad42:	47a8      	blx	r5
	
	if (year >= menue_lift_data_applied.year)
  40ad44:	4b15      	ldr	r3, [pc, #84]	; (40ad9c <con_toff_comp_time+0x78>)
  40ad46:	9a02      	ldr	r2, [sp, #8]
  40ad48:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
  40ad4c:	4291      	cmp	r1, r2
  40ad4e:	d804      	bhi.n	40ad5a <con_toff_comp_time+0x36>
	if (month >= menue_lift_data_applied.month)
  40ad50:	f893 10c4 	ldrb.w	r1, [r3, #196]	; 0xc4
  40ad54:	9a03      	ldr	r2, [sp, #12]
  40ad56:	4291      	cmp	r1, r2
  40ad58:	d902      	bls.n	40ad60 <con_toff_comp_time+0x3c>
	if (day >= menue_lift_data_applied.day)
	if (hour >= menue_lift_data_applied.hour)
	if (min >= menue_lift_data_applied.minute)
	if (sec >= menue_lift_data_applied.second) 
	return 1;
	return 0;
  40ad5a:	4620      	mov	r0, r4
}
  40ad5c:	b009      	add	sp, #36	; 0x24
  40ad5e:	bd30      	pop	{r4, r5, pc}
	if (day >= menue_lift_data_applied.day)
  40ad60:	f893 10c3 	ldrb.w	r1, [r3, #195]	; 0xc3
  40ad64:	9a04      	ldr	r2, [sp, #16]
  40ad66:	4291      	cmp	r1, r2
  40ad68:	d8f7      	bhi.n	40ad5a <con_toff_comp_time+0x36>
	if (hour >= menue_lift_data_applied.hour)
  40ad6a:	f893 10c5 	ldrb.w	r1, [r3, #197]	; 0xc5
  40ad6e:	9a05      	ldr	r2, [sp, #20]
  40ad70:	4291      	cmp	r1, r2
  40ad72:	d8f2      	bhi.n	40ad5a <con_toff_comp_time+0x36>
	if (min >= menue_lift_data_applied.minute)
  40ad74:	f893 10c6 	ldrb.w	r1, [r3, #198]	; 0xc6
  40ad78:	9a06      	ldr	r2, [sp, #24]
  40ad7a:	4291      	cmp	r1, r2
  40ad7c:	d8ed      	bhi.n	40ad5a <con_toff_comp_time+0x36>
	if (sec >= menue_lift_data_applied.second) 
  40ad7e:	9807      	ldr	r0, [sp, #28]
  40ad80:	f893 40c7 	ldrb.w	r4, [r3, #199]	; 0xc7
  40ad84:	4284      	cmp	r4, r0
  40ad86:	bf8c      	ite	hi
  40ad88:	2000      	movhi	r0, #0
  40ad8a:	2001      	movls	r0, #1
  40ad8c:	e7e6      	b.n	40ad5c <con_toff_comp_time+0x38>
  40ad8e:	bf00      	nop
  40ad90:	400e1860 	.word	0x400e1860
  40ad94:	00400611 	.word	0x00400611
  40ad98:	004005b9 	.word	0x004005b9
  40ad9c:	204052b4 	.word	0x204052b4

0040ada0 <con_toff_monitor_handler>:

void con_toff_monitor_handler(void)
{
	if (menue_lift_data_applied.m_cont_dis_technique == 1) device_off = con_toff_comp_services();
  40ada0:	4a0e      	ldr	r2, [pc, #56]	; (40addc <con_toff_monitor_handler+0x3c>)
{
  40ada2:	b508      	push	{r3, lr}
	if (menue_lift_data_applied.m_cont_dis_technique == 1) device_off = con_toff_comp_services();
  40ada4:	f892 30c2 	ldrb.w	r3, [r2, #194]	; 0xc2
  40ada8:	2b01      	cmp	r3, #1
  40adaa:	d007      	beq.n	40adbc <con_toff_monitor_handler+0x1c>
	else if (menue_lift_data_applied.m_cont_dis_technique == 2) device_off = con_toff_comp_time();
  40adac:	2b02      	cmp	r3, #2
  40adae:	d010      	beq.n	40add2 <con_toff_monitor_handler+0x32>
	else 
	{
		device_off = 0;
  40adb0:	2300      	movs	r3, #0
  40adb2:	490b      	ldr	r1, [pc, #44]	; (40ade0 <con_toff_monitor_handler+0x40>)
		toff_counter = 0;
  40adb4:	4a0b      	ldr	r2, [pc, #44]	; (40ade4 <con_toff_monitor_handler+0x44>)
		device_off = 0;
  40adb6:	600b      	str	r3, [r1, #0]
		toff_counter = 0;
  40adb8:	6013      	str	r3, [r2, #0]
  40adba:	bd08      	pop	{r3, pc}
	if(toff_counter >= menue_lift_data_applied.services)
  40adbc:	4909      	ldr	r1, [pc, #36]	; (40ade4 <con_toff_monitor_handler+0x44>)
  40adbe:	f8d2 30cc 	ldr.w	r3, [r2, #204]	; 0xcc
  40adc2:	6809      	ldr	r1, [r1, #0]
	if (menue_lift_data_applied.m_cont_dis_technique == 1) device_off = con_toff_comp_services();
  40adc4:	4a06      	ldr	r2, [pc, #24]	; (40ade0 <con_toff_monitor_handler+0x40>)
	if(toff_counter >= menue_lift_data_applied.services)
  40adc6:	428b      	cmp	r3, r1
  40adc8:	bf8c      	ite	hi
  40adca:	2300      	movhi	r3, #0
  40adcc:	2301      	movls	r3, #1
	if (menue_lift_data_applied.m_cont_dis_technique == 1) device_off = con_toff_comp_services();
  40adce:	6013      	str	r3, [r2, #0]
  40add0:	bd08      	pop	{r3, pc}
	else if (menue_lift_data_applied.m_cont_dis_technique == 2) device_off = con_toff_comp_time();
  40add2:	4b05      	ldr	r3, [pc, #20]	; (40ade8 <con_toff_monitor_handler+0x48>)
  40add4:	4798      	blx	r3
  40add6:	4b02      	ldr	r3, [pc, #8]	; (40ade0 <con_toff_monitor_handler+0x40>)
  40add8:	6018      	str	r0, [r3, #0]
  40adda:	bd08      	pop	{r3, pc}
  40addc:	204052b4 	.word	0x204052b4
  40ade0:	204008f0 	.word	0x204008f0
  40ade4:	204008f4 	.word	0x204008f4
  40ade8:	0040ad25 	.word	0x0040ad25

0040adec <list_input_val_exe.part.0>:
	{
		*(uint8_t *)(lst_opt_val->val) = lst_val_entered;
	}
	if(lst_opt_val->new_val_flag) *lst_opt_val->new_val_flag =1;
}
uint_t list_input_val_exe(option_val_t *lst_opt_val, char enter, char esc, char up, char down, char left, char right)
  40adec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40adf0:	b083      	sub	sp, #12
  40adf2:	4605      	mov	r5, r0
	{
		list_save_val(lst_opt_val);
		return 0;
	}
	if(esc) return 0;
	if(right) list_cursor++;
  40adf4:	4fa3      	ldr	r7, [pc, #652]	; (40b084 <list_input_val_exe.part.0+0x298>)
uint_t list_input_val_exe(option_val_t *lst_opt_val, char enter, char esc, char up, char down, char left, char right)
  40adf6:	f89d 4030 	ldrb.w	r4, [sp, #48]	; 0x30
	if(right) list_cursor++;
  40adfa:	2c00      	cmp	r4, #0
  40adfc:	f000 80a5 	beq.w	40af4a <list_input_val_exe.part.0+0x15e>
  40ae00:	783c      	ldrb	r4, [r7, #0]
  40ae02:	3401      	adds	r4, #1
  40ae04:	b2e4      	uxtb	r4, r4
  40ae06:	703c      	strb	r4, [r7, #0]
	else if(left) list_cursor--;
		
	if(list_cursor == 0xFF) list_cursor = lst_opt_val->mantissa_count + lst_opt_val->real_count + list_has_asign - 1;
  40ae08:	2cff      	cmp	r4, #255	; 0xff
  40ae0a:	f8df 8294 	ldr.w	r8, [pc, #660]	; 40b0a0 <list_input_val_exe.part.0+0x2b4>
  40ae0e:	68a8      	ldr	r0, [r5, #8]
  40ae10:	d018      	beq.n	40ae44 <list_input_val_exe.part.0+0x58>
	else if(list_cursor >= lst_opt_val->mantissa_count + lst_opt_val->real_count + list_has_asign) list_cursor = 0;	
  40ae12:	686b      	ldr	r3, [r5, #4]
  40ae14:	f898 6000 	ldrb.w	r6, [r8]
  40ae18:	eb00 0e03 	add.w	lr, r0, r3
  40ae1c:	44b6      	add	lr, r6
  40ae1e:	4574      	cmp	r4, lr
  40ae20:	d317      	bcc.n	40ae52 <list_input_val_exe.part.0+0x66>
  40ae22:	2400      	movs	r4, #0
  40ae24:	703c      	strb	r4, [r7, #0]
	
	if((list_has_asign) && (list_cursor == 0) && ((up) || (down)))
  40ae26:	b1c6      	cbz	r6, 40ae5a <list_input_val_exe.part.0+0x6e>
  40ae28:	b911      	cbnz	r1, 40ae30 <list_input_val_exe.part.0+0x44>
  40ae2a:	2a00      	cmp	r2, #0
  40ae2c:	f000 8126 	beq.w	40b07c <list_input_val_exe.part.0+0x290>
	{
		lst_val_entered *= -1;
  40ae30:	4e95      	ldr	r6, [pc, #596]	; (40b088 <list_input_val_exe.part.0+0x29c>)
	}
	else if(down)
	{
		lst_val_entered -= lst_power(lst_opt_val->mantissa_count + lst_opt_val->real_count - (list_cursor - list_has_asign + 1));
	}
	if (lst_val_entered > list_val_max)
  40ae32:	4a96      	ldr	r2, [pc, #600]	; (40b08c <list_input_val_exe.part.0+0x2a0>)
		lst_val_entered *= -1;
  40ae34:	6833      	ldr	r3, [r6, #0]
	if (lst_val_entered > list_val_max)
  40ae36:	6812      	ldr	r2, [r2, #0]
		lst_val_entered *= -1;
  40ae38:	425b      	negs	r3, r3
	if (lst_val_entered > list_val_max)
  40ae3a:	429a      	cmp	r2, r3
		lst_val_entered *= -1;
  40ae3c:	6033      	str	r3, [r6, #0]
	if (lst_val_entered > list_val_max)
  40ae3e:	da24      	bge.n	40ae8a <list_input_val_exe.part.0+0x9e>
	{
		lst_val_entered = list_val_max;
	} 
	else if (lst_val_entered < list_val_min)
	{
		lst_val_entered = list_val_min;
  40ae40:	6032      	str	r2, [r6, #0]
  40ae42:	e027      	b.n	40ae94 <list_input_val_exe.part.0+0xa8>
	if(list_cursor == 0xFF) list_cursor = lst_opt_val->mantissa_count + lst_opt_val->real_count + list_has_asign - 1;
  40ae44:	f898 6000 	ldrb.w	r6, [r8]
  40ae48:	686b      	ldr	r3, [r5, #4]
  40ae4a:	1e74      	subs	r4, r6, #1
  40ae4c:	4404      	add	r4, r0
  40ae4e:	441c      	add	r4, r3
  40ae50:	703c      	strb	r4, [r7, #0]
	if((list_has_asign) && (list_cursor == 0) && ((up) || (down)))
  40ae52:	b116      	cbz	r6, 40ae5a <list_input_val_exe.part.0+0x6e>
  40ae54:	783c      	ldrb	r4, [r7, #0]
  40ae56:	2c00      	cmp	r4, #0
  40ae58:	d0e6      	beq.n	40ae28 <list_input_val_exe.part.0+0x3c>
	else if(up)
  40ae5a:	2900      	cmp	r1, #0
  40ae5c:	d07d      	beq.n	40af5a <list_input_val_exe.part.0+0x16e>
		lst_val_entered += lst_power(lst_opt_val->mantissa_count + lst_opt_val->real_count - (list_cursor - list_has_asign + 1));
  40ae5e:	4403      	add	r3, r0
  40ae60:	783a      	ldrb	r2, [r7, #0]
  40ae62:	3b01      	subs	r3, #1
  40ae64:	1b92      	subs	r2, r2, r6
	for (count; count>0; count--)
  40ae66:	1a9a      	subs	r2, r3, r2
  40ae68:	f04f 0301 	mov.w	r3, #1
  40ae6c:	d005      	beq.n	40ae7a <list_input_val_exe.part.0+0x8e>
		res *= 10;
  40ae6e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	for (count; count>0; count--)
  40ae72:	3a01      	subs	r2, #1
		res *= 10;
  40ae74:	ea4f 0343 	mov.w	r3, r3, lsl #1
	for (count; count>0; count--)
  40ae78:	d1f9      	bne.n	40ae6e <list_input_val_exe.part.0+0x82>
		lst_val_entered += lst_power(lst_opt_val->mantissa_count + lst_opt_val->real_count - (list_cursor - list_has_asign + 1));
  40ae7a:	4e83      	ldr	r6, [pc, #524]	; (40b088 <list_input_val_exe.part.0+0x29c>)
  40ae7c:	6832      	ldr	r2, [r6, #0]
  40ae7e:	4413      	add	r3, r2
  40ae80:	6033      	str	r3, [r6, #0]
	if (lst_val_entered > list_val_max)
  40ae82:	4a82      	ldr	r2, [pc, #520]	; (40b08c <list_input_val_exe.part.0+0x2a0>)
  40ae84:	6812      	ldr	r2, [r2, #0]
  40ae86:	429a      	cmp	r2, r3
  40ae88:	dbda      	blt.n	40ae40 <list_input_val_exe.part.0+0x54>
	else if (lst_val_entered < list_val_min)
  40ae8a:	4a81      	ldr	r2, [pc, #516]	; (40b090 <list_input_val_exe.part.0+0x2a4>)
  40ae8c:	6812      	ldr	r2, [r2, #0]
  40ae8e:	429a      	cmp	r2, r3
  40ae90:	dcd6      	bgt.n	40ae40 <list_input_val_exe.part.0+0x54>
  40ae92:	461a      	mov	r2, r3
	}
	
	if(lst_val_entered >= 0) temp = lst_val_entered;
	else temp = -lst_val_entered;
	
	list_val_break = itos(temp);
  40ae94:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
  40ae98:	4b7e      	ldr	r3, [pc, #504]	; (40b094 <list_input_val_exe.part.0+0x2a8>)
  40ae9a:	2100      	movs	r1, #0
	for (count; count>0; count--)
  40ae9c:	f04f 0b01 	mov.w	fp, #1
	list_val_break = itos(temp);
  40aea0:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
  40aea4:	4798      	blx	r3
	
	temp = lst_power(lst_opt_val->real_count + lst_opt_val->mantissa_count -1);
  40aea6:	686a      	ldr	r2, [r5, #4]
  40aea8:	68ab      	ldr	r3, [r5, #8]
	list_val_break = itos(temp);
  40aeaa:	4604      	mov	r4, r0
	temp = lst_power(lst_opt_val->real_count + lst_opt_val->mantissa_count -1);
  40aeac:	441a      	add	r2, r3
	for (count; count>0; count--)
  40aeae:	3a01      	subs	r2, #1
  40aeb0:	d005      	beq.n	40aebe <list_input_val_exe.part.0+0xd2>
		res *= 10;
  40aeb2:	eb0b 038b 	add.w	r3, fp, fp, lsl #2
	for (count; count>0; count--)
  40aeb6:	3a01      	subs	r2, #1
		res *= 10;
  40aeb8:	ea4f 0b43 	mov.w	fp, r3, lsl #1
	for (count; count>0; count--)
  40aebc:	d1f9      	bne.n	40aeb2 <list_input_val_exe.part.0+0xc6>

// print on the LCD ___________________________	
	
	if (lst_opt_val->text)
  40aebe:	692a      	ldr	r2, [r5, #16]
  40aec0:	2a00      	cmp	r2, #0
  40aec2:	f000 8096 	beq.w	40aff2 <list_input_val_exe.part.0+0x206>
	{
		glcd_gotoxy(2,16);
  40aec6:	2110      	movs	r1, #16
  40aec8:	2002      	movs	r0, #2
  40aeca:	f8df 91d8 	ldr.w	r9, [pc, #472]	; 40b0a4 <list_input_val_exe.part.0+0x2b8>
  40aece:	47c8      	blx	r9
		glcd_putsf(lst_opt_val->text, 0);
  40aed0:	2100      	movs	r1, #0
  40aed2:	6928      	ldr	r0, [r5, #16]
  40aed4:	4a70      	ldr	r2, [pc, #448]	; (40b098 <list_input_val_exe.part.0+0x2ac>)
  40aed6:	4790      	blx	r2
	}
	
	glcd_gotoxy(2, 53);
  40aed8:	2135      	movs	r1, #53	; 0x35
  40aeda:	2002      	movs	r0, #2
  40aedc:	47c8      	blx	r9
	if(list_has_asign)
  40aede:	f898 2000 	ldrb.w	r2, [r8]
  40aee2:	2a00      	cmp	r2, #0
  40aee4:	d178      	bne.n	40afd8 <list_input_val_exe.part.0+0x1ec>
  40aee6:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 40b0a8 <list_input_val_exe.part.0+0x2bc>
	{
		if(lst_val_entered < 0) out_char('-', (0 == list_cursor));
		else out_char('+', (0 == list_cursor));
	}
	
	if(lst_val_entered < 0) l_sign = -1;
  40aeea:	6830      	ldr	r0, [r6, #0]
	lst_val_entered *= l_sign;
	
	if(lst_opt_val->real_count == 0) out_char('0', 0); //print decimal 0
  40aeec:	6869      	ldr	r1, [r5, #4]
	if(lst_val_entered < 0) l_sign = -1;
  40aeee:	2800      	cmp	r0, #0
  40aef0:	bfb4      	ite	lt
  40aef2:	f04f 33ff 	movlt.w	r3, #4294967295
  40aef6:	2301      	movge	r3, #1
	lst_val_entered *= l_sign;
  40aef8:	fb03 f000 	mul.w	r0, r3, r0
	if(lst_val_entered < 0) l_sign = -1;
  40aefc:	9301      	str	r3, [sp, #4]
	lst_val_entered *= l_sign;
  40aefe:	6030      	str	r0, [r6, #0]
	if(lst_opt_val->real_count == 0) out_char('0', 0); //print decimal 0
  40af00:	2900      	cmp	r1, #0
  40af02:	d079      	beq.n	40aff8 <list_input_val_exe.part.0+0x20c>
	if(lst_val_entered < 0) l_sign = -1;
  40af04:	f04f 0a00 	mov.w	sl, #0
  40af08:	e010      	b.n	40af2c <list_input_val_exe.part.0+0x140>
			out_char('0', (i + list_has_asign == list_cursor));
			temp /= 10;
		}
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
		{
			out_char(*list_val_break , (i + list_has_asign == list_cursor));
  40af0a:	4670      	mov	r0, lr
			list_val_break++;
  40af0c:	3401      	adds	r4, #1
			out_char(*list_val_break , (i + list_has_asign == list_cursor));
  40af0e:	f897 e000 	ldrb.w	lr, [r7]
		}
		else
		{
			out_char('0', (i + list_has_asign == list_cursor));
  40af12:	4451      	add	r1, sl
	for (i=0; i<lst_opt_val->real_count; i++)
  40af14:	f10a 0a01 	add.w	sl, sl, #1
			out_char('0', (i + list_has_asign == list_cursor));
  40af18:	eba1 010e 	sub.w	r1, r1, lr
  40af1c:	fab1 f181 	clz	r1, r1
  40af20:	0949      	lsrs	r1, r1, #5
  40af22:	47c8      	blx	r9
	for (i=0; i<lst_opt_val->real_count; i++)
  40af24:	6869      	ldr	r1, [r5, #4]
  40af26:	458a      	cmp	sl, r1
  40af28:	d242      	bcs.n	40afb0 <list_input_val_exe.part.0+0x1c4>
  40af2a:	6830      	ldr	r0, [r6, #0]
		if (lst_val_entered < temp)
  40af2c:	4558      	cmp	r0, fp
  40af2e:	d329      	bcc.n	40af84 <list_input_val_exe.part.0+0x198>
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40af30:	f894 e000 	ldrb.w	lr, [r4]
			out_char('0', (i + list_has_asign == list_cursor));
  40af34:	2030      	movs	r0, #48	; 0x30
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40af36:	f1ae 0130 	sub.w	r1, lr, #48	; 0x30
  40af3a:	2909      	cmp	r1, #9
			out_char(*list_val_break , (i + list_has_asign == list_cursor));
  40af3c:	f898 1000 	ldrb.w	r1, [r8]
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40af40:	d9e3      	bls.n	40af0a <list_input_val_exe.part.0+0x11e>
			list_val_break++;
  40af42:	3401      	adds	r4, #1
			out_char('0', (i + list_has_asign == list_cursor));
  40af44:	f897 e000 	ldrb.w	lr, [r7]
  40af48:	e7e3      	b.n	40af12 <list_input_val_exe.part.0+0x126>
	else if(left) list_cursor--;
  40af4a:	783c      	ldrb	r4, [r7, #0]
  40af4c:	2b00      	cmp	r3, #0
  40af4e:	f43f af5b 	beq.w	40ae08 <list_input_val_exe.part.0+0x1c>
  40af52:	3c01      	subs	r4, #1
  40af54:	b2e4      	uxtb	r4, r4
  40af56:	703c      	strb	r4, [r7, #0]
  40af58:	e756      	b.n	40ae08 <list_input_val_exe.part.0+0x1c>
	else if(down)
  40af5a:	2a00      	cmp	r2, #0
  40af5c:	f000 808e 	beq.w	40b07c <list_input_val_exe.part.0+0x290>
		lst_val_entered -= lst_power(lst_opt_val->mantissa_count + lst_opt_val->real_count - (list_cursor - list_has_asign + 1));
  40af60:	4403      	add	r3, r0
  40af62:	7839      	ldrb	r1, [r7, #0]
	for (count; count>0; count--)
  40af64:	2201      	movs	r2, #1
		lst_val_entered -= lst_power(lst_opt_val->mantissa_count + lst_opt_val->real_count - (list_cursor - list_has_asign + 1));
  40af66:	3b01      	subs	r3, #1
  40af68:	1b89      	subs	r1, r1, r6
	for (count; count>0; count--)
  40af6a:	1a59      	subs	r1, r3, r1
  40af6c:	d005      	beq.n	40af7a <list_input_val_exe.part.0+0x18e>
		res *= 10;
  40af6e:	eb02 0382 	add.w	r3, r2, r2, lsl #2
	for (count; count>0; count--)
  40af72:	3901      	subs	r1, #1
		res *= 10;
  40af74:	ea4f 0243 	mov.w	r2, r3, lsl #1
	for (count; count>0; count--)
  40af78:	d1f9      	bne.n	40af6e <list_input_val_exe.part.0+0x182>
		lst_val_entered -= lst_power(lst_opt_val->mantissa_count + lst_opt_val->real_count - (list_cursor - list_has_asign + 1));
  40af7a:	4e43      	ldr	r6, [pc, #268]	; (40b088 <list_input_val_exe.part.0+0x29c>)
  40af7c:	6833      	ldr	r3, [r6, #0]
  40af7e:	1a9b      	subs	r3, r3, r2
  40af80:	6033      	str	r3, [r6, #0]
  40af82:	e77e      	b.n	40ae82 <list_input_val_exe.part.0+0x96>
			out_char('0', (i + list_has_asign == list_cursor));
  40af84:	f898 1000 	ldrb.w	r1, [r8]
  40af88:	2030      	movs	r0, #48	; 0x30
  40af8a:	f897 e000 	ldrb.w	lr, [r7]
  40af8e:	4451      	add	r1, sl
	for (i=0; i<lst_opt_val->real_count; i++)
  40af90:	f10a 0a01 	add.w	sl, sl, #1
			out_char('0', (i + list_has_asign == list_cursor));
  40af94:	eba1 010e 	sub.w	r1, r1, lr
  40af98:	fab1 f181 	clz	r1, r1
  40af9c:	0949      	lsrs	r1, r1, #5
  40af9e:	47c8      	blx	r9
			temp /= 10;
  40afa0:	4b3e      	ldr	r3, [pc, #248]	; (40b09c <list_input_val_exe.part.0+0x2b0>)
	for (i=0; i<lst_opt_val->real_count; i++)
  40afa2:	6869      	ldr	r1, [r5, #4]
			temp /= 10;
  40afa4:	fba3 230b 	umull	r2, r3, r3, fp
	for (i=0; i<lst_opt_val->real_count; i++)
  40afa8:	458a      	cmp	sl, r1
			temp /= 10;
  40afaa:	ea4f 0bd3 	mov.w	fp, r3, lsr #3
	for (i=0; i<lst_opt_val->real_count; i++)
  40afae:	d3bc      	bcc.n	40af2a <list_input_val_exe.part.0+0x13e>
		}
	}
	if(lst_opt_val->mantissa_count) out_char('.', 0);
  40afb0:	68aa      	ldr	r2, [r5, #8]
  40afb2:	bb42      	cbnz	r2, 40b006 <list_input_val_exe.part.0+0x21a>
		{
			out_char('0', (i + list_has_asign + lst_opt_val->real_count == list_cursor));
			list_val_break++;
		}
	}
	if (lst_opt_val->unit)
  40afb4:	68eb      	ldr	r3, [r5, #12]
  40afb6:	b133      	cbz	r3, 40afc6 <list_input_val_exe.part.0+0x1da>
	{
		out_char(' ',0);
  40afb8:	2100      	movs	r1, #0
  40afba:	2020      	movs	r0, #32
  40afbc:	47c8      	blx	r9
		glcd_putsf(lst_opt_val->unit, 0);
  40afbe:	68e8      	ldr	r0, [r5, #12]
  40afc0:	2100      	movs	r1, #0
  40afc2:	4b35      	ldr	r3, [pc, #212]	; (40b098 <list_input_val_exe.part.0+0x2ac>)
  40afc4:	4798      	blx	r3
	}
	
	lst_val_entered *= l_sign;
  40afc6:	6833      	ldr	r3, [r6, #0]
	
	return 1;
}
  40afc8:	2001      	movs	r0, #1
	lst_val_entered *= l_sign;
  40afca:	9a01      	ldr	r2, [sp, #4]
  40afcc:	fb02 f203 	mul.w	r2, r2, r3
  40afd0:	6032      	str	r2, [r6, #0]
}
  40afd2:	b003      	add	sp, #12
  40afd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(lst_val_entered < 0) out_char('-', (0 == list_cursor));
  40afd8:	6832      	ldr	r2, [r6, #0]
  40afda:	7839      	ldrb	r1, [r7, #0]
  40afdc:	2a00      	cmp	r2, #0
		else out_char('+', (0 == list_cursor));
  40afde:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 40b0a8 <list_input_val_exe.part.0+0x2bc>
  40afe2:	fab1 f181 	clz	r1, r1
		if(lst_val_entered < 0) out_char('-', (0 == list_cursor));
  40afe6:	bfb4      	ite	lt
  40afe8:	202d      	movlt	r0, #45	; 0x2d
		else out_char('+', (0 == list_cursor));
  40afea:	202b      	movge	r0, #43	; 0x2b
  40afec:	0949      	lsrs	r1, r1, #5
  40afee:	47c8      	blx	r9
  40aff0:	e77b      	b.n	40aeea <list_input_val_exe.part.0+0xfe>
  40aff2:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 40b0a4 <list_input_val_exe.part.0+0x2b8>
  40aff6:	e76f      	b.n	40aed8 <list_input_val_exe.part.0+0xec>
	if(lst_opt_val->real_count == 0) out_char('0', 0); //print decimal 0
  40aff8:	2030      	movs	r0, #48	; 0x30
  40affa:	47c8      	blx	r9
	for (i=0; i<lst_opt_val->real_count; i++)
  40affc:	686a      	ldr	r2, [r5, #4]
  40affe:	2a00      	cmp	r2, #0
  40b000:	d0d6      	beq.n	40afb0 <list_input_val_exe.part.0+0x1c4>
  40b002:	6830      	ldr	r0, [r6, #0]
  40b004:	e77e      	b.n	40af04 <list_input_val_exe.part.0+0x118>
	if(lst_opt_val->mantissa_count) out_char('.', 0);
  40b006:	2100      	movs	r1, #0
  40b008:	202e      	movs	r0, #46	; 0x2e
  40b00a:	47c8      	blx	r9
	for (i=0; i<lst_opt_val->mantissa_count; i++)
  40b00c:	68aa      	ldr	r2, [r5, #8]
  40b00e:	2a00      	cmp	r2, #0
  40b010:	d0d0      	beq.n	40afb4 <list_input_val_exe.part.0+0x1c8>
  40b012:	f04f 0a00 	mov.w	sl, #0
  40b016:	e01a      	b.n	40b04e <list_input_val_exe.part.0+0x262>
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b018:	f894 e000 	ldrb.w	lr, [r4]
			out_char('0', (i + list_has_asign + lst_opt_val->real_count == list_cursor));
  40b01c:	2030      	movs	r0, #48	; 0x30
  40b01e:	686b      	ldr	r3, [r5, #4]
			list_val_break++;
  40b020:	3401      	adds	r4, #1
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b022:	f1ae 0130 	sub.w	r1, lr, #48	; 0x30
  40b026:	2909      	cmp	r1, #9
			out_char(*list_val_break, (i + list_has_asign + lst_opt_val->real_count == list_cursor));
  40b028:	f898 1000 	ldrb.w	r1, [r8]
			out_char('0', (i + list_has_asign + lst_opt_val->real_count == list_cursor));
  40b02c:	4419      	add	r1, r3
			out_char(*list_val_break, (i + list_has_asign + lst_opt_val->real_count == list_cursor));
  40b02e:	bf98      	it	ls
  40b030:	4670      	movls	r0, lr
			out_char('0', (i + list_has_asign + lst_opt_val->real_count == list_cursor));
  40b032:	f897 e000 	ldrb.w	lr, [r7]
  40b036:	4451      	add	r1, sl
  40b038:	eba1 010e 	sub.w	r1, r1, lr
  40b03c:	fab1 f181 	clz	r1, r1
  40b040:	0949      	lsrs	r1, r1, #5
  40b042:	47c8      	blx	r9
	for (i=0; i<lst_opt_val->mantissa_count; i++)
  40b044:	f10a 0a01 	add.w	sl, sl, #1
  40b048:	68a9      	ldr	r1, [r5, #8]
  40b04a:	458a      	cmp	sl, r1
  40b04c:	d2b2      	bcs.n	40afb4 <list_input_val_exe.part.0+0x1c8>
		if (lst_val_entered < temp)
  40b04e:	6831      	ldr	r1, [r6, #0]
  40b050:	4559      	cmp	r1, fp
  40b052:	d2e1      	bcs.n	40b018 <list_input_val_exe.part.0+0x22c>
			out_char('0', (i + list_has_asign + lst_opt_val->real_count == list_cursor));
  40b054:	f898 e000 	ldrb.w	lr, [r8]
  40b058:	2030      	movs	r0, #48	; 0x30
  40b05a:	6869      	ldr	r1, [r5, #4]
  40b05c:	4471      	add	r1, lr
  40b05e:	f897 e000 	ldrb.w	lr, [r7]
  40b062:	4451      	add	r1, sl
  40b064:	eba1 010e 	sub.w	r1, r1, lr
  40b068:	fab1 f181 	clz	r1, r1
  40b06c:	0949      	lsrs	r1, r1, #5
  40b06e:	47c8      	blx	r9
			temp /= 10;
  40b070:	4b0a      	ldr	r3, [pc, #40]	; (40b09c <list_input_val_exe.part.0+0x2b0>)
  40b072:	fba3 230b 	umull	r2, r3, r3, fp
  40b076:	ea4f 0bd3 	mov.w	fp, r3, lsr #3
  40b07a:	e7e3      	b.n	40b044 <list_input_val_exe.part.0+0x258>
  40b07c:	4e02      	ldr	r6, [pc, #8]	; (40b088 <list_input_val_exe.part.0+0x29c>)
  40b07e:	6833      	ldr	r3, [r6, #0]
  40b080:	e6ff      	b.n	40ae82 <list_input_val_exe.part.0+0x96>
  40b082:	bf00      	nop
  40b084:	204008fa 	.word	0x204008fa
  40b088:	20405680 	.word	0x20405680
  40b08c:	2040568c 	.word	0x2040568c
  40b090:	2040567c 	.word	0x2040567c
  40b094:	0040c205 	.word	0x0040c205
  40b098:	0040c7b9 	.word	0x0040c7b9
  40b09c:	cccccccd 	.word	0xcccccccd
  40b0a0:	204008fb 	.word	0x204008fb
  40b0a4:	0040c7a5 	.word	0x0040c7a5
  40b0a8:	0040c6f9 	.word	0x0040c6f9

0040b0ac <fill_menue_list>:
{
  40b0ac:	b4f0      	push	{r4, r5, r6, r7}
  40b0ae:	9e04      	ldr	r6, [sp, #16]
	(*mnu).m_type = GRAPHICAL_MENUE_LIST;
  40b0b0:	2400      	movs	r4, #0
	highlight_rect.x=2;
  40b0b2:	4d07      	ldr	r5, [pc, #28]	; (40b0d0 <fill_menue_list+0x24>)
  40b0b4:	2702      	movs	r7, #2
	(*mnu).list_max=lst_max;
  40b0b6:	7302      	strb	r2, [r0, #12]
	highlight_rect.width=124;	
  40b0b8:	227c      	movs	r2, #124	; 0x7c
	(*mnu).m_type = GRAPHICAL_MENUE_LIST;
  40b0ba:	7004      	strb	r4, [r0, #0]
	(*mnu).save_val = mnuval;
  40b0bc:	6106      	str	r6, [r0, #16]
	(*mnu).list_start=0;
  40b0be:	7344      	strb	r4, [r0, #13]
	(*mnu).list_highlight=0;
  40b0c0:	7384      	strb	r4, [r0, #14]
	highlight_rect.x=2;
  40b0c2:	702f      	strb	r7, [r5, #0]
	highlight_rect.width=124;	
  40b0c4:	70aa      	strb	r2, [r5, #2]
	(*mnu).lst_itms=list;
  40b0c6:	6081      	str	r1, [r0, #8]
	(*mnu).parent = parent;
  40b0c8:	6043      	str	r3, [r0, #4]
}
  40b0ca:	bcf0      	pop	{r4, r5, r6, r7}
  40b0cc:	4770      	bx	lr
  40b0ce:	bf00      	nop
  40b0d0:	20405688 	.word	0x20405688

0040b0d4 <fill_menue_image>:
{
  40b0d4:	b470      	push	{r4, r5, r6}
  40b0d6:	9d03      	ldr	r5, [sp, #12]
	(*mnu).m_type = GRAPHICAL_MENUE_PHOTO;
  40b0d8:	2601      	movs	r6, #1
	(*mnu).menue_opened = 0;
  40b0da:	2400      	movs	r4, #0
	(*mnu).image = image;
  40b0dc:	6182      	str	r2, [r0, #24]
	(*mnu).menue_name = menue_name;
  40b0de:	61c3      	str	r3, [r0, #28]
	(*mnu).m_type = GRAPHICAL_MENUE_PHOTO;
  40b0e0:	7006      	strb	r6, [r0, #0]
	(*mnu).menue_password = menue_pass;
  40b0e2:	6105      	str	r5, [r0, #16]
	(*mnu).menue_opened = 0;
  40b0e4:	7504      	strb	r4, [r0, #20]
	if(child)
  40b0e6:	b109      	cbz	r1, 40b0ec <fill_menue_image+0x18>
		(*mnu).child = child;
  40b0e8:	6041      	str	r1, [r0, #4]
		(*(*mnu).child).menue_name = menue_name;
  40b0ea:	618b      	str	r3, [r1, #24]
}
  40b0ec:	bc70      	pop	{r4, r5, r6}
  40b0ee:	4770      	bx	lr

0040b0f0 <dec_list>:
	uint8_t current_list_count = (*curr_lst).list_highlight;
  40b0f0:	4a0a      	ldr	r2, [pc, #40]	; (40b11c <dec_list+0x2c>)
	if(++(curr_lst->list_highlight) >= curr_lst_max/*(*curr_lst).list_max*/)
  40b0f2:	4b0b      	ldr	r3, [pc, #44]	; (40b120 <dec_list+0x30>)
	uint8_t current_list_count = (*curr_lst).list_highlight;
  40b0f4:	6812      	ldr	r2, [r2, #0]
	if(++(curr_lst->list_highlight) >= curr_lst_max/*(*curr_lst).list_max*/)
  40b0f6:	7819      	ldrb	r1, [r3, #0]
  40b0f8:	7b93      	ldrb	r3, [r2, #14]
  40b0fa:	3301      	adds	r3, #1
  40b0fc:	b2db      	uxtb	r3, r3
  40b0fe:	428b      	cmp	r3, r1
  40b100:	7393      	strb	r3, [r2, #14]
  40b102:	d302      	bcc.n	40b10a <dec_list+0x1a>
		curr_lst->list_highlight = /*(*curr_lst).list_max*/curr_lst_max - 1;		
  40b104:	1e4b      	subs	r3, r1, #1
  40b106:	b2db      	uxtb	r3, r3
  40b108:	7393      	strb	r3, [r2, #14]
	if(curr_lst->list_highlight > curr_lst->list_start) 
  40b10a:	7b51      	ldrb	r1, [r2, #13]
  40b10c:	4299      	cmp	r1, r3
  40b10e:	d204      	bcs.n	40b11a <dec_list+0x2a>
		if((curr_lst->list_highlight - curr_lst->list_start) > 3) 
  40b110:	1a59      	subs	r1, r3, r1
  40b112:	2903      	cmp	r1, #3
  40b114:	dd01      	ble.n	40b11a <dec_list+0x2a>
			curr_lst->list_start = curr_lst->list_highlight - 3;
  40b116:	3b03      	subs	r3, #3
  40b118:	7353      	strb	r3, [r2, #13]
  40b11a:	4770      	bx	lr
  40b11c:	204056c4 	.word	0x204056c4
  40b120:	20405684 	.word	0x20405684

0040b124 <list_view>:
{
  40b124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	boarder.width=128;
  40b128:	2280      	movs	r2, #128	; 0x80
{
  40b12a:	b083      	sub	sp, #12
	const char side_arrow[2] = {4,0};
  40b12c:	2400      	movs	r4, #0
	boarder.length=64;
  40b12e:	2340      	movs	r3, #64	; 0x40
	boarder.width=128;
  40b130:	f88d 2006 	strb.w	r2, [sp, #6]
	const char side_arrow[2] = {4,0};
  40b134:	2504      	movs	r5, #4
	boarder.length=64;
  40b136:	f88d 3007 	strb.w	r3, [sp, #7]
	boarder.x=0;
  40b13a:	f88d 4004 	strb.w	r4, [sp, #4]
	boarder.y=0;
  40b13e:	f88d 4005 	strb.w	r4, [sp, #5]
	draw_rect(boarder);
  40b142:	9801      	ldr	r0, [sp, #4]
  40b144:	4b38      	ldr	r3, [pc, #224]	; (40b228 <list_view+0x104>)
	if((*curr_lst).menue_name) write_r_text((*curr_lst).menue_name, public_lang);
  40b146:	4e39      	ldr	r6, [pc, #228]	; (40b22c <list_view+0x108>)
	const char side_arrow[2] = {4,0};
  40b148:	f88d 4001 	strb.w	r4, [sp, #1]
  40b14c:	f88d 5000 	strb.w	r5, [sp]
	draw_rect(boarder);
  40b150:	4798      	blx	r3
	glcd_gotoxy (4,3);
  40b152:	4628      	mov	r0, r5
  40b154:	4b36      	ldr	r3, [pc, #216]	; (40b230 <list_view+0x10c>)
  40b156:	2103      	movs	r1, #3
  40b158:	4798      	blx	r3
	if((*curr_lst).menue_name) write_r_text((*curr_lst).menue_name, public_lang);
  40b15a:	6833      	ldr	r3, [r6, #0]
  40b15c:	6998      	ldr	r0, [r3, #24]
  40b15e:	b110      	cbz	r0, 40b166 <list_view+0x42>
  40b160:	4621      	mov	r1, r4
  40b162:	4b34      	ldr	r3, [pc, #208]	; (40b234 <list_view+0x110>)
  40b164:	4798      	blx	r3
	d_line(0, 128, 13, 13);
  40b166:	230d      	movs	r3, #13
  40b168:	4d33      	ldr	r5, [pc, #204]	; (40b238 <list_view+0x114>)
  40b16a:	2180      	movs	r1, #128	; 0x80
  40b16c:	2000      	movs	r0, #0
  40b16e:	461a      	mov	r2, r3
	tmp_lst = curr_lst->lst_itms;
  40b170:	2414      	movs	r4, #20
	d_line(0, 128, 13, 13);
  40b172:	47a8      	blx	r5
	tmp_lst = curr_lst->lst_itms;
  40b174:	6833      	ldr	r3, [r6, #0]
  40b176:	2500      	movs	r5, #0
  40b178:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 40b24c <list_view+0x128>
  40b17c:	f8d3 a008 	ldr.w	sl, [r3, #8]
  40b180:	7b5a      	ldrb	r2, [r3, #13]
			write_r_text(itos(i + curr_lst->list_start), public_lang);
  40b182:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 40b234 <list_view+0x110>
		if(((*curr_lst).list_start + i) < curr_lst_max)
  40b186:	eb02 0e05 	add.w	lr, r2, r5
  40b18a:	f89b c000 	ldrb.w	ip, [fp]
			write_r_text( (tmp_lst + lst_indeces[i + curr_lst->list_start])->text, public_lang);
  40b18e:	4f2b      	ldr	r7, [pc, #172]	; (40b23c <list_view+0x118>)
			glcd_gotoxy(2, i*11 + 20);
  40b190:	4621      	mov	r1, r4
		if(((*curr_lst).list_start + i) < curr_lst_max)
  40b192:	45e6      	cmp	lr, ip
			glcd_gotoxy(2, i*11 + 20);
  40b194:	f04f 0002 	mov.w	r0, #2
			write_r_text( (tmp_lst + lst_indeces[i + curr_lst->list_start])->text, public_lang);
  40b198:	eb07 0805 	add.w	r8, r7, r5
		if(((*curr_lst).list_start + i) < curr_lst_max)
  40b19c:	da32      	bge.n	40b204 <list_view+0xe0>
			glcd_gotoxy(2, i*11 + 20);
  40b19e:	4b24      	ldr	r3, [pc, #144]	; (40b230 <list_view+0x10c>)
  40b1a0:	4798      	blx	r3
			write_r_text(itos(i + curr_lst->list_start), public_lang);
  40b1a2:	6833      	ldr	r3, [r6, #0]
  40b1a4:	7b58      	ldrb	r0, [r3, #13]
  40b1a6:	4b26      	ldr	r3, [pc, #152]	; (40b240 <list_view+0x11c>)
  40b1a8:	4428      	add	r0, r5
  40b1aa:	3501      	adds	r5, #1
  40b1ac:	17c1      	asrs	r1, r0, #31
  40b1ae:	4798      	blx	r3
  40b1b0:	2100      	movs	r1, #0
  40b1b2:	47c8      	blx	r9
			glcd_gotoxy(16, i*11 + 20);
  40b1b4:	4621      	mov	r1, r4
  40b1b6:	2010      	movs	r0, #16
  40b1b8:	4b1d      	ldr	r3, [pc, #116]	; (40b230 <list_view+0x10c>)
  40b1ba:	4798      	blx	r3
			write_r_text( (tmp_lst + lst_indeces[i + curr_lst->list_start])->text, public_lang);
  40b1bc:	6833      	ldr	r3, [r6, #0]
  40b1be:	2100      	movs	r1, #0
  40b1c0:	7b5b      	ldrb	r3, [r3, #13]
  40b1c2:	f818 3003 	ldrb.w	r3, [r8, r3]
  40b1c6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40b1ca:	f85a 0033 	ldr.w	r0, [sl, r3, lsl #3]
  40b1ce:	47c8      	blx	r9
			glcd_gotoxy(128-2-6, i*11 + 20);
  40b1d0:	4621      	mov	r1, r4
  40b1d2:	2078      	movs	r0, #120	; 0x78
  40b1d4:	4b16      	ldr	r3, [pc, #88]	; (40b230 <list_view+0x10c>)
  40b1d6:	4798      	blx	r3
			if((tmp_lst + lst_indeces[i + curr_lst->list_start])->child) write_r_text(side_arrow, public_lang);
  40b1d8:	6833      	ldr	r3, [r6, #0]
  40b1da:	2100      	movs	r1, #0
  40b1dc:	4668      	mov	r0, sp
  40b1de:	7b5a      	ldrb	r2, [r3, #13]
  40b1e0:	f818 e002 	ldrb.w	lr, [r8, r2]
  40b1e4:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
  40b1e8:	eb0a 0ece 	add.w	lr, sl, lr, lsl #3
  40b1ec:	f8de e020 	ldr.w	lr, [lr, #32]
  40b1f0:	f1be 0f00 	cmp.w	lr, #0
  40b1f4:	d002      	beq.n	40b1fc <list_view+0xd8>
  40b1f6:	47c8      	blx	r9
  40b1f8:	6833      	ldr	r3, [r6, #0]
  40b1fa:	7b5a      	ldrb	r2, [r3, #13]
  40b1fc:	340b      	adds	r4, #11
	for(i=0; i < 4; i++)
  40b1fe:	2d04      	cmp	r5, #4
  40b200:	b2e4      	uxtb	r4, r4
  40b202:	d1c0      	bne.n	40b186 <list_view+0x62>
	highlight_rect.y =(curr_lst->list_highlight - curr_lst->list_start)*11 + 20 -1;
  40b204:	7b9b      	ldrb	r3, [r3, #14]
	highlight_rect.length =9+1;
  40b206:	200a      	movs	r0, #10
	highlight_rect.y =(curr_lst->list_highlight - curr_lst->list_start)*11 + 20 -1;
  40b208:	490e      	ldr	r1, [pc, #56]	; (40b244 <list_view+0x120>)
  40b20a:	1a9a      	subs	r2, r3, r2
	flip_rect(highlight_rect);
  40b20c:	4b0e      	ldr	r3, [pc, #56]	; (40b248 <list_view+0x124>)
	highlight_rect.length =9+1;
  40b20e:	70c8      	strb	r0, [r1, #3]
	highlight_rect.y =(curr_lst->list_highlight - curr_lst->list_start)*11 + 20 -1;
  40b210:	eb02 0082 	add.w	r0, r2, r2, lsl #2
  40b214:	eb02 0240 	add.w	r2, r2, r0, lsl #1
  40b218:	3213      	adds	r2, #19
  40b21a:	704a      	strb	r2, [r1, #1]
	flip_rect(highlight_rect);
  40b21c:	6808      	ldr	r0, [r1, #0]
  40b21e:	4798      	blx	r3
}
  40b220:	b003      	add	sp, #12
  40b222:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40b226:	bf00      	nop
  40b228:	0040c6a1 	.word	0x0040c6a1
  40b22c:	204056c4 	.word	0x204056c4
  40b230:	0040c7a5 	.word	0x0040c7a5
  40b234:	0040cf51 	.word	0x0040cf51
  40b238:	0040c541 	.word	0x0040c541
  40b23c:	20405690 	.word	0x20405690
  40b240:	0040c205 	.word	0x0040c205
  40b244:	20405688 	.word	0x20405688
  40b248:	0040c669 	.word	0x0040c669
  40b24c:	20405684 	.word	0x20405684

0040b250 <list_save_val>:
{
  40b250:	b570      	push	{r4, r5, r6, lr}
	if(lst_opt_val->data_types  == float_dt)
  40b252:	7803      	ldrb	r3, [r0, #0]
{
  40b254:	4604      	mov	r4, r0
	if(lst_opt_val->data_types  == float_dt)
  40b256:	2b03      	cmp	r3, #3
  40b258:	d00a      	beq.n	40b270 <list_save_val+0x20>
	else if(lst_opt_val->data_types == fixedpt_dt)
  40b25a:	2b02      	cmp	r3, #2
  40b25c:	d026      	beq.n	40b2ac <list_save_val+0x5c>
	else if(lst_opt_val->data_types == uint16_dt)
  40b25e:	2b01      	cmp	r3, #1
  40b260:	d03f      	beq.n	40b2e2 <list_save_val+0x92>
	else if(lst_opt_val->data_types == uint8_dt)
  40b262:	2b00      	cmp	r3, #0
  40b264:	d038      	beq.n	40b2d8 <list_save_val+0x88>
	if(lst_opt_val->new_val_flag) *lst_opt_val->new_val_flag =1;
  40b266:	6a23      	ldr	r3, [r4, #32]
  40b268:	b10b      	cbz	r3, 40b26e <list_save_val+0x1e>
  40b26a:	2201      	movs	r2, #1
  40b26c:	701a      	strb	r2, [r3, #0]
  40b26e:	bd70      	pop	{r4, r5, r6, pc}
		*(float *)(lst_opt_val->val) = lst_val_entered;
  40b270:	4a20      	ldr	r2, [pc, #128]	; (40b2f4 <list_save_val+0xa4>)
  40b272:	69c3      	ldr	r3, [r0, #28]
  40b274:	edd2 7a00 	vldr	s15, [r2]
  40b278:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b27c:	edc3 7a00 	vstr	s15, [r3]
		*(float *)(lst_opt_val->val) /= lst_power(lst_opt_val->mantissa_count);
  40b280:	6882      	ldr	r2, [r0, #8]
	for (count; count>0; count--)
  40b282:	2a00      	cmp	r2, #0
  40b284:	d032      	beq.n	40b2ec <list_save_val+0x9c>
  40b286:	2301      	movs	r3, #1
		res *= 10;
  40b288:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	for (count; count>0; count--)
  40b28c:	3a01      	subs	r2, #1
		res *= 10;
  40b28e:	ea4f 0343 	mov.w	r3, r3, lsl #1
	for (count; count>0; count--)
  40b292:	d1f9      	bne.n	40b288 <list_save_val+0x38>
  40b294:	ee07 3a90 	vmov	s15, r3
  40b298:	eef8 7a67 	vcvt.f32.u32	s15, s15
		*(float *)(lst_opt_val->val) /= lst_power(lst_opt_val->mantissa_count);
  40b29c:	69e3      	ldr	r3, [r4, #28]
  40b29e:	edd3 6a00 	vldr	s13, [r3]
  40b2a2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  40b2a6:	ed83 7a00 	vstr	s14, [r3]
  40b2aa:	e7dc      	b.n	40b266 <list_save_val+0x16>
		tmp = (lst_val_entered);
  40b2ac:	4a11      	ldr	r2, [pc, #68]	; (40b2f4 <list_save_val+0xa4>)
		tmp /= lst_power(lst_opt_val->mantissa_count);
  40b2ae:	6883      	ldr	r3, [r0, #8]
		tmp *= FIXEDPT_ONE;
  40b2b0:	6812      	ldr	r2, [r2, #0]
  40b2b2:	17d1      	asrs	r1, r2, #31
  40b2b4:	03d0      	lsls	r0, r2, #15
  40b2b6:	03c9      	lsls	r1, r1, #15
  40b2b8:	ea41 4152 	orr.w	r1, r1, r2, lsr #17
	for (count; count>0; count--)
  40b2bc:	2201      	movs	r2, #1
  40b2be:	b12b      	cbz	r3, 40b2cc <list_save_val+0x7c>
		res *= 10;
  40b2c0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	for (count; count>0; count--)
  40b2c4:	3b01      	subs	r3, #1
		res *= 10;
  40b2c6:	ea4f 0242 	mov.w	r2, r2, lsl #1
	for (count; count>0; count--)
  40b2ca:	d1f9      	bne.n	40b2c0 <list_save_val+0x70>
		*(fixedpt *)(lst_opt_val->val) = tmp;
  40b2cc:	69e5      	ldr	r5, [r4, #28]
		tmp /= lst_power(lst_opt_val->mantissa_count);
  40b2ce:	2300      	movs	r3, #0
  40b2d0:	4e09      	ldr	r6, [pc, #36]	; (40b2f8 <list_save_val+0xa8>)
  40b2d2:	47b0      	blx	r6
		*(fixedpt *)(lst_opt_val->val) = tmp;
  40b2d4:	6028      	str	r0, [r5, #0]
  40b2d6:	e7c6      	b.n	40b266 <list_save_val+0x16>
		*(uint8_t *)(lst_opt_val->val) = lst_val_entered;
  40b2d8:	4a06      	ldr	r2, [pc, #24]	; (40b2f4 <list_save_val+0xa4>)
  40b2da:	69c3      	ldr	r3, [r0, #28]
  40b2dc:	6812      	ldr	r2, [r2, #0]
  40b2de:	701a      	strb	r2, [r3, #0]
  40b2e0:	e7c1      	b.n	40b266 <list_save_val+0x16>
		*(uint16_t *)(lst_opt_val->val) = lst_val_entered;
  40b2e2:	4a04      	ldr	r2, [pc, #16]	; (40b2f4 <list_save_val+0xa4>)
  40b2e4:	69c3      	ldr	r3, [r0, #28]
  40b2e6:	6812      	ldr	r2, [r2, #0]
  40b2e8:	801a      	strh	r2, [r3, #0]
  40b2ea:	e7bc      	b.n	40b266 <list_save_val+0x16>
	for (count; count>0; count--)
  40b2ec:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  40b2f0:	e7d4      	b.n	40b29c <list_save_val+0x4c>
  40b2f2:	bf00      	nop
  40b2f4:	20405680 	.word	0x20405680
  40b2f8:	0041905d 	.word	0x0041905d

0040b2fc <list_input_val_decipher>:
void list_input_val_decipher(option_val_t *lst_opt_val)
{
  40b2fc:	b410      	push	{r4}
	uint32_t i, real_part=0, mantissa_part=0, multiplier;
	float lst_val, lst_max, lst_min;
	lst_max = lst_opt_val->max_value;
	lst_min = lst_opt_val->min_value;
	
	if (lst_opt_val->data_types == float_dt)
  40b2fe:	7803      	ldrb	r3, [r0, #0]
	lst_max = lst_opt_val->max_value;
  40b300:	ed90 6a05 	vldr	s12, [r0, #20]
	if (lst_opt_val->data_types == float_dt)
  40b304:	2b03      	cmp	r3, #3
	lst_min = lst_opt_val->min_value;
  40b306:	edd0 6a06 	vldr	s13, [r0, #24]
	if (lst_opt_val->data_types == float_dt)
  40b30a:	d060      	beq.n	40b3ce <list_input_val_decipher+0xd2>
	{
		lst_val = *((float *)(lst_opt_val->val));
	}
	else if(lst_opt_val->data_types == fixedpt_dt)
  40b30c:	2b02      	cmp	r3, #2
  40b30e:	d062      	beq.n	40b3d6 <list_input_val_decipher+0xda>
	{
		lst_val = fixedpt_tofloat( *((fixedpt *)(lst_opt_val->val)));
	}
	else if(lst_opt_val->data_types == uint16_dt)
  40b310:	2b01      	cmp	r3, #1
  40b312:	d06d      	beq.n	40b3f0 <list_input_val_decipher+0xf4>
	{
		lst_val = *((uint16_t *)(lst_opt_val->val));
	}
	else if(lst_opt_val->data_types == uint8_dt)
  40b314:	2b00      	cmp	r3, #0
  40b316:	d064      	beq.n	40b3e2 <list_input_val_decipher+0xe6>
	{
		lst_val = *((uint8_t *)(lst_opt_val->val));
	}
	list_has_asign = 0;
	if(lst_min < 0) list_has_asign = 1;
  40b318:	eef5 6ac0 	vcmpe.f32	s13, #0.0
  40b31c:	4b3b      	ldr	r3, [pc, #236]	; (40b40c <list_input_val_decipher+0x110>)
  40b31e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	
	if(lst_val > lst_max) lst_val = lst_max;
  40b322:	eef4 7ac6 	vcmpe.f32	s15, s12
	list_has_asign = 0;
  40b326:	bf54      	ite	pl
  40b328:	2200      	movpl	r2, #0
	if(lst_min < 0) list_has_asign = 1;
  40b32a:	2201      	movmi	r2, #1
	if(lst_val > lst_max) lst_val = lst_max;
  40b32c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if(lst_min < 0) list_has_asign = 1;
  40b330:	701a      	strb	r2, [r3, #0]
	if(lst_val > lst_max) lst_val = lst_max;
  40b332:	dc40      	bgt.n	40b3b6 <list_input_val_decipher+0xba>
  40b334:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
	else if(lst_val < lst_min) lst_val = lst_min;
	

	if (lst_val < 0)
  40b338:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40b33c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40b340:	d440      	bmi.n	40b3c4 <list_input_val_decipher+0xc8>
  40b342:	2401      	movs	r4, #1
	{
		list_val_sign = -1;
		lst_val *= -1;	
	}
	real_part = lst_val;
  40b344:	eefc 5ae7 	vcvt.u32.f32	s11, s15
	lst_val -= real_part;
	mantissa_part = 0;
	for (i=0; i<lst_opt_val->mantissa_count; i++)
  40b348:	6881      	ldr	r1, [r0, #8]
	lst_val -= real_part;
  40b34a:	eeb8 7a65 	vcvt.f32.u32	s14, s11
  40b34e:	ee77 7ac7 	vsub.f32	s15, s15, s14
	for (i=0; i<lst_opt_val->mantissa_count; i++)
  40b352:	2900      	cmp	r1, #0
  40b354:	d053      	beq.n	40b3fe <list_input_val_decipher+0x102>
	{
		lst_val *= 10;
  40b356:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
	for (i=0; i<lst_opt_val->mantissa_count; i++)
  40b35a:	2300      	movs	r3, #0
  40b35c:	3301      	adds	r3, #1
		lst_val *= 10;
  40b35e:	ee67 7a87 	vmul.f32	s15, s15, s14
	for (i=0; i<lst_opt_val->mantissa_count; i++)
  40b362:	428b      	cmp	r3, r1
  40b364:	d1fa      	bne.n	40b35c <list_input_val_decipher+0x60>
	}
	mantissa_part = lst_val;
  40b366:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  40b36a:	2201      	movs	r2, #1
		res *= 10;
  40b36c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	for (count; count>0; count--)
  40b370:	3b01      	subs	r3, #1
		res *= 10;
  40b372:	ea4f 0242 	mov.w	r2, r2, lsl #1
	for (count; count>0; count--)
  40b376:	d1f9      	bne.n	40b36c <list_input_val_decipher+0x70>
  40b378:	ee07 2a10 	vmov	s14, r2
  40b37c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
	
	multiplier = lst_power(lst_opt_val->mantissa_count);

	lst_val_entered = real_part * multiplier + mantissa_part;
  40b380:	ee15 3a90 	vmov	r3, s11
  40b384:	ee17 1a90 	vmov	r1, s15
	lst_val_entered *= list_val_sign;
	
	list_val_max = (lst_opt_val->max_value * multiplier);
  40b388:	ee26 6a07 	vmul.f32	s12, s12, s14
	lst_val_entered *= list_val_sign;
  40b38c:	4820      	ldr	r0, [pc, #128]	; (40b410 <list_input_val_decipher+0x114>)
	list_val_min = (lst_opt_val->min_value * multiplier);
  40b38e:	ee66 6a87 	vmul.f32	s13, s13, s14
	lst_val_entered = real_part * multiplier + mantissa_part;
  40b392:	fb02 1203 	mla	r2, r2, r3, r1
	list_val_max = (lst_opt_val->max_value * multiplier);
  40b396:	491f      	ldr	r1, [pc, #124]	; (40b414 <list_input_val_decipher+0x118>)
  40b398:	eebd 6ac6 	vcvt.s32.f32	s12, s12
	lst_val_entered *= list_val_sign;
  40b39c:	fb04 f202 	mul.w	r2, r4, r2
	list_val_min = (lst_opt_val->min_value * multiplier);
  40b3a0:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  40b3a4:	4b1c      	ldr	r3, [pc, #112]	; (40b418 <list_input_val_decipher+0x11c>)
	lst_val_entered *= list_val_sign;
  40b3a6:	6002      	str	r2, [r0, #0]
	list_val_max = (lst_opt_val->max_value * multiplier);
  40b3a8:	ed81 6a00 	vstr	s12, [r1]
	list_val_min = (lst_opt_val->min_value * multiplier);
  40b3ac:	edc3 6a00 	vstr	s13, [r3]
	
}
  40b3b0:	f85d 4b04 	ldr.w	r4, [sp], #4
  40b3b4:	4770      	bx	lr
	if(lst_val > lst_max) lst_val = lst_max;
  40b3b6:	eef0 7a46 	vmov.f32	s15, s12
	if (lst_val < 0)
  40b3ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40b3be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40b3c2:	d5be      	bpl.n	40b342 <list_input_val_decipher+0x46>
		lst_val *= -1;	
  40b3c4:	eef1 7a67 	vneg.f32	s15, s15
  40b3c8:	f04f 34ff 	mov.w	r4, #4294967295
  40b3cc:	e7ba      	b.n	40b344 <list_input_val_decipher+0x48>
		lst_val = *((float *)(lst_opt_val->val));
  40b3ce:	69c3      	ldr	r3, [r0, #28]
  40b3d0:	edd3 7a00 	vldr	s15, [r3]
  40b3d4:	e7a0      	b.n	40b318 <list_input_val_decipher+0x1c>
		lst_val = fixedpt_tofloat( *((fixedpt *)(lst_opt_val->val)));
  40b3d6:	69c3      	ldr	r3, [r0, #28]
  40b3d8:	edd3 7a00 	vldr	s15, [r3]
  40b3dc:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
  40b3e0:	e79a      	b.n	40b318 <list_input_val_decipher+0x1c>
		lst_val = *((uint8_t *)(lst_opt_val->val));
  40b3e2:	69c3      	ldr	r3, [r0, #28]
  40b3e4:	781b      	ldrb	r3, [r3, #0]
  40b3e6:	ee07 3a90 	vmov	s15, r3
  40b3ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
  40b3ee:	e793      	b.n	40b318 <list_input_val_decipher+0x1c>
		lst_val = *((uint16_t *)(lst_opt_val->val));
  40b3f0:	69c3      	ldr	r3, [r0, #28]
  40b3f2:	881b      	ldrh	r3, [r3, #0]
  40b3f4:	ee07 3a90 	vmov	s15, r3
  40b3f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
  40b3fc:	e78c      	b.n	40b318 <list_input_val_decipher+0x1c>
	mantissa_part = lst_val;
  40b3fe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	uint32_t res=1;
  40b402:	2201      	movs	r2, #1
	mantissa_part = lst_val;
  40b404:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  40b408:	e7ba      	b.n	40b380 <list_input_val_decipher+0x84>
  40b40a:	bf00      	nop
  40b40c:	204008fb 	.word	0x204008fb
  40b410:	20405680 	.word	0x20405680
  40b414:	2040568c 	.word	0x2040568c
  40b418:	2040567c 	.word	0x2040567c

0040b41c <list_set_date_exe>:
/////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t lst_date_t_entered[3];
uint8_t time_date_mode = 0;
uint_t list_set_date_exe(option_val_t *lst_opt_val, char enter, char esc, char up, char down, char left, char right)
{
  40b41c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40b420:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
  40b424:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
  40b428:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
	uint32_t i, l, d_index;
	uint32_t temp;
	char *list_val_break;
	
	if(enter)
  40b42c:	b159      	cbz	r1, 40b446 <list_set_date_exe+0x2a>
	{
		//todo save date
		if(time_date_mode == 0) rtc_save_date(lst_date_t_entered[0], lst_date_t_entered[1], lst_date_t_entered[2]);
  40b42e:	4b67      	ldr	r3, [pc, #412]	; (40b5cc <list_set_date_exe+0x1b0>)
  40b430:	781c      	ldrb	r4, [r3, #0]
  40b432:	4b67      	ldr	r3, [pc, #412]	; (40b5d0 <list_set_date_exe+0x1b4>)
  40b434:	2c00      	cmp	r4, #0
  40b436:	d070      	beq.n	40b51a <list_set_date_exe+0xfe>
		else con_toff_save_date(lst_date_t_entered[0], lst_date_t_entered[1], lst_date_t_entered[2]);
  40b438:	4c66      	ldr	r4, [pc, #408]	; (40b5d4 <list_set_date_exe+0x1b8>)
  40b43a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  40b43e:	47a0      	blx	r4
		return 0;
  40b440:	2000      	movs	r0, #0
  40b442:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	
	if(esc) return 0;
  40b446:	2a00      	cmp	r2, #0
  40b448:	d1fa      	bne.n	40b440 <list_set_date_exe+0x24>
	if(right) list_cursor++;
  40b44a:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 40b600 <list_set_date_exe+0x1e4>
  40b44e:	f898 2000 	ldrb.w	r2, [r8]
  40b452:	2800      	cmp	r0, #0
  40b454:	d168      	bne.n	40b528 <list_set_date_exe+0x10c>
	else if(left) list_cursor--;
  40b456:	b11d      	cbz	r5, 40b460 <list_set_date_exe+0x44>
  40b458:	3a01      	subs	r2, #1
  40b45a:	b2d2      	uxtb	r2, r2
  40b45c:	f888 2000 	strb.w	r2, [r8]
	
	if(list_cursor == 0xFF) list_cursor = 7;
  40b460:	2aff      	cmp	r2, #255	; 0xff
  40b462:	f000 8098 	beq.w	40b596 <list_set_date_exe+0x17a>
	else if(list_cursor > 7) list_cursor = 0;
  40b466:	2a07      	cmp	r2, #7
  40b468:	f240 8086 	bls.w	40b578 <list_set_date_exe+0x15c>
  40b46c:	2100      	movs	r1, #0
	
	if (list_cursor < 2) d_index = 0; 
  40b46e:	460a      	mov	r2, r1
	else if(list_cursor > 7) list_cursor = 0;
  40b470:	f888 1000 	strb.w	r1, [r8]
	else if (list_cursor < 4) d_index = 1; 
	else d_index = 2;
	
	if(up)
  40b474:	2b00      	cmp	r3, #0
  40b476:	d07b      	beq.n	40b570 <list_set_date_exe+0x154>
	{
		lst_date_t_entered[d_index] += lst_power( 1 - (list_cursor - d_index * 2));
  40b478:	ebc2 0341 	rsb	r3, r2, r1, lsl #1
  40b47c:	3301      	adds	r3, #1
	else d_index = 2;
  40b47e:	2201      	movs	r2, #1
		res *= 10;
  40b480:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	for (count; count>0; count--)
  40b484:	3b01      	subs	r3, #1
		res *= 10;
  40b486:	ea4f 0242 	mov.w	r2, r2, lsl #1
	for (count; count>0; count--)
  40b48a:	d1f9      	bne.n	40b480 <list_set_date_exe+0x64>
		lst_date_t_entered[d_index] += lst_power( 1 - (list_cursor - d_index * 2));
  40b48c:	f8df 9140 	ldr.w	r9, [pc, #320]	; 40b5d0 <list_set_date_exe+0x1b4>
  40b490:	f859 3021 	ldr.w	r3, [r9, r1, lsl #2]
  40b494:	441a      	add	r2, r3
  40b496:	f849 2021 	str.w	r2, [r9, r1, lsl #2]
	}
	else if(down)
	{
		lst_date_t_entered[d_index] -= lst_power( 1 - (list_cursor - d_index * 2));
	}
	rtc_date_check(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b49a:	4a4f      	ldr	r2, [pc, #316]	; (40b5d8 <list_set_date_exe+0x1bc>)

	glcd_gotoxy(2,16);
	glcd_putsf("Set date", 0);
	
	glcd_gotoxy(2, 53);
	glcd_putsf("20", 0);
  40b49c:	2500      	movs	r5, #0
	rtc_date_check(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b49e:	4b4f      	ldr	r3, [pc, #316]	; (40b5dc <list_set_date_exe+0x1c0>)
  40b4a0:	1f11      	subs	r1, r2, #4
  40b4a2:	f1a2 0008 	sub.w	r0, r2, #8
  40b4a6:	4798      	blx	r3
	glcd_gotoxy(2,16);
  40b4a8:	4c4d      	ldr	r4, [pc, #308]	; (40b5e0 <list_set_date_exe+0x1c4>)
  40b4aa:	2110      	movs	r1, #16
  40b4ac:	2002      	movs	r0, #2
  40b4ae:	47a0      	blx	r4
	glcd_putsf("Set date", 0);
  40b4b0:	4b4c      	ldr	r3, [pc, #304]	; (40b5e4 <list_set_date_exe+0x1c8>)
  40b4b2:	4629      	mov	r1, r5
  40b4b4:	484c      	ldr	r0, [pc, #304]	; (40b5e8 <list_set_date_exe+0x1cc>)
  40b4b6:	4798      	blx	r3
	glcd_gotoxy(2, 53);
  40b4b8:	2135      	movs	r1, #53	; 0x35
  40b4ba:	2002      	movs	r0, #2
  40b4bc:	f8df a144 	ldr.w	sl, [pc, #324]	; 40b604 <list_set_date_exe+0x1e8>
  40b4c0:	47a0      	blx	r4
	glcd_putsf("20", 0);
  40b4c2:	4629      	mov	r1, r5
  40b4c4:	4849      	ldr	r0, [pc, #292]	; (40b5ec <list_set_date_exe+0x1d0>)
  40b4c6:	4b47      	ldr	r3, [pc, #284]	; (40b5e4 <list_set_date_exe+0x1c8>)
  40b4c8:	4798      	blx	r3
	
	for (l=0; l<3; l++)
	{
		temp = lst_date_t_entered[l];
		
		list_val_break = itos(temp);
  40b4ca:	2100      	movs	r1, #0
  40b4cc:	f859 0015 	ldr.w	r0, [r9, r5, lsl #1]
  40b4d0:	4b47      	ldr	r3, [pc, #284]	; (40b5f0 <list_set_date_exe+0x1d4>)
		temp = lst_date_t_entered[l];
  40b4d2:	eb09 0645 	add.w	r6, r9, r5, lsl #1
		
		temp = 10;
		
		for (i=0; i<2; i++)
  40b4d6:	460c      	mov	r4, r1
		temp = 10;
  40b4d8:	270a      	movs	r7, #10
		list_val_break = itos(temp);
  40b4da:	4798      	blx	r3
  40b4dc:	4683      	mov	fp, r0
		{
			if (lst_date_t_entered[l] < temp)
  40b4de:	6833      	ldr	r3, [r6, #0]
  40b4e0:	42bb      	cmp	r3, r7
  40b4e2:	d331      	bcc.n	40b548 <list_set_date_exe+0x12c>
			{
				out_char('0', (i + l*2  == list_cursor));
				temp /= 10;
			}
			else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b4e4:	f89b 3000 	ldrb.w	r3, [fp]
			{
				out_char(*list_val_break , (i + l*2 == list_cursor));
  40b4e8:	1929      	adds	r1, r5, r4
				list_val_break++;
			}
			else
			{
				out_char('0', (i + l*2 == list_cursor));
  40b4ea:	2030      	movs	r0, #48	; 0x30
			else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b4ec:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
				out_char('0', (i + l*2 == list_cursor));
  40b4f0:	468e      	mov	lr, r1
			else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b4f2:	2a09      	cmp	r2, #9
  40b4f4:	d81d      	bhi.n	40b532 <list_set_date_exe+0x116>
				out_char(*list_val_break , (i + l*2 == list_cursor));
  40b4f6:	f898 2000 	ldrb.w	r2, [r8]
  40b4fa:	4618      	mov	r0, r3
				list_val_break++;
  40b4fc:	f10b 0b01 	add.w	fp, fp, #1
				out_char(*list_val_break , (i + l*2 == list_cursor));
  40b500:	1a89      	subs	r1, r1, r2
  40b502:	fab1 f181 	clz	r1, r1
  40b506:	0949      	lsrs	r1, r1, #5
  40b508:	47d0      	blx	sl
		for (i=0; i<2; i++)
  40b50a:	3401      	adds	r4, #1
  40b50c:	2c02      	cmp	r4, #2
  40b50e:	d1e6      	bne.n	40b4de <list_set_date_exe+0xc2>
				list_val_break++;
			}
		}
		if (l<2) glcd_putsf("/", 0);
  40b510:	2d04      	cmp	r5, #4
  40b512:	d127      	bne.n	40b564 <list_set_date_exe+0x148>
  40b514:	2001      	movs	r0, #1
  40b516:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(time_date_mode == 0) rtc_save_date(lst_date_t_entered[0], lst_date_t_entered[1], lst_date_t_entered[2]);
  40b51a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  40b51e:	4d35      	ldr	r5, [pc, #212]	; (40b5f4 <list_set_date_exe+0x1d8>)
  40b520:	47a8      	blx	r5
		return 0;
  40b522:	4620      	mov	r0, r4
  40b524:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(right) list_cursor++;
  40b528:	3201      	adds	r2, #1
  40b52a:	b2d2      	uxtb	r2, r2
  40b52c:	f888 2000 	strb.w	r2, [r8]
  40b530:	e796      	b.n	40b460 <list_set_date_exe+0x44>
				out_char('0', (i + l*2 == list_cursor));
  40b532:	f898 1000 	ldrb.w	r1, [r8]
				list_val_break++;
  40b536:	f10b 0b01 	add.w	fp, fp, #1
				out_char('0', (i + l*2 == list_cursor));
  40b53a:	ebae 0101 	sub.w	r1, lr, r1
  40b53e:	fab1 f181 	clz	r1, r1
  40b542:	0949      	lsrs	r1, r1, #5
  40b544:	47d0      	blx	sl
  40b546:	e7e0      	b.n	40b50a <list_set_date_exe+0xee>
				out_char('0', (i + l*2  == list_cursor));
  40b548:	f898 3000 	ldrb.w	r3, [r8]
  40b54c:	1929      	adds	r1, r5, r4
  40b54e:	2030      	movs	r0, #48	; 0x30
  40b550:	1a59      	subs	r1, r3, r1
  40b552:	fab1 f181 	clz	r1, r1
  40b556:	0949      	lsrs	r1, r1, #5
  40b558:	47d0      	blx	sl
				temp /= 10;
  40b55a:	4b27      	ldr	r3, [pc, #156]	; (40b5f8 <list_set_date_exe+0x1dc>)
  40b55c:	fba3 3707 	umull	r3, r7, r3, r7
  40b560:	08ff      	lsrs	r7, r7, #3
  40b562:	e7d2      	b.n	40b50a <list_set_date_exe+0xee>
		if (l<2) glcd_putsf("/", 0);
  40b564:	2100      	movs	r1, #0
  40b566:	4825      	ldr	r0, [pc, #148]	; (40b5fc <list_set_date_exe+0x1e0>)
  40b568:	4b1e      	ldr	r3, [pc, #120]	; (40b5e4 <list_set_date_exe+0x1c8>)
  40b56a:	3502      	adds	r5, #2
  40b56c:	4798      	blx	r3
  40b56e:	e7ac      	b.n	40b4ca <list_set_date_exe+0xae>
	else if(down)
  40b570:	b9b4      	cbnz	r4, 40b5a0 <list_set_date_exe+0x184>
  40b572:	f8df 905c 	ldr.w	r9, [pc, #92]	; 40b5d0 <list_set_date_exe+0x1b4>
  40b576:	e790      	b.n	40b49a <list_set_date_exe+0x7e>
	if (list_cursor < 2) d_index = 0; 
  40b578:	2a01      	cmp	r2, #1
  40b57a:	d924      	bls.n	40b5c6 <list_set_date_exe+0x1aa>
	else if (list_cursor < 4) d_index = 1; 
  40b57c:	2a03      	cmp	r2, #3
  40b57e:	bf8c      	ite	hi
  40b580:	2102      	movhi	r1, #2
  40b582:	2101      	movls	r1, #1
	if(up)
  40b584:	2b00      	cmp	r3, #0
  40b586:	d0f3      	beq.n	40b570 <list_set_date_exe+0x154>
		lst_date_t_entered[d_index] += lst_power( 1 - (list_cursor - d_index * 2));
  40b588:	ebc2 0341 	rsb	r3, r2, r1, lsl #1
	for (count; count>0; count--)
  40b58c:	3301      	adds	r3, #1
  40b58e:	f47f af76 	bne.w	40b47e <list_set_date_exe+0x62>
	uint32_t res=1;
  40b592:	2201      	movs	r2, #1
  40b594:	e77a      	b.n	40b48c <list_set_date_exe+0x70>
	if(list_cursor == 0xFF) list_cursor = 7;
  40b596:	2207      	movs	r2, #7
	else d_index = 2;
  40b598:	2102      	movs	r1, #2
	if(list_cursor == 0xFF) list_cursor = 7;
  40b59a:	f888 2000 	strb.w	r2, [r8]
  40b59e:	e769      	b.n	40b474 <list_set_date_exe+0x58>
		lst_date_t_entered[d_index] -= lst_power( 1 - (list_cursor - d_index * 2));
  40b5a0:	ebc2 0341 	rsb	r3, r2, r1, lsl #1
	for (count; count>0; count--)
  40b5a4:	2201      	movs	r2, #1
  40b5a6:	3301      	adds	r3, #1
  40b5a8:	d005      	beq.n	40b5b6 <list_set_date_exe+0x19a>
		res *= 10;
  40b5aa:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	for (count; count>0; count--)
  40b5ae:	3b01      	subs	r3, #1
		res *= 10;
  40b5b0:	ea4f 0242 	mov.w	r2, r2, lsl #1
	for (count; count>0; count--)
  40b5b4:	d1f9      	bne.n	40b5aa <list_set_date_exe+0x18e>
		lst_date_t_entered[d_index] -= lst_power( 1 - (list_cursor - d_index * 2));
  40b5b6:	f8df 9018 	ldr.w	r9, [pc, #24]	; 40b5d0 <list_set_date_exe+0x1b4>
  40b5ba:	f859 3021 	ldr.w	r3, [r9, r1, lsl #2]
  40b5be:	1a9a      	subs	r2, r3, r2
  40b5c0:	f849 2021 	str.w	r2, [r9, r1, lsl #2]
  40b5c4:	e769      	b.n	40b49a <list_set_date_exe+0x7e>
	if (list_cursor < 2) d_index = 0; 
  40b5c6:	2100      	movs	r1, #0
  40b5c8:	e7dc      	b.n	40b584 <list_set_date_exe+0x168>
  40b5ca:	bf00      	nop
  40b5cc:	204008fd 	.word	0x204008fd
  40b5d0:	20405670 	.word	0x20405670
  40b5d4:	0040acbd 	.word	0x0040acbd
  40b5d8:	20405678 	.word	0x20405678
  40b5dc:	0040c0ed 	.word	0x0040c0ed
  40b5e0:	0040c7a5 	.word	0x0040c7a5
  40b5e4:	0040c7b9 	.word	0x0040c7b9
  40b5e8:	0041a720 	.word	0x0041a720
  40b5ec:	0041c9fc 	.word	0x0041c9fc
  40b5f0:	0040c205 	.word	0x0040c205
  40b5f4:	0040c159 	.word	0x0040c159
  40b5f8:	cccccccd 	.word	0xcccccccd
  40b5fc:	0041b008 	.word	0x0041b008
  40b600:	204008fa 	.word	0x204008fa
  40b604:	0040c6f9 	.word	0x0040c6f9

0040b608 <list_set_time_exe>:
	
	
	return 1;
}
uint_t list_set_time_exe(option_val_t *lst_opt_val, char enter, char esc, char up, char down, char left, char right)
{
  40b608:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40b60c:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
  40b610:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
  40b614:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
	uint32_t i, l, d_index;
	uint32_t temp;
	char *list_val_break;
	
	if(enter)
  40b618:	b159      	cbz	r1, 40b632 <list_set_time_exe+0x2a>
	{
		//todo save date
		if(time_date_mode == 0) rtc_save_time(lst_date_t_entered[0], lst_date_t_entered[1], lst_date_t_entered[2]);
  40b61a:	4b65      	ldr	r3, [pc, #404]	; (40b7b0 <list_set_time_exe+0x1a8>)
  40b61c:	781c      	ldrb	r4, [r3, #0]
  40b61e:	4b65      	ldr	r3, [pc, #404]	; (40b7b4 <list_set_time_exe+0x1ac>)
  40b620:	2c00      	cmp	r4, #0
  40b622:	d06c      	beq.n	40b6fe <list_set_time_exe+0xf6>
		else con_toff_save_time(lst_date_t_entered[0], lst_date_t_entered[1], lst_date_t_entered[2]);
  40b624:	4c64      	ldr	r4, [pc, #400]	; (40b7b8 <list_set_time_exe+0x1b0>)
  40b626:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  40b62a:	47a0      	blx	r4
		return 0;
  40b62c:	2000      	movs	r0, #0
  40b62e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	
	if(esc) return 0;
  40b632:	2a00      	cmp	r2, #0
  40b634:	d1fa      	bne.n	40b62c <list_set_time_exe+0x24>
	if(right) list_cursor++;
  40b636:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 40b7e0 <list_set_time_exe+0x1d8>
  40b63a:	f898 2000 	ldrb.w	r2, [r8]
  40b63e:	2800      	cmp	r0, #0
  40b640:	d164      	bne.n	40b70c <list_set_time_exe+0x104>
	else if(left) list_cursor--;
  40b642:	b11d      	cbz	r5, 40b64c <list_set_time_exe+0x44>
  40b644:	3a01      	subs	r2, #1
  40b646:	b2d2      	uxtb	r2, r2
  40b648:	f888 2000 	strb.w	r2, [r8]
	
	if(list_cursor == 0xFF) list_cursor = 7;
  40b64c:	2aff      	cmp	r2, #255	; 0xff
  40b64e:	f000 8094 	beq.w	40b77a <list_set_time_exe+0x172>
	else if(list_cursor > 7) list_cursor = 0;
  40b652:	2a07      	cmp	r2, #7
  40b654:	f240 8082 	bls.w	40b75c <list_set_time_exe+0x154>
  40b658:	2100      	movs	r1, #0
	
	if (list_cursor < 2) d_index = 0;
  40b65a:	460a      	mov	r2, r1
	else if(list_cursor > 7) list_cursor = 0;
  40b65c:	f888 1000 	strb.w	r1, [r8]
	else if (list_cursor < 4) d_index = 1;
	else d_index = 2;
	
	if(up)
  40b660:	2b00      	cmp	r3, #0
  40b662:	d077      	beq.n	40b754 <list_set_time_exe+0x14c>
	{
		lst_date_t_entered[d_index] += lst_power( 1 - (list_cursor - d_index * 2));
  40b664:	ebc2 0341 	rsb	r3, r2, r1, lsl #1
  40b668:	3301      	adds	r3, #1
	else d_index = 2;
  40b66a:	2201      	movs	r2, #1
		res *= 10;
  40b66c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	for (count; count>0; count--)
  40b670:	3b01      	subs	r3, #1
		res *= 10;
  40b672:	ea4f 0242 	mov.w	r2, r2, lsl #1
	for (count; count>0; count--)
  40b676:	d1f9      	bne.n	40b66c <list_set_time_exe+0x64>
		lst_date_t_entered[d_index] += lst_power( 1 - (list_cursor - d_index * 2));
  40b678:	f8df 9138 	ldr.w	r9, [pc, #312]	; 40b7b4 <list_set_time_exe+0x1ac>
  40b67c:	f859 3021 	ldr.w	r3, [r9, r1, lsl #2]
  40b680:	441a      	add	r2, r3
  40b682:	f849 2021 	str.w	r2, [r9, r1, lsl #2]
	}
	else if(down)
	{
		lst_date_t_entered[d_index] -= lst_power( 1 - (list_cursor - d_index * 2));
	}
	rtc_time_check(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b686:	4a4d      	ldr	r2, [pc, #308]	; (40b7bc <list_set_time_exe+0x1b4>)
	

	glcd_gotoxy(2,16);
	glcd_putsf("Set time", 0);
	
	glcd_gotoxy(2, 53);
  40b688:	2500      	movs	r5, #0
	rtc_time_check(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b68a:	4b4d      	ldr	r3, [pc, #308]	; (40b7c0 <list_set_time_exe+0x1b8>)
  40b68c:	1f11      	subs	r1, r2, #4
  40b68e:	f1a2 0008 	sub.w	r0, r2, #8
  40b692:	4798      	blx	r3
	glcd_gotoxy(2,16);
  40b694:	4c4b      	ldr	r4, [pc, #300]	; (40b7c4 <list_set_time_exe+0x1bc>)
  40b696:	2110      	movs	r1, #16
  40b698:	2002      	movs	r0, #2
  40b69a:	47a0      	blx	r4
	glcd_putsf("Set time", 0);
  40b69c:	4629      	mov	r1, r5
  40b69e:	484a      	ldr	r0, [pc, #296]	; (40b7c8 <list_set_time_exe+0x1c0>)
  40b6a0:	4b4a      	ldr	r3, [pc, #296]	; (40b7cc <list_set_time_exe+0x1c4>)
  40b6a2:	4798      	blx	r3
	glcd_gotoxy(2, 53);
  40b6a4:	2135      	movs	r1, #53	; 0x35
  40b6a6:	2002      	movs	r0, #2
  40b6a8:	f8df a138 	ldr.w	sl, [pc, #312]	; 40b7e4 <list_set_time_exe+0x1dc>
  40b6ac:	47a0      	blx	r4
	
	for (l=0; l<3; l++)
	{
		temp = lst_date_t_entered[l];
		
		list_val_break = itos(temp);
  40b6ae:	2100      	movs	r1, #0
  40b6b0:	f859 0015 	ldr.w	r0, [r9, r5, lsl #1]
  40b6b4:	4b46      	ldr	r3, [pc, #280]	; (40b7d0 <list_set_time_exe+0x1c8>)
		temp = lst_date_t_entered[l];
  40b6b6:	eb09 0645 	add.w	r6, r9, r5, lsl #1
		
		temp = 10;
		
		for (i=0; i<2; i++)
  40b6ba:	460c      	mov	r4, r1
		temp = 10;
  40b6bc:	270a      	movs	r7, #10
		list_val_break = itos(temp);
  40b6be:	4798      	blx	r3
  40b6c0:	4683      	mov	fp, r0
		{
			if (lst_date_t_entered[l] < temp)
  40b6c2:	6833      	ldr	r3, [r6, #0]
  40b6c4:	42bb      	cmp	r3, r7
  40b6c6:	d331      	bcc.n	40b72c <list_set_time_exe+0x124>
			{
				out_char('0', (i + l*2  == list_cursor));
				temp /= 10;
			}
			else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b6c8:	f89b 3000 	ldrb.w	r3, [fp]
			{
				out_char(*list_val_break , (i + l*2 == list_cursor));
  40b6cc:	1929      	adds	r1, r5, r4
				list_val_break++;
			}
			else
			{
				out_char('0', (i + l*2 == list_cursor));
  40b6ce:	2030      	movs	r0, #48	; 0x30
			else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b6d0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
				out_char('0', (i + l*2 == list_cursor));
  40b6d4:	468e      	mov	lr, r1
			else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40b6d6:	2a09      	cmp	r2, #9
  40b6d8:	d81d      	bhi.n	40b716 <list_set_time_exe+0x10e>
				out_char(*list_val_break , (i + l*2 == list_cursor));
  40b6da:	f898 2000 	ldrb.w	r2, [r8]
  40b6de:	4618      	mov	r0, r3
				list_val_break++;
  40b6e0:	f10b 0b01 	add.w	fp, fp, #1
				out_char(*list_val_break , (i + l*2 == list_cursor));
  40b6e4:	1a89      	subs	r1, r1, r2
  40b6e6:	fab1 f181 	clz	r1, r1
  40b6ea:	0949      	lsrs	r1, r1, #5
  40b6ec:	47d0      	blx	sl
		for (i=0; i<2; i++)
  40b6ee:	3401      	adds	r4, #1
  40b6f0:	2c02      	cmp	r4, #2
  40b6f2:	d1e6      	bne.n	40b6c2 <list_set_time_exe+0xba>
				list_val_break++;
			}
		}
		if (l<2) glcd_putsf(":", 0);
  40b6f4:	2d04      	cmp	r5, #4
  40b6f6:	d127      	bne.n	40b748 <list_set_time_exe+0x140>
  40b6f8:	2001      	movs	r0, #1
  40b6fa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(time_date_mode == 0) rtc_save_time(lst_date_t_entered[0], lst_date_t_entered[1], lst_date_t_entered[2]);
  40b6fe:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  40b702:	4d34      	ldr	r5, [pc, #208]	; (40b7d4 <list_set_time_exe+0x1cc>)
  40b704:	47a8      	blx	r5
		return 0;
  40b706:	4620      	mov	r0, r4
  40b708:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(right) list_cursor++;
  40b70c:	3201      	adds	r2, #1
  40b70e:	b2d2      	uxtb	r2, r2
  40b710:	f888 2000 	strb.w	r2, [r8]
  40b714:	e79a      	b.n	40b64c <list_set_time_exe+0x44>
				out_char('0', (i + l*2 == list_cursor));
  40b716:	f898 1000 	ldrb.w	r1, [r8]
				list_val_break++;
  40b71a:	f10b 0b01 	add.w	fp, fp, #1
				out_char('0', (i + l*2 == list_cursor));
  40b71e:	ebae 0101 	sub.w	r1, lr, r1
  40b722:	fab1 f181 	clz	r1, r1
  40b726:	0949      	lsrs	r1, r1, #5
  40b728:	47d0      	blx	sl
  40b72a:	e7e0      	b.n	40b6ee <list_set_time_exe+0xe6>
				out_char('0', (i + l*2  == list_cursor));
  40b72c:	f898 3000 	ldrb.w	r3, [r8]
  40b730:	1929      	adds	r1, r5, r4
  40b732:	2030      	movs	r0, #48	; 0x30
  40b734:	1a59      	subs	r1, r3, r1
  40b736:	fab1 f181 	clz	r1, r1
  40b73a:	0949      	lsrs	r1, r1, #5
  40b73c:	47d0      	blx	sl
				temp /= 10;
  40b73e:	4b26      	ldr	r3, [pc, #152]	; (40b7d8 <list_set_time_exe+0x1d0>)
  40b740:	fba3 3707 	umull	r3, r7, r3, r7
  40b744:	08ff      	lsrs	r7, r7, #3
  40b746:	e7d2      	b.n	40b6ee <list_set_time_exe+0xe6>
		if (l<2) glcd_putsf(":", 0);
  40b748:	2100      	movs	r1, #0
  40b74a:	4824      	ldr	r0, [pc, #144]	; (40b7dc <list_set_time_exe+0x1d4>)
  40b74c:	4b1f      	ldr	r3, [pc, #124]	; (40b7cc <list_set_time_exe+0x1c4>)
  40b74e:	3502      	adds	r5, #2
  40b750:	4798      	blx	r3
  40b752:	e7ac      	b.n	40b6ae <list_set_time_exe+0xa6>
	else if(down)
  40b754:	b9b4      	cbnz	r4, 40b784 <list_set_time_exe+0x17c>
  40b756:	f8df 905c 	ldr.w	r9, [pc, #92]	; 40b7b4 <list_set_time_exe+0x1ac>
  40b75a:	e794      	b.n	40b686 <list_set_time_exe+0x7e>
	if (list_cursor < 2) d_index = 0;
  40b75c:	2a01      	cmp	r2, #1
  40b75e:	d924      	bls.n	40b7aa <list_set_time_exe+0x1a2>
	else if (list_cursor < 4) d_index = 1;
  40b760:	2a03      	cmp	r2, #3
  40b762:	bf8c      	ite	hi
  40b764:	2102      	movhi	r1, #2
  40b766:	2101      	movls	r1, #1
	if(up)
  40b768:	2b00      	cmp	r3, #0
  40b76a:	d0f3      	beq.n	40b754 <list_set_time_exe+0x14c>
		lst_date_t_entered[d_index] += lst_power( 1 - (list_cursor - d_index * 2));
  40b76c:	ebc2 0341 	rsb	r3, r2, r1, lsl #1
	for (count; count>0; count--)
  40b770:	3301      	adds	r3, #1
  40b772:	f47f af7a 	bne.w	40b66a <list_set_time_exe+0x62>
	uint32_t res=1;
  40b776:	2201      	movs	r2, #1
  40b778:	e77e      	b.n	40b678 <list_set_time_exe+0x70>
	if(list_cursor == 0xFF) list_cursor = 7;
  40b77a:	2207      	movs	r2, #7
	else d_index = 2;
  40b77c:	2102      	movs	r1, #2
	if(list_cursor == 0xFF) list_cursor = 7;
  40b77e:	f888 2000 	strb.w	r2, [r8]
  40b782:	e76d      	b.n	40b660 <list_set_time_exe+0x58>
		lst_date_t_entered[d_index] -= lst_power( 1 - (list_cursor - d_index * 2));
  40b784:	ebc2 0341 	rsb	r3, r2, r1, lsl #1
	for (count; count>0; count--)
  40b788:	2201      	movs	r2, #1
  40b78a:	3301      	adds	r3, #1
  40b78c:	d005      	beq.n	40b79a <list_set_time_exe+0x192>
		res *= 10;
  40b78e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	for (count; count>0; count--)
  40b792:	3b01      	subs	r3, #1
		res *= 10;
  40b794:	ea4f 0242 	mov.w	r2, r2, lsl #1
	for (count; count>0; count--)
  40b798:	d1f9      	bne.n	40b78e <list_set_time_exe+0x186>
		lst_date_t_entered[d_index] -= lst_power( 1 - (list_cursor - d_index * 2));
  40b79a:	f8df 9018 	ldr.w	r9, [pc, #24]	; 40b7b4 <list_set_time_exe+0x1ac>
  40b79e:	f859 3021 	ldr.w	r3, [r9, r1, lsl #2]
  40b7a2:	1a9a      	subs	r2, r3, r2
  40b7a4:	f849 2021 	str.w	r2, [r9, r1, lsl #2]
  40b7a8:	e76d      	b.n	40b686 <list_set_time_exe+0x7e>
	if (list_cursor < 2) d_index = 0;
  40b7aa:	2100      	movs	r1, #0
  40b7ac:	e7dc      	b.n	40b768 <list_set_time_exe+0x160>
  40b7ae:	bf00      	nop
  40b7b0:	204008fd 	.word	0x204008fd
  40b7b4:	20405670 	.word	0x20405670
  40b7b8:	0040acd1 	.word	0x0040acd1
  40b7bc:	20405678 	.word	0x20405678
  40b7c0:	0040c16d 	.word	0x0040c16d
  40b7c4:	0040c7a5 	.word	0x0040c7a5
  40b7c8:	0041a72c 	.word	0x0041a72c
  40b7cc:	0040c7b9 	.word	0x0040c7b9
  40b7d0:	0040c205 	.word	0x0040c205
  40b7d4:	0040c18d 	.word	0x0040c18d
  40b7d8:	cccccccd 	.word	0xcccccccd
  40b7dc:	0041b00c 	.word	0x0041b00c
  40b7e0:	204008fa 	.word	0x204008fa
  40b7e4:	0040c6f9 	.word	0x0040c6f9

0040b7e8 <list_enter>:

uint_t list_enter(void)
{
	option_t *tmp_lst;
	char lst_highlight, retval = 0;
	tmp_lst = curr_lst->lst_itms;
  40b7e8:	4b32      	ldr	r3, [pc, #200]	; (40b8b4 <list_enter+0xcc>)
	return lst_indeces[lst_highlight];
  40b7ea:	4933      	ldr	r1, [pc, #204]	; (40b8b8 <list_enter+0xd0>)
{
  40b7ec:	b530      	push	{r4, r5, lr}
	tmp_lst = curr_lst->lst_itms;
  40b7ee:	681b      	ldr	r3, [r3, #0]
{
  40b7f0:	b083      	sub	sp, #12
	return lst_indeces[lst_highlight];
  40b7f2:	7b9a      	ldrb	r2, [r3, #14]
	lst_highlight = get_list_indx_from_lhi_light(curr_lst->list_highlight);
	if((tmp_lst+lst_highlight)->enter)
  40b7f4:	689c      	ldr	r4, [r3, #8]
  40b7f6:	5c8b      	ldrb	r3, [r1, r2]
  40b7f8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40b7fc:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
  40b800:	6963      	ldr	r3, [r4, #20]
  40b802:	b10b      	cbz	r3, 40b808 <list_enter+0x20>
	{
		//the list has a funtion to execute 
		(tmp_lst+lst_highlight)->enter();
  40b804:	4798      	blx	r3
		retval = 2;
  40b806:	2302      	movs	r3, #2
	}
	if((tmp_lst + lst_highlight)->option_save_val == 1)
  40b808:	6a60      	ldr	r0, [r4, #36]	; 0x24
  40b80a:	2801      	cmp	r0, #1
  40b80c:	d016      	beq.n	40b83c <list_enter+0x54>
		rtc_get_date(RTC, &lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2], 0);
		if(lst_date_t_entered[0] > 2000) lst_date_t_entered[0] -= 2000;
		time_date_mode = 0;
		retval = 1;
	}
	else if((tmp_lst + lst_highlight)->option_save_val == 2)
  40b80e:	2802      	cmp	r0, #2
  40b810:	d041      	beq.n	40b896 <list_enter+0xae>
		//the list has a time val load RTC
		rtc_get_time(RTC, &lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
		time_date_mode = 0;
		retval = 1;
	}
	else if((tmp_lst + lst_highlight)->option_save_val == 3)
  40b812:	2803      	cmp	r0, #3
  40b814:	d02b      	beq.n	40b86e <list_enter+0x86>
		con_toff_get_date(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
		if(lst_date_t_entered[0] > 2000) lst_date_t_entered[0] -= 2000;
		time_date_mode = 1;
		retval = 1;
	}
	else if((tmp_lst + lst_highlight)->option_save_val == 4)
  40b816:	2804      	cmp	r0, #4
  40b818:	d045      	beq.n	40b8a6 <list_enter+0xbe>
		//the list has a time val load RTC
		con_toff_get_time(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
		time_date_mode = 1;
		retval = 1;
	}
	else if((tmp_lst + lst_highlight)->option_save_val)
  40b81a:	b120      	cbz	r0, 40b826 <list_enter+0x3e>
	{
		//the list has a value to input
		list_input_val_decipher((tmp_lst + lst_highlight)->option_save_val);
  40b81c:	4b27      	ldr	r3, [pc, #156]	; (40b8bc <list_enter+0xd4>)
  40b81e:	4798      	blx	r3
  40b820:	2001      	movs	r0, #1
	{
		//the list has a function to execute
		retval = 1;
	}
	return retval;
}
  40b822:	b003      	add	sp, #12
  40b824:	bd30      	pop	{r4, r5, pc}
	else if((tmp_lst + lst_highlight)->confirmed_sub)
  40b826:	69e2      	ldr	r2, [r4, #28]
  40b828:	b112      	cbz	r2, 40b830 <list_enter+0x48>
  40b82a:	2001      	movs	r0, #1
}
  40b82c:	b003      	add	sp, #12
  40b82e:	bd30      	pop	{r4, r5, pc}
	else if((tmp_lst + lst_highlight)->exe)
  40b830:	68a2      	ldr	r2, [r4, #8]
  40b832:	2a00      	cmp	r2, #0
  40b834:	bf0c      	ite	eq
  40b836:	4618      	moveq	r0, r3
  40b838:	2001      	movne	r0, #1
  40b83a:	e7f2      	b.n	40b822 <list_enter+0x3a>
		rtc_get_date(RTC, &lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2], 0);
  40b83c:	4c20      	ldr	r4, [pc, #128]	; (40b8c0 <list_enter+0xd8>)
  40b83e:	2500      	movs	r5, #0
  40b840:	4820      	ldr	r0, [pc, #128]	; (40b8c4 <list_enter+0xdc>)
  40b842:	4623      	mov	r3, r4
  40b844:	9500      	str	r5, [sp, #0]
  40b846:	1f22      	subs	r2, r4, #4
  40b848:	f1a4 0108 	sub.w	r1, r4, #8
  40b84c:	4d1e      	ldr	r5, [pc, #120]	; (40b8c8 <list_enter+0xe0>)
  40b84e:	47a8      	blx	r5
		if(lst_date_t_entered[0] > 2000) lst_date_t_entered[0] -= 2000;
  40b850:	f854 3c08 	ldr.w	r3, [r4, #-8]
  40b854:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  40b858:	d903      	bls.n	40b862 <list_enter+0x7a>
  40b85a:	f5a3 63fa 	sub.w	r3, r3, #2000	; 0x7d0
  40b85e:	f844 3c08 	str.w	r3, [r4, #-8]
		time_date_mode = 0;
  40b862:	4b1a      	ldr	r3, [pc, #104]	; (40b8cc <list_enter+0xe4>)
  40b864:	2200      	movs	r2, #0
  40b866:	2001      	movs	r0, #1
  40b868:	701a      	strb	r2, [r3, #0]
}
  40b86a:	b003      	add	sp, #12
  40b86c:	bd30      	pop	{r4, r5, pc}
		con_toff_get_date(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b86e:	4c14      	ldr	r4, [pc, #80]	; (40b8c0 <list_enter+0xd8>)
  40b870:	4b17      	ldr	r3, [pc, #92]	; (40b8d0 <list_enter+0xe8>)
  40b872:	4622      	mov	r2, r4
  40b874:	1f21      	subs	r1, r4, #4
  40b876:	f1a4 0008 	sub.w	r0, r4, #8
  40b87a:	4798      	blx	r3
		if(lst_date_t_entered[0] > 2000) lst_date_t_entered[0] -= 2000;
  40b87c:	f854 3c08 	ldr.w	r3, [r4, #-8]
  40b880:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  40b884:	d903      	bls.n	40b88e <list_enter+0xa6>
  40b886:	f5a3 63fa 	sub.w	r3, r3, #2000	; 0x7d0
  40b88a:	f844 3c08 	str.w	r3, [r4, #-8]
		time_date_mode = 1;
  40b88e:	4b0f      	ldr	r3, [pc, #60]	; (40b8cc <list_enter+0xe4>)
  40b890:	2001      	movs	r0, #1
  40b892:	7018      	strb	r0, [r3, #0]
  40b894:	e7c5      	b.n	40b822 <list_enter+0x3a>
		rtc_get_time(RTC, &lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b896:	4b0a      	ldr	r3, [pc, #40]	; (40b8c0 <list_enter+0xd8>)
  40b898:	480a      	ldr	r0, [pc, #40]	; (40b8c4 <list_enter+0xdc>)
  40b89a:	1f1a      	subs	r2, r3, #4
  40b89c:	f1a3 0108 	sub.w	r1, r3, #8
  40b8a0:	4c0c      	ldr	r4, [pc, #48]	; (40b8d4 <list_enter+0xec>)
  40b8a2:	47a0      	blx	r4
  40b8a4:	e7dd      	b.n	40b862 <list_enter+0x7a>
		con_toff_get_time(&lst_date_t_entered[0], &lst_date_t_entered[1], &lst_date_t_entered[2]);
  40b8a6:	4a06      	ldr	r2, [pc, #24]	; (40b8c0 <list_enter+0xd8>)
  40b8a8:	4b0b      	ldr	r3, [pc, #44]	; (40b8d8 <list_enter+0xf0>)
  40b8aa:	1f11      	subs	r1, r2, #4
  40b8ac:	f1a2 0008 	sub.w	r0, r2, #8
  40b8b0:	4798      	blx	r3
  40b8b2:	e7ec      	b.n	40b88e <list_enter+0xa6>
  40b8b4:	204056c4 	.word	0x204056c4
  40b8b8:	20405690 	.word	0x20405690
  40b8bc:	0040b2fd 	.word	0x0040b2fd
  40b8c0:	20405678 	.word	0x20405678
  40b8c4:	400e1860 	.word	0x400e1860
  40b8c8:	00400611 	.word	0x00400611
  40b8cc:	204008fd 	.word	0x204008fd
  40b8d0:	0040ace5 	.word	0x0040ace5
  40b8d4:	004005b9 	.word	0x004005b9
  40b8d8:	0040ad05 	.word	0x0040ad05

0040b8dc <list_input_val>:
uint_t list_input_val(char enter, char esc, char up, char down, char left, char right)
{
  40b8dc:	b5f0      	push	{r4, r5, r6, r7, lr}
	option_t *tmp_lst;
	char lst_highlight;
	tmp_lst=curr_lst->lst_itms;
  40b8de:	4c24      	ldr	r4, [pc, #144]	; (40b970 <list_input_val+0x94>)
{
  40b8e0:	461f      	mov	r7, r3
	return lst_indeces[lst_highlight];
  40b8e2:	4d24      	ldr	r5, [pc, #144]	; (40b974 <list_input_val+0x98>)
{
  40b8e4:	4616      	mov	r6, r2
	tmp_lst=curr_lst->lst_itms;
  40b8e6:	6824      	ldr	r4, [r4, #0]
{
  40b8e8:	b085      	sub	sp, #20
	return lst_indeces[lst_highlight];
  40b8ea:	7ba3      	ldrb	r3, [r4, #14]
	lst_highlight = get_list_indx_from_lhi_light(curr_lst->list_highlight);
	if((tmp_lst + lst_highlight)->option_save_val == 1) //set date
  40b8ec:	68a2      	ldr	r2, [r4, #8]
  40b8ee:	5ceb      	ldrb	r3, [r5, r3]
{
  40b8f0:	f89d e028 	ldrb.w	lr, [sp, #40]	; 0x28
	if((tmp_lst + lst_highlight)->option_save_val == 1) //set date
  40b8f4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
{
  40b8f8:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
	if((tmp_lst + lst_highlight)->option_save_val == 1) //set date
  40b8fc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  40b900:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  40b902:	2c01      	cmp	r4, #1
  40b904:	d01e      	beq.n	40b944 <list_input_val+0x68>
	{
		return list_set_date_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
	}
	else if((tmp_lst + lst_highlight)->option_save_val == 2) // set time
  40b906:	2c02      	cmp	r4, #2
  40b908:	d027      	beq.n	40b95a <list_input_val+0x7e>
	{
		return list_set_time_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
	}
	else if((tmp_lst + lst_highlight)->option_save_val == 3) //set date
  40b90a:	2c03      	cmp	r4, #3
  40b90c:	d01a      	beq.n	40b944 <list_input_val+0x68>
	{
		return list_set_date_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
	}
	else if((tmp_lst + lst_highlight)->option_save_val == 4) // set time
  40b90e:	2c04      	cmp	r4, #4
  40b910:	d023      	beq.n	40b95a <list_input_val+0x7e>
	{
		return list_set_time_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
	}
	else if((tmp_lst + lst_highlight)->option_save_val)
  40b912:	b11c      	cbz	r4, 40b91c <list_input_val+0x40>
	if(enter)
  40b914:	b928      	cbnz	r0, 40b922 <list_input_val+0x46>
	if(esc) return 0;
  40b916:	b151      	cbz	r1, 40b92e <list_input_val+0x52>
	{
		return list_input_val_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
	}
	else return 2; //no val to input
}
  40b918:	b005      	add	sp, #20
  40b91a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else return 2; //no val to input
  40b91c:	2002      	movs	r0, #2
}
  40b91e:	b005      	add	sp, #20
  40b920:	bdf0      	pop	{r4, r5, r6, r7, pc}
		list_save_val(lst_opt_val);
  40b922:	4620      	mov	r0, r4
  40b924:	4b14      	ldr	r3, [pc, #80]	; (40b978 <list_input_val+0x9c>)
  40b926:	4798      	blx	r3
		return 0;
  40b928:	2000      	movs	r0, #0
}
  40b92a:	b005      	add	sp, #20
  40b92c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40b92e:	4620      	mov	r0, r4
  40b930:	4c12      	ldr	r4, [pc, #72]	; (40b97c <list_input_val+0xa0>)
  40b932:	4673      	mov	r3, lr
  40b934:	463a      	mov	r2, r7
  40b936:	4631      	mov	r1, r6
  40b938:	46a4      	mov	ip, r4
  40b93a:	950a      	str	r5, [sp, #40]	; 0x28
  40b93c:	b005      	add	sp, #20
  40b93e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  40b942:	4760      	bx	ip
		return list_set_date_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
  40b944:	460a      	mov	r2, r1
  40b946:	9502      	str	r5, [sp, #8]
  40b948:	4601      	mov	r1, r0
  40b94a:	4633      	mov	r3, r6
  40b94c:	f8cd e004 	str.w	lr, [sp, #4]
  40b950:	4620      	mov	r0, r4
  40b952:	9700      	str	r7, [sp, #0]
  40b954:	4c0a      	ldr	r4, [pc, #40]	; (40b980 <list_input_val+0xa4>)
  40b956:	47a0      	blx	r4
  40b958:	e7de      	b.n	40b918 <list_input_val+0x3c>
		return list_set_time_exe((tmp_lst + lst_highlight)->option_save_val, enter, esc, up, down, left, right);
  40b95a:	460a      	mov	r2, r1
  40b95c:	9502      	str	r5, [sp, #8]
  40b95e:	4601      	mov	r1, r0
  40b960:	4633      	mov	r3, r6
  40b962:	f8cd e004 	str.w	lr, [sp, #4]
  40b966:	4620      	mov	r0, r4
  40b968:	9700      	str	r7, [sp, #0]
  40b96a:	4c06      	ldr	r4, [pc, #24]	; (40b984 <list_input_val+0xa8>)
  40b96c:	47a0      	blx	r4
  40b96e:	e7d3      	b.n	40b918 <list_input_val+0x3c>
  40b970:	204056c4 	.word	0x204056c4
  40b974:	20405690 	.word	0x20405690
  40b978:	0040b251 	.word	0x0040b251
  40b97c:	0040aded 	.word	0x0040aded
  40b980:	0040b41d 	.word	0x0040b41d
  40b984:	0040b609 	.word	0x0040b609

0040b988 <list_confirm_exe>:
uint_t list_confirm_exe(char enter, char esc, char up, char down, char left, char right)
{
	option_t *tmp_lst;
	char lst_highlight;
	tmp_lst = curr_lst->lst_itms;
  40b988:	4a1a      	ldr	r2, [pc, #104]	; (40b9f4 <list_confirm_exe+0x6c>)
	return lst_indeces[lst_highlight];
  40b98a:	4b1b      	ldr	r3, [pc, #108]	; (40b9f8 <list_confirm_exe+0x70>)
{
  40b98c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	tmp_lst = curr_lst->lst_itms;
  40b990:	6812      	ldr	r2, [r2, #0]
	lst_highlight = get_list_indx_from_lhi_light(curr_lst->list_highlight);
  40b992:	7b96      	ldrb	r6, [r2, #14]
	if(curr_lst->save_val)
  40b994:	6914      	ldr	r4, [r2, #16]
	return lst_indeces[lst_highlight];
  40b996:	5d9b      	ldrb	r3, [r3, r6]
	tmp_lst = curr_lst->lst_itms;
  40b998:	6895      	ldr	r5, [r2, #8]
	if(curr_lst->save_val)
  40b99a:	b104      	cbz	r4, 40b99e <list_confirm_exe+0x16>
	{
		*(curr_lst->save_val) = curr_lst->list_highlight; //if there is a value to save; save it
  40b99c:	7026      	strb	r6, [r4, #0]
	}
	if((tmp_lst + lst_highlight)->confirmed_sub)
  40b99e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40b9a2:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
  40b9a6:	69eb      	ldr	r3, [r5, #28]
  40b9a8:	b1e3      	cbz	r3, 40b9e4 <list_confirm_exe+0x5c>
	{
		glcd_gotoxy(2,18);
  40b9aa:	f8df 805c 	ldr.w	r8, [pc, #92]	; 40ba08 <list_confirm_exe+0x80>
  40b9ae:	4606      	mov	r6, r0
  40b9b0:	460c      	mov	r4, r1
  40b9b2:	2002      	movs	r0, #2
  40b9b4:	2112      	movs	r1, #18
		glcd_putsf((tmp_lst + lst_highlight)->confirm_msg, 0);
  40b9b6:	4f11      	ldr	r7, [pc, #68]	; (40b9fc <list_confirm_exe+0x74>)
		glcd_gotoxy(2,18);
  40b9b8:	47c0      	blx	r8
		glcd_putsf((tmp_lst + lst_highlight)->confirm_msg, 0);
  40b9ba:	2100      	movs	r1, #0
  40b9bc:	6868      	ldr	r0, [r5, #4]
  40b9be:	47b8      	blx	r7
		
		glcd_gotoxy(2,54);
  40b9c0:	2136      	movs	r1, #54	; 0x36
  40b9c2:	2002      	movs	r0, #2
  40b9c4:	47c0      	blx	r8
		glcd_putsf("No", 0);
  40b9c6:	2100      	movs	r1, #0
  40b9c8:	480d      	ldr	r0, [pc, #52]	; (40ba00 <list_confirm_exe+0x78>)
  40b9ca:	47b8      	blx	r7
		
		glcd_gotoxy(107,54);
  40b9cc:	2136      	movs	r1, #54	; 0x36
  40b9ce:	206b      	movs	r0, #107	; 0x6b
  40b9d0:	47c0      	blx	r8
		glcd_putsf("Yes", 0);
  40b9d2:	2100      	movs	r1, #0
  40b9d4:	480b      	ldr	r0, [pc, #44]	; (40ba04 <list_confirm_exe+0x7c>)
  40b9d6:	47b8      	blx	r7
		if (enter) 
  40b9d8:	b93e      	cbnz	r6, 40b9ea <list_confirm_exe+0x62>
		{
			(tmp_lst + lst_highlight)->confirmed_sub(); // if there is a function at the function pointer execute it
			return 0;
		}
		else if(esc)
  40b9da:	fab4 f084 	clz	r0, r4
  40b9de:	0940      	lsrs	r0, r0, #5
  40b9e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		{
			return 0;
		}
		return 1;
	}
	else return 2;
  40b9e4:	2002      	movs	r0, #2
}
  40b9e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			(tmp_lst + lst_highlight)->confirmed_sub(); // if there is a function at the function pointer execute it
  40b9ea:	69eb      	ldr	r3, [r5, #28]
  40b9ec:	4798      	blx	r3
			return 0;
  40b9ee:	2000      	movs	r0, #0
  40b9f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40b9f4:	204056c4 	.word	0x204056c4
  40b9f8:	20405690 	.word	0x20405690
  40b9fc:	0040c7b9 	.word	0x0040c7b9
  40ba00:	0041c9f4 	.word	0x0041c9f4
  40ba04:	0041c9f8 	.word	0x0041c9f8
  40ba08:	0040c7a5 	.word	0x0040c7a5

0040ba0c <list_exe>:
uint_t list_exe(char enter, char esc, char up, char down, char left, char right)
{
  40ba0c:	b5f0      	push	{r4, r5, r6, r7, lr}
	option_t *tmp_lst;
	char lst_highlight;
	tmp_lst = curr_lst->lst_itms;
  40ba0e:	4d0f      	ldr	r5, [pc, #60]	; (40ba4c <list_exe+0x40>)
{
  40ba10:	b083      	sub	sp, #12
	return lst_indeces[lst_highlight];
  40ba12:	4c0f      	ldr	r4, [pc, #60]	; (40ba50 <list_exe+0x44>)
	tmp_lst = curr_lst->lst_itms;
  40ba14:	682d      	ldr	r5, [r5, #0]
{
  40ba16:	f89d e020 	ldrb.w	lr, [sp, #32]
	lst_highlight = get_list_indx_from_lhi_light(curr_lst->list_highlight);
  40ba1a:	7baf      	ldrb	r7, [r5, #14]
	if(curr_lst->save_val) 
  40ba1c:	692e      	ldr	r6, [r5, #16]
	return lst_indeces[lst_highlight];
  40ba1e:	5de4      	ldrb	r4, [r4, r7]
	tmp_lst = curr_lst->lst_itms;
  40ba20:	68ad      	ldr	r5, [r5, #8]
{
  40ba22:	f89d c024 	ldrb.w	ip, [sp, #36]	; 0x24
	if(curr_lst->save_val) 
  40ba26:	b106      	cbz	r6, 40ba2a <list_exe+0x1e>
	{
		*(curr_lst->save_val) = curr_lst->list_highlight; //if there is a value to save; save it
  40ba28:	7037      	strb	r7, [r6, #0]
	}
	if((tmp_lst + lst_highlight)->exe) 
  40ba2a:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  40ba2e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  40ba32:	68a4      	ldr	r4, [r4, #8]
  40ba34:	b134      	cbz	r4, 40ba44 <list_exe+0x38>
	{
		return (tmp_lst + lst_highlight)->exe(enter, esc, up, down, left, right); // if there is a function at the function pointer execute it
  40ba36:	f8cd c004 	str.w	ip, [sp, #4]
  40ba3a:	f8cd e000 	str.w	lr, [sp]
  40ba3e:	47a0      	blx	r4
	}
	else return 2;
}
  40ba40:	b003      	add	sp, #12
  40ba42:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else return 2;
  40ba44:	2002      	movs	r0, #2
}
  40ba46:	b003      	add	sp, #12
  40ba48:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40ba4a:	bf00      	nop
  40ba4c:	204056c4 	.word	0x204056c4
  40ba50:	20405690 	.word	0x20405690

0040ba54 <count_unhidden_list_items>:

void count_unhidden_list_items(void)
{
	curr_lst_max = 0;
	uint32_t i, l = 0;
	for (i=0; i<curr_lst->list_max; i++)
  40ba54:	4b14      	ldr	r3, [pc, #80]	; (40baa8 <count_unhidden_list_items+0x54>)
	curr_lst_max = 0;
  40ba56:	2200      	movs	r2, #0
{
  40ba58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (i=0; i<curr_lst->list_max; i++)
  40ba5c:	6818      	ldr	r0, [r3, #0]
	curr_lst_max = 0;
  40ba5e:	f8df 804c 	ldr.w	r8, [pc, #76]	; 40baac <count_unhidden_list_items+0x58>
	for (i=0; i<curr_lst->list_max; i++)
  40ba62:	7b04      	ldrb	r4, [r0, #12]
	curr_lst_max = 0;
  40ba64:	f888 2000 	strb.w	r2, [r8]
	for (i=0; i<curr_lst->list_max; i++)
  40ba68:	b1c4      	cbz	r4, 40ba9c <count_unhidden_list_items+0x48>
	{
		if (!(curr_lst->lst_itms + i)->option_characteristics & OPTION_HIDDEN)
		{
			//there is an unhidden option count it
			curr_lst_max++;
			lst_indeces[l++] = i;
  40ba6a:	f8df c044 	ldr.w	ip, [pc, #68]	; 40bab0 <count_unhidden_list_items+0x5c>
	for (i=0; i<curr_lst->list_max; i++)
  40ba6e:	4696      	mov	lr, r2
  40ba70:	4615      	mov	r5, r2
  40ba72:	4616      	mov	r6, r2
  40ba74:	4611      	mov	r1, r2
		if (!(curr_lst->lst_itms + i)->option_characteristics & OPTION_HIDDEN)
  40ba76:	6883      	ldr	r3, [r0, #8]
			curr_lst_max++;
  40ba78:	1c6f      	adds	r7, r5, #1
		if (!(curr_lst->lst_itms + i)->option_characteristics & OPTION_HIDDEN)
  40ba7a:	4413      	add	r3, r2
  40ba7c:	7c1b      	ldrb	r3, [r3, #16]
  40ba7e:	b933      	cbnz	r3, 40ba8e <count_unhidden_list_items+0x3a>
			lst_indeces[l++] = i;
  40ba80:	f80c 1006 	strb.w	r1, [ip, r6]
			curr_lst_max++;
  40ba84:	b2fd      	uxtb	r5, r7
			lst_indeces[l++] = i;
  40ba86:	3601      	adds	r6, #1
  40ba88:	7b04      	ldrb	r4, [r0, #12]
  40ba8a:	f04f 0e01 	mov.w	lr, #1
	for (i=0; i<curr_lst->list_max; i++)
  40ba8e:	3101      	adds	r1, #1
  40ba90:	3228      	adds	r2, #40	; 0x28
  40ba92:	428c      	cmp	r4, r1
  40ba94:	d8ef      	bhi.n	40ba76 <count_unhidden_list_items+0x22>
  40ba96:	f1be 0f00 	cmp.w	lr, #0
  40ba9a:	d101      	bne.n	40baa0 <count_unhidden_list_items+0x4c>
  40ba9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40baa0:	f888 5000 	strb.w	r5, [r8]
  40baa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40baa8:	204056c4 	.word	0x204056c4
  40baac:	20405684 	.word	0x20405684
  40bab0:	20405690 	.word	0x20405690

0040bab4 <list_join>:
		}
	}
}
uint_t list_join(void)
{
  40bab4:	b5f0      	push	{r4, r5, r6, r7, lr}
	option_t *tmp_lst;
	char lst_highlight;
	tmp_lst=(*curr_lst).lst_itms;
  40bab6:	4d28      	ldr	r5, [pc, #160]	; (40bb58 <list_join+0xa4>)
{
  40bab8:	b083      	sub	sp, #12
	return lst_indeces[lst_highlight];
  40baba:	4c28      	ldr	r4, [pc, #160]	; (40bb5c <list_join+0xa8>)
	tmp_lst=(*curr_lst).lst_itms;
  40babc:	682a      	ldr	r2, [r5, #0]
	return lst_indeces[lst_highlight];
  40babe:	7b93      	ldrb	r3, [r2, #14]
	lst_highlight = get_list_indx_from_lhi_light(curr_lst->list_highlight);
	
	if ((*curr_lst).save_val)
  40bac0:	6911      	ldr	r1, [r2, #16]
	return lst_indeces[lst_highlight];
  40bac2:	5ce3      	ldrb	r3, [r4, r3]
	tmp_lst=(*curr_lst).lst_itms;
  40bac4:	6896      	ldr	r6, [r2, #8]
	if ((*curr_lst).save_val)
  40bac6:	b101      	cbz	r1, 40baca <list_join+0x16>
	{
		*((*curr_lst).save_val) = lst_highlight;
  40bac8:	700b      	strb	r3, [r1, #0]
	}
	if((*(tmp_lst+lst_highlight)).child)
  40baca:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40bace:	00db      	lsls	r3, r3, #3
  40bad0:	18f2      	adds	r2, r6, r3
  40bad2:	6a10      	ldr	r0, [r2, #32]
  40bad4:	2800      	cmp	r0, #0
  40bad6:	d02d      	beq.n	40bb34 <list_join+0x80>
	{
		(tmp_lst + lst_highlight)->child->parent = curr_lst;
  40bad8:	682f      	ldr	r7, [r5, #0]
		(tmp_lst + lst_highlight)->child->menue_name = (tmp_lst + lst_highlight)->text;
		curr_lst = (tmp_lst + lst_highlight)->child; // if there is a child list at the pointer, join it
		
		count_unhidden_list_items();
  40bada:	4921      	ldr	r1, [pc, #132]	; (40bb60 <list_join+0xac>)
		(tmp_lst + lst_highlight)->child->parent = curr_lst;
  40badc:	6047      	str	r7, [r0, #4]
		(tmp_lst + lst_highlight)->child->menue_name = (tmp_lst + lst_highlight)->text;
  40bade:	58f0      	ldr	r0, [r6, r3]
  40bae0:	6a13      	ldr	r3, [r2, #32]
  40bae2:	6198      	str	r0, [r3, #24]
		curr_lst = (tmp_lst + lst_highlight)->child; // if there is a child list at the pointer, join it
  40bae4:	6a13      	ldr	r3, [r2, #32]
  40bae6:	602b      	str	r3, [r5, #0]
		count_unhidden_list_items();
  40bae8:	4788      	blx	r1
		if(curr_lst->save_val)
  40baea:	682d      	ldr	r5, [r5, #0]
  40baec:	692b      	ldr	r3, [r5, #16]
  40baee:	b34b      	cbz	r3, 40bb44 <list_join+0x90>
		{
			// if the child has a value to save, load it to highlight the default option
			if(*(curr_lst->save_val) < curr_lst->list_max) 
  40baf0:	781a      	ldrb	r2, [r3, #0]
  40baf2:	7b2b      	ldrb	r3, [r5, #12]
  40baf4:	4293      	cmp	r3, r2
	for (i=0; i<curr_lst_max; i++)
  40baf6:	f04f 0300 	mov.w	r3, #0
			if(*(curr_lst->save_val) < curr_lst->list_max) 
  40bafa:	d91d      	bls.n	40bb38 <list_join+0x84>
	for (i=0; i<curr_lst_max; i++)
  40bafc:	4919      	ldr	r1, [pc, #100]	; (40bb64 <list_join+0xb0>)
  40bafe:	9301      	str	r3, [sp, #4]
  40bb00:	9b01      	ldr	r3, [sp, #4]
  40bb02:	7809      	ldrb	r1, [r1, #0]
  40bb04:	428b      	cmp	r3, r1
  40bb06:	d305      	bcc.n	40bb14 <list_join+0x60>
  40bb08:	e01f      	b.n	40bb4a <list_join+0x96>
  40bb0a:	3301      	adds	r3, #1
  40bb0c:	9301      	str	r3, [sp, #4]
  40bb0e:	9b01      	ldr	r3, [sp, #4]
  40bb10:	428b      	cmp	r3, r1
  40bb12:	d21a      	bcs.n	40bb4a <list_join+0x96>
		if (lst_indeces[i] == lst_index)
  40bb14:	9b01      	ldr	r3, [sp, #4]
  40bb16:	5ce3      	ldrb	r3, [r4, r3]
  40bb18:	4293      	cmp	r3, r2
			return i;
  40bb1a:	9b01      	ldr	r3, [sp, #4]
		if (lst_indeces[i] == lst_index)
  40bb1c:	d1f5      	bne.n	40bb0a <list_join+0x56>
  40bb1e:	b2db      	uxtb	r3, r3
	if(curr_lst->list_highlight > curr_lst->list_start) 
  40bb20:	7b6a      	ldrb	r2, [r5, #13]
  40bb22:	429a      	cmp	r2, r3
			{
				curr_lst->list_highlight = get_listHiLight_from_listIndex(*(curr_lst->save_val)); //if there is a value to save; load it
  40bb24:	73ab      	strb	r3, [r5, #14]
	if(curr_lst->list_highlight > curr_lst->list_start) 
  40bb26:	d213      	bcs.n	40bb50 <list_join+0x9c>
		if((curr_lst->list_highlight - curr_lst->list_start) > 3) 
  40bb28:	1a9a      	subs	r2, r3, r2
  40bb2a:	2a03      	cmp	r2, #3
  40bb2c:	dd0a      	ble.n	40bb44 <list_join+0x90>
		curr_lst->list_start = curr_lst->list_highlight - 3;
  40bb2e:	3b03      	subs	r3, #3
			{
				curr_lst->list_highlight = 0; //else load default 0
			}
			list_pos_adjust();
		}
		return 1;
  40bb30:	2001      	movs	r0, #1
		curr_lst->list_start = curr_lst->list_highlight - 3;
  40bb32:	736b      	strb	r3, [r5, #13]
	}
	return 0;
}
  40bb34:	b003      	add	sp, #12
  40bb36:	bdf0      	pop	{r4, r5, r6, r7, pc}
				curr_lst->list_highlight = 0; //else load default 0
  40bb38:	73ab      	strb	r3, [r5, #14]
		curr_lst->list_start = 0;
  40bb3a:	2300      	movs	r3, #0
		return 1;
  40bb3c:	2001      	movs	r0, #1
		curr_lst->list_start = 0;
  40bb3e:	736b      	strb	r3, [r5, #13]
}
  40bb40:	b003      	add	sp, #12
  40bb42:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 1;
  40bb44:	2001      	movs	r0, #1
}
  40bb46:	b003      	add	sp, #12
  40bb48:	bdf0      	pop	{r4, r5, r6, r7, pc}
				curr_lst->list_highlight = get_listHiLight_from_listIndex(*(curr_lst->save_val)); //if there is a value to save; load it
  40bb4a:	2300      	movs	r3, #0
  40bb4c:	73ab      	strb	r3, [r5, #14]
  40bb4e:	e7f4      	b.n	40bb3a <list_join+0x86>
	else if(curr_lst->list_highlight > 3)
  40bb50:	2b03      	cmp	r3, #3
  40bb52:	d8ec      	bhi.n	40bb2e <list_join+0x7a>
  40bb54:	e7f1      	b.n	40bb3a <list_join+0x86>
  40bb56:	bf00      	nop
  40bb58:	204056c4 	.word	0x204056c4
  40bb5c:	20405690 	.word	0x20405690
  40bb60:	0040ba55 	.word	0x0040ba55
  40bb64:	20405684 	.word	0x20405684

0040bb68 <list_draw_frame>:
void list_draw_frame(char write)
{	
	struct rect boarder;
	option_t *opt;
	
	opt=&(curr_lst->lst_itms[curr_lst->list_highlight]);
  40bb68:	4b17      	ldr	r3, [pc, #92]	; (40bbc8 <list_draw_frame+0x60>)
	boarder.x=0;
	boarder.y=0;
	boarder.width=128;
  40bb6a:	2180      	movs	r1, #128	; 0x80
	boarder.length=64;
  40bb6c:	2240      	movs	r2, #64	; 0x40
{	
  40bb6e:	b570      	push	{r4, r5, r6, lr}
	boarder.x=0;
  40bb70:	2400      	movs	r4, #0
{	
  40bb72:	b082      	sub	sp, #8
	opt=&(curr_lst->lst_itms[curr_lst->list_highlight]);
  40bb74:	681b      	ldr	r3, [r3, #0]
	boarder.x=0;
  40bb76:	f88d 4004 	strb.w	r4, [sp, #4]
	opt=&(curr_lst->lst_itms[curr_lst->list_highlight]);
  40bb7a:	689e      	ldr	r6, [r3, #8]
  40bb7c:	7b9d      	ldrb	r5, [r3, #14]
	boarder.y=0;
  40bb7e:	f88d 4005 	strb.w	r4, [sp, #5]
	boarder.width=128;
  40bb82:	f88d 1006 	strb.w	r1, [sp, #6]
	boarder.length=64;
  40bb86:	f88d 2007 	strb.w	r2, [sp, #7]
	if(write) glcd_clear();
  40bb8a:	b960      	cbnz	r0, 40bba6 <list_draw_frame+0x3e>
	draw_rect(boarder);
  40bb8c:	9801      	ldr	r0, [sp, #4]
  40bb8e:	4b0f      	ldr	r3, [pc, #60]	; (40bbcc <list_draw_frame+0x64>)
  40bb90:	4798      	blx	r3
	{
		glcd_gotoxy (4,3);
		write_r_text(opt->text, public_lang);
	}

	d_line(0, 128, 13, 13);
  40bb92:	230d      	movs	r3, #13
  40bb94:	4c0e      	ldr	r4, [pc, #56]	; (40bbd0 <list_draw_frame+0x68>)
  40bb96:	2180      	movs	r1, #128	; 0x80
  40bb98:	2000      	movs	r0, #0
  40bb9a:	461a      	mov	r2, r3
  40bb9c:	46a4      	mov	ip, r4
}
  40bb9e:	b002      	add	sp, #8
  40bba0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	d_line(0, 128, 13, 13);
  40bba4:	4760      	bx	ip
	if(write) glcd_clear();
  40bba6:	4b0b      	ldr	r3, [pc, #44]	; (40bbd4 <list_draw_frame+0x6c>)
	opt=&(curr_lst->lst_itms[curr_lst->list_highlight]);
  40bba8:	eb05 0585 	add.w	r5, r5, r5, lsl #2
	if(write) glcd_clear();
  40bbac:	4798      	blx	r3
	draw_rect(boarder);
  40bbae:	9801      	ldr	r0, [sp, #4]
  40bbb0:	4b06      	ldr	r3, [pc, #24]	; (40bbcc <list_draw_frame+0x64>)
  40bbb2:	4798      	blx	r3
		glcd_gotoxy (4,3);
  40bbb4:	2103      	movs	r1, #3
  40bbb6:	2004      	movs	r0, #4
  40bbb8:	4b07      	ldr	r3, [pc, #28]	; (40bbd8 <list_draw_frame+0x70>)
  40bbba:	4798      	blx	r3
		write_r_text(opt->text, public_lang);
  40bbbc:	4621      	mov	r1, r4
  40bbbe:	4b07      	ldr	r3, [pc, #28]	; (40bbdc <list_draw_frame+0x74>)
  40bbc0:	f856 0035 	ldr.w	r0, [r6, r5, lsl #3]
  40bbc4:	4798      	blx	r3
  40bbc6:	e7e4      	b.n	40bb92 <list_draw_frame+0x2a>
  40bbc8:	204056c4 	.word	0x204056c4
  40bbcc:	0040c6a1 	.word	0x0040c6a1
  40bbd0:	0040c541 	.word	0x0040c541
  40bbd4:	0040c2e5 	.word	0x0040c2e5
  40bbd8:	0040c7a5 	.word	0x0040c7a5
  40bbdc:	0040cf51 	.word	0x0040cf51

0040bbe0 <set_current_list>:

void set_current_list(menue_design_t *menue)
{
	curr_lst = menue;
  40bbe0:	4b01      	ldr	r3, [pc, #4]	; (40bbe8 <set_current_list+0x8>)
  40bbe2:	6018      	str	r0, [r3, #0]
  40bbe4:	4770      	bx	lr
  40bbe6:	bf00      	nop
  40bbe8:	204056c4 	.word	0x204056c4

0040bbec <enter_pass_exe>:
}

uint_t enter_pass_exe(char enter, char esc, char left, char right, char up, char down)
{
  40bbec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40bbf0:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
  40bbf4:	f89d 702c 	ldrb.w	r7, [sp, #44]	; 0x2c
	if (esc) return 2;
  40bbf8:	b111      	cbz	r1, 40bc00 <enter_pass_exe+0x14>
  40bbfa:	2002      	movs	r0, #2
  40bbfc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bc00:	4699      	mov	r9, r3
	glcd_clear();
  40bc02:	4b4f      	ldr	r3, [pc, #316]	; (40bd40 <enter_pass_exe+0x154>)
  40bc04:	460c      	mov	r4, r1
  40bc06:	4680      	mov	r8, r0
  40bc08:	4692      	mov	sl, r2
  40bc0a:	4798      	blx	r3
	out_image(25,15, p_lock);
  40bc0c:	4a4d      	ldr	r2, [pc, #308]	; (40bd44 <enter_pass_exe+0x158>)
  40bc0e:	210f      	movs	r1, #15
  40bc10:	4b4d      	ldr	r3, [pc, #308]	; (40bd48 <enter_pass_exe+0x15c>)
  40bc12:	2019      	movs	r0, #25
  40bc14:	4798      	blx	r3
	glcd_gotoxy(4,3);
  40bc16:	4e4d      	ldr	r6, [pc, #308]	; (40bd4c <enter_pass_exe+0x160>)
  40bc18:	2103      	movs	r1, #3
  40bc1a:	2004      	movs	r0, #4
  40bc1c:	47b0      	blx	r6
	write_r_text("Enter password" ,0);
  40bc1e:	484c      	ldr	r0, [pc, #304]	; (40bd50 <enter_pass_exe+0x164>)
  40bc20:	4b4c      	ldr	r3, [pc, #304]	; (40bd54 <enter_pass_exe+0x168>)
  40bc22:	4621      	mov	r1, r4
  40bc24:	4798      	blx	r3
	list_draw_frame(0);
  40bc26:	4620      	mov	r0, r4
  40bc28:	4b4b      	ldr	r3, [pc, #300]	; (40bd58 <enter_pass_exe+0x16c>)
  40bc2a:	4798      	blx	r3
	uint32_t i;
	uint32_t temp;
	char *list_val_break;
	int8_t l_sign = 1;
	
	if(enter)
  40bc2c:	f1b8 0f00 	cmp.w	r8, #0
  40bc30:	d11d      	bne.n	40bc6e <enter_pass_exe+0x82>
		//list_save_val(lst_opt_val);
		//return 0;
		return 1;
	}
	
	if(right) list_cursor++;
  40bc32:	4c4a      	ldr	r4, [pc, #296]	; (40bd5c <enter_pass_exe+0x170>)
  40bc34:	7823      	ldrb	r3, [r4, #0]
  40bc36:	f1b9 0f00 	cmp.w	r9, #0
  40bc3a:	d061      	beq.n	40bd00 <enter_pass_exe+0x114>
  40bc3c:	3301      	adds	r3, #1
  40bc3e:	b2db      	uxtb	r3, r3
  40bc40:	7023      	strb	r3, [r4, #0]
	else if(left) list_cursor--;
	
	if(list_cursor == 0xFF) list_cursor = 4;
  40bc42:	2bff      	cmp	r3, #255	; 0xff
  40bc44:	d016      	beq.n	40bc74 <enter_pass_exe+0x88>
	if(list_cursor >= 4) list_cursor = 0;
  40bc46:	2b03      	cmp	r3, #3
  40bc48:	d814      	bhi.n	40bc74 <enter_pass_exe+0x88>
	
	else if(up)
  40bc4a:	2d00      	cmp	r5, #0
  40bc4c:	d05f      	beq.n	40bd0e <enter_pass_exe+0x122>
	for (count; count>0; count--)
  40bc4e:	f1d3 0303 	rsbs	r3, r3, #3
  40bc52:	f04f 0001 	mov.w	r0, #1
  40bc56:	d005      	beq.n	40bc64 <enter_pass_exe+0x78>
		res *= 10;
  40bc58:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	for (count; count>0; count--)
  40bc5c:	3b01      	subs	r3, #1
		res *= 10;
  40bc5e:	ea4f 0040 	mov.w	r0, r0, lsl #1
	for (count; count>0; count--)
  40bc62:	d1f9      	bne.n	40bc58 <enter_pass_exe+0x6c>
	{
		lst_val_entered += lst_power(3 - (list_cursor));
  40bc64:	4f3e      	ldr	r7, [pc, #248]	; (40bd60 <enter_pass_exe+0x174>)
  40bc66:	683b      	ldr	r3, [r7, #0]
  40bc68:	4418      	add	r0, r3
  40bc6a:	6038      	str	r0, [r7, #0]
  40bc6c:	e006      	b.n	40bc7c <enter_pass_exe+0x90>
		return 1;
  40bc6e:	2001      	movs	r0, #1
  40bc70:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bc74:	4f3a      	ldr	r7, [pc, #232]	; (40bd60 <enter_pass_exe+0x174>)
	if(list_cursor >= 4) list_cursor = 0;
  40bc76:	2300      	movs	r3, #0
  40bc78:	6838      	ldr	r0, [r7, #0]
  40bc7a:	7023      	strb	r3, [r4, #0]
	}
	else if(down)
	{
		lst_val_entered -= lst_power(3 - (list_cursor));
	}
	if (lst_val_entered > 9999)
  40bc7c:	f242 730f 	movw	r3, #9999	; 0x270f
  40bc80:	4298      	cmp	r0, r3
  40bc82:	dd39      	ble.n	40bcf8 <enter_pass_exe+0x10c>
	{
		lst_val_entered = 9999;
  40bc84:	f242 700f 	movw	r0, #9999	; 0x270f
  40bc88:	2100      	movs	r1, #0
  40bc8a:	603b      	str	r3, [r7, #0]
	}
	
	if(lst_val_entered >= 0) temp = lst_val_entered;
	else temp = -lst_val_entered;
	
	list_val_break = itos(temp);
  40bc8c:	4b35      	ldr	r3, [pc, #212]	; (40bd64 <enter_pass_exe+0x178>)
	
	
	glcd_gotoxy(2, 53);
	
	
	for (i=0; i<4; i++)
  40bc8e:	2500      	movs	r5, #0
	list_val_break = itos(temp);
  40bc90:	4798      	blx	r3
	glcd_gotoxy(2, 53);
  40bc92:	2135      	movs	r1, #53	; 0x35
	list_val_break = itos(temp);
  40bc94:	4680      	mov	r8, r0
	glcd_gotoxy(2, 53);
  40bc96:	2002      	movs	r0, #2
  40bc98:	47b0      	blx	r6
  40bc9a:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 40bd68 <enter_pass_exe+0x17c>
		res *= 10;
  40bc9e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
	{
		if (lst_val_entered < temp)
		{
			out_char('0', (i + list_has_asign == list_cursor));
  40bca2:	f8df b0c8 	ldr.w	fp, [pc, #200]	; 40bd6c <enter_pass_exe+0x180>
			temp /= 10;
  40bca6:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 40bd70 <enter_pass_exe+0x184>
		if (lst_val_entered < temp)
  40bcaa:	683b      	ldr	r3, [r7, #0]
  40bcac:	42b3      	cmp	r3, r6
  40bcae:	d315      	bcc.n	40bcdc <enter_pass_exe+0xf0>
		}
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40bcb0:	f898 3000 	ldrb.w	r3, [r8]
			out_char(*list_val_break , (i == list_cursor));
			list_val_break++;
		}
		else
		{
			out_char('0', (i == list_cursor));
  40bcb4:	2030      	movs	r0, #48	; 0x30
			out_char(*list_val_break , (i == list_cursor));
  40bcb6:	7821      	ldrb	r1, [r4, #0]
			list_val_break++;
  40bcb8:	f108 0801 	add.w	r8, r8, #1
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40bcbc:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
			out_char('0', (i == list_cursor));
  40bcc0:	1b49      	subs	r1, r1, r5
		else if ((*list_val_break >= 0x30) && (*list_val_break <= 0x39))
  40bcc2:	2a09      	cmp	r2, #9
			out_char('0', (i == list_cursor));
  40bcc4:	fab1 f181 	clz	r1, r1
			out_char(*list_val_break , (i == list_cursor));
  40bcc8:	bf98      	it	ls
  40bcca:	4618      	movls	r0, r3
			out_char('0', (i == list_cursor));
  40bccc:	0949      	lsrs	r1, r1, #5
  40bcce:	47c8      	blx	r9
	for (i=0; i<4; i++)
  40bcd0:	3501      	adds	r5, #1
  40bcd2:	2d04      	cmp	r5, #4
  40bcd4:	d1e9      	bne.n	40bcaa <enter_pass_exe+0xbe>
  40bcd6:	2000      	movs	r0, #0
  40bcd8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			out_char('0', (i + list_has_asign == list_cursor));
  40bcdc:	f89b 3000 	ldrb.w	r3, [fp]
  40bce0:	2030      	movs	r0, #48	; 0x30
  40bce2:	7821      	ldrb	r1, [r4, #0]
  40bce4:	442b      	add	r3, r5
  40bce6:	1a59      	subs	r1, r3, r1
			temp /= 10;
  40bce8:	fbaa 3606 	umull	r3, r6, sl, r6
			out_char('0', (i + list_has_asign == list_cursor));
  40bcec:	fab1 f181 	clz	r1, r1
			temp /= 10;
  40bcf0:	08f6      	lsrs	r6, r6, #3
			out_char('0', (i + list_has_asign == list_cursor));
  40bcf2:	0949      	lsrs	r1, r1, #5
  40bcf4:	47c8      	blx	r9
  40bcf6:	e7eb      	b.n	40bcd0 <enter_pass_exe+0xe4>
	else if (lst_val_entered < 0)
  40bcf8:	2800      	cmp	r0, #0
  40bcfa:	db0c      	blt.n	40bd16 <enter_pass_exe+0x12a>
  40bcfc:	17c1      	asrs	r1, r0, #31
  40bcfe:	e7c5      	b.n	40bc8c <enter_pass_exe+0xa0>
	else if(left) list_cursor--;
  40bd00:	f1ba 0f00 	cmp.w	sl, #0
  40bd04:	d09d      	beq.n	40bc42 <enter_pass_exe+0x56>
  40bd06:	3b01      	subs	r3, #1
  40bd08:	b2db      	uxtb	r3, r3
  40bd0a:	7023      	strb	r3, [r4, #0]
  40bd0c:	e799      	b.n	40bc42 <enter_pass_exe+0x56>
	else if(down)
  40bd0e:	b93f      	cbnz	r7, 40bd20 <enter_pass_exe+0x134>
  40bd10:	4f13      	ldr	r7, [pc, #76]	; (40bd60 <enter_pass_exe+0x174>)
  40bd12:	6838      	ldr	r0, [r7, #0]
  40bd14:	e7b2      	b.n	40bc7c <enter_pass_exe+0x90>
		lst_val_entered = 0;
  40bd16:	2300      	movs	r3, #0
  40bd18:	2000      	movs	r0, #0
  40bd1a:	2100      	movs	r1, #0
  40bd1c:	603b      	str	r3, [r7, #0]
  40bd1e:	e7b5      	b.n	40bc8c <enter_pass_exe+0xa0>
	for (count; count>0; count--)
  40bd20:	f1d3 0303 	rsbs	r3, r3, #3
  40bd24:	f04f 0201 	mov.w	r2, #1
  40bd28:	d005      	beq.n	40bd36 <enter_pass_exe+0x14a>
		res *= 10;
  40bd2a:	eb02 0082 	add.w	r0, r2, r2, lsl #2
	for (count; count>0; count--)
  40bd2e:	3b01      	subs	r3, #1
		res *= 10;
  40bd30:	ea4f 0240 	mov.w	r2, r0, lsl #1
	for (count; count>0; count--)
  40bd34:	d1f9      	bne.n	40bd2a <enter_pass_exe+0x13e>
		lst_val_entered -= lst_power(3 - (list_cursor));
  40bd36:	4f0a      	ldr	r7, [pc, #40]	; (40bd60 <enter_pass_exe+0x174>)
  40bd38:	6838      	ldr	r0, [r7, #0]
  40bd3a:	1a80      	subs	r0, r0, r2
  40bd3c:	6038      	str	r0, [r7, #0]
  40bd3e:	e79d      	b.n	40bc7c <enter_pass_exe+0x90>
  40bd40:	0040c2e5 	.word	0x0040c2e5
  40bd44:	0041a2b0 	.word	0x0041a2b0
  40bd48:	0040c4a5 	.word	0x0040c4a5
  40bd4c:	0040c7a5 	.word	0x0040c7a5
  40bd50:	0041c9e4 	.word	0x0041c9e4
  40bd54:	0040cf51 	.word	0x0040cf51
  40bd58:	0040bb69 	.word	0x0040bb69
  40bd5c:	204008fa 	.word	0x204008fa
  40bd60:	20405680 	.word	0x20405680
  40bd64:	0040c205 	.word	0x0040c205
  40bd68:	0040c6f9 	.word	0x0040c6f9
  40bd6c:	204008fb 	.word	0x204008fb
  40bd70:	cccccccd 	.word	0xcccccccd

0040bd74 <menue_photo_execute>:
	
	return 0;
}
uint8_t pass_exe = 0, general_pass_open = 0;
uint_t menue_photo_execute(char enter, char esc, char left, char right, char up, char down)
{
  40bd74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	if (pass_exe)
  40bd78:	4f3c      	ldr	r7, [pc, #240]	; (40be6c <menue_photo_execute+0xf8>)
{
  40bd7a:	b082      	sub	sp, #8
	if (pass_exe)
  40bd7c:	783d      	ldrb	r5, [r7, #0]
{
  40bd7e:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
  40bd82:	f89d e02c 	ldrb.w	lr, [sp, #44]	; 0x2c
	if (pass_exe)
  40bd86:	b15d      	cbz	r5, 40bda0 <menue_photo_execute+0x2c>
	{
		uint_t ret_val = enter_pass_exe(enter, esc, left, right, up, down);
  40bd88:	4c39      	ldr	r4, [pc, #228]	; (40be70 <menue_photo_execute+0xfc>)
  40bd8a:	e88d 4040 	stmia.w	sp, {r6, lr}
  40bd8e:	47a0      	blx	r4
		if( ret_val == 1 )
  40bd90:	2801      	cmp	r0, #1
  40bd92:	d038      	beq.n	40be06 <menue_photo_execute+0x92>
				//enter child menue
				if((*(menue_design_image_t *)curr_lst).child)  curr_lst = (*(menue_design_image_t *)curr_lst).child;
				count_unhidden_list_items();
			} 
		}
		else if( ret_val == 2 ) pass_exe = 0;
  40bd94:	2802      	cmp	r0, #2
  40bd96:	d05e      	beq.n	40be56 <menue_photo_execute+0xe2>
		return 0;
  40bd98:	2000      	movs	r0, #0
	{
		if((*(menue_design_image_t *)curr_lst).m_right)	curr_lst = (*(menue_design_image_t *)curr_lst).m_right;
	}
	else if(esc) return 1;
	return 0;	
}
  40bd9a:	b002      	add	sp, #8
  40bd9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	out_image(25,15,(*(menue_design_image_t *)curr_lst).image);
  40bda0:	4e34      	ldr	r6, [pc, #208]	; (40be74 <menue_photo_execute+0x100>)
  40bda2:	4699      	mov	r9, r3
	glcd_clear();
  40bda4:	4b34      	ldr	r3, [pc, #208]	; (40be78 <menue_photo_execute+0x104>)
  40bda6:	4604      	mov	r4, r0
  40bda8:	468a      	mov	sl, r1
  40bdaa:	4690      	mov	r8, r2
  40bdac:	4798      	blx	r3
	out_image(25,15,(*(menue_design_image_t *)curr_lst).image);
  40bdae:	6833      	ldr	r3, [r6, #0]
  40bdb0:	210f      	movs	r1, #15
  40bdb2:	2019      	movs	r0, #25
  40bdb4:	699a      	ldr	r2, [r3, #24]
  40bdb6:	4b31      	ldr	r3, [pc, #196]	; (40be7c <menue_photo_execute+0x108>)
  40bdb8:	4798      	blx	r3
	glcd_gotoxy(4,3);
  40bdba:	2103      	movs	r1, #3
  40bdbc:	2004      	movs	r0, #4
  40bdbe:	4b30      	ldr	r3, [pc, #192]	; (40be80 <menue_photo_execute+0x10c>)
  40bdc0:	4798      	blx	r3
	write_r_text((*(menue_design_image_t *)curr_lst).menue_name ,0);
  40bdc2:	6832      	ldr	r2, [r6, #0]
  40bdc4:	4b2f      	ldr	r3, [pc, #188]	; (40be84 <menue_photo_execute+0x110>)
  40bdc6:	4629      	mov	r1, r5
  40bdc8:	69d0      	ldr	r0, [r2, #28]
  40bdca:	4798      	blx	r3
	list_draw_frame(0);
  40bdcc:	4628      	mov	r0, r5
  40bdce:	4b2e      	ldr	r3, [pc, #184]	; (40be88 <menue_photo_execute+0x114>)
  40bdd0:	4798      	blx	r3
	if(enter)
  40bdd2:	b15c      	cbz	r4, 40bdec <menue_photo_execute+0x78>
		if ( ((*(menue_design_image_t *)curr_lst).menue_password == 0) ||  ((*(menue_design_image_t *)curr_lst).menue_opened) || general_pass_open)
  40bdd4:	6833      	ldr	r3, [r6, #0]
  40bdd6:	691a      	ldr	r2, [r3, #16]
  40bdd8:	b112      	cbz	r2, 40bde0 <menue_photo_execute+0x6c>
  40bdda:	7d1a      	ldrb	r2, [r3, #20]
  40bddc:	2a00      	cmp	r2, #0
  40bdde:	d030      	beq.n	40be42 <menue_photo_execute+0xce>
			if((*(menue_design_image_t *)curr_lst).child)  curr_lst = (*(menue_design_image_t *)curr_lst).child;
  40bde0:	685b      	ldr	r3, [r3, #4]
  40bde2:	b103      	cbz	r3, 40bde6 <menue_photo_execute+0x72>
				if((*(menue_design_image_t *)curr_lst).child)  curr_lst = (*(menue_design_image_t *)curr_lst).child;
  40bde4:	6033      	str	r3, [r6, #0]
				count_unhidden_list_items();
  40bde6:	4b29      	ldr	r3, [pc, #164]	; (40be8c <menue_photo_execute+0x118>)
  40bde8:	4798      	blx	r3
  40bdea:	e7d5      	b.n	40bd98 <menue_photo_execute+0x24>
	else if(left)
  40bdec:	f1b8 0f00 	cmp.w	r8, #0
  40bdf0:	d11e      	bne.n	40be30 <menue_photo_execute+0xbc>
	else if(right)
  40bdf2:	f1b9 0f00 	cmp.w	r9, #0
  40bdf6:	d033      	beq.n	40be60 <menue_photo_execute+0xec>
		if((*(menue_design_image_t *)curr_lst).m_right)	curr_lst = (*(menue_design_image_t *)curr_lst).m_right;
  40bdf8:	6833      	ldr	r3, [r6, #0]
  40bdfa:	68db      	ldr	r3, [r3, #12]
  40bdfc:	2b00      	cmp	r3, #0
  40bdfe:	d0cb      	beq.n	40bd98 <menue_photo_execute+0x24>
  40be00:	6033      	str	r3, [r6, #0]
	return 0;	
  40be02:	4640      	mov	r0, r8
  40be04:	e7c9      	b.n	40bd9a <menue_photo_execute+0x26>
			if ( (*(*(menue_design_image_t *)curr_lst).menue_password == lst_val_entered) || (lst_val_entered == 1321) )
  40be06:	4e1b      	ldr	r6, [pc, #108]	; (40be74 <menue_photo_execute+0x100>)
			pass_exe = 0;
  40be08:	2100      	movs	r1, #0
			if ( (*(*(menue_design_image_t *)curr_lst).menue_password == lst_val_entered) || (lst_val_entered == 1321) )
  40be0a:	4b21      	ldr	r3, [pc, #132]	; (40be90 <menue_photo_execute+0x11c>)
  40be0c:	6832      	ldr	r2, [r6, #0]
			pass_exe = 0;
  40be0e:	7039      	strb	r1, [r7, #0]
			if ( (*(*(menue_design_image_t *)curr_lst).menue_password == lst_val_entered) || (lst_val_entered == 1321) )
  40be10:	6911      	ldr	r1, [r2, #16]
  40be12:	681b      	ldr	r3, [r3, #0]
  40be14:	8809      	ldrh	r1, [r1, #0]
  40be16:	4299      	cmp	r1, r3
  40be18:	d003      	beq.n	40be22 <menue_photo_execute+0xae>
  40be1a:	f240 5129 	movw	r1, #1321	; 0x529
  40be1e:	428b      	cmp	r3, r1
  40be20:	d1ba      	bne.n	40bd98 <menue_photo_execute+0x24>
				if((*(menue_design_image_t *)curr_lst).child)  curr_lst = (*(menue_design_image_t *)curr_lst).child;
  40be22:	6853      	ldr	r3, [r2, #4]
				general_pass_open = 1;
  40be24:	2101      	movs	r1, #1
  40be26:	4a1b      	ldr	r2, [pc, #108]	; (40be94 <menue_photo_execute+0x120>)
  40be28:	7011      	strb	r1, [r2, #0]
				if((*(menue_design_image_t *)curr_lst).child)  curr_lst = (*(menue_design_image_t *)curr_lst).child;
  40be2a:	2b00      	cmp	r3, #0
  40be2c:	d1da      	bne.n	40bde4 <menue_photo_execute+0x70>
  40be2e:	e7da      	b.n	40bde6 <menue_photo_execute+0x72>
		if((*(menue_design_image_t *)curr_lst).m_left)	curr_lst = (*(menue_design_image_t *)curr_lst).m_left;
  40be30:	6833      	ldr	r3, [r6, #0]
  40be32:	689b      	ldr	r3, [r3, #8]
  40be34:	2b00      	cmp	r3, #0
  40be36:	d0af      	beq.n	40bd98 <menue_photo_execute+0x24>
	return 0;	
  40be38:	4620      	mov	r0, r4
		if((*(menue_design_image_t *)curr_lst).m_left)	curr_lst = (*(menue_design_image_t *)curr_lst).m_left;
  40be3a:	6033      	str	r3, [r6, #0]
}
  40be3c:	b002      	add	sp, #8
  40be3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if ( ((*(menue_design_image_t *)curr_lst).menue_password == 0) ||  ((*(menue_design_image_t *)curr_lst).menue_opened) || general_pass_open)
  40be42:	4a14      	ldr	r2, [pc, #80]	; (40be94 <menue_photo_execute+0x120>)
  40be44:	7812      	ldrb	r2, [r2, #0]
  40be46:	2a00      	cmp	r2, #0
  40be48:	d1ca      	bne.n	40bde0 <menue_photo_execute+0x6c>
			pass_exe = 1;
  40be4a:	2101      	movs	r1, #1
			lst_val_entered = 0;
  40be4c:	4b10      	ldr	r3, [pc, #64]	; (40be90 <menue_photo_execute+0x11c>)
	return 0;	
  40be4e:	4610      	mov	r0, r2
			pass_exe = 1;
  40be50:	7039      	strb	r1, [r7, #0]
			lst_val_entered = 0;
  40be52:	601a      	str	r2, [r3, #0]
  40be54:	e7a1      	b.n	40bd9a <menue_photo_execute+0x26>
		else if( ret_val == 2 ) pass_exe = 0;
  40be56:	2000      	movs	r0, #0
  40be58:	7038      	strb	r0, [r7, #0]
}
  40be5a:	b002      	add	sp, #8
  40be5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	else if(esc) return 1;
  40be60:	f11a 0000 	adds.w	r0, sl, #0
  40be64:	bf18      	it	ne
  40be66:	2001      	movne	r0, #1
  40be68:	e797      	b.n	40bd9a <menue_photo_execute+0x26>
  40be6a:	bf00      	nop
  40be6c:	204008fc 	.word	0x204008fc
  40be70:	0040bbed 	.word	0x0040bbed
  40be74:	204056c4 	.word	0x204056c4
  40be78:	0040c2e5 	.word	0x0040c2e5
  40be7c:	0040c4a5 	.word	0x0040c4a5
  40be80:	0040c7a5 	.word	0x0040c7a5
  40be84:	0040cf51 	.word	0x0040cf51
  40be88:	0040bb69 	.word	0x0040bb69
  40be8c:	0040ba55 	.word	0x0040ba55
  40be90:	20405680 	.word	0x20405680
  40be94:	204008f8 	.word	0x204008f8

0040be98 <menue_execute>:

char in_depth=0;
uint_t menue_execute(char enter, char esc, char up, char down, char left, char right)
{
  40be98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char enter_return;
	if((*curr_lst).m_type == GRAPHICAL_MENUE_LIST)
  40be9c:	4d4e      	ldr	r5, [pc, #312]	; (40bfd8 <menue_execute+0x140>)
{
  40be9e:	b085      	sub	sp, #20
	if((*curr_lst).m_type == GRAPHICAL_MENUE_LIST)
  40bea0:	682f      	ldr	r7, [r5, #0]
{
  40bea2:	f89d 8038 	ldrb.w	r8, [sp, #56]	; 0x38
	if((*curr_lst).m_type == GRAPHICAL_MENUE_LIST)
  40bea6:	783f      	ldrb	r7, [r7, #0]
{
  40bea8:	f89d 903c 	ldrb.w	r9, [sp, #60]	; 0x3c
	if((*curr_lst).m_type == GRAPHICAL_MENUE_LIST)
  40beac:	bb67      	cbnz	r7, 40bf08 <menue_execute+0x70>
	{
		if(in_depth)
  40beae:	f8df a158 	ldr.w	sl, [pc, #344]	; 40c008 <menue_execute+0x170>
  40beb2:	460c      	mov	r4, r1
  40beb4:	9003      	str	r0, [sp, #12]
  40beb6:	461f      	mov	r7, r3
  40beb8:	f89a b000 	ldrb.w	fp, [sl]
  40bebc:	4616      	mov	r6, r2
  40bebe:	f1bb 0f00 	cmp.w	fp, #0
  40bec2:	d027      	beq.n	40bf14 <menue_execute+0x7c>
		{
			list_draw_frame(1);
  40bec4:	2001      	movs	r0, #1
  40bec6:	4b45      	ldr	r3, [pc, #276]	; (40bfdc <menue_execute+0x144>)
  40bec8:	4798      	blx	r3
			if(list_input_val(enter, esc, up, down, left, right) == 0)
  40beca:	f8df b140 	ldr.w	fp, [pc, #320]	; 40c00c <menue_execute+0x174>
  40bece:	463b      	mov	r3, r7
  40bed0:	4632      	mov	r2, r6
  40bed2:	4621      	mov	r1, r4
  40bed4:	9803      	ldr	r0, [sp, #12]
  40bed6:	e88d 0300 	stmia.w	sp, {r8, r9}
  40beda:	47d8      	blx	fp
  40bedc:	2800      	cmp	r0, #0
  40bede:	d153      	bne.n	40bf88 <menue_execute+0xf0>
	tmp_lst = curr_lst->lst_itms;
  40bee0:	682b      	ldr	r3, [r5, #0]
	return lst_indeces[lst_highlight];
  40bee2:	4c3f      	ldr	r4, [pc, #252]	; (40bfe0 <menue_execute+0x148>)
  40bee4:	7b99      	ldrb	r1, [r3, #14]
	if((tmp_lst + lst_highlight)->exit_menue)
  40bee6:	689a      	ldr	r2, [r3, #8]
  40bee8:	5c63      	ldrb	r3, [r4, r1]
			{
				in_depth = 0;
  40beea:	f88a 0000 	strb.w	r0, [sl]
	if((tmp_lst + lst_highlight)->exit_menue)
  40beee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40bef2:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  40bef6:	699b      	ldr	r3, [r3, #24]
  40bef8:	b103      	cbz	r3, 40befc <menue_execute+0x64>
		(tmp_lst + lst_highlight)->exit_menue(); // if there is a function at the function pointer execute it
  40befa:	4798      	blx	r3
				list_exit();
				dec_list();
  40befc:	4b39      	ldr	r3, [pc, #228]	; (40bfe4 <menue_execute+0x14c>)
  40befe:	4798      	blx	r3
			{
				in_depth = 0;
				list_exit();
				dec_list();
			}
			return 0;
  40bf00:	2000      	movs	r0, #0
	else if((*curr_lst).m_type == GRAPHICAL_MENUE_PHOTO)
	{
		return menue_photo_execute(enter, esc, left, right, up, down);	
	}
	return 0;	
}
  40bf02:	b005      	add	sp, #20
  40bf04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	else if((*curr_lst).m_type == GRAPHICAL_MENUE_PHOTO)
  40bf08:	2f01      	cmp	r7, #1
  40bf0a:	d033      	beq.n	40bf74 <menue_execute+0xdc>
			return 0;
  40bf0c:	2000      	movs	r0, #0
}
  40bf0e:	b005      	add	sp, #20
  40bf10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		glcd_clear();
  40bf14:	4b34      	ldr	r3, [pc, #208]	; (40bfe8 <menue_execute+0x150>)
  40bf16:	4798      	blx	r3
		glcd_gotoxy(0,0);
  40bf18:	4659      	mov	r1, fp
  40bf1a:	4658      	mov	r0, fp
  40bf1c:	4b33      	ldr	r3, [pc, #204]	; (40bfec <menue_execute+0x154>)
  40bf1e:	4798      	blx	r3
		if(up) inc_list();
  40bf20:	b1ce      	cbz	r6, 40bf56 <menue_execute+0xbe>
	if(((*curr_lst).list_highlight)>0)
  40bf22:	682a      	ldr	r2, [r5, #0]
  40bf24:	7b93      	ldrb	r3, [r2, #14]
  40bf26:	b113      	cbz	r3, 40bf2e <menue_execute+0x96>
		--((*curr_lst).list_highlight);
  40bf28:	3b01      	subs	r3, #1
  40bf2a:	b2db      	uxtb	r3, r3
  40bf2c:	7393      	strb	r3, [r2, #14]
	if(curr_lst->list_highlight < curr_lst->list_start)	 curr_lst->list_start = curr_lst->list_highlight;
  40bf2e:	7b51      	ldrb	r1, [r2, #13]
  40bf30:	4299      	cmp	r1, r3
  40bf32:	d900      	bls.n	40bf36 <menue_execute+0x9e>
  40bf34:	7353      	strb	r3, [r2, #13]
		if(esc) 
  40bf36:	2c00      	cmp	r4, #0
  40bf38:	d040      	beq.n	40bfbc <menue_execute+0x124>
			if((*(menue_design_t *)curr_lst).parent)  
  40bf3a:	682b      	ldr	r3, [r5, #0]
  40bf3c:	685b      	ldr	r3, [r3, #4]
  40bf3e:	2b00      	cmp	r3, #0
  40bf40:	d043      	beq.n	40bfca <menue_execute+0x132>
				curr_lst = (*(menue_design_t *)curr_lst).parent;
  40bf42:	602b      	str	r3, [r5, #0]
				if ((*curr_lst).m_type == GRAPHICAL_MENUE_LIST)
  40bf44:	781c      	ldrb	r4, [r3, #0]
  40bf46:	2c00      	cmp	r4, #0
  40bf48:	d1e0      	bne.n	40bf0c <menue_execute+0x74>
					count_unhidden_list_items();
  40bf4a:	4b29      	ldr	r3, [pc, #164]	; (40bff0 <menue_execute+0x158>)
  40bf4c:	4798      	blx	r3
					dec_list();
  40bf4e:	4b25      	ldr	r3, [pc, #148]	; (40bfe4 <menue_execute+0x14c>)
  40bf50:	4798      	blx	r3
				return 0;
  40bf52:	4620      	mov	r0, r4
  40bf54:	e7db      	b.n	40bf0e <menue_execute+0x76>
		else if(down) dec_list();
  40bf56:	2f00      	cmp	r7, #0
  40bf58:	d134      	bne.n	40bfc4 <menue_execute+0x12c>
		else if(enter)
  40bf5a:	9b03      	ldr	r3, [sp, #12]
  40bf5c:	2b00      	cmp	r3, #0
  40bf5e:	d0ea      	beq.n	40bf36 <menue_execute+0x9e>
			enter_return = list_enter();
  40bf60:	4b24      	ldr	r3, [pc, #144]	; (40bff4 <menue_execute+0x15c>)
  40bf62:	4798      	blx	r3
			if(enter_return == 1)
  40bf64:	b2c0      	uxtb	r0, r0
  40bf66:	2801      	cmp	r0, #1
  40bf68:	d031      	beq.n	40bfce <menue_execute+0x136>
			else if(list_join())
  40bf6a:	4b23      	ldr	r3, [pc, #140]	; (40bff8 <menue_execute+0x160>)
  40bf6c:	4798      	blx	r3
  40bf6e:	2800      	cmp	r0, #0
  40bf70:	d1e1      	bne.n	40bf36 <menue_execute+0x9e>
  40bf72:	e7e2      	b.n	40bf3a <menue_execute+0xa2>
		return menue_photo_execute(enter, esc, left, right, up, down);	
  40bf74:	4c21      	ldr	r4, [pc, #132]	; (40bffc <menue_execute+0x164>)
  40bf76:	930f      	str	r3, [sp, #60]	; 0x3c
  40bf78:	464b      	mov	r3, r9
  40bf7a:	920e      	str	r2, [sp, #56]	; 0x38
  40bf7c:	46a4      	mov	ip, r4
  40bf7e:	4642      	mov	r2, r8
}
  40bf80:	b005      	add	sp, #20
  40bf82:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return menue_photo_execute(enter, esc, left, right, up, down);	
  40bf86:	4760      	bx	ip
			else if (list_confirm_exe(enter, esc, up, down, left, right) == 0)
  40bf88:	f8cd 9004 	str.w	r9, [sp, #4]
  40bf8c:	463b      	mov	r3, r7
  40bf8e:	f8cd 8000 	str.w	r8, [sp]
  40bf92:	4632      	mov	r2, r6
  40bf94:	4621      	mov	r1, r4
  40bf96:	9803      	ldr	r0, [sp, #12]
  40bf98:	f8df b074 	ldr.w	fp, [pc, #116]	; 40c010 <menue_execute+0x178>
  40bf9c:	47d8      	blx	fp
  40bf9e:	2800      	cmp	r0, #0
  40bfa0:	d09e      	beq.n	40bee0 <menue_execute+0x48>
			else if(list_exe(enter, esc, up, down, left, right) == 0) 
  40bfa2:	4621      	mov	r1, r4
  40bfa4:	f8cd 9004 	str.w	r9, [sp, #4]
  40bfa8:	463b      	mov	r3, r7
  40bfaa:	f8cd 8000 	str.w	r8, [sp]
  40bfae:	4632      	mov	r2, r6
  40bfb0:	9803      	ldr	r0, [sp, #12]
  40bfb2:	4c13      	ldr	r4, [pc, #76]	; (40c000 <menue_execute+0x168>)
  40bfb4:	47a0      	blx	r4
  40bfb6:	2800      	cmp	r0, #0
  40bfb8:	d092      	beq.n	40bee0 <menue_execute+0x48>
  40bfba:	e7a7      	b.n	40bf0c <menue_execute+0x74>
		list_view();
  40bfbc:	4b11      	ldr	r3, [pc, #68]	; (40c004 <menue_execute+0x16c>)
  40bfbe:	4798      	blx	r3
	return 0;	
  40bfc0:	4620      	mov	r0, r4
  40bfc2:	e7a4      	b.n	40bf0e <menue_execute+0x76>
		else if(down) dec_list();
  40bfc4:	4b07      	ldr	r3, [pc, #28]	; (40bfe4 <menue_execute+0x14c>)
  40bfc6:	4798      	blx	r3
  40bfc8:	e7b5      	b.n	40bf36 <menue_execute+0x9e>
			else return 1; //there is no parent to reutrn to
  40bfca:	2001      	movs	r0, #1
  40bfcc:	e79f      	b.n	40bf0e <menue_execute+0x76>
				in_depth=1;
  40bfce:	f88a 0000 	strb.w	r0, [sl]
				return 0;
  40bfd2:	4638      	mov	r0, r7
  40bfd4:	e79b      	b.n	40bf0e <menue_execute+0x76>
  40bfd6:	bf00      	nop
  40bfd8:	204056c4 	.word	0x204056c4
  40bfdc:	0040bb69 	.word	0x0040bb69
  40bfe0:	20405690 	.word	0x20405690
  40bfe4:	0040b0f1 	.word	0x0040b0f1
  40bfe8:	0040c2e5 	.word	0x0040c2e5
  40bfec:	0040c7a5 	.word	0x0040c7a5
  40bff0:	0040ba55 	.word	0x0040ba55
  40bff4:	0040b7e9 	.word	0x0040b7e9
  40bff8:	0040bab5 	.word	0x0040bab5
  40bffc:	0040bd75 	.word	0x0040bd75
  40c000:	0040ba0d 	.word	0x0040ba0d
  40c004:	0040b125 	.word	0x0040b125
  40c008:	204008f9 	.word	0x204008f9
  40c00c:	0040b8dd 	.word	0x0040b8dd
  40c010:	0040b989 	.word	0x0040b989

0040c014 <connect_graphical_menues>:
void connect_graphical_menues(menue_design_image_t *m_left, menue_design_image_t *m_right)
{
	(*m_left).m_right = m_right;
  40c014:	60c1      	str	r1, [r0, #12]
	(*m_right).m_left = m_left;	
  40c016:	6088      	str	r0, [r1, #8]
  40c018:	4770      	bx	lr
  40c01a:	bf00      	nop

0040c01c <pop_ups_handler>:

uint32_t pups_timelapse = 0;
const char *msg;
void pop_ups_handler(void)
{
	if (pups_timelapse > 0) pups_timelapse--;
  40c01c:	4a02      	ldr	r2, [pc, #8]	; (40c028 <pop_ups_handler+0xc>)
  40c01e:	6813      	ldr	r3, [r2, #0]
  40c020:	b10b      	cbz	r3, 40c026 <pop_ups_handler+0xa>
  40c022:	3b01      	subs	r3, #1
  40c024:	6013      	str	r3, [r2, #0]
  40c026:	4770      	bx	lr
  40c028:	20400900 	.word	0x20400900

0040c02c <pop_ups_showMessage>:
}

int32_t pop_ups_showMessage(void)
{
  40c02c:	b508      	push	{r3, lr}
	if (pups_timelapse > 0)
  40c02e:	4b08      	ldr	r3, [pc, #32]	; (40c050 <pop_ups_showMessage+0x24>)
  40c030:	6818      	ldr	r0, [r3, #0]
  40c032:	b158      	cbz	r0, 40c04c <pop_ups_showMessage+0x20>
	{
		glcd_clear();
  40c034:	4b07      	ldr	r3, [pc, #28]	; (40c054 <pop_ups_showMessage+0x28>)
  40c036:	4798      	blx	r3
		glcd_gotoxy(4,32);
  40c038:	2120      	movs	r1, #32
  40c03a:	2004      	movs	r0, #4
  40c03c:	4b06      	ldr	r3, [pc, #24]	; (40c058 <pop_ups_showMessage+0x2c>)
  40c03e:	4798      	blx	r3
		write_r_text(msg ,0);
  40c040:	4a06      	ldr	r2, [pc, #24]	; (40c05c <pop_ups_showMessage+0x30>)
  40c042:	2100      	movs	r1, #0
  40c044:	4b06      	ldr	r3, [pc, #24]	; (40c060 <pop_ups_showMessage+0x34>)
  40c046:	6810      	ldr	r0, [r2, #0]
  40c048:	4798      	blx	r3
		
		return 1;
  40c04a:	2001      	movs	r0, #1
	}
	return 0;
}
  40c04c:	bd08      	pop	{r3, pc}
  40c04e:	bf00      	nop
  40c050:	20400900 	.word	0x20400900
  40c054:	0040c2e5 	.word	0x0040c2e5
  40c058:	0040c7a5 	.word	0x0040c7a5
  40c05c:	204056c8 	.word	0x204056c8
  40c060:	0040cf51 	.word	0x0040cf51

0040c064 <pop_ups_add>:

void pop_ups_add(const char *str, uint32_t ms_time)
{
	pups_timelapse = ms_time;
  40c064:	4a02      	ldr	r2, [pc, #8]	; (40c070 <pop_ups_add+0xc>)
	msg = str;
  40c066:	4b03      	ldr	r3, [pc, #12]	; (40c074 <pop_ups_add+0x10>)
	pups_timelapse = ms_time;
  40c068:	6011      	str	r1, [r2, #0]
	msg = str;
  40c06a:	6018      	str	r0, [r3, #0]
  40c06c:	4770      	bx	lr
  40c06e:	bf00      	nop
  40c070:	20400900 	.word	0x20400900
  40c074:	204056c8 	.word	0x204056c8

0040c078 <RTC_Handler>:
#define M_DAY   (29)


void RTC_Handler (void)
{
	uint32_t status = rtc_get_status(RTC);
  40c078:	4b0d      	ldr	r3, [pc, #52]	; (40c0b0 <RTC_Handler+0x38>)
  40c07a:	480e      	ldr	r0, [pc, #56]	; (40c0b4 <RTC_Handler+0x3c>)
{
  40c07c:	b510      	push	{r4, lr}
	uint32_t status = rtc_get_status(RTC);
  40c07e:	4798      	blx	r3
	if (status & RTC_SR_ALARM)
  40c080:	0783      	lsls	r3, r0, #30
  40c082:	d400      	bmi.n	40c086 <RTC_Handler+0xe>
  40c084:	bd10      	pop	{r4, pc}
	{
		rtc_disable_interrupt(RTC, RTC_IDR_ALRDIS);
  40c086:	2102      	movs	r1, #2
  40c088:	480a      	ldr	r0, [pc, #40]	; (40c0b4 <RTC_Handler+0x3c>)
  40c08a:	4b0b      	ldr	r3, [pc, #44]	; (40c0b8 <RTC_Handler+0x40>)
  40c08c:	4798      	blx	r3
		rtc_clear_date_alarm(RTC);
  40c08e:	4809      	ldr	r0, [pc, #36]	; (40c0b4 <RTC_Handler+0x3c>)
  40c090:	4b0a      	ldr	r3, [pc, #40]	; (40c0bc <RTC_Handler+0x44>)
  40c092:	4798      	blx	r3
		rtc_clear_time_alarm(RTC);
  40c094:	4807      	ldr	r0, [pc, #28]	; (40c0b4 <RTC_Handler+0x3c>)
  40c096:	4b0a      	ldr	r3, [pc, #40]	; (40c0c0 <RTC_Handler+0x48>)
  40c098:	4798      	blx	r3
		rtc_clear_status(RTC, RTC_SCCR_ALRCLR);
  40c09a:	2102      	movs	r1, #2
  40c09c:	4805      	ldr	r0, [pc, #20]	; (40c0b4 <RTC_Handler+0x3c>)
  40c09e:	4b09      	ldr	r3, [pc, #36]	; (40c0c4 <RTC_Handler+0x4c>)
  40c0a0:	4798      	blx	r3
		rtc_enable_interrupt(RTC, RTC_IER_ALREN);
  40c0a2:	2102      	movs	r1, #2
  40c0a4:	4803      	ldr	r0, [pc, #12]	; (40c0b4 <RTC_Handler+0x3c>)
  40c0a6:	4b08      	ldr	r3, [pc, #32]	; (40c0c8 <RTC_Handler+0x50>)
	}
}
  40c0a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		rtc_enable_interrupt(RTC, RTC_IER_ALREN);
  40c0ac:	4718      	bx	r3
  40c0ae:	bf00      	nop
  40c0b0:	00400699 	.word	0x00400699
  40c0b4:	400e1860 	.word	0x400e1860
  40c0b8:	004005b5 	.word	0x004005b5
  40c0bc:	0040068d 	.word	0x0040068d
  40c0c0:	00400685 	.word	0x00400685
  40c0c4:	0040069d 	.word	0x0040069d
  40c0c8:	004005b1 	.word	0x004005b1

0040c0cc <rtc_init>:

void rtc_init(void)
{
  40c0cc:	b510      	push	{r4, lr}
  40c0ce:	b086      	sub	sp, #24
	volatile uint32_t year, day, week, month;
	rtc_get_date(RTC, &year, &month, &day, &week);
  40c0d0:	4c04      	ldr	r4, [pc, #16]	; (40c0e4 <rtc_init+0x18>)
  40c0d2:	a804      	add	r0, sp, #16
  40c0d4:	ab03      	add	r3, sp, #12
  40c0d6:	aa05      	add	r2, sp, #20
  40c0d8:	a902      	add	r1, sp, #8
  40c0da:	9000      	str	r0, [sp, #0]
  40c0dc:	4802      	ldr	r0, [pc, #8]	; (40c0e8 <rtc_init+0x1c>)
  40c0de:	47a0      	blx	r4
	//rtc_set_date(RTC, M_YEAR, M_MONTH, M_DAY, M_WEEK);
	if(year < M_YEAR)
	{
		rtc_set_date(RTC, M_YEAR, M_MONTH, M_DAY, M_WEEK);
	}
}
  40c0e0:	b006      	add	sp, #24
  40c0e2:	bd10      	pop	{r4, pc}
  40c0e4:	00400611 	.word	0x00400611
  40c0e8:	400e1860 	.word	0x400e1860

0040c0ec <rtc_date_check>:

void rtc_date_check(uint32_t *p_ul_year, uint32_t *p_ul_month, uint32_t *p_ul_day)
{
	if (*p_ul_year < 10) *p_ul_year = 10;
  40c0ec:	6803      	ldr	r3, [r0, #0]
  40c0ee:	2b09      	cmp	r3, #9
  40c0f0:	d80a      	bhi.n	40c108 <rtc_date_check+0x1c>
  40c0f2:	230a      	movs	r3, #10
  40c0f4:	6003      	str	r3, [r0, #0]
	else if (*p_ul_year > 99) *p_ul_year = 99;
	
	if (*p_ul_month < 1) *p_ul_month = 1;
  40c0f6:	680b      	ldr	r3, [r1, #0]
  40c0f8:	b96b      	cbnz	r3, 40c116 <rtc_date_check+0x2a>
  40c0fa:	2301      	movs	r3, #1
  40c0fc:	600b      	str	r3, [r1, #0]
	else if (*p_ul_month > 12) *p_ul_month = 12;
	
	if (*p_ul_day < 1) *p_ul_day = 1;
  40c0fe:	6813      	ldr	r3, [r2, #0]
  40c100:	b983      	cbnz	r3, 40c124 <rtc_date_check+0x38>
  40c102:	2301      	movs	r3, #1
  40c104:	6013      	str	r3, [r2, #0]
  40c106:	4770      	bx	lr
	else if (*p_ul_year > 99) *p_ul_year = 99;
  40c108:	2b63      	cmp	r3, #99	; 0x63
  40c10a:	d9f4      	bls.n	40c0f6 <rtc_date_check+0xa>
  40c10c:	2363      	movs	r3, #99	; 0x63
  40c10e:	6003      	str	r3, [r0, #0]
	if (*p_ul_month < 1) *p_ul_month = 1;
  40c110:	680b      	ldr	r3, [r1, #0]
  40c112:	2b00      	cmp	r3, #0
  40c114:	d0f1      	beq.n	40c0fa <rtc_date_check+0xe>
	else if (*p_ul_month > 12) *p_ul_month = 12;
  40c116:	2b0c      	cmp	r3, #12
  40c118:	d9f1      	bls.n	40c0fe <rtc_date_check+0x12>
  40c11a:	230c      	movs	r3, #12
  40c11c:	600b      	str	r3, [r1, #0]
	if (*p_ul_day < 1) *p_ul_day = 1;
  40c11e:	6813      	ldr	r3, [r2, #0]
  40c120:	2b00      	cmp	r3, #0
  40c122:	d0ee      	beq.n	40c102 <rtc_date_check+0x16>
{
  40c124:	b430      	push	{r4, r5}
	else if (*p_ul_day > month_max[*p_ul_month - 1]) *p_ul_day = month_max[*p_ul_month - 1];
  40c126:	680d      	ldr	r5, [r1, #0]
  40c128:	4c0a      	ldr	r4, [pc, #40]	; (40c154 <rtc_date_check+0x68>)
  40c12a:	442c      	add	r4, r5
  40c12c:	f814 4c01 	ldrb.w	r4, [r4, #-1]
  40c130:	42a3      	cmp	r3, r4
  40c132:	d901      	bls.n	40c138 <rtc_date_check+0x4c>
  40c134:	6014      	str	r4, [r2, #0]
  40c136:	680d      	ldr	r5, [r1, #0]
	
	if ((*p_ul_month == 2) && (*p_ul_day == 29))
  40c138:	2d02      	cmp	r5, #2
  40c13a:	d001      	beq.n	40c140 <rtc_date_check+0x54>
	{
		if (((*p_ul_year) % 4) != 0) (*p_ul_day)--;
	}
}
  40c13c:	bc30      	pop	{r4, r5}
  40c13e:	4770      	bx	lr
	if ((*p_ul_month == 2) && (*p_ul_day == 29))
  40c140:	6813      	ldr	r3, [r2, #0]
  40c142:	2b1d      	cmp	r3, #29
  40c144:	d1fa      	bne.n	40c13c <rtc_date_check+0x50>
		if (((*p_ul_year) % 4) != 0) (*p_ul_day)--;
  40c146:	6803      	ldr	r3, [r0, #0]
  40c148:	079b      	lsls	r3, r3, #30
  40c14a:	d0f7      	beq.n	40c13c <rtc_date_check+0x50>
  40c14c:	231c      	movs	r3, #28
  40c14e:	6013      	str	r3, [r2, #0]
}
  40c150:	e7f4      	b.n	40c13c <rtc_date_check+0x50>
  40c152:	bf00      	nop
  40c154:	0041ca1c 	.word	0x0041ca1c

0040c158 <rtc_save_date>:

void rtc_save_date(uint32_t year, uint32_t month, uint32_t day)
{
	//rtc_set_date(RTC, year + 2000, month, day, 1);
	pop_ups_add("Date set!", 1200);
  40c158:	f44f 6196 	mov.w	r1, #1200	; 0x4b0
  40c15c:	4801      	ldr	r0, [pc, #4]	; (40c164 <rtc_save_date+0xc>)
  40c15e:	4b02      	ldr	r3, [pc, #8]	; (40c168 <rtc_save_date+0x10>)
  40c160:	4718      	bx	r3
  40c162:	bf00      	nop
  40c164:	0041ca2c 	.word	0x0041ca2c
  40c168:	0040c065 	.word	0x0040c065

0040c16c <rtc_time_check>:
}

void rtc_time_check(uint32_t *p_ul_hour, uint32_t *p_ul_min, uint32_t *p_ul_sec)
{
	uint32_t tmp;
	if (*p_ul_hour > 23) *p_ul_hour = 23;
  40c16c:	6803      	ldr	r3, [r0, #0]
  40c16e:	2b17      	cmp	r3, #23
  40c170:	d901      	bls.n	40c176 <rtc_time_check+0xa>
  40c172:	2317      	movs	r3, #23
  40c174:	6003      	str	r3, [r0, #0]
	
	if (*p_ul_min > 59) *p_ul_min = 59;
  40c176:	680b      	ldr	r3, [r1, #0]
  40c178:	2b3b      	cmp	r3, #59	; 0x3b
  40c17a:	d901      	bls.n	40c180 <rtc_time_check+0x14>
  40c17c:	233b      	movs	r3, #59	; 0x3b
  40c17e:	600b      	str	r3, [r1, #0]
	
	if (*p_ul_sec > 59) *p_ul_sec = 59;
  40c180:	6813      	ldr	r3, [r2, #0]
  40c182:	2b3b      	cmp	r3, #59	; 0x3b
  40c184:	d901      	bls.n	40c18a <rtc_time_check+0x1e>
  40c186:	233b      	movs	r3, #59	; 0x3b
  40c188:	6013      	str	r3, [r2, #0]
  40c18a:	4770      	bx	lr

0040c18c <rtc_save_time>:
}

void rtc_save_time(uint32_t hour, uint32_t min, uint32_t sec)
{
	//rtc_set_time(RTC, hour, min, sec);
	pop_ups_add("Time set!", 1200);
  40c18c:	f44f 6196 	mov.w	r1, #1200	; 0x4b0
  40c190:	4801      	ldr	r0, [pc, #4]	; (40c198 <rtc_save_time+0xc>)
  40c192:	4b02      	ldr	r3, [pc, #8]	; (40c19c <rtc_save_time+0x10>)
  40c194:	4718      	bx	r3
  40c196:	bf00      	nop
  40c198:	0041ca38 	.word	0x0041ca38
  40c19c:	0040c065 	.word	0x0040c065

0040c1a0 <rtc_get_week>:
static uint32_t calculate_week(uint32_t ul_year, uint32_t ul_month,
		uint32_t ul_day)
{
	uint32_t ul_week;

	if (ul_month == 1 || ul_month == 2) {
  40c1a0:	1e4b      	subs	r3, r1, #1
  40c1a2:	2b01      	cmp	r3, #1
			return "Fri";
	}
	
}
const char *rtc_get_week(uint32_t year, uint32_t month, uint32_t day)
{
  40c1a4:	b430      	push	{r4, r5}
	if (ul_month == 1 || ul_month == 2) {
  40c1a6:	d801      	bhi.n	40c1ac <rtc_get_week+0xc>
		ul_month += 12;
  40c1a8:	310c      	adds	r1, #12
		--ul_year;
  40c1aa:	3801      	subs	r0, #1
			ul_year / 4 - ul_year / 100 + ul_year / 400) % 7;
  40c1ac:	1813      	adds	r3, r2, r0
  40c1ae:	4c11      	ldr	r4, [pc, #68]	; (40c1f4 <rtc_get_week+0x54>)
	ul_week = (ul_day + 2 * ul_month + 3 * (ul_month + 1) / 5 + ul_year +
  40c1b0:	1c4a      	adds	r2, r1, #1
  40c1b2:	4d11      	ldr	r5, [pc, #68]	; (40c1f8 <rtc_get_week+0x58>)
			ul_year / 4 - ul_year / 100 + ul_year / 400) % 7;
  40c1b4:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  40c1b8:	fba4 1400 	umull	r1, r4, r4, r0
	ul_week = (ul_day + 2 * ul_month + 3 * (ul_month + 1) / 5 + ul_year +
  40c1bc:	eb02 0142 	add.w	r1, r2, r2, lsl #1
  40c1c0:	4a0e      	ldr	r2, [pc, #56]	; (40c1fc <rtc_get_week+0x5c>)
			ul_year / 4 - ul_year / 100 + ul_year / 400) % 7;
  40c1c2:	eb03 0390 	add.w	r3, r3, r0, lsr #2
	return rtc_get_week_name(calculate_week(year, month, day));
  40c1c6:	480e      	ldr	r0, [pc, #56]	; (40c200 <rtc_get_week+0x60>)
	ul_week = (ul_day + 2 * ul_month + 3 * (ul_month + 1) / 5 + ul_year +
  40c1c8:	fba5 5101 	umull	r5, r1, r5, r1
			ul_year / 4 - ul_year / 100 + ul_year / 400) % 7;
  40c1cc:	eb03 13d4 	add.w	r3, r3, r4, lsr #7
  40c1d0:	eba3 1354 	sub.w	r3, r3, r4, lsr #5
  40c1d4:	eb03 0391 	add.w	r3, r3, r1, lsr #2
	ul_week = (ul_day + 2 * ul_month + 3 * (ul_month + 1) / 5 + ul_year +
  40c1d8:	fba2 1203 	umull	r1, r2, r2, r3
  40c1dc:	1a99      	subs	r1, r3, r2
  40c1de:	eb02 0251 	add.w	r2, r2, r1, lsr #1
  40c1e2:	0892      	lsrs	r2, r2, #2
  40c1e4:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
  40c1e8:	1a9b      	subs	r3, r3, r2
  40c1ea:	bc30      	pop	{r4, r5}
  40c1ec:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  40c1f0:	4770      	bx	lr
  40c1f2:	bf00      	nop
  40c1f4:	51eb851f 	.word	0x51eb851f
  40c1f8:	cccccccd 	.word	0xcccccccd
  40c1fc:	24924925 	.word	0x24924925
  40c200:	0041ca00 	.word	0x0041ca00

0040c204 <itos>:
char *temp_surface = temp_surface1;
char *surface_print = temp_surface2;

char temp[21];
char *itos(uint64_t val)
{
  40c204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	char *temp_ptr=&temp[20];
	temp[20]=0;
  40c206:	2300      	movs	r3, #0
{
  40c208:	4604      	mov	r4, r0
  40c20a:	460d      	mov	r5, r1
	temp[20]=0;
  40c20c:	4e10      	ldr	r6, [pc, #64]	; (40c250 <itos+0x4c>)
  40c20e:	7533      	strb	r3, [r6, #20]
	if(val > 0)
  40c210:	ea54 0305 	orrs.w	r3, r4, r5
  40c214:	d016      	beq.n	40c244 <itos+0x40>
  40c216:	3614      	adds	r6, #20
  40c218:	4f0e      	ldr	r7, [pc, #56]	; (40c254 <itos+0x50>)
	{
		while(val)
		{
			*--temp_ptr = (val%10)|0x30;
  40c21a:	4620      	mov	r0, r4
  40c21c:	4629      	mov	r1, r5
  40c21e:	220a      	movs	r2, #10
  40c220:	2300      	movs	r3, #0
  40c222:	47b8      	blx	r7
  40c224:	f042 0e30 	orr.w	lr, r2, #48	; 0x30
			val/=10;
  40c228:	4620      	mov	r0, r4
  40c22a:	4629      	mov	r1, r5
  40c22c:	2300      	movs	r3, #0
  40c22e:	220a      	movs	r2, #10
			*--temp_ptr = (val%10)|0x30;
  40c230:	f806 ed01 	strb.w	lr, [r6, #-1]!
			val/=10;
  40c234:	47b8      	blx	r7
  40c236:	4604      	mov	r4, r0
  40c238:	460d      	mov	r5, r1
		while(val)
  40c23a:	ea54 0305 	orrs.w	r3, r4, r5
  40c23e:	d1ec      	bne.n	40c21a <itos+0x16>
		}
	}
	else *--temp_ptr = 0x30;
	return temp_ptr;
}
  40c240:	4630      	mov	r0, r6
  40c242:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	else *--temp_ptr = 0x30;
  40c244:	2330      	movs	r3, #48	; 0x30
  40c246:	f806 3f13 	strb.w	r3, [r6, #19]!
}
  40c24a:	4630      	mov	r0, r6
  40c24c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40c24e:	bf00      	nop
  40c250:	204056cc 	.word	0x204056cc
  40c254:	004190fd 	.word	0x004190fd

0040c258 <sitos>:

char *sitos(int64_t val)
{
  40c258:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40c25c:	4604      	mov	r4, r0

	char *temp_ptr=&temp[20], sign = 0;
	temp[20] = 0;
  40c25e:	2300      	movs	r3, #0
  40c260:	481d      	ldr	r0, [pc, #116]	; (40c2d8 <sitos+0x80>)
{
  40c262:	460d      	mov	r5, r1
	
	if(val < 0)
  40c264:	2c00      	cmp	r4, #0
	temp[20] = 0;
  40c266:	7503      	strb	r3, [r0, #20]
	if(val < 0)
  40c268:	f171 0200 	sbcs.w	r2, r1, #0
  40c26c:	db2a      	blt.n	40c2c4 <sitos+0x6c>
	{
		sign = 1;
		val = -val;
	}
	
	if(val > 0)
  40c26e:	ea54 0205 	orrs.w	r2, r4, r5
  40c272:	d022      	beq.n	40c2ba <sitos+0x62>
	char *temp_ptr=&temp[20], sign = 0;
  40c274:	4699      	mov	r9, r3
  40c276:	4e19      	ldr	r6, [pc, #100]	; (40c2dc <sitos+0x84>)
  40c278:	4f19      	ldr	r7, [pc, #100]	; (40c2e0 <sitos+0x88>)
  40c27a:	e000      	b.n	40c27e <sitos+0x26>
  40c27c:	4646      	mov	r6, r8
	{
		while(val)
		{
			*--temp_ptr = (val%10)|0x30;
  40c27e:	4620      	mov	r0, r4
  40c280:	4629      	mov	r1, r5
  40c282:	220a      	movs	r2, #10
  40c284:	2300      	movs	r3, #0
  40c286:	47b8      	blx	r7
  40c288:	f042 0e30 	orr.w	lr, r2, #48	; 0x30
			val/=10;
  40c28c:	4620      	mov	r0, r4
  40c28e:	4629      	mov	r1, r5
  40c290:	2300      	movs	r3, #0
  40c292:	220a      	movs	r2, #10
			*--temp_ptr = (val%10)|0x30;
  40c294:	f806 ec01 	strb.w	lr, [r6, #-1]
  40c298:	f106 38ff 	add.w	r8, r6, #4294967295
			val/=10;
  40c29c:	47b8      	blx	r7
  40c29e:	4604      	mov	r4, r0
  40c2a0:	460d      	mov	r5, r1
		while(val)
  40c2a2:	ea54 0305 	orrs.w	r3, r4, r5
  40c2a6:	d1e9      	bne.n	40c27c <sitos+0x24>
		}
	}
	else *--temp_ptr = 0x30;
	
	if (sign)
  40c2a8:	f1b9 0f00 	cmp.w	r9, #0
  40c2ac:	d010      	beq.n	40c2d0 <sitos+0x78>
	{
		*--temp_ptr = '-';
  40c2ae:	232d      	movs	r3, #45	; 0x2d
  40c2b0:	1eb0      	subs	r0, r6, #2
  40c2b2:	f808 3c01 	strb.w	r3, [r8, #-1]
  40c2b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	else *--temp_ptr = 0x30;
  40c2ba:	2330      	movs	r3, #48	; 0x30
  40c2bc:	f800 3f13 	strb.w	r3, [r0, #19]!
  40c2c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		val = -val;
  40c2c4:	4264      	negs	r4, r4
		sign = 1;
  40c2c6:	f04f 0901 	mov.w	r9, #1
		val = -val;
  40c2ca:	eb61 0541 	sbc.w	r5, r1, r1, lsl #1
  40c2ce:	e7d2      	b.n	40c276 <sitos+0x1e>
  40c2d0:	4640      	mov	r0, r8
	}
	
	return temp_ptr;
}
  40c2d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40c2d6:	bf00      	nop
  40c2d8:	204056cc 	.word	0x204056cc
  40c2dc:	204056e0 	.word	0x204056e0
  40c2e0:	0041905d 	.word	0x0041905d

0040c2e4 <glcd_clear>:
void glcd_clear(void)
{
    unsigned int i;
    for(i=0; i<1024; i++) temp_surface[i]=0;
  40c2e4:	2300      	movs	r3, #0
  40c2e6:	4804      	ldr	r0, [pc, #16]	; (40c2f8 <glcd_clear+0x14>)
  40c2e8:	4619      	mov	r1, r3
  40c2ea:	6802      	ldr	r2, [r0, #0]
  40c2ec:	54d1      	strb	r1, [r2, r3]
  40c2ee:	3301      	adds	r3, #1
  40c2f0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  40c2f4:	d1f9      	bne.n	40c2ea <glcd_clear+0x6>
}
  40c2f6:	4770      	bx	lr
  40c2f8:	2040034c 	.word	0x2040034c

0040c2fc <u_glcd_send_line>:
void u_glcd_send_line(uchar *dis_data, uchar page)
{
  40c2fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40c2fe:	4605      	mov	r5, r0
	uint32_t i;
	uchar tmp_data;
	
	SdCmd(0xb0 | page);	// select page 0~7
  40c300:	4f08      	ldr	r7, [pc, #32]	; (40c324 <u_glcd_send_line+0x28>)
  40c302:	f041 00b0 	orr.w	r0, r1, #176	; 0xb0
  40c306:	4e08      	ldr	r6, [pc, #32]	; (40c328 <u_glcd_send_line+0x2c>)
  40c308:	47b8      	blx	r7
	SdCmd(0x10);	    // start from column 0
  40c30a:	2010      	movs	r0, #16
  40c30c:	47b8      	blx	r7
	SdCmd(0x00);	    // (2byte command)
  40c30e:	2000      	movs	r0, #0
  40c310:	1e6c      	subs	r4, r5, #1
  40c312:	357f      	adds	r5, #127	; 0x7f
  40c314:	47b8      	blx	r7
	
	for (i=0; i<128; i++)
	{
		tmp_data = *(dis_data+i);
		SdData(tmp_data);
  40c316:	f814 0f01 	ldrb.w	r0, [r4, #1]!
  40c31a:	47b0      	blx	r6
	for (i=0; i<128; i++)
  40c31c:	42ac      	cmp	r4, r5
  40c31e:	d1fa      	bne.n	40c316 <u_glcd_send_line+0x1a>
	}
}
  40c320:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40c322:	bf00      	nop
  40c324:	0040d11d 	.word	0x0040d11d
  40c328:	0040d195 	.word	0x0040d195

0040c32c <u_glcd_screen_updater>:
	}
}

uchar lcd_page_counter = 0;
void u_glcd_screen_updater(void)
{
  40c32c:	b510      	push	{r4, lr}
	
	u_glcd_send_line(surface_print + (lcd_page_counter * 128), lcd_page_counter);
  40c32e:	4b08      	ldr	r3, [pc, #32]	; (40c350 <u_glcd_screen_updater+0x24>)
  40c330:	4c08      	ldr	r4, [pc, #32]	; (40c354 <u_glcd_screen_updater+0x28>)
  40c332:	6818      	ldr	r0, [r3, #0]
  40c334:	7821      	ldrb	r1, [r4, #0]
  40c336:	4b08      	ldr	r3, [pc, #32]	; (40c358 <u_glcd_screen_updater+0x2c>)
  40c338:	eb00 10c1 	add.w	r0, r0, r1, lsl #7
  40c33c:	4798      	blx	r3
	if(++lcd_page_counter >= 8) 
  40c33e:	7823      	ldrb	r3, [r4, #0]
  40c340:	3301      	adds	r3, #1
  40c342:	b2db      	uxtb	r3, r3
  40c344:	2b07      	cmp	r3, #7
	{
		lcd_page_counter = 0;
  40c346:	bf88      	it	hi
  40c348:	2300      	movhi	r3, #0
  40c34a:	7023      	strb	r3, [r4, #0]
  40c34c:	bd10      	pop	{r4, pc}
  40c34e:	bf00      	nop
  40c350:	20400348 	.word	0x20400348
  40c354:	20400904 	.word	0x20400904
  40c358:	0040c2fd 	.word	0x0040c2fd

0040c35c <lcd_update>:
	if (temp_surface == temp_surface1) 
  40c35c:	4b07      	ldr	r3, [pc, #28]	; (40c37c <lcd_update+0x20>)
  40c35e:	4a08      	ldr	r2, [pc, #32]	; (40c380 <lcd_update+0x24>)
  40c360:	6819      	ldr	r1, [r3, #0]
  40c362:	4291      	cmp	r1, r2
  40c364:	d004      	beq.n	40c370 <lcd_update+0x14>
		surface_print = temp_surface2;
  40c366:	4907      	ldr	r1, [pc, #28]	; (40c384 <lcd_update+0x28>)
  40c368:	4807      	ldr	r0, [pc, #28]	; (40c388 <lcd_update+0x2c>)
		temp_surface = temp_surface1;
  40c36a:	601a      	str	r2, [r3, #0]
		surface_print = temp_surface2;
  40c36c:	6008      	str	r0, [r1, #0]
  40c36e:	4770      	bx	lr
		surface_print = temp_surface1;
  40c370:	4804      	ldr	r0, [pc, #16]	; (40c384 <lcd_update+0x28>)
		temp_surface = temp_surface2;
  40c372:	4a05      	ldr	r2, [pc, #20]	; (40c388 <lcd_update+0x2c>)
		surface_print = temp_surface1;
  40c374:	6001      	str	r1, [r0, #0]
		temp_surface = temp_surface2;
  40c376:	601a      	str	r2, [r3, #0]
  40c378:	4770      	bx	lr
  40c37a:	bf00      	nop
  40c37c:	2040034c 	.word	0x2040034c
  40c380:	20405c04 	.word	0x20405c04
  40c384:	20400348 	.word	0x20400348
  40c388:	204056e4 	.word	0x204056e4

0040c38c <flip_v_line>:
void flip_line(char page,char x,char mask)
{
    temp_surface[(page * 128)+x]^=mask;
}
void flip_v_line(char y,char x,char length)
{
  40c38c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    char page,bits,msk,tmp;
    page=y>>3;
    bits=y&0x07;
  40c390:	f000 0e07 	and.w	lr, r0, #7
    

    msk=(0xFF << bits);//get mask
  40c394:	24ff      	movs	r4, #255	; 0xff
    page=y>>3;
  40c396:	08c0      	lsrs	r0, r0, #3
    if(length < (8-bits))
  40c398:	f1ce 0308 	rsb	r3, lr, #8
    msk=(0xFF << bits);//get mask
  40c39c:	fa04 f70e 	lsl.w	r7, r4, lr
    if(length < (8-bits))
  40c3a0:	429a      	cmp	r2, r3
    msk=(0xFF << bits);//get mask
  40c3a2:	b2ff      	uxtb	r7, r7
    if(length < (8-bits))
  40c3a4:	da14      	bge.n	40c3d0 <flip_v_line+0x44>
    {
        // short mask from below
        tmp = 0xFF >> (8 - bits - length );
  40c3a6:	1a9a      	subs	r2, r3, r2
    temp_surface[(page * 128)+x]^=mask;
  40c3a8:	4d26      	ldr	r5, [pc, #152]	; (40c444 <flip_v_line+0xb8>)
  40c3aa:	eb01 16c0 	add.w	r6, r1, r0, lsl #7
        length=0;
    }
    else length-=(8-bits);
        
    flip_line(page,x,msk);
    page++;
  40c3ae:	1c43      	adds	r3, r0, #1
        tmp = 0xFF >> (8 - bits - length );
  40c3b0:	fa44 f002 	asr.w	r0, r4, r2
    temp_surface[(page * 128)+x]^=mask;
  40c3b4:	682c      	ldr	r4, [r5, #0]
    page++;
  40c3b6:	2200      	movs	r2, #0
        msk&= tmp;
  40c3b8:	4038      	ands	r0, r7
    temp_surface[(page * 128)+x]^=mask;
  40c3ba:	5da7      	ldrb	r7, [r4, r6]
  40c3bc:	4078      	eors	r0, r7
  40c3be:	55a0      	strb	r0, [r4, r6]
  40c3c0:	eb01 11c3 	add.w	r1, r1, r3, lsl #7
  40c3c4:	682b      	ldr	r3, [r5, #0]
  40c3c6:	5c58      	ldrb	r0, [r3, r1]
  40c3c8:	4042      	eors	r2, r0
  40c3ca:	545a      	strb	r2, [r3, r1]
  40c3cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c3d0:	3a08      	subs	r2, #8
  40c3d2:	4d1c      	ldr	r5, [pc, #112]	; (40c444 <flip_v_line+0xb8>)
  40c3d4:	2680      	movs	r6, #128	; 0x80
    page++;
  40c3d6:	1c43      	adds	r3, r0, #1
    temp_surface[(page * 128)+x]^=mask;
  40c3d8:	f8d5 8000 	ldr.w	r8, [r5]
    else length-=(8-bits);
  40c3dc:	fa5e fe82 	uxtab	lr, lr, r2
    temp_surface[(page * 128)+x]^=mask;
  40c3e0:	fb16 1c00 	smlabb	ip, r6, r0, r1
    else length-=(8-bits);
  40c3e4:	fa5f fe8e 	uxtb.w	lr, lr
    temp_surface[(page * 128)+x]^=mask;
  40c3e8:	f818 200c 	ldrb.w	r2, [r8, ip]
    
    while(length>=8)
  40c3ec:	f1be 0f07 	cmp.w	lr, #7
    temp_surface[(page * 128)+x]^=mask;
  40c3f0:	ea87 0702 	eor.w	r7, r7, r2
  40c3f4:	f808 700c 	strb.w	r7, [r8, ip]
    while(length>=8)
  40c3f8:	d91e      	bls.n	40c438 <flip_v_line+0xac>
  40c3fa:	f1ae 0808 	sub.w	r8, lr, #8
  40c3fe:	f100 0c02 	add.w	ip, r0, #2
  40c402:	f3c8 08c4 	ubfx	r8, r8, #3, #5
  40c406:	eb08 070c 	add.w	r7, r8, ip
  40c40a:	b2ff      	uxtb	r7, r7
    temp_surface[(page * 128)+x]^=mask;
  40c40c:	fb16 1003 	smlabb	r0, r6, r3, r1
  40c410:	682c      	ldr	r4, [r5, #0]
    {
        flip_line(page,x,0xFF);
        length-=8;
        page++;            
  40c412:	3301      	adds	r3, #1
    temp_surface[(page * 128)+x]^=mask;
  40c414:	5c22      	ldrb	r2, [r4, r0]
        page++;            
  40c416:	b2db      	uxtb	r3, r3
    temp_surface[(page * 128)+x]^=mask;
  40c418:	43d2      	mvns	r2, r2
    while(length>=8)
  40c41a:	42bb      	cmp	r3, r7
    temp_surface[(page * 128)+x]^=mask;
  40c41c:	5422      	strb	r2, [r4, r0]
    while(length>=8)
  40c41e:	d1f5      	bne.n	40c40c <flip_v_line+0x80>
  40c420:	f00e 0e07 	and.w	lr, lr, #7
  40c424:	22ff      	movs	r2, #255	; 0xff
  40c426:	fa58 f38c 	uxtab	r3, r8, ip
  40c42a:	f1ce 0e08 	rsb	lr, lr, #8
  40c42e:	b2db      	uxtb	r3, r3
  40c430:	fa42 f20e 	asr.w	r2, r2, lr
  40c434:	b2d2      	uxtb	r2, r2
  40c436:	e7c3      	b.n	40c3c0 <flip_v_line+0x34>
  40c438:	f1ce 0208 	rsb	r2, lr, #8
  40c43c:	fa44 f202 	asr.w	r2, r4, r2
  40c440:	b2d2      	uxtb	r2, r2
  40c442:	e7bd      	b.n	40c3c0 <flip_v_line+0x34>
  40c444:	2040034c 	.word	0x2040034c

0040c448 <glcd_write_Tbyte>:

void glcd_write_Tbyte(uchar data)
{
    uchar page,bits;
    uchar * data1,*data2;
    page=(d_y >> 3);
  40c448:	4a13      	ldr	r2, [pc, #76]	; (40c498 <glcd_write_Tbyte+0x50>)
    bits=d_y & 0x07;
    
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c44a:	4b14      	ldr	r3, [pc, #80]	; (40c49c <glcd_write_Tbyte+0x54>)
{
  40c44c:	b5f0      	push	{r4, r5, r6, r7, lr}
    page=(d_y >> 3);
  40c44e:	7811      	ldrb	r1, [r2, #0]
    data2=&temp_surface[(page + 1) * 128 + d_x]; // last partial byte
    
    *data1 &=(0xff >> (8-bits));
  40c450:	25ff      	movs	r5, #255	; 0xff
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c452:	f893 e000 	ldrb.w	lr, [r3]
  40c456:	08cb      	lsrs	r3, r1, #3
  40c458:	4a11      	ldr	r2, [pc, #68]	; (40c4a0 <glcd_write_Tbyte+0x58>)
    *data1 &=(0xff >> (8-bits));
  40c45a:	f001 0107 	and.w	r1, r1, #7
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c45e:	01db      	lsls	r3, r3, #7
  40c460:	6812      	ldr	r2, [r2, #0]
    *data1 &=(0xff >> (8-bits));
  40c462:	f1c1 0c08 	rsb	ip, r1, #8
    *data2 &=(0xff << bits);
  40c466:	fa05 f601 	lsl.w	r6, r5, r1
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c46a:	eb03 040e 	add.w	r4, r3, lr
    data2=&temp_surface[(page + 1) * 128 + d_x]; // last partial byte
  40c46e:	3380      	adds	r3, #128	; 0x80
    *data1 &=(0xff >> (8-bits));
  40c470:	fa45 f50c 	asr.w	r5, r5, ip
    *data1 |=(data << bits);
  40c474:	fa00 f101 	lsl.w	r1, r0, r1
    *data1 &=(0xff >> (8-bits));
  40c478:	5d17      	ldrb	r7, [r2, r4]
    data2=&temp_surface[(page + 1) * 128 + d_x]; // last partial byte
  40c47a:	4473      	add	r3, lr
    *data2 |=(data >> (8-bits));
  40c47c:	fa40 f00c 	asr.w	r0, r0, ip
    *data1 &=(0xff >> (8-bits));
  40c480:	403d      	ands	r5, r7
  40c482:	5515      	strb	r5, [r2, r4]
    *data2 &=(0xff << bits);
  40c484:	5cd5      	ldrb	r5, [r2, r3]
  40c486:	4035      	ands	r5, r6
  40c488:	54d5      	strb	r5, [r2, r3]
    *data1 |=(data << bits);
  40c48a:	5d15      	ldrb	r5, [r2, r4]
  40c48c:	4329      	orrs	r1, r5
  40c48e:	5511      	strb	r1, [r2, r4]
    *data2 |=(data >> (8-bits));
  40c490:	5cd1      	ldrb	r1, [r2, r3]
  40c492:	4308      	orrs	r0, r1
  40c494:	54d0      	strb	r0, [r2, r3]
  40c496:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40c498:	20400c61 	.word	0x20400c61
  40c49c:	20400c60 	.word	0x20400c60
  40c4a0:	2040034c 	.word	0x2040034c

0040c4a4 <out_image>:
        d_x=0;
   }
}
//------------------------
void out_image(uchar x, uchar y, const char *DisplayData)    // DisplayData should be 164x64/8 = 1312byte
{
  40c4a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40c4a8:	4688      	mov	r8, r1
    uint width,height;
    

    width=*DisplayData + ((*(DisplayData+1))<<8);
    DisplayData+=2;
    height=*DisplayData + ((*(DisplayData+1))<<8);
  40c4aa:	f892 a002 	ldrb.w	sl, [r2, #2]
  40c4ae:	78d1      	ldrb	r1, [r2, #3]
{
  40c4b0:	b083      	sub	sp, #12
    width=*DisplayData + ((*(DisplayData+1))<<8);
  40c4b2:	7853      	ldrb	r3, [r2, #1]
    height=*DisplayData + ((*(DisplayData+1))<<8);
  40c4b4:	eb0a 2a01 	add.w	sl, sl, r1, lsl #8
    width=*DisplayData + ((*(DisplayData+1))<<8);
  40c4b8:	7815      	ldrb	r5, [r2, #0]
{
  40c4ba:	9001      	str	r0, [sp, #4]
    if(height&0x0007) height+=8;
    height=height>>3;
    
    DisplayData+=2;
  40c4bc:	1d10      	adds	r0, r2, #4
    if(height&0x0007) height+=8;
  40c4be:	f01a 0f07 	tst.w	sl, #7
    width=*DisplayData + ((*(DisplayData+1))<<8);
  40c4c2:	eb05 2503 	add.w	r5, r5, r3, lsl #8
    if(height&0x0007) height+=8;
  40c4c6:	bf18      	it	ne
  40c4c8:	f10a 0a08 	addne.w	sl, sl, #8

	for(i=0;i<height;i++)
  40c4cc:	ea5f 03da 	movs.w	r3, sl, lsr #3
  40c4d0:	9300      	str	r3, [sp, #0]
  40c4d2:	d02b      	beq.n	40c52c <out_image+0x88>
  40c4d4:	2700      	movs	r7, #0
  40c4d6:	f8df b064 	ldr.w	fp, [pc, #100]	; 40c53c <out_image+0x98>
  40c4da:	4e16      	ldr	r6, [pc, #88]	; (40c534 <out_image+0x90>)
        d_x=0;
  40c4dc:	46b9      	mov	r9, r7
	    {
    	d_y=(8 * i)+y;	// select page 0~7
  40c4de:	4b16      	ldr	r3, [pc, #88]	; (40c538 <out_image+0x94>)
  40c4e0:	f883 8000 	strb.w	r8, [r3]
    	d_x=x;
  40c4e4:	f89d 3004 	ldrb.w	r3, [sp, #4]
  40c4e8:	f88b 3000 	strb.w	r3, [fp]
     	for(j=0;(j< width );j++)
  40c4ec:	b1ad      	cbz	r5, 40c51a <out_image+0x76>
  40c4ee:	4604      	mov	r4, r0
  40c4f0:	4682      	mov	sl, r0
   glcd_write_Tbyte(b);
  40c4f2:	f81a 0b01 	ldrb.w	r0, [sl], #1
  40c4f6:	47b0      	blx	r6
   if(++d_x > 127)
  40c4f8:	f89b 3000 	ldrb.w	r3, [fp]
     		{
     		TempData=*DisplayData;
     		glcd_write(TempData);
            DisplayData++;
  40c4fc:	4650      	mov	r0, sl
   if(++d_x > 127)
  40c4fe:	3301      	adds	r3, #1
  40c500:	b2db      	uxtb	r3, r3
  40c502:	061a      	lsls	r2, r3, #24
  40c504:	bf58      	it	pl
  40c506:	f88b 3000 	strbpl.w	r3, [fp]
     	for(j=0;(j< width );j++)
  40c50a:	ebaa 0304 	sub.w	r3, sl, r4
        d_x=0;
  40c50e:	bf48      	it	mi
  40c510:	f88b 9000 	strbmi.w	r9, [fp]
     	for(j=0;(j< width );j++)
  40c514:	b2db      	uxtb	r3, r3
  40c516:	429d      	cmp	r5, r3
  40c518:	d8eb      	bhi.n	40c4f2 <out_image+0x4e>
	for(i=0;i<height;i++)
  40c51a:	3701      	adds	r7, #1
  40c51c:	9b00      	ldr	r3, [sp, #0]
  40c51e:	f108 0808 	add.w	r8, r8, #8
  40c522:	b2ff      	uxtb	r7, r7
  40c524:	fa5f f888 	uxtb.w	r8, r8
  40c528:	42bb      	cmp	r3, r7
  40c52a:	d8d8      	bhi.n	40c4de <out_image+0x3a>
 		    }
        }
}
  40c52c:	b003      	add	sp, #12
  40c52e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40c532:	bf00      	nop
  40c534:	0040c449 	.word	0x0040c449
  40c538:	20400c61 	.word	0x20400c61
  40c53c:	20400c60 	.word	0x20400c60

0040c540 <d_line>:
void d_line(uchar x1,uchar x2,uchar y1, uchar y2)
{
    float m,res;
    float x;
    
    if(x1==x2)
  40c540:	4288      	cmp	r0, r1
{
  40c542:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c546:	b082      	sub	sp, #8
    if(x1==x2)
  40c548:	d04a      	beq.n	40c5e0 <d_line+0xa0>
  40c54a:	4288      	cmp	r0, r1
    {
        x=x1;
        x1=x2;
        x2=x1;
    }    
    res=(y2-y1);
  40c54c:	eba3 0302 	sub.w	r3, r3, r2
    x=(x2-x1);
    
    m=res / x;
    x=0;

        d_x=x1;
  40c550:	4d41      	ldr	r5, [pc, #260]	; (40c658 <d_line+0x118>)
  40c552:	bf28      	it	cs
  40c554:	4608      	movcs	r0, r1
    res=(y2-y1);
  40c556:	ee07 3a90 	vmov	s15, r3
    x=(x2-x1);
  40c55a:	1a0c      	subs	r4, r1, r0
    res=(y2-y1);
  40c55c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        while(d_x<=x2)
  40c560:	4281      	cmp	r1, r0
        d_x=x1;
  40c562:	7028      	strb	r0, [r5, #0]
    x=(x2-x1);
  40c564:	ee07 4a10 	vmov	s14, r4
  40c568:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    m=res / x;
  40c56c:	ee87 6a87 	vdiv.f32	s12, s15, s14
        while(d_x<=x2)
  40c570:	d333      	bcc.n	40c5da <d_line+0x9a>
  40c572:	ee07 2a90 	vmov	s15, r2
  40c576:	ed9f 7a39 	vldr	s14, [pc, #228]	; 40c65c <d_line+0x11c>
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c57a:	f04f 0c80 	mov.w	ip, #128	; 0x80
  40c57e:	4e38      	ldr	r6, [pc, #224]	; (40c660 <d_line+0x120>)
    *data1 |=1 << bits;    
  40c580:	f04f 0e01 	mov.w	lr, #1
  40c584:	4f37      	ldr	r7, [pc, #220]	; (40c664 <d_line+0x124>)
  40c586:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            if(++d_x > 127)
            {
                d_x=0;
                return;
            }
            x+=1;
  40c58a:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
  40c58e:	e001      	b.n	40c594 <d_line+0x54>
        while(d_x<=x2)
  40c590:	4281      	cmp	r1, r0
  40c592:	d322      	bcc.n	40c5da <d_line+0x9a>
            d_y = (x * m) + y1;
  40c594:	eef0 6a67 	vmov.f32	s13, s15
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c598:	f8d7 8000 	ldr.w	r8, [r7]
            d_y = (x * m) + y1;
  40c59c:	eee6 6a07 	vfma.f32	s13, s12, s14
            x+=1;
  40c5a0:	ee37 7a25 	vadd.f32	s14, s14, s11
            d_y = (x * m) + y1;
  40c5a4:	eefc 6ae6 	vcvt.u32.f32	s13, s13
  40c5a8:	edcd 6a01 	vstr	s13, [sp, #4]
  40c5ac:	f89d 2004 	ldrb.w	r2, [sp, #4]
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c5b0:	08d4      	lsrs	r4, r2, #3
    *data1 |=1 << bits;    
  40c5b2:	f002 0307 	and.w	r3, r2, #7
            d_y = (x * m) + y1;
  40c5b6:	7032      	strb	r2, [r6, #0]
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c5b8:	fb1c 0004 	smlabb	r0, ip, r4, r0
    *data1 |=1 << bits;    
  40c5bc:	fa0e f303 	lsl.w	r3, lr, r3
  40c5c0:	f818 2000 	ldrb.w	r2, [r8, r0]
  40c5c4:	4313      	orrs	r3, r2
  40c5c6:	f808 3000 	strb.w	r3, [r8, r0]
            if(++d_x > 127)
  40c5ca:	7828      	ldrb	r0, [r5, #0]
  40c5cc:	3001      	adds	r0, #1
  40c5ce:	b2c0      	uxtb	r0, r0
  40c5d0:	0603      	lsls	r3, r0, #24
  40c5d2:	7028      	strb	r0, [r5, #0]
  40c5d4:	d5dc      	bpl.n	40c590 <d_line+0x50>
                d_x=0;
  40c5d6:	2300      	movs	r3, #0
  40c5d8:	702b      	strb	r3, [r5, #0]
        }

}
  40c5da:	b002      	add	sp, #8
  40c5dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        d_x=x1;
  40c5e0:	4d1d      	ldr	r5, [pc, #116]	; (40c658 <d_line+0x118>)
        if(y2>=y1)
  40c5e2:	429a      	cmp	r2, r3
        d_y=y1;
  40c5e4:	4e1e      	ldr	r6, [pc, #120]	; (40c660 <d_line+0x120>)
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c5e6:	f04f 0e80 	mov.w	lr, #128	; 0x80
        d_x=x1;
  40c5ea:	7029      	strb	r1, [r5, #0]
    *data1 |=1 << bits;    
  40c5ec:	f04f 0401 	mov.w	r4, #1
        d_y=y1;
  40c5f0:	7032      	strb	r2, [r6, #0]
  40c5f2:	4f1c      	ldr	r7, [pc, #112]	; (40c664 <d_line+0x124>)
        if(y2>=y1)
  40c5f4:	d819      	bhi.n	40c62a <d_line+0xea>
  40c5f6:	e000      	b.n	40c5fa <d_line+0xba>
  40c5f8:	7829      	ldrb	r1, [r5, #0]
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c5fa:	08d0      	lsrs	r0, r2, #3
  40c5fc:	f8d7 c000 	ldr.w	ip, [r7]
    *data1 |=1 << bits;    
  40c600:	f002 0207 	and.w	r2, r2, #7
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c604:	fb1e 1100 	smlabb	r1, lr, r0, r1
    *data1 |=1 << bits;    
  40c608:	fa04 f202 	lsl.w	r2, r4, r2
  40c60c:	f81c 0001 	ldrb.w	r0, [ip, r1]
  40c610:	4302      	orrs	r2, r0
  40c612:	f80c 2001 	strb.w	r2, [ip, r1]
                d_y++;
  40c616:	7832      	ldrb	r2, [r6, #0]
  40c618:	3201      	adds	r2, #1
  40c61a:	b2d2      	uxtb	r2, r2
            while(d_y<=y2)
  40c61c:	4293      	cmp	r3, r2
                d_y++;
  40c61e:	7032      	strb	r2, [r6, #0]
            while(d_y<=y2)
  40c620:	d2ea      	bcs.n	40c5f8 <d_line+0xb8>
}
  40c622:	b002      	add	sp, #8
  40c624:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c628:	7829      	ldrb	r1, [r5, #0]
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c62a:	08d0      	lsrs	r0, r2, #3
  40c62c:	f8d7 c000 	ldr.w	ip, [r7]
    *data1 |=1 << bits;    
  40c630:	f002 0207 	and.w	r2, r2, #7
    data1=&temp_surface[page * 128 + d_x]; //first partial byte
  40c634:	fb1e 1100 	smlabb	r1, lr, r0, r1
    *data1 |=1 << bits;    
  40c638:	fa04 f202 	lsl.w	r2, r4, r2
  40c63c:	f81c 0001 	ldrb.w	r0, [ip, r1]
  40c640:	4302      	orrs	r2, r0
  40c642:	f80c 2001 	strb.w	r2, [ip, r1]
                d_y--;
  40c646:	7832      	ldrb	r2, [r6, #0]
  40c648:	3a01      	subs	r2, #1
  40c64a:	b2d2      	uxtb	r2, r2
            while(d_y>=y2)
  40c64c:	4293      	cmp	r3, r2
                d_y--;
  40c64e:	7032      	strb	r2, [r6, #0]
            while(d_y>=y2)
  40c650:	d9ea      	bls.n	40c628 <d_line+0xe8>
}
  40c652:	b002      	add	sp, #8
  40c654:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c658:	20400c60 	.word	0x20400c60
  40c65c:	00000000 	.word	0x00000000
  40c660:	20400c61 	.word	0x20400c61
  40c664:	2040034c 	.word	0x2040034c

0040c668 <flip_rect>:

//---------------------------

void flip_rect(struct rect rec)
{
  40c668:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c66c:	b2c4      	uxtb	r4, r0
    char i;
    for(i=rec.x;i<rec.x+rec.width;i++) flip_v_line(rec.y,i,rec.length);
  40c66e:	f3c0 4507 	ubfx	r5, r0, #16, #8
{
  40c672:	b082      	sub	sp, #8
    for(i=rec.x;i<rec.x+rec.width;i++) flip_v_line(rec.y,i,rec.length);
  40c674:	4425      	add	r5, r4
{
  40c676:	9001      	str	r0, [sp, #4]
    for(i=rec.x;i<rec.x+rec.width;i++) flip_v_line(rec.y,i,rec.length);
  40c678:	42ac      	cmp	r4, r5
  40c67a:	da0c      	bge.n	40c696 <flip_rect+0x2e>
  40c67c:	f89d 8005 	ldrb.w	r8, [sp, #5]
  40c680:	f89d 7007 	ldrb.w	r7, [sp, #7]
  40c684:	4e05      	ldr	r6, [pc, #20]	; (40c69c <flip_rect+0x34>)
  40c686:	4621      	mov	r1, r4
  40c688:	3401      	adds	r4, #1
  40c68a:	463a      	mov	r2, r7
  40c68c:	4640      	mov	r0, r8
  40c68e:	b2e4      	uxtb	r4, r4
  40c690:	47b0      	blx	r6
  40c692:	42ac      	cmp	r4, r5
  40c694:	dbf7      	blt.n	40c686 <flip_rect+0x1e>
}
  40c696:	b002      	add	sp, #8
  40c698:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c69c:	0040c38d 	.word	0x0040c38d

0040c6a0 <draw_rect>:

void draw_rect(struct rect rec)
{
  40c6a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c6a4:	b2c7      	uxtb	r7, r0
    d_line(rec.x , rec.x+rec.width-1 , rec.y , rec.y);
  40c6a6:	f3c0 4507 	ubfx	r5, r0, #16, #8
  40c6aa:	f3c0 2607 	ubfx	r6, r0, #8, #8
  40c6ae:	0e04      	lsrs	r4, r0, #24
  40c6b0:	443d      	add	r5, r7
{
  40c6b2:	b082      	sub	sp, #8
    d_line(rec.x,rec.x, rec.y , rec.y+rec.length-1);
  40c6b4:	4434      	add	r4, r6
    d_line(rec.x , rec.x+rec.width-1 , rec.y , rec.y);
  40c6b6:	f8df 803c 	ldr.w	r8, [pc, #60]	; 40c6f4 <draw_rect+0x54>
  40c6ba:	3d01      	subs	r5, #1
{
  40c6bc:	9001      	str	r0, [sp, #4]
    d_line(rec.x,rec.x, rec.y , rec.y+rec.length-1);
  40c6be:	3c01      	subs	r4, #1
    d_line(rec.x , rec.x+rec.width-1 , rec.y , rec.y);
  40c6c0:	4633      	mov	r3, r6
  40c6c2:	b2ed      	uxtb	r5, r5
  40c6c4:	4638      	mov	r0, r7
    d_line(rec.x,rec.x, rec.y , rec.y+rec.length-1);
  40c6c6:	b2e4      	uxtb	r4, r4
    d_line(rec.x , rec.x+rec.width-1 , rec.y , rec.y);
  40c6c8:	4632      	mov	r2, r6
  40c6ca:	4629      	mov	r1, r5
  40c6cc:	47c0      	blx	r8
    d_line(rec.x,rec.x, rec.y , rec.y+rec.length-1);
  40c6ce:	4632      	mov	r2, r6
  40c6d0:	4639      	mov	r1, r7
  40c6d2:	4638      	mov	r0, r7
  40c6d4:	4623      	mov	r3, r4
  40c6d6:	47c0      	blx	r8
    d_line(rec.x , rec.x+rec.width-1 , rec.y+rec.length-1 , rec.y+rec.length-1);
  40c6d8:	4623      	mov	r3, r4
  40c6da:	4622      	mov	r2, r4
  40c6dc:	4629      	mov	r1, r5
  40c6de:	4638      	mov	r0, r7
  40c6e0:	47c0      	blx	r8
    d_line(rec.x+rec.width-1 , rec.x+rec.width-1 ,rec.y , rec.y+rec.length-1);
  40c6e2:	4623      	mov	r3, r4
  40c6e4:	4632      	mov	r2, r6
  40c6e6:	4629      	mov	r1, r5
  40c6e8:	4628      	mov	r0, r5
  40c6ea:	46c4      	mov	ip, r8
}
  40c6ec:	b002      	add	sp, #8
  40c6ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    d_line(rec.x+rec.width-1 , rec.x+rec.width-1 ,rec.y , rec.y+rec.length-1);
  40c6f2:	4760      	bx	ip
  40c6f4:	0040c541 	.word	0x0040c541

0040c6f8 <out_char>:
{
  uByte_t i;
  char length,uline=0;
  if(u) uline=0x80;

  length=font[9*c];
  40c6f8:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
  40c6fc:	4b12      	ldr	r3, [pc, #72]	; (40c748 <out_char+0x50>)
  char length,uline=0;
  40c6fe:	2900      	cmp	r1, #0
{
  40c700:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  length=font[9*c];
  40c704:	5c1f      	ldrb	r7, [r3, r0]
  char length,uline=0;
  40c706:	bf14      	ite	ne
  40c708:	2580      	movne	r5, #128	; 0x80
  40c70a:	2500      	moveq	r5, #0
  for(i=1;i<=length;i++)
  40c70c:	b1cf      	cbz	r7, 40c742 <out_char+0x4a>
  40c70e:	3001      	adds	r0, #1
  40c710:	4e0e      	ldr	r6, [pc, #56]	; (40c74c <out_char+0x54>)
  40c712:	f8df a03c 	ldr.w	sl, [pc, #60]	; 40c750 <out_char+0x58>
        d_x=0;
  40c716:	f04f 0800 	mov.w	r8, #0
  40c71a:	19c4      	adds	r4, r0, r7
  40c71c:	eb00 0903 	add.w	r9, r0, r3
  40c720:	441c      	add	r4, r3
  {
     glcd_write(font[(9*c)+i] | uline);
  40c722:	f819 0b01 	ldrb.w	r0, [r9], #1
   glcd_write_Tbyte(b);
  40c726:	4328      	orrs	r0, r5
  40c728:	47b0      	blx	r6
   if(++d_x > 127)
  40c72a:	f89a 3000 	ldrb.w	r3, [sl]
  40c72e:	3301      	adds	r3, #1
  40c730:	b2db      	uxtb	r3, r3
  40c732:	061a      	lsls	r2, r3, #24
  40c734:	bf54      	ite	pl
  40c736:	f88a 3000 	strbpl.w	r3, [sl]
        d_x=0;
  40c73a:	f88a 8000 	strbmi.w	r8, [sl]
  for(i=1;i<=length;i++)
  40c73e:	45a1      	cmp	r9, r4
  40c740:	d1ef      	bne.n	40c722 <out_char+0x2a>
  }
  return length;
}
  40c742:	4638      	mov	r0, r7
  40c744:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40c748:	0041bb8c 	.word	0x0041bb8c
  40c74c:	0040c449 	.word	0x0040c449
  40c750:	20400c60 	.word	0x20400c60

0040c754 <putIt>:
char putIt(unsigned char c)
{
  40c754:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  byte i;
  char length;
  length=font[9*c];
  40c758:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
  40c75c:	4b0e      	ldr	r3, [pc, #56]	; (40c798 <putIt+0x44>)
  40c75e:	5c1e      	ldrb	r6, [r3, r0]
  for(i=1;i<=length;i++)
  40c760:	b1be      	cbz	r6, 40c792 <putIt+0x3e>
  40c762:	3001      	adds	r0, #1
  40c764:	4d0d      	ldr	r5, [pc, #52]	; (40c79c <putIt+0x48>)
  40c766:	f8df 9038 	ldr.w	r9, [pc, #56]	; 40c7a0 <putIt+0x4c>
        d_x=0;
  40c76a:	2700      	movs	r7, #0
  40c76c:	eb06 0800 	add.w	r8, r6, r0
  40c770:	18c4      	adds	r4, r0, r3
  40c772:	4498      	add	r8, r3
   glcd_write_Tbyte(b);
  40c774:	f814 0b01 	ldrb.w	r0, [r4], #1
  40c778:	47a8      	blx	r5
   if(++d_x > 127)
  40c77a:	f899 3000 	ldrb.w	r3, [r9]
  40c77e:	3301      	adds	r3, #1
  40c780:	b2db      	uxtb	r3, r3
  40c782:	061a      	lsls	r2, r3, #24
  40c784:	bf54      	ite	pl
  40c786:	f889 3000 	strbpl.w	r3, [r9]
        d_x=0;
  40c78a:	f889 7000 	strbmi.w	r7, [r9]
  for(i=1;i<=length;i++)
  40c78e:	4544      	cmp	r4, r8
  40c790:	d1f0      	bne.n	40c774 <putIt+0x20>
  {
     glcd_write(font[(9*c)+i]);
  }
  return length;
}
  40c792:	4630      	mov	r0, r6
  40c794:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40c798:	0041bb8c 	.word	0x0041bb8c
  40c79c:	0040c449 	.word	0x0040c449
  40c7a0:	20400c60 	.word	0x20400c60

0040c7a4 <glcd_gotoxy>:
{
  return font[9*c];
}
void glcd_gotoxy(char x,char y)
{
    d_x=x; d_y=y;
  40c7a4:	4a02      	ldr	r2, [pc, #8]	; (40c7b0 <glcd_gotoxy+0xc>)
  40c7a6:	4b03      	ldr	r3, [pc, #12]	; (40c7b4 <glcd_gotoxy+0x10>)
  40c7a8:	7010      	strb	r0, [r2, #0]
  40c7aa:	7019      	strb	r1, [r3, #0]
  40c7ac:	4770      	bx	lr
  40c7ae:	bf00      	nop
  40c7b0:	20400c60 	.word	0x20400c60
  40c7b4:	20400c61 	.word	0x20400c61

0040c7b8 <glcd_putsf>:
        }
    }  
}

void glcd_putsf(const char *c,unsigned char l)
{
  40c7b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40c7bc:	4605      	mov	r5, r0
    char special = 0;
    char initial=0;
    char _c_width;
    unsigned char temp_char=0;
    char connection=0; // flags if the charcter connected in the front and rear 
    if(l) // arabic detected
  40c7be:	b9f9      	cbnz	r1, 40c800 <glcd_putsf+0x48>
            initial=1;
        }           
    }
    else // normal english
    {
        while(*c)
  40c7c0:	7800      	ldrb	r0, [r0, #0]
  40c7c2:	2800      	cmp	r0, #0
  40c7c4:	f000 8110 	beq.w	40c9e8 <glcd_putsf+0x230>
        {
            temp_char = *c;
            _c_width=get_font_width(temp_char);//get the width of char
            if((128-d_x)<_c_width) 
            {
                d_x=0;
  40c7c8:	4689      	mov	r9, r1
  40c7ca:	4c89      	ldr	r4, [pc, #548]	; (40c9f0 <glcd_putsf+0x238>)
  40c7cc:	4f89      	ldr	r7, [pc, #548]	; (40c9f4 <glcd_putsf+0x23c>)
  40c7ce:	4e8a      	ldr	r6, [pc, #552]	; (40c9f8 <glcd_putsf+0x240>)
                d_y+=8;
  40c7d0:	f8df 8228 	ldr.w	r8, [pc, #552]	; 40c9fc <glcd_putsf+0x244>
            if((128-d_x)<_c_width) 
  40c7d4:	7823      	ldrb	r3, [r4, #0]
  return font[9*c];
  40c7d6:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
            if((128-d_x)<_c_width) 
  40c7da:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
  40c7de:	5cba      	ldrb	r2, [r7, r2]
  40c7e0:	4293      	cmp	r3, r2
  40c7e2:	da06      	bge.n	40c7f2 <glcd_putsf+0x3a>
                d_y+=8;
  40c7e4:	f898 3000 	ldrb.w	r3, [r8]
                d_x=0;
  40c7e8:	f884 9000 	strb.w	r9, [r4]
                d_y+=8;
  40c7ec:	3308      	adds	r3, #8
  40c7ee:	f888 3000 	strb.w	r3, [r8]
            }
            putIt(temp_char);
  40c7f2:	47b0      	blx	r6
        while(*c)
  40c7f4:	f815 0f01 	ldrb.w	r0, [r5, #1]!
  40c7f8:	2800      	cmp	r0, #0
  40c7fa:	d1eb      	bne.n	40c7d4 <glcd_putsf+0x1c>
  40c7fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while(*c)
  40c800:	7802      	ldrb	r2, [r0, #0]
  40c802:	2a00      	cmp	r2, #0
  40c804:	d0fa      	beq.n	40c7fc <glcd_putsf+0x44>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c806:	f890 e001 	ldrb.w	lr, [r0, #1]
  40c80a:	f8df a1f4 	ldr.w	sl, [pc, #500]	; 40ca00 <glcd_putsf+0x248>
  40c80e:	f1ae 03c1 	sub.w	r3, lr, #193	; 0xc1
  40c812:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  40c816:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
  40c81a:	691b      	ldr	r3, [r3, #16]
  40c81c:	b1ab      	cbz	r3, 40c84a <glcd_putsf+0x92>
  40c81e:	f1a2 01c1 	sub.w	r1, r2, #193	; 0xc1
  40c822:	4c73      	ldr	r4, [pc, #460]	; (40c9f0 <glcd_putsf+0x238>)
  40c824:	f04f 0c00 	mov.w	ip, #0
  40c828:	4f72      	ldr	r7, [pc, #456]	; (40c9f4 <glcd_putsf+0x23c>)
  40c82a:	ea4f 0b41 	mov.w	fp, r1, lsl #1
  40c82e:	7823      	ldrb	r3, [r4, #0]
  40c830:	46e1      	mov	r9, ip
  40c832:	4e71      	ldr	r6, [pc, #452]	; (40c9f8 <glcd_putsf+0x240>)
  40c834:	eb0b 0001 	add.w	r0, fp, r1
  40c838:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
  40c83c:	6940      	ldr	r0, [r0, #20]
  40c83e:	2800      	cmp	r0, #0
  40c840:	d146      	bne.n	40c8d0 <glcd_putsf+0x118>
            if(*c >= 193)
  40c842:	2ac0      	cmp	r2, #192	; 0xc0
  40c844:	d84b      	bhi.n	40c8de <glcd_putsf+0x126>
  40c846:	4691      	mov	r9, r2
  40c848:	e006      	b.n	40c858 <glcd_putsf+0xa0>
  40c84a:	2ac0      	cmp	r2, #192	; 0xc0
  40c84c:	d857      	bhi.n	40c8fe <glcd_putsf+0x146>
  40c84e:	4c68      	ldr	r4, [pc, #416]	; (40c9f0 <glcd_putsf+0x238>)
  40c850:	4691      	mov	r9, r2
  40c852:	4f68      	ldr	r7, [pc, #416]	; (40c9f4 <glcd_putsf+0x23c>)
  40c854:	7823      	ldrb	r3, [r4, #0]
  40c856:	4e68      	ldr	r6, [pc, #416]	; (40c9f8 <glcd_putsf+0x240>)
                d_y++;
  40c858:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 40c9fc <glcd_putsf+0x244>
  return font[9*c];
  40c85c:	fa0f f289 	sxth.w	r2, r9
  40c860:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
  40c864:	f817 b002 	ldrb.w	fp, [r7, r2]
            if(d_x>=_c_width) d_x-=_c_width;
  40c868:	459b      	cmp	fp, r3
  40c86a:	d83f      	bhi.n	40c8ec <glcd_putsf+0x134>
  40c86c:	eba3 030b 	sub.w	r3, r3, fp
  40c870:	7023      	strb	r3, [r4, #0]
            putIt(temp_char);
  40c872:	4648      	mov	r0, r9
  40c874:	47b0      	blx	r6
            d_x-=_c_width;
  40c876:	7823      	ldrb	r3, [r4, #0]
            (c++);
  40c878:	1c68      	adds	r0, r5, #1
            d_x-=_c_width;
  40c87a:	eba3 030b 	sub.w	r3, r3, fp
  40c87e:	b2db      	uxtb	r3, r3
  40c880:	7023      	strb	r3, [r4, #0]
        while(*c)
  40c882:	786a      	ldrb	r2, [r5, #1]
  40c884:	2a00      	cmp	r2, #0
  40c886:	f000 80a0 	beq.w	40c9ca <glcd_putsf+0x212>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40c88a:	f810 ec01 	ldrb.w	lr, [r0, #-1]
  40c88e:	f1ae 01c1 	sub.w	r1, lr, #193	; 0xc1
  40c892:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  40c896:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
  40c89a:	f8d1 c014 	ldr.w	ip, [r1, #20]
  40c89e:	f1bc 0f00 	cmp.w	ip, #0
  40c8a2:	d140      	bne.n	40c926 <glcd_putsf+0x16e>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c8a4:	f890 e001 	ldrb.w	lr, [r0, #1]
  40c8a8:	f1ae 01c1 	sub.w	r1, lr, #193	; 0xc1
  40c8ac:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  40c8b0:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
  40c8b4:	6909      	ldr	r1, [r1, #16]
  40c8b6:	b379      	cbz	r1, 40c918 <glcd_putsf+0x160>
  40c8b8:	f1a2 01c1 	sub.w	r1, r2, #193	; 0xc1
            (c++);
  40c8bc:	4605      	mov	r5, r0
  40c8be:	ea4f 0b41 	mov.w	fp, r1, lsl #1
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c8c2:	eb0b 0001 	add.w	r0, fp, r1
  40c8c6:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
  40c8ca:	6940      	ldr	r0, [r0, #20]
  40c8cc:	2800      	cmp	r0, #0
  40c8ce:	d0b8      	beq.n	40c842 <glcd_putsf+0x8a>
  40c8d0:	2ac0      	cmp	r2, #192	; 0xc0
  40c8d2:	d9b8      	bls.n	40c846 <glcd_putsf+0x8e>
  40c8d4:	f1be 0fc0 	cmp.w	lr, #192	; 0xc0
  40c8d8:	d901      	bls.n	40c8de <glcd_putsf+0x126>
                    connection |= 2;
  40c8da:	f04c 0c02 	orr.w	ip, ip, #2
                switch(connection)
  40c8de:	f1bc 0f03 	cmp.w	ip, #3
  40c8e2:	d8b9      	bhi.n	40c858 <glcd_putsf+0xa0>
  40c8e4:	e8df f00c 	tbb	[pc, ip]
  40c8e8:	656b5082 	.word	0x656b5082
                d_y++;
  40c8ec:	f898 3000 	ldrb.w	r3, [r8]
                d_x=128-_c_width;
  40c8f0:	f1cb 0280 	rsb	r2, fp, #128	; 0x80
                d_y++;
  40c8f4:	3301      	adds	r3, #1
                d_x=128-_c_width;
  40c8f6:	7022      	strb	r2, [r4, #0]
                d_y++;
  40c8f8:	f888 3000 	strb.w	r3, [r8]
  40c8fc:	e7b9      	b.n	40c872 <glcd_putsf+0xba>
  40c8fe:	f1a2 01c1 	sub.w	r1, r2, #193	; 0xc1
  40c902:	4c3b      	ldr	r4, [pc, #236]	; (40c9f0 <glcd_putsf+0x238>)
  40c904:	4f3b      	ldr	r7, [pc, #236]	; (40c9f4 <glcd_putsf+0x23c>)
  40c906:	ea4f 0b41 	mov.w	fp, r1, lsl #1
  40c90a:	7823      	ldrb	r3, [r4, #0]
  40c90c:	4e3a      	ldr	r6, [pc, #232]	; (40c9f8 <glcd_putsf+0x240>)
                    temp_char=map[*c-193][0];
  40c90e:	4459      	add	r1, fp
                    break;
  40c910:	4605      	mov	r5, r0
                    temp_char=map[*c-193][0];
  40c912:	f81a 9031 	ldrb.w	r9, [sl, r1, lsl #3]
                    break;
  40c916:	e79f      	b.n	40c858 <glcd_putsf+0xa0>
            if(*c >= 193)
  40c918:	2ac0      	cmp	r2, #192	; 0xc0
  40c91a:	d91f      	bls.n	40c95c <glcd_putsf+0x1a4>
  40c91c:	f1a2 01c1 	sub.w	r1, r2, #193	; 0xc1
  40c920:	ea4f 0b41 	mov.w	fp, r1, lsl #1
  40c924:	e7f3      	b.n	40c90e <glcd_putsf+0x156>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40c926:	f1a2 01c1 	sub.w	r1, r2, #193	; 0xc1
  40c92a:	ea4f 0b41 	mov.w	fp, r1, lsl #1
  40c92e:	eb0b 0c01 	add.w	ip, fp, r1
  40c932:	eb0a 0ccc 	add.w	ip, sl, ip, lsl #3
  40c936:	f8dc c010 	ldr.w	ip, [ip, #16]
  40c93a:	f1bc 0f00 	cmp.w	ip, #0
  40c93e:	d110      	bne.n	40c962 <glcd_putsf+0x1aa>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c940:	f890 e001 	ldrb.w	lr, [r0, #1]
  40c944:	f1ae 05c1 	sub.w	r5, lr, #193	; 0xc1
  40c948:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  40c94c:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
  40c950:	692d      	ldr	r5, [r5, #16]
  40c952:	b10d      	cbz	r5, 40c958 <glcd_putsf+0x1a0>
  40c954:	4605      	mov	r5, r0
  40c956:	e76d      	b.n	40c834 <glcd_putsf+0x7c>
            if(*c >= 193)
  40c958:	2ac0      	cmp	r2, #192	; 0xc0
  40c95a:	d8d8      	bhi.n	40c90e <glcd_putsf+0x156>
  40c95c:	4691      	mov	r9, r2
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c95e:	4605      	mov	r5, r0
  40c960:	e77c      	b.n	40c85c <glcd_putsf+0xa4>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40c962:	2ac0      	cmp	r2, #192	; 0xc0
  40c964:	d916      	bls.n	40c994 <glcd_putsf+0x1dc>
  40c966:	f1be 0fc0 	cmp.w	lr, #192	; 0xc0
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c96a:	f895 e002 	ldrb.w	lr, [r5, #2]
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40c96e:	d92e      	bls.n	40c9ce <glcd_putsf+0x216>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c970:	f1ae 05c1 	sub.w	r5, lr, #193	; 0xc1
                    connection = 1;
  40c974:	f04f 0c01 	mov.w	ip, #1
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c978:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  40c97c:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
  40c980:	692d      	ldr	r5, [r5, #16]
  40c982:	2d00      	cmp	r5, #0
  40c984:	d1e6      	bne.n	40c954 <glcd_putsf+0x19c>
  40c986:	4605      	mov	r5, r0
                    temp_char=map[*c-193][2];
  40c988:	4459      	add	r1, fp
  40c98a:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
  40c98e:	f891 9008 	ldrb.w	r9, [r1, #8]
                    break;
  40c992:	e761      	b.n	40c858 <glcd_putsf+0xa0>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c994:	f890 e001 	ldrb.w	lr, [r0, #1]
  40c998:	f04f 0c00 	mov.w	ip, #0
  40c99c:	f1ae 05c1 	sub.w	r5, lr, #193	; 0xc1
  40c9a0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  40c9a4:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
  40c9a8:	692d      	ldr	r5, [r5, #16]
  40c9aa:	2d00      	cmp	r5, #0
  40c9ac:	d0d6      	beq.n	40c95c <glcd_putsf+0x1a4>
  40c9ae:	4605      	mov	r5, r0
  40c9b0:	e740      	b.n	40c834 <glcd_putsf+0x7c>
                    temp_char=map[*c-193][3];
  40c9b2:	4459      	add	r1, fp
  40c9b4:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
  40c9b8:	f891 900c 	ldrb.w	r9, [r1, #12]
                    break;                    
  40c9bc:	e74c      	b.n	40c858 <glcd_putsf+0xa0>
                    temp_char=map[*c-193][1];
  40c9be:	4459      	add	r1, fp
  40c9c0:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
  40c9c4:	f891 9004 	ldrb.w	r9, [r1, #4]
                    break;
  40c9c8:	e746      	b.n	40c858 <glcd_putsf+0xa0>
  40c9ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40c9ce:	f1ae 05c1 	sub.w	r5, lr, #193	; 0xc1
  40c9d2:	f04f 0c00 	mov.w	ip, #0
  40c9d6:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  40c9da:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
  40c9de:	692d      	ldr	r5, [r5, #16]
  40c9e0:	2d00      	cmp	r5, #0
  40c9e2:	d094      	beq.n	40c90e <glcd_putsf+0x156>
  40c9e4:	4605      	mov	r5, r0
  40c9e6:	e725      	b.n	40c834 <glcd_putsf+0x7c>
  40c9e8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                switch(connection)
  40c9ec:	4628      	mov	r0, r5
  40c9ee:	e78e      	b.n	40c90e <glcd_putsf+0x156>
  40c9f0:	20400c60 	.word	0x20400c60
  40c9f4:	0041bb8c 	.word	0x0041bb8c
  40c9f8:	0040c755 	.word	0x0040c755
  40c9fc:	20400c61 	.word	0x20400c61
  40ca00:	0041c48c 	.word	0x0041c48c

0040ca04 <glcd_puts>:
  40ca04:	4b00      	ldr	r3, [pc, #0]	; (40ca08 <glcd_puts+0x4>)
  40ca06:	4718      	bx	r3
  40ca08:	0040c7b9 	.word	0x0040c7b9

0040ca0c <get_text_width>:
    char initial=0;
    char _c_width,ret_width=0;
    unsigned char temp_char=0;
    char connection=0; // flags if the charcter connected in the front and rear 

        while(count-->0)
  40ca0c:	2900      	cmp	r1, #0
  40ca0e:	f000 80c3 	beq.w	40cb98 <get_text_width+0x18c>
  40ca12:	4603      	mov	r3, r0
{
  40ca14:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40ca18:	1e4f      	subs	r7, r1, #1
        while(count-->0)
  40ca1a:	2400      	movs	r4, #0
  40ca1c:	4d5f      	ldr	r5, [pc, #380]	; (40cb9c <get_text_width+0x190>)
  40ca1e:	b2ff      	uxtb	r7, r7
  40ca20:	f8df e17c 	ldr.w	lr, [pc, #380]	; 40cba0 <get_text_width+0x194>
  40ca24:	4626      	mov	r6, r4
  40ca26:	3701      	adds	r7, #1
  40ca28:	4407      	add	r7, r0
  40ca2a:	4620      	mov	r0, r4
        {
            //get the  
            if((*c == 225) && (*(c+1) == 199))
  40ca2c:	f813 1b01 	ldrb.w	r1, [r3], #1
                x -= 8;
                special = 0;
                continue;
                */
            }    
            if(initial)// if this is not the initial charcter
  40ca30:	2e00      	cmp	r6, #0
  40ca32:	d15f      	bne.n	40caf4 <get_text_width+0xe8>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
                {
                    connection = 1;
                }
            }
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40ca34:	f893 8000 	ldrb.w	r8, [r3]
  40ca38:	f1a8 02c1 	sub.w	r2, r8, #193	; 0xc1
  40ca3c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40ca40:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
  40ca44:	6912      	ldr	r2, [r2, #16]
  40ca46:	2a00      	cmp	r2, #0
  40ca48:	d04d      	beq.n	40cae6 <get_text_width+0xda>
  40ca4a:	f1a1 02c1 	sub.w	r2, r1, #193	; 0xc1
  40ca4e:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40ca52:	eb0c 0902 	add.w	r9, ip, r2
  40ca56:	eb05 09c9 	add.w	r9, r5, r9, lsl #3
  40ca5a:	f8d9 9014 	ldr.w	r9, [r9, #20]
  40ca5e:	f1b9 0f00 	cmp.w	r9, #0
  40ca62:	d073      	beq.n	40cb4c <get_text_width+0x140>
  40ca64:	29c0      	cmp	r1, #192	; 0xc0
  40ca66:	d905      	bls.n	40ca74 <get_text_width+0x68>
  40ca68:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
  40ca6c:	d830      	bhi.n	40cad0 <get_text_width+0xc4>
            if(*c >= 193)
            {
                switch(connection)
                {
                    case 0:
                    temp_char=map[*c-193][0];
  40ca6e:	4462      	add	r2, ip
  40ca70:	f815 4032 	ldrb.w	r4, [r5, r2, lsl #3]
  return font[9*c];
  40ca74:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
        while(count-->0)
  40ca78:	429f      	cmp	r7, r3
            ret_width+=_c_width;


            c++;
            connection=0;
            initial=1;
  40ca7a:	f04f 0601 	mov.w	r6, #1
            ret_width+=_c_width;
  40ca7e:	f81e 1002 	ldrb.w	r1, [lr, r2]
  40ca82:	4408      	add	r0, r1
  40ca84:	b2c0      	uxtb	r0, r0
        while(count-->0)
  40ca86:	d1d1      	bne.n	40ca2c <get_text_width+0x20>
  40ca88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40ca8c:	f1a1 02c1 	sub.w	r2, r1, #193	; 0xc1
  40ca90:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40ca94:	eb0c 0902 	add.w	r9, ip, r2
  40ca98:	eb05 09c9 	add.w	r9, r5, r9, lsl #3
  40ca9c:	f8d9 a010 	ldr.w	sl, [r9, #16]
  40caa0:	f1ba 0f00 	cmp.w	sl, #0
  40caa4:	d155      	bne.n	40cb52 <get_text_width+0x146>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40caa6:	f893 8000 	ldrb.w	r8, [r3]
  40caaa:	f1a8 06c1 	sub.w	r6, r8, #193	; 0xc1
  40caae:	eb06 0646 	add.w	r6, r6, r6, lsl #1
  40cab2:	eb05 06c6 	add.w	r6, r5, r6, lsl #3
  40cab6:	6936      	ldr	r6, [r6, #16]
  40cab8:	2e00      	cmp	r6, #0
  40caba:	d047      	beq.n	40cb4c <get_text_width+0x140>
  40cabc:	f8d9 6014 	ldr.w	r6, [r9, #20]
  40cac0:	2e00      	cmp	r6, #0
  40cac2:	d043      	beq.n	40cb4c <get_text_width+0x140>
  40cac4:	29c0      	cmp	r1, #192	; 0xc0
  40cac6:	d9d5      	bls.n	40ca74 <get_text_width+0x68>
  40cac8:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
  40cacc:	d9cf      	bls.n	40ca6e <get_text_width+0x62>
  40cace:	2600      	movs	r6, #0
                switch(connection)
  40cad0:	b126      	cbz	r6, 40cadc <get_text_width+0xd0>
                    temp_char=map[*c-193][3];
  40cad2:	4462      	add	r2, ip
  40cad4:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
  40cad8:	7b14      	ldrb	r4, [r2, #12]
                    break;                    
  40cada:	e7cb      	b.n	40ca74 <get_text_width+0x68>
                    temp_char=map[*c-193][1];
  40cadc:	4462      	add	r2, ip
  40cade:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
  40cae2:	7914      	ldrb	r4, [r2, #4]
                    break;
  40cae4:	e7c6      	b.n	40ca74 <get_text_width+0x68>
            if(*c >= 193)
  40cae6:	29c0      	cmp	r1, #192	; 0xc0
  40cae8:	d9c4      	bls.n	40ca74 <get_text_width+0x68>
  40caea:	f1a1 02c1 	sub.w	r2, r1, #193	; 0xc1
  40caee:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40caf2:	e7bc      	b.n	40ca6e <get_text_width+0x62>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40caf4:	f813 8c02 	ldrb.w	r8, [r3, #-2]
  40caf8:	f1a8 02c1 	sub.w	r2, r8, #193	; 0xc1
  40cafc:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40cb00:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
  40cb04:	f8d2 9014 	ldr.w	r9, [r2, #20]
  40cb08:	f1b9 0f00 	cmp.w	r9, #0
  40cb0c:	d1be      	bne.n	40ca8c <get_text_width+0x80>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cb0e:	781e      	ldrb	r6, [r3, #0]
  40cb10:	f1a6 02c1 	sub.w	r2, r6, #193	; 0xc1
  40cb14:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40cb18:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
  40cb1c:	6912      	ldr	r2, [r2, #16]
  40cb1e:	2a00      	cmp	r2, #0
  40cb20:	d0e1      	beq.n	40cae6 <get_text_width+0xda>
  40cb22:	f1a1 02c1 	sub.w	r2, r1, #193	; 0xc1
  40cb26:	ea4f 0c42 	mov.w	ip, r2, lsl #1
  40cb2a:	eb0c 0802 	add.w	r8, ip, r2
  40cb2e:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
  40cb32:	f8d8 8014 	ldr.w	r8, [r8, #20]
  40cb36:	f1b8 0f00 	cmp.w	r8, #0
  40cb3a:	d007      	beq.n	40cb4c <get_text_width+0x140>
  40cb3c:	29c0      	cmp	r1, #192	; 0xc0
  40cb3e:	d999      	bls.n	40ca74 <get_text_width+0x68>
  40cb40:	2ec0      	cmp	r6, #192	; 0xc0
  40cb42:	d994      	bls.n	40ca6e <get_text_width+0x62>
  40cb44:	464e      	mov	r6, r9
                switch(connection)
  40cb46:	2e00      	cmp	r6, #0
  40cb48:	d1c3      	bne.n	40cad2 <get_text_width+0xc6>
  40cb4a:	e7c7      	b.n	40cadc <get_text_width+0xd0>
            if(*c >= 193)
  40cb4c:	29c0      	cmp	r1, #192	; 0xc0
  40cb4e:	d88e      	bhi.n	40ca6e <get_text_width+0x62>
  40cb50:	e790      	b.n	40ca74 <get_text_width+0x68>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40cb52:	29c0      	cmp	r1, #192	; 0xc0
  40cb54:	d98e      	bls.n	40ca74 <get_text_width+0x68>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cb56:	781c      	ldrb	r4, [r3, #0]
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40cb58:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cb5c:	f1a4 01c1 	sub.w	r1, r4, #193	; 0xc1
  40cb60:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  40cb64:	eb05 01c1 	add.w	r1, r5, r1, lsl #3
  40cb68:	6909      	ldr	r1, [r1, #16]
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40cb6a:	d90a      	bls.n	40cb82 <get_text_width+0x176>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cb6c:	b121      	cbz	r1, 40cb78 <get_text_width+0x16c>
  40cb6e:	f8d9 1014 	ldr.w	r1, [r9, #20]
  40cb72:	b109      	cbz	r1, 40cb78 <get_text_width+0x16c>
  40cb74:	2cc0      	cmp	r4, #192	; 0xc0
  40cb76:	d8ab      	bhi.n	40cad0 <get_text_width+0xc4>
                    temp_char=map[*c-193][2];
  40cb78:	4462      	add	r2, ip
  40cb7a:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
  40cb7e:	7a14      	ldrb	r4, [r2, #8]
                    break;
  40cb80:	e778      	b.n	40ca74 <get_text_width+0x68>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cb82:	2900      	cmp	r1, #0
  40cb84:	f43f af73 	beq.w	40ca6e <get_text_width+0x62>
  40cb88:	f8d9 1014 	ldr.w	r1, [r9, #20]
  40cb8c:	2900      	cmp	r1, #0
  40cb8e:	f43f af6e 	beq.w	40ca6e <get_text_width+0x62>
  40cb92:	2cc0      	cmp	r4, #192	; 0xc0
  40cb94:	d89b      	bhi.n	40cace <get_text_width+0xc2>
  40cb96:	e76a      	b.n	40ca6e <get_text_width+0x62>
    char _c_width,ret_width=0;
  40cb98:	4608      	mov	r0, r1
  40cb9a:	4770      	bx	lr
  40cb9c:	0041c48c 	.word	0x0041c48c
  40cba0:	0041bb8c 	.word	0x0041bb8c

0040cba4 <get_fitted_word>:
        }
        return ret_width;
}
unsigned int get_fitted_word(const char *c,unsigned char awidth)
{
  40cba4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const char *c1;
    //unsigned int ret_val=0;
    //en 65 2 122
    //Ar 187 & 192 2 251
    c1=c;
    while( awidth > (nwidth + temp_calc_w) )
  40cba8:	468b      	mov	fp, r1
  40cbaa:	2900      	cmp	r1, #0
  40cbac:	f000 808b 	beq.w	40ccc6 <get_fitted_word+0x122>
    {
        //if the available width > needed width continue
        if(*c==0)
  40cbb0:	7804      	ldrb	r4, [r0, #0]
  40cbb2:	2c00      	cmp	r4, #0
  40cbb4:	f000 808a 	beq.w	40cccc <get_fitted_word+0x128>
  40cbb8:	f04f 0e00 	mov.w	lr, #0
  40cbbc:	4607      	mov	r7, r0
  return font[9*c];
  40cbbe:	f8df a118 	ldr.w	sl, [pc, #280]	; 40ccd8 <get_fitted_word+0x134>
        if(*c==0)
  40cbc2:	4675      	mov	r5, lr
  40cbc4:	46f4      	mov	ip, lr
  40cbc6:	4676      	mov	r6, lr
  40cbc8:	46f0      	mov	r8, lr
                nchar+= temp_calc_char; //add the last word no of char            
            }
            break; //if end of string return
        }
        //detect language
        if((*c>47)&&(*c<123))
  40cbca:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
  40cbce:	2b4a      	cmp	r3, #74	; 0x4a
  40cbd0:	d951      	bls.n	40cc76 <get_fitted_word+0xd2>
        {
            //english detected
            t_lang=1;
            //putIt('E');
        }
        else if(((*c>191)&&(*c<252))||(*c==187))
  40cbd2:	f104 0140 	add.w	r1, r4, #64	; 0x40
  40cbd6:	b2c9      	uxtb	r1, r1
  40cbd8:	293b      	cmp	r1, #59	; 0x3b
  40cbda:	d912      	bls.n	40cc02 <get_fitted_word+0x5e>
  40cbdc:	2cbb      	cmp	r4, #187	; 0xbb
  40cbde:	d010      	beq.n	40cc02 <get_fitted_word+0x5e>
            //putIt('A');
        }
        else t_lang=0; //unknown language
        
        //if language change break;
        if(lang==0) lang=t_lang;//if unknown lang set language
  40cbe0:	f1be 0f00 	cmp.w	lr, #0
  40cbe4:	d021      	beq.n	40cc2a <get_fitted_word+0x86>
                    nchar+= temp_calc_char; //add the last word no of char
                    break;
                }
            }
        }
        if(*c==' ')
  40cbe6:	2c20      	cmp	r4, #32
  40cbe8:	d121      	bne.n	40cc2e <get_fitted_word+0x8a>
        {
            if(lang!=2)
  40cbea:	f1be 0f02 	cmp.w	lr, #2
  40cbee:	d047      	beq.n	40cc80 <get_fitted_word+0xdc>
            {
                //english or other l 2 r languages
                //word break
                nwidth+= temp_calc_w; //add the last word
  40cbf0:	4466      	add	r6, ip
                temp_calc_w=0;
            
                nchar+= temp_calc_char; //add the last word no of char
  40cbf2:	44a8      	add	r8, r5
                temp_calc_w=0;
  40cbf4:	f04f 0c00 	mov.w	ip, #0
  40cbf8:	2501      	movs	r5, #1
                nwidth+= temp_calc_w; //add the last word
  40cbfa:	b2f6      	uxtb	r6, r6
                nchar+= temp_calc_char; //add the last word no of char
  40cbfc:	fa5f f888 	uxtb.w	r8, r8
  40cc00:	e017      	b.n	40cc32 <get_fitted_word+0x8e>
        if(lang==0) lang=t_lang;//if unknown lang set language
  40cc02:	f1be 0f00 	cmp.w	lr, #0
  40cc06:	d02f      	beq.n	40cc68 <get_fitted_word+0xc4>
            t_lang=2;
  40cc08:	2302      	movs	r3, #2
                if(t_lang!=0)
  40cc0a:	459e      	cmp	lr, r3
  40cc0c:	d0eb      	beq.n	40cbe6 <get_fitted_word+0x42>
                    nchar+= temp_calc_char; //add the last word no of char
  40cc0e:	4445      	add	r5, r8
                    nwidth+= temp_calc_w; //add the last word
  40cc10:	eb06 030c 	add.w	r3, r6, ip
                    nchar+= temp_calc_char; //add the last word no of char
  40cc14:	fa5f f885 	uxtb.w	r8, r5
  40cc18:	fa5f f983 	uxtb.w	r9, r3
        c++; //prepare pointer for next check
    }
    

    //putIt(nchar + 0x30);
    if(lang==2) 
  40cc1c:	f1be 0f02 	cmp.w	lr, #2
  40cc20:	d04b      	beq.n	40ccba <get_fitted_word+0x116>
  40cc22:	eb09 2008 	add.w	r0, r9, r8, lsl #8
  40cc26:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(*c==' ')
  40cc2a:	2c20      	cmp	r4, #32
  40cc2c:	d0e0      	beq.n	40cbf0 <get_fitted_word+0x4c>
  40cc2e:	3501      	adds	r5, #1
  40cc30:	b2ed      	uxtb	r5, r5
  return font[9*c];
  40cc32:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
    while( awidth > (nwidth + temp_calc_w) )
  40cc36:	46b1      	mov	r9, r6
        temp_calc_w = temp_calc_w +  get_font_width(*c);
  40cc38:	f81a 3004 	ldrb.w	r3, [sl, r4]
  40cc3c:	4463      	add	r3, ip
  40cc3e:	fa5f fc83 	uxtb.w	ip, r3
    while( awidth > (nwidth + temp_calc_w) )
  40cc42:	eb0c 0306 	add.w	r3, ip, r6
  40cc46:	459b      	cmp	fp, r3
  40cc48:	dde8      	ble.n	40cc1c <get_fitted_word+0x78>
        if(*c==0)
  40cc4a:	f817 4f01 	ldrb.w	r4, [r7, #1]!
  40cc4e:	2c00      	cmp	r4, #0
  40cc50:	d1bb      	bne.n	40cbca <get_fitted_word+0x26>
            if(lang!=2)
  40cc52:	f1be 0f02 	cmp.w	lr, #2
  40cc56:	d027      	beq.n	40cca8 <get_fitted_word+0x104>
  40cc58:	44a8      	add	r8, r5
  40cc5a:	b2db      	uxtb	r3, r3
  40cc5c:	fa5f f888 	uxtb.w	r8, r8
  40cc60:	eb03 2008 	add.w	r0, r3, r8, lsl #8
  40cc64:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(*c==' ')
  40cc68:	2c20      	cmp	r4, #32
  40cc6a:	d009      	beq.n	40cc80 <get_fitted_word+0xdc>
  40cc6c:	3501      	adds	r5, #1
            t_lang=2;
  40cc6e:	f04f 0e02 	mov.w	lr, #2
  40cc72:	b2ed      	uxtb	r5, r5
  40cc74:	e7dd      	b.n	40cc32 <get_fitted_word+0x8e>
        if(lang==0) lang=t_lang;//if unknown lang set language
  40cc76:	f1be 0f00 	cmp.w	lr, #0
  40cc7a:	d010      	beq.n	40cc9e <get_fitted_word+0xfa>
            t_lang=1;
  40cc7c:	2301      	movs	r3, #1
  40cc7e:	e7c4      	b.n	40cc0a <get_fitted_word+0x66>
                nwidth = nwidth + get_text_width(c1, temp_calc_char);
  40cc80:	4629      	mov	r1, r5
  40cc82:	4b14      	ldr	r3, [pc, #80]	; (40ccd4 <get_fitted_word+0x130>)
  40cc84:	4798      	blx	r3
                nchar+= temp_calc_char; //add the last word no of char
  40cc86:	4445      	add	r5, r8
                nwidth = nwidth + get_text_width(c1, temp_calc_char);
  40cc88:	4406      	add	r6, r0
                nchar+= temp_calc_char; //add the last word no of char
  40cc8a:	f04f 0e02 	mov.w	lr, #2
  40cc8e:	fa5f f885 	uxtb.w	r8, r5
  40cc92:	1e78      	subs	r0, r7, #1
  40cc94:	2501      	movs	r5, #1
                nwidth = nwidth + get_text_width(c1, temp_calc_char);
  40cc96:	b2f6      	uxtb	r6, r6
                temp_calc_w=0;
  40cc98:	f04f 0c00 	mov.w	ip, #0
  40cc9c:	e7c9      	b.n	40cc32 <get_fitted_word+0x8e>
  40cc9e:	3501      	adds	r5, #1
            t_lang=1;
  40cca0:	f04f 0e01 	mov.w	lr, #1
  40cca4:	b2ed      	uxtb	r5, r5
  40cca6:	e7c4      	b.n	40cc32 <get_fitted_word+0x8e>
                nwidth = nwidth + get_text_width(c1, temp_calc_char);
  40cca8:	4629      	mov	r1, r5
  40ccaa:	4b0a      	ldr	r3, [pc, #40]	; (40ccd4 <get_fitted_word+0x130>)
  40ccac:	4798      	blx	r3
                nchar+= temp_calc_char; //add the last word no of char            
  40ccae:	4445      	add	r5, r8
                nwidth = nwidth + get_text_width(c1, temp_calc_char);
  40ccb0:	4481      	add	r9, r0
                nchar+= temp_calc_char; //add the last word no of char            
  40ccb2:	fa5f f885 	uxtb.w	r8, r5
  40ccb6:	fa5f f989 	uxtb.w	r9, r9
  40ccba:	f048 0880 	orr.w	r8, r8, #128	; 0x80
  40ccbe:	eb09 2008 	add.w	r0, r9, r8, lsl #8
  40ccc2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while( awidth > (nwidth + temp_calc_w) )
  40ccc6:	4608      	mov	r0, r1
        nchar|=0x80;
        //putIt('A');
    }
    
    return (nchar<<8)+nwidth;
}
  40ccc8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(*c==0)
  40cccc:	4620      	mov	r0, r4
  40ccce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40ccd2:	bf00      	nop
  40ccd4:	0040ca0d 	.word	0x0040ca0d
  40ccd8:	0041bb8c 	.word	0x0041bb8c

0040ccdc <special_putsf>:
void special_putsf(const char *c,uchar l,uchar count)
{
  40ccdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40cce0:	b083      	sub	sp, #12
    char special = 0;
    char initial=0;
    char _c_width;
    unsigned char temp_char = 0;
    char connection=0; // flags if the charcter connected in the front and rear 
    if(l) // arabic detected
  40cce2:	bb19      	cbnz	r1, 40cd2c <special_putsf+0x50>
            initial=1;
        }           
    }
    else // normal english
    {
        while(count-->0)
  40cce4:	f102 38ff 	add.w	r8, r2, #4294967295
  40cce8:	fa5f f888 	uxtb.w	r8, r8
  40ccec:	b1da      	cbz	r2, 40cd26 <special_putsf+0x4a>
  40ccee:	4480      	add	r8, r0
  40ccf0:	1e44      	subs	r4, r0, #1
        {
            temp_char = *c;
            _c_width=get_font_width(temp_char);//get the width of char
            if((128-d_x)<_c_width) 
            {
                d_x=0;
  40ccf2:	468a      	mov	sl, r1
  40ccf4:	4d91      	ldr	r5, [pc, #580]	; (40cf3c <special_putsf+0x260>)
  40ccf6:	4f92      	ldr	r7, [pc, #584]	; (40cf40 <special_putsf+0x264>)
  40ccf8:	4e92      	ldr	r6, [pc, #584]	; (40cf44 <special_putsf+0x268>)
                d_y+=8;
  40ccfa:	f8df 924c 	ldr.w	r9, [pc, #588]	; 40cf48 <special_putsf+0x26c>
            temp_char = *c;
  40ccfe:	f814 0f01 	ldrb.w	r0, [r4, #1]!
            if((128-d_x)<_c_width) 
  40cd02:	782b      	ldrb	r3, [r5, #0]
  return font[9*c];
  40cd04:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
            if((128-d_x)<_c_width) 
  40cd08:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
  40cd0c:	5cba      	ldrb	r2, [r7, r2]
  40cd0e:	4293      	cmp	r3, r2
  40cd10:	da06      	bge.n	40cd20 <special_putsf+0x44>
                d_y+=8;
  40cd12:	f899 3000 	ldrb.w	r3, [r9]
                d_x=0;
  40cd16:	f885 a000 	strb.w	sl, [r5]
                d_y+=8;
  40cd1a:	3308      	adds	r3, #8
  40cd1c:	f889 3000 	strb.w	r3, [r9]
            }
            putIt(temp_char);
  40cd20:	47b0      	blx	r6
        while(count-->0)
  40cd22:	45a0      	cmp	r8, r4
  40cd24:	d1eb      	bne.n	40ccfe <special_putsf+0x22>
            //return;
            (c++);
        }
    }   
}
  40cd26:	b003      	add	sp, #12
  40cd28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while(count-->0)
  40cd2c:	1e53      	subs	r3, r2, #1
  40cd2e:	b2db      	uxtb	r3, r3
  40cd30:	2a00      	cmp	r2, #0
  40cd32:	d0f8      	beq.n	40cd26 <special_putsf+0x4a>
  40cd34:	3301      	adds	r3, #1
  40cd36:	4604      	mov	r4, r0
  40cd38:	4d80      	ldr	r5, [pc, #512]	; (40cf3c <special_putsf+0x260>)
  40cd3a:	f04f 0c00 	mov.w	ip, #0
  40cd3e:	4e81      	ldr	r6, [pc, #516]	; (40cf44 <special_putsf+0x268>)
  40cd40:	eb00 0b03 	add.w	fp, r0, r3
  40cd44:	f8df 8204 	ldr.w	r8, [pc, #516]	; 40cf4c <special_putsf+0x270>
  40cd48:	782b      	ldrb	r3, [r5, #0]
  40cd4a:	4f7d      	ldr	r7, [pc, #500]	; (40cf40 <special_putsf+0x264>)
                d_y++;
  40cd4c:	9601      	str	r6, [sp, #4]
            if((*c == 225) && (*(c+1) == 199))
  40cd4e:	f814 0b01 	ldrb.w	r0, [r4], #1
            if(initial)// if this is not the initial charcter
  40cd52:	f1bc 0f00 	cmp.w	ip, #0
  40cd56:	d13b      	bne.n	40cdd0 <special_putsf+0xf4>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cd58:	f894 9000 	ldrb.w	r9, [r4]
  40cd5c:	f1a9 02c1 	sub.w	r2, r9, #193	; 0xc1
  40cd60:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40cd64:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  40cd68:	6912      	ldr	r2, [r2, #16]
  40cd6a:	2a00      	cmp	r2, #0
  40cd6c:	d079      	beq.n	40ce62 <special_putsf+0x186>
  40cd6e:	f1a0 01c1 	sub.w	r1, r0, #193	; 0xc1
  40cd72:	4602      	mov	r2, r0
  40cd74:	ea4f 0e41 	mov.w	lr, r1, lsl #1
  40cd78:	eb0e 0a01 	add.w	sl, lr, r1
  40cd7c:	eb08 0aca 	add.w	sl, r8, sl, lsl #3
  40cd80:	f8da a014 	ldr.w	sl, [sl, #20]
  40cd84:	f1ba 0f00 	cmp.w	sl, #0
  40cd88:	f000 80b1 	beq.w	40ceee <special_putsf+0x212>
  40cd8c:	28c0      	cmp	r0, #192	; 0xc0
  40cd8e:	d97c      	bls.n	40ce8a <special_putsf+0x1ae>
  40cd90:	f1b9 0fc0 	cmp.w	r9, #192	; 0xc0
  40cd94:	d848      	bhi.n	40ce28 <special_putsf+0x14c>
                    temp_char=map[*c-193][0];
  40cd96:	4471      	add	r1, lr
  40cd98:	f818 0031 	ldrb.w	r0, [r8, r1, lsl #3]
  40cd9c:	4602      	mov	r2, r0
  return font[9*c];
  40cd9e:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
  40cda2:	f817 9002 	ldrb.w	r9, [r7, r2]
            if(d_x>=_c_width) d_x-=_c_width;
  40cda6:	4599      	cmp	r9, r3
  40cda8:	d84c      	bhi.n	40ce44 <special_putsf+0x168>
  40cdaa:	eba3 0309 	sub.w	r3, r3, r9
  40cdae:	702b      	strb	r3, [r5, #0]
            putIt(temp_char);
  40cdb0:	9b01      	ldr	r3, [sp, #4]
  40cdb2:	4798      	blx	r3
            d_x-=_c_width;
  40cdb4:	782b      	ldrb	r3, [r5, #0]
        while(count-->0)
  40cdb6:	455c      	cmp	r4, fp
            initial=1;
  40cdb8:	f04f 0c01 	mov.w	ip, #1
            d_x-=_c_width;
  40cdbc:	eba3 0309 	sub.w	r3, r3, r9
  40cdc0:	b2db      	uxtb	r3, r3
  40cdc2:	702b      	strb	r3, [r5, #0]
        while(count-->0)
  40cdc4:	d0af      	beq.n	40cd26 <special_putsf+0x4a>
            if((*c == 225) && (*(c+1) == 199))
  40cdc6:	f814 0b01 	ldrb.w	r0, [r4], #1
            if(initial)// if this is not the initial charcter
  40cdca:	f1bc 0f00 	cmp.w	ip, #0
  40cdce:	d0c3      	beq.n	40cd58 <special_putsf+0x7c>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40cdd0:	f814 9c02 	ldrb.w	r9, [r4, #-2]
  40cdd4:	f1a9 02c1 	sub.w	r2, r9, #193	; 0xc1
  40cdd8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40cddc:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  40cde0:	f8d2 a014 	ldr.w	sl, [r2, #20]
  40cde4:	f1ba 0f00 	cmp.w	sl, #0
  40cde8:	d156      	bne.n	40ce98 <special_putsf+0x1bc>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cdea:	f894 c000 	ldrb.w	ip, [r4]
  40cdee:	f1ac 02c1 	sub.w	r2, ip, #193	; 0xc1
  40cdf2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40cdf6:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  40cdfa:	6912      	ldr	r2, [r2, #16]
  40cdfc:	2a00      	cmp	r2, #0
  40cdfe:	d047      	beq.n	40ce90 <special_putsf+0x1b4>
  40ce00:	f1a0 01c1 	sub.w	r1, r0, #193	; 0xc1
  40ce04:	4602      	mov	r2, r0
  40ce06:	ea4f 0e41 	mov.w	lr, r1, lsl #1
  40ce0a:	eb0e 0901 	add.w	r9, lr, r1
  40ce0e:	eb08 09c9 	add.w	r9, r8, r9, lsl #3
  40ce12:	f8d9 9014 	ldr.w	r9, [r9, #20]
  40ce16:	f1b9 0f00 	cmp.w	r9, #0
  40ce1a:	d068      	beq.n	40ceee <special_putsf+0x212>
  40ce1c:	28c0      	cmp	r0, #192	; 0xc0
  40ce1e:	d934      	bls.n	40ce8a <special_putsf+0x1ae>
  40ce20:	f1bc 0fc0 	cmp.w	ip, #192	; 0xc0
  40ce24:	d9b7      	bls.n	40cd96 <special_putsf+0xba>
  40ce26:	46d4      	mov	ip, sl
                switch(connection)
  40ce28:	f1bc 0f00 	cmp.w	ip, #0
  40ce2c:	d013      	beq.n	40ce56 <special_putsf+0x17a>
                    temp_char=map[*c-193][3];
  40ce2e:	4471      	add	r1, lr
  40ce30:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
  40ce34:	7b08      	ldrb	r0, [r1, #12]
  40ce36:	4602      	mov	r2, r0
  return font[9*c];
  40ce38:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
  40ce3c:	f817 9002 	ldrb.w	r9, [r7, r2]
            if(d_x>=_c_width) d_x-=_c_width;
  40ce40:	4599      	cmp	r9, r3
  40ce42:	d9b2      	bls.n	40cdaa <special_putsf+0xce>
                d_y++;
  40ce44:	4b40      	ldr	r3, [pc, #256]	; (40cf48 <special_putsf+0x26c>)
                d_x=128-_c_width;
  40ce46:	f1c9 0280 	rsb	r2, r9, #128	; 0x80
                d_y++;
  40ce4a:	781b      	ldrb	r3, [r3, #0]
                d_x=128-_c_width;
  40ce4c:	702a      	strb	r2, [r5, #0]
                d_y++;
  40ce4e:	3301      	adds	r3, #1
  40ce50:	4a3d      	ldr	r2, [pc, #244]	; (40cf48 <special_putsf+0x26c>)
  40ce52:	7013      	strb	r3, [r2, #0]
  40ce54:	e7ac      	b.n	40cdb0 <special_putsf+0xd4>
                    temp_char=map[*c-193][1];
  40ce56:	4471      	add	r1, lr
  40ce58:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
  40ce5c:	7908      	ldrb	r0, [r1, #4]
  40ce5e:	4602      	mov	r2, r0
  40ce60:	e79d      	b.n	40cd9e <special_putsf+0xc2>
            if(*c >= 193)
  40ce62:	28c0      	cmp	r0, #192	; 0xc0
  40ce64:	d9e7      	bls.n	40ce36 <special_putsf+0x15a>
  40ce66:	f1a0 01c1 	sub.w	r1, r0, #193	; 0xc1
  40ce6a:	ea4f 0e41 	mov.w	lr, r1, lsl #1
  40ce6e:	e792      	b.n	40cd96 <special_putsf+0xba>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40ce70:	28c0      	cmp	r0, #192	; 0xc0
  40ce72:	d841      	bhi.n	40cef8 <special_putsf+0x21c>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40ce74:	7821      	ldrb	r1, [r4, #0]
  40ce76:	39c1      	subs	r1, #193	; 0xc1
  40ce78:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  40ce7c:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
  40ce80:	6909      	ldr	r1, [r1, #16]
  40ce82:	b119      	cbz	r1, 40ce8c <special_putsf+0x1b0>
  40ce84:	f8da 1014 	ldr.w	r1, [sl, #20]
  40ce88:	b101      	cbz	r1, 40ce8c <special_putsf+0x1b0>
  40ce8a:	4602      	mov	r2, r0
            if((*c == 225) && (*(c+1) == 199))
  40ce8c:	4610      	mov	r0, r2
  40ce8e:	e786      	b.n	40cd9e <special_putsf+0xc2>
            if(*c >= 193)
  40ce90:	28c0      	cmp	r0, #192	; 0xc0
  40ce92:	d8e8      	bhi.n	40ce66 <special_putsf+0x18a>
  40ce94:	4602      	mov	r2, r0
  40ce96:	e7f9      	b.n	40ce8c <special_putsf+0x1b0>
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40ce98:	f1a0 01c1 	sub.w	r1, r0, #193	; 0xc1
  40ce9c:	4602      	mov	r2, r0
  40ce9e:	ea4f 0e41 	mov.w	lr, r1, lsl #1
  40cea2:	eb0e 0a01 	add.w	sl, lr, r1
  40cea6:	eb08 0aca 	add.w	sl, r8, sl, lsl #3
  40ceaa:	f8da 6010 	ldr.w	r6, [sl, #16]
  40ceae:	2e00      	cmp	r6, #0
  40ceb0:	d1de      	bne.n	40ce70 <special_putsf+0x194>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40ceb2:	f894 9000 	ldrb.w	r9, [r4]
  40ceb6:	f1a9 0cc1 	sub.w	ip, r9, #193	; 0xc1
  40ceba:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
  40cebe:	eb08 0ccc 	add.w	ip, r8, ip, lsl #3
  40cec2:	f8dc c010 	ldr.w	ip, [ip, #16]
  40cec6:	f1bc 0f00 	cmp.w	ip, #0
  40ceca:	d010      	beq.n	40ceee <special_putsf+0x212>
  40cecc:	f8da c014 	ldr.w	ip, [sl, #20]
  40ced0:	f1bc 0f00 	cmp.w	ip, #0
  40ced4:	d00b      	beq.n	40ceee <special_putsf+0x212>
  40ced6:	28c0      	cmp	r0, #192	; 0xc0
  40ced8:	d9d7      	bls.n	40ce8a <special_putsf+0x1ae>
  40ceda:	f1b9 0fc0 	cmp.w	r9, #192	; 0xc0
  40cede:	f67f af5a 	bls.w	40cd96 <special_putsf+0xba>
  40cee2:	f04f 0c00 	mov.w	ip, #0
                switch(connection)
  40cee6:	f1bc 0f00 	cmp.w	ip, #0
  40ceea:	d1a0      	bne.n	40ce2e <special_putsf+0x152>
  40ceec:	e7b3      	b.n	40ce56 <special_putsf+0x17a>
            if(*c >= 193)
  40ceee:	2ac0      	cmp	r2, #192	; 0xc0
  40cef0:	f63f af51 	bhi.w	40cd96 <special_putsf+0xba>
            if((*c == 225) && (*(c+1) == 199))
  40cef4:	4610      	mov	r0, r2
  40cef6:	e752      	b.n	40cd9e <special_putsf+0xc2>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cef8:	7820      	ldrb	r0, [r4, #0]
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40cefa:	f1b9 0fc0 	cmp.w	r9, #192	; 0xc0
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cefe:	f1a0 02c1 	sub.w	r2, r0, #193	; 0xc1
  40cf02:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  40cf06:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
  40cf0a:	6912      	ldr	r2, [r2, #16]
                if((map[*(c-1)-193][5]) && (map[(*c)-193][4]) && (*c >= 193) && (*(c-1) >= 193))
  40cf0c:	d90b      	bls.n	40cf26 <special_putsf+0x24a>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cf0e:	b122      	cbz	r2, 40cf1a <special_putsf+0x23e>
  40cf10:	f8da 2014 	ldr.w	r2, [sl, #20]
  40cf14:	b10a      	cbz	r2, 40cf1a <special_putsf+0x23e>
  40cf16:	28c0      	cmp	r0, #192	; 0xc0
  40cf18:	d886      	bhi.n	40ce28 <special_putsf+0x14c>
                    temp_char=map[*c-193][2];
  40cf1a:	4471      	add	r1, lr
  40cf1c:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
  40cf20:	7a08      	ldrb	r0, [r1, #8]
  40cf22:	4602      	mov	r2, r0
  40cf24:	e73b      	b.n	40cd9e <special_putsf+0xc2>
            if((map[*(c+1)-193][4]) && (map[(*c)-193][5]) && (*c >= 193) && (*(c+1) >= 193))
  40cf26:	2a00      	cmp	r2, #0
  40cf28:	f43f af35 	beq.w	40cd96 <special_putsf+0xba>
  40cf2c:	f8da 2014 	ldr.w	r2, [sl, #20]
  40cf30:	2a00      	cmp	r2, #0
  40cf32:	f43f af30 	beq.w	40cd96 <special_putsf+0xba>
  40cf36:	28c0      	cmp	r0, #192	; 0xc0
  40cf38:	d8d3      	bhi.n	40cee2 <special_putsf+0x206>
  40cf3a:	e72c      	b.n	40cd96 <special_putsf+0xba>
  40cf3c:	20400c60 	.word	0x20400c60
  40cf40:	0041bb8c 	.word	0x0041bb8c
  40cf44:	0040c755 	.word	0x0040c755
  40cf48:	20400c61 	.word	0x20400c61
  40cf4c:	0041c48c 	.word	0x0041c48c

0040cf50 <write_r_text>:
void write_r_text(const char *c, unsigned char rtl)
{
  40cf50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40cf54:	4604      	mov	r4, r0
    unsigned char nchar,width_pix,lang,awidth=128;
    unsigned int res;
    if(rtl) d_x=127-d_x; //flip the surface
  40cf56:	460f      	mov	r7, r1
  40cf58:	b121      	cbz	r1, 40cf64 <write_r_text+0x14>
  40cf5a:	4a2b      	ldr	r2, [pc, #172]	; (40d008 <write_r_text+0xb8>)
  40cf5c:	7813      	ldrb	r3, [r2, #0]
  40cf5e:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
  40cf62:	7013      	strb	r3, [r2, #0]
        nchar&=0x7F;
        
        if(width_pix==0)
        {
            //no space to fit text
            awidth=128;
  40cf64:	2580      	movs	r5, #128	; 0x80
        res=get_fitted_word(c,awidth);
  40cf66:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 40d010 <write_r_text+0xc0>
            }
            else
            {
                awidth-=width_pix; //dec available width
                if(lang) d_x+=width_pix;
                special_putsf(c,lang,nchar);
  40cf6a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 40d014 <write_r_text+0xc4>
                if(lang) d_x+=width_pix;
  40cf6e:	4e26      	ldr	r6, [pc, #152]	; (40d008 <write_r_text+0xb8>)
    while(*c)
  40cf70:	7823      	ldrb	r3, [r4, #0]
  40cf72:	b17b      	cbz	r3, 40cf94 <write_r_text+0x44>
        res=get_fitted_word(c,awidth);
  40cf74:	4629      	mov	r1, r5
  40cf76:	4620      	mov	r0, r4
  40cf78:	47c0      	blx	r8
        if(width_pix==0)
  40cf7a:	f010 0aff 	ands.w	sl, r0, #255	; 0xff
  40cf7e:	d10b      	bne.n	40cf98 <write_r_text+0x48>
            d_y+=9;
  40cf80:	4a22      	ldr	r2, [pc, #136]	; (40d00c <write_r_text+0xbc>)
  40cf82:	7813      	ldrb	r3, [r2, #0]
  40cf84:	3309      	adds	r3, #9
  40cf86:	7013      	strb	r3, [r2, #0]
            if(rtl) d_x=127-d_x; //flip the surface
  40cf88:	bb7f      	cbnz	r7, 40cfea <write_r_text+0x9a>
            d_x=0;
  40cf8a:	7037      	strb	r7, [r6, #0]
            awidth=128;
  40cf8c:	2580      	movs	r5, #128	; 0x80
    while(*c)
  40cf8e:	7823      	ldrb	r3, [r4, #0]
  40cf90:	2b00      	cmp	r3, #0
  40cf92:	d1ef      	bne.n	40cf74 <write_r_text+0x24>
  40cf94:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        nchar = (res>>8);
  40cf98:	0a00      	lsrs	r0, r0, #8
                awidth-=width_pix; //dec available width
  40cf9a:	eba5 050a 	sub.w	r5, r5, sl
        if(nchar&0x80) lang=1;
  40cf9e:	b243      	sxtb	r3, r0
        nchar&=0x7F;
  40cfa0:	f000 0b7f 	and.w	fp, r0, #127	; 0x7f
                awidth-=width_pix; //dec available width
  40cfa4:	b2ed      	uxtb	r5, r5
        if(nchar&0x80) lang=1;
  40cfa6:	0fd9      	lsrs	r1, r3, #31
            if(rtl)
  40cfa8:	b187      	cbz	r7, 40cfcc <write_r_text+0x7c>
                if(lang==0) d_x-=width_pix;
  40cfaa:	2b00      	cmp	r3, #0
  40cfac:	db21      	blt.n	40cff2 <write_r_text+0xa2>
  40cfae:	7833      	ldrb	r3, [r6, #0]
                special_putsf(c,lang,nchar);
  40cfb0:	4620      	mov	r0, r4
  40cfb2:	465a      	mov	r2, fp
  40cfb4:	2100      	movs	r1, #0
                if(lang==0) d_x-=width_pix;
  40cfb6:	eba3 030a 	sub.w	r3, r3, sl
                if(lang) d_x+=width_pix;
                c+=nchar;
  40cfba:	445c      	add	r4, fp
                if(lang==0) d_x-=width_pix;
  40cfbc:	7033      	strb	r3, [r6, #0]
                special_putsf(c,lang,nchar);
  40cfbe:	47c8      	blx	r9
                if(lang==0) d_x-=width_pix;
  40cfc0:	7833      	ldrb	r3, [r6, #0]
  40cfc2:	eba3 0a0a 	sub.w	sl, r3, sl
  40cfc6:	f886 a000 	strb.w	sl, [r6]
  40cfca:	e7d1      	b.n	40cf70 <write_r_text+0x20>
                if(lang) d_x+=width_pix;
  40cfcc:	2b00      	cmp	r3, #0
  40cfce:	da15      	bge.n	40cffc <write_r_text+0xac>
  40cfd0:	7833      	ldrb	r3, [r6, #0]
                special_putsf(c,lang,nchar);
  40cfd2:	4620      	mov	r0, r4
  40cfd4:	465a      	mov	r2, fp
  40cfd6:	2101      	movs	r1, #1
                if(lang) d_x+=width_pix;
  40cfd8:	4453      	add	r3, sl
                c+=nchar;
  40cfda:	445c      	add	r4, fp
                if(lang) d_x+=width_pix;
  40cfdc:	7033      	strb	r3, [r6, #0]
                special_putsf(c,lang,nchar);
  40cfde:	47c8      	blx	r9
                if(lang) d_x+=width_pix;
  40cfe0:	7833      	ldrb	r3, [r6, #0]
  40cfe2:	449a      	add	sl, r3
  40cfe4:	f886 a000 	strb.w	sl, [r6]
  40cfe8:	e7c2      	b.n	40cf70 <write_r_text+0x20>
            if(rtl) d_x=127-d_x; //flip the surface
  40cfea:	237f      	movs	r3, #127	; 0x7f
            awidth=128;
  40cfec:	2580      	movs	r5, #128	; 0x80
            if(rtl) d_x=127-d_x; //flip the surface
  40cfee:	7033      	strb	r3, [r6, #0]
  40cff0:	e7be      	b.n	40cf70 <write_r_text+0x20>
                special_putsf(c,lang,nchar);
  40cff2:	4620      	mov	r0, r4
  40cff4:	465a      	mov	r2, fp
  40cff6:	47c8      	blx	r9
                c+=nchar;
  40cff8:	445c      	add	r4, fp
  40cffa:	e7b9      	b.n	40cf70 <write_r_text+0x20>
                special_putsf(c,lang,nchar);
  40cffc:	4620      	mov	r0, r4
  40cffe:	465a      	mov	r2, fp
  40d000:	4639      	mov	r1, r7
                c+=nchar;
  40d002:	445c      	add	r4, fp
                special_putsf(c,lang,nchar);
  40d004:	47c8      	blx	r9
  40d006:	e7b3      	b.n	40cf70 <write_r_text+0x20>
  40d008:	20400c60 	.word	0x20400c60
  40d00c:	20400c61 	.word	0x20400c61
  40d010:	0040cba5 	.word	0x0040cba5
  40d014:	0040ccdd 	.word	0x0040ccdd

0040d018 <sph_timer_init>:

sph_timer_t timer_instances[TIMERS_COUNT];

//init the timer module
void sph_timer_init()
{
  40d018:	4b05      	ldr	r3, [pc, #20]	; (40d030 <sph_timer_init+0x18>)
	uint32_t i;
	for (i=0; i<TIMERS_COUNT; i++)
	{
		timer_instances[i].start_handler = 0;
  40d01a:	2200      	movs	r2, #0
  40d01c:	f503 7196 	add.w	r1, r3, #300	; 0x12c
  40d020:	60da      	str	r2, [r3, #12]
		timer_instances[i].stop_handler = 0;
  40d022:	611a      	str	r2, [r3, #16]
		timer_instances[i].timer_counter = 0;
  40d024:	605a      	str	r2, [r3, #4]
		timer_instances[i].timer_val = 0;
  40d026:	f843 2b14 	str.w	r2, [r3], #20
	for (i=0; i<TIMERS_COUNT; i++)
  40d02a:	428b      	cmp	r3, r1
  40d02c:	d1f8      	bne.n	40d020 <sph_timer_init+0x8>
	}
		
}
  40d02e:	4770      	bx	lr
  40d030:	20406124 	.word	0x20406124

0040d034 <sph_timer_handler>:
//a fixed 1Khz tiemr handler routine
void sph_timer_handler()
{
  40d034:	b538      	push	{r3, r4, r5, lr}
  40d036:	4c08      	ldr	r4, [pc, #32]	; (40d058 <sph_timer_handler+0x24>)
  40d038:	f504 7596 	add.w	r5, r4, #300	; 0x12c
	int32_t i;
	for (i=0; i<TIMERS_COUNT; i++)
	{
		if (timer_instances[i].timer_val)
  40d03c:	6823      	ldr	r3, [r4, #0]
  40d03e:	b13b      	cbz	r3, 40d050 <sph_timer_handler+0x1c>
		{
			//there is a timer at this location
			if (timer_instances[i].timer_counter > 0)
  40d040:	6863      	ldr	r3, [r4, #4]
			{
				if (--timer_instances[i].timer_counter == 0)
  40d042:	1e5a      	subs	r2, r3, #1
			if (timer_instances[i].timer_counter > 0)
  40d044:	b123      	cbz	r3, 40d050 <sph_timer_handler+0x1c>
				if (--timer_instances[i].timer_counter == 0)
  40d046:	6062      	str	r2, [r4, #4]
  40d048:	b912      	cbnz	r2, 40d050 <sph_timer_handler+0x1c>
				{
					//timer rolled over
					if (timer_instances[i].stop_handler)
  40d04a:	6923      	ldr	r3, [r4, #16]
  40d04c:	b103      	cbz	r3, 40d050 <sph_timer_handler+0x1c>
					{
						timer_instances[i].stop_handler();
  40d04e:	4798      	blx	r3
  40d050:	3414      	adds	r4, #20
	for (i=0; i<TIMERS_COUNT; i++)
  40d052:	42ac      	cmp	r4, r5
  40d054:	d1f2      	bne.n	40d03c <sph_timer_handler+0x8>
			}
					
		}
	}
		
}
  40d056:	bd38      	pop	{r3, r4, r5, pc}
  40d058:	20406124 	.word	0x20406124

0040d05c <sph_timer_add>:

uint32_t sph_timer_add(uint32_t *timer_val, uint16_t timer_multiplier, void ( *start_handler ) (void), void ( *stop_handler )  (void) )
{
  40d05c:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t i = 0;
	
	if(timer_multiplier == 0) timer_multiplier = 1;
  40d05e:	2400      	movs	r4, #0
{
  40d060:	4607      	mov	r7, r0
  40d062:	4e0c      	ldr	r6, [pc, #48]	; (40d094 <sph_timer_add+0x38>)
	if(timer_multiplier == 0) timer_multiplier = 1;
  40d064:	42a1      	cmp	r1, r4
  40d066:	bf08      	it	eq
  40d068:	2101      	moveq	r1, #1
	for (i=0; i<TIMERS_COUNT; i++)
  40d06a:	4620      	mov	r0, r4
	{
		if (timer_instances[i].timer_val == 0)
  40d06c:	5935      	ldr	r5, [r6, r4]
  40d06e:	3414      	adds	r4, #20
  40d070:	b135      	cbz	r5, 40d080 <sph_timer_add+0x24>
	for (i=0; i<TIMERS_COUNT; i++)
  40d072:	3001      	adds	r0, #1
  40d074:	280f      	cmp	r0, #15
  40d076:	d1f9      	bne.n	40d06c <sph_timer_add+0x10>
			timer_instances[i].stop_handler = stop_handler;
			return i;
		}
	}
	// no empty timer space found
	return 0xFFFFFFFF;
  40d078:	f04f 30ff 	mov.w	r0, #4294967295
}
  40d07c:	bcf0      	pop	{r4, r5, r6, r7}
  40d07e:	4770      	bx	lr
			timer_instances[i].timer_val = timer_val;
  40d080:	eb00 0480 	add.w	r4, r0, r0, lsl #2
  40d084:	00a4      	lsls	r4, r4, #2
  40d086:	1935      	adds	r5, r6, r4
  40d088:	5137      	str	r7, [r6, r4]
			timer_instances[i].timer_multiplier = timer_multiplier;
  40d08a:	8129      	strh	r1, [r5, #8]
			timer_instances[i].start_handler = start_handler;
  40d08c:	60ea      	str	r2, [r5, #12]
			timer_instances[i].stop_handler = stop_handler;
  40d08e:	612b      	str	r3, [r5, #16]
}
  40d090:	bcf0      	pop	{r4, r5, r6, r7}
  40d092:	4770      	bx	lr
  40d094:	20406124 	.word	0x20406124

0040d098 <sph_timer_reset>:
	}
}

void sph_timer_reset(uint32_t timer_indx)
{
	if (timer_indx < TIMERS_COUNT)
  40d098:	280e      	cmp	r0, #14
  40d09a:	d815      	bhi.n	40d0c8 <sph_timer_reset+0x30>
{
  40d09c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	{
		//there might be a timer there
		if (timer_instances[timer_indx].timer_val)
  40d09e:	0087      	lsls	r7, r0, #2
  40d0a0:	4d0a      	ldr	r5, [pc, #40]	; (40d0cc <sph_timer_reset+0x34>)
  40d0a2:	183e      	adds	r6, r7, r0
  40d0a4:	00b6      	lsls	r6, r6, #2
  40d0a6:	59ab      	ldr	r3, [r5, r6]
  40d0a8:	19aa      	adds	r2, r5, r6
  40d0aa:	b163      	cbz	r3, 40d0c6 <sph_timer_reset+0x2e>
		{
			if(timer_instances[timer_indx].start_handler) timer_instances[timer_indx].start_handler();
  40d0ac:	68d2      	ldr	r2, [r2, #12]
  40d0ae:	4604      	mov	r4, r0
  40d0b0:	b10a      	cbz	r2, 40d0b6 <sph_timer_reset+0x1e>
  40d0b2:	4790      	blx	r2
  40d0b4:	59ab      	ldr	r3, [r5, r6]
			timer_instances[timer_indx].timer_counter = *timer_instances[timer_indx].timer_val;
			timer_instances[timer_indx].timer_counter *= timer_instances[timer_indx].timer_multiplier;
  40d0b6:	1938      	adds	r0, r7, r4
			timer_instances[timer_indx].timer_counter = *timer_instances[timer_indx].timer_val;
  40d0b8:	781a      	ldrb	r2, [r3, #0]
			timer_instances[timer_indx].timer_counter *= timer_instances[timer_indx].timer_multiplier;
  40d0ba:	eb05 0580 	add.w	r5, r5, r0, lsl #2
  40d0be:	892b      	ldrh	r3, [r5, #8]
  40d0c0:	fb03 f302 	mul.w	r3, r3, r2
  40d0c4:	606b      	str	r3, [r5, #4]
  40d0c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40d0c8:	4770      	bx	lr
  40d0ca:	bf00      	nop
  40d0cc:	20406124 	.word	0x20406124

0040d0d0 <dac_interface_init>:




void dac_interface_init(void)
{
  40d0d0:	b570      	push	{r4, r5, r6, lr}
	pmc_enable_periph_clk(ID_DACC);
	
	/* Reset DACC registers */
	dacc_reset(DACC);
  40d0d2:	4c0c      	ldr	r4, [pc, #48]	; (40d104 <dac_interface_init+0x34>)
	pmc_enable_periph_clk(ID_DACC);
  40d0d4:	201e      	movs	r0, #30
  40d0d6:	4b0c      	ldr	r3, [pc, #48]	; (40d108 <dac_interface_init+0x38>)
  40d0d8:	4798      	blx	r3
	dacc_reset(DACC);
  40d0da:	4620      	mov	r0, r4
  40d0dc:	4b0b      	ldr	r3, [pc, #44]	; (40d10c <dac_interface_init+0x3c>)
  40d0de:	4798      	blx	r3
	/* Half word transfer mode */
	dacc_set_transfer_mode(DACC, 0);
  40d0e0:	4b0b      	ldr	r3, [pc, #44]	; (40d110 <dac_interface_init+0x40>)
  40d0e2:	4620      	mov	r0, r4
  40d0e4:	2100      	movs	r1, #0
  40d0e6:	4798      	blx	r3
	
	
	/* Enable output channel DACC_CHANNEL */
	dacc_enable_channel(DACC, 0);
  40d0e8:	4d0a      	ldr	r5, [pc, #40]	; (40d114 <dac_interface_init+0x44>)
  40d0ea:	4620      	mov	r0, r4
  40d0ec:	2100      	movs	r1, #0
  40d0ee:	47a8      	blx	r5
	dacc_enable_channel(DACC, 1);
  40d0f0:	4620      	mov	r0, r4
  40d0f2:	2101      	movs	r1, #1
  40d0f4:	47a8      	blx	r5
	
	/* Set up analog current */
	dacc_set_analog_control(DACC, DACC_ANALOG_CONTROL);
  40d0f6:	4620      	mov	r0, r4
  40d0f8:	210a      	movs	r1, #10
  40d0fa:	4b07      	ldr	r3, [pc, #28]	; (40d118 <dac_interface_init+0x48>)
}
  40d0fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	dacc_set_analog_control(DACC, DACC_ANALOG_CONTROL);
  40d100:	4718      	bx	r3
  40d102:	bf00      	nop
  40d104:	40040000 	.word	0x40040000
  40d108:	00417a25 	.word	0x00417a25
  40d10c:	004178f1 	.word	0x004178f1
  40d110:	004178f9 	.word	0x004178f9
  40d114:	00417901 	.word	0x00417901
  40d118:	00417919 	.word	0x00417919

0040d11c <SdCmd>:
    SID = DData & 0x01;  SCLK= 1;  SCLK= 0;
    _CS1 = 1;
}
#else
void SdCmd(uByte_t Command)       //send command
{
  40d11c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    Wr(1);
  40d120:	4e17      	ldr	r6, [pc, #92]	; (40d180 <SdCmd+0x64>)
{
  40d122:	4607      	mov	r7, r0
    Rd(1);
  40d124:	4d17      	ldr	r5, [pc, #92]	; (40d184 <SdCmd+0x68>)
    Wr(1);
  40d126:	2201      	movs	r2, #1
  40d128:	4c17      	ldr	r4, [pc, #92]	; (40d188 <SdCmd+0x6c>)
  40d12a:	4630      	mov	r0, r6
  40d12c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40d130:	47a0      	blx	r4
    Rd(1);
  40d132:	4628      	mov	r0, r5
  40d134:	2201      	movs	r2, #1
  40d136:	f44f 6100 	mov.w	r1, #2048	; 0x800
  40d13a:	47a0      	blx	r4
    A0(0);
  40d13c:	4628      	mov	r0, r5
  40d13e:	2200      	movs	r2, #0
  40d140:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
  40d144:	47a0      	blx	r4
    _CS1(0);
  40d146:	4628      	mov	r0, r5
  40d148:	2200      	movs	r2, #0
  40d14a:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  40d14e:	47a0      	blx	r4
    //delay_ms(1);
    lc_out(Command);
  40d150:	2301      	movs	r3, #1
  40d152:	463a      	mov	r2, r7
  40d154:	21ff      	movs	r1, #255	; 0xff
  40d156:	480d      	ldr	r0, [pc, #52]	; (40d18c <SdCmd+0x70>)
  40d158:	4f0d      	ldr	r7, [pc, #52]	; (40d190 <SdCmd+0x74>)
  40d15a:	47b8      	blx	r7
	//lc_out(0xaa);
    Wr(0);
  40d15c:	4630      	mov	r0, r6
  40d15e:	2200      	movs	r2, #0
  40d160:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40d164:	47a0      	blx	r4
    Wr(1); 
  40d166:	4630      	mov	r0, r6
  40d168:	2201      	movs	r2, #1
  40d16a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40d16e:	47a0      	blx	r4
    _CS1(1);
  40d170:	4628      	mov	r0, r5
  40d172:	4623      	mov	r3, r4
  40d174:	2201      	movs	r2, #1
  40d176:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
}
  40d17a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _CS1(1);
  40d17e:	4718      	bx	r3
  40d180:	400e1400 	.word	0x400e1400
  40d184:	400e0e00 	.word	0x400e0e00
  40d188:	0040d2b9 	.word	0x0040d2b9
  40d18c:	400e1200 	.word	0x400e1200
  40d190:	0040d2c5 	.word	0x0040d2c5

0040d194 <SdData>:
void SdData(uByte_t DData)        //send data
{
  40d194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    Wr(1);
  40d198:	4e17      	ldr	r6, [pc, #92]	; (40d1f8 <SdData+0x64>)
{
  40d19a:	4607      	mov	r7, r0
    Rd(1);
  40d19c:	4d17      	ldr	r5, [pc, #92]	; (40d1fc <SdData+0x68>)
    Wr(1);
  40d19e:	2201      	movs	r2, #1
  40d1a0:	4c17      	ldr	r4, [pc, #92]	; (40d200 <SdData+0x6c>)
  40d1a2:	4630      	mov	r0, r6
  40d1a4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40d1a8:	47a0      	blx	r4
    Rd(1);
  40d1aa:	4628      	mov	r0, r5
  40d1ac:	2201      	movs	r2, #1
  40d1ae:	f44f 6100 	mov.w	r1, #2048	; 0x800
  40d1b2:	47a0      	blx	r4
    A0(1);
  40d1b4:	4628      	mov	r0, r5
  40d1b6:	2201      	movs	r2, #1
  40d1b8:	f04f 6180 	mov.w	r1, #67108864	; 0x4000000
  40d1bc:	47a0      	blx	r4
    _CS1(0);
  40d1be:	4628      	mov	r0, r5
  40d1c0:	2200      	movs	r2, #0
  40d1c2:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  40d1c6:	47a0      	blx	r4
    lc_out(DData);
  40d1c8:	2301      	movs	r3, #1
  40d1ca:	463a      	mov	r2, r7
  40d1cc:	21ff      	movs	r1, #255	; 0xff
  40d1ce:	480d      	ldr	r0, [pc, #52]	; (40d204 <SdData+0x70>)
  40d1d0:	4f0d      	ldr	r7, [pc, #52]	; (40d208 <SdData+0x74>)
  40d1d2:	47b8      	blx	r7
    Wr(0);
  40d1d4:	4630      	mov	r0, r6
  40d1d6:	2200      	movs	r2, #0
  40d1d8:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40d1dc:	47a0      	blx	r4
    Wr(1);
  40d1de:	4630      	mov	r0, r6
  40d1e0:	2201      	movs	r2, #1
  40d1e2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  40d1e6:	47a0      	blx	r4
    _CS1(1);
  40d1e8:	4628      	mov	r0, r5
  40d1ea:	4623      	mov	r3, r4
  40d1ec:	2201      	movs	r2, #1
  40d1ee:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
}
  40d1f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _CS1(1);
  40d1f6:	4718      	bx	r3
  40d1f8:	400e1400 	.word	0x400e1400
  40d1fc:	400e0e00 	.word	0x400e0e00
  40d200:	0040d2b9 	.word	0x0040d2b9
  40d204:	400e1200 	.word	0x400e1200
  40d208:	0040d2c5 	.word	0x0040d2c5

0040d20c <init_glcd>:
    ContrastLevel=contrast; 
	SdCmd(0x81);            // E-Vol setting
    SdCmd(ContrastLevel);   // (2byte command)
}
void init_glcd(void)
{
  40d20c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    BKL(1);
  40d210:	4d20      	ldr	r5, [pc, #128]	; (40d294 <init_glcd+0x88>)
  40d212:	2201      	movs	r2, #1
  40d214:	4c20      	ldr	r4, [pc, #128]	; (40d298 <init_glcd+0x8c>)
  40d216:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
    _RST(1);                 // hardware reset LCD module
    delay_ms(10);
  40d21a:	4f20      	ldr	r7, [pc, #128]	; (40d29c <init_glcd+0x90>)
    BKL(1);
  40d21c:	4628      	mov	r0, r5
  40d21e:	47a0      	blx	r4
    _RST(1);                 // hardware reset LCD module
  40d220:	4628      	mov	r0, r5
  40d222:	2201      	movs	r2, #1
  40d224:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  40d228:	47a0      	blx	r4
    delay_ms(10);
  40d22a:	4e1d      	ldr	r6, [pc, #116]	; (40d2a0 <init_glcd+0x94>)
  40d22c:	4638      	mov	r0, r7
    _RST(0);
    delay_ms(10);
    _RST(1);
    delay_ms(10);
        
    ContrastLevel=0x17;     // default Contrast Level
  40d22e:	f8df 8078 	ldr.w	r8, [pc, #120]	; 40d2a8 <init_glcd+0x9c>
    delay_ms(10);
  40d232:	47b0      	blx	r6
    _RST(0);
  40d234:	4628      	mov	r0, r5
  40d236:	2200      	movs	r2, #0
  40d238:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  40d23c:	47a0      	blx	r4
    delay_ms(10);
  40d23e:	4638      	mov	r0, r7
  40d240:	47b0      	blx	r6
    _RST(1);
  40d242:	2201      	movs	r2, #1
  40d244:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  40d248:	4628      	mov	r0, r5
  40d24a:	47a0      	blx	r4
    delay_ms(10);
  40d24c:	4638      	mov	r0, r7
  40d24e:	47b0      	blx	r6
    ContrastLevel=0x17;     // default Contrast Level
  40d250:	2317      	movs	r3, #23
    
	SdCmd(0xaf);            // display on
  40d252:	4c14      	ldr	r4, [pc, #80]	; (40d2a4 <init_glcd+0x98>)
  40d254:	20af      	movs	r0, #175	; 0xaf
    ContrastLevel=0x17;     // default Contrast Level
  40d256:	f888 3000 	strb.w	r3, [r8]
	SdCmd(0xaf);            // display on
  40d25a:	47a0      	blx	r4
	SdCmd(0x40);            // display start line=0
  40d25c:	2040      	movs	r0, #64	; 0x40
  40d25e:	47a0      	blx	r4
    SdCmd(0xa0);            // ADC=0
  40d260:	20a0      	movs	r0, #160	; 0xa0
  40d262:	47a0      	blx	r4
    SdCmd(0xa6);            // normal display
  40d264:	20a6      	movs	r0, #166	; 0xa6
  40d266:	47a0      	blx	r4
    SdCmd(0xa4);            // Display all point = off
  40d268:	20a4      	movs	r0, #164	; 0xa4
  40d26a:	47a0      	blx	r4
    
    SdCmd(0xa2);            // LCD bias = 1/9
  40d26c:	20a2      	movs	r0, #162	; 0xa2
  40d26e:	47a0      	blx	r4
    SdCmd(0xc8);            // Common output mode select= reverse
  40d270:	20c8      	movs	r0, #200	; 0xc8
  40d272:	47a0      	blx	r4


    SdCmd(0x2f);            // Power control = all on
  40d274:	202f      	movs	r0, #47	; 0x2f
  40d276:	47a0      	blx	r4

   	SdCmd(0x25);			// RA/RB setting
  40d278:	2025      	movs	r0, #37	; 0x25
  40d27a:	47a0      	blx	r4

   	SdCmd(0xf8);SdCmd(0x00);// Booster Ratio Set= 2x,3x,4x (2byte command)
  40d27c:	20f8      	movs	r0, #248	; 0xf8
  40d27e:	47a0      	blx	r4
  40d280:	2000      	movs	r0, #0
  40d282:	47a0      	blx	r4

	SdCmd(0x81);            // E-Vol setting
  40d284:	2081      	movs	r0, #129	; 0x81
  40d286:	47a0      	blx	r4
    SdCmd(ContrastLevel);   // (2byte command)
  40d288:	f898 0000 	ldrb.w	r0, [r8]
  40d28c:	4623      	mov	r3, r4
}
  40d28e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    SdCmd(ContrastLevel);   // (2byte command)
  40d292:	4718      	bx	r3
  40d294:	400e1400 	.word	0x400e1400
  40d298:	0040d2b9 	.word	0x0040d2b9
  40d29c:	0007b784 	.word	0x0007b784
  40d2a0:	20400001 	.word	0x20400001
  40d2a4:	0040d11d 	.word	0x0040d11d
  40d2a8:	20406250 	.word	0x20406250

0040d2ac <pio_set_lc_writeProtect>:

#include <GIO.h>
uint32_t lc_writeP = 0;
void pio_set_lc_writeProtect(void)
{
	lc_writeP = 1;
  40d2ac:	4b01      	ldr	r3, [pc, #4]	; (40d2b4 <pio_set_lc_writeProtect+0x8>)
  40d2ae:	2201      	movs	r2, #1
  40d2b0:	601a      	str	r2, [r3, #0]
  40d2b2:	4770      	bx	lr
  40d2b4:	20400908 	.word	0x20400908

0040d2b8 <pio_set_data>:
}
void pio_set_data(Pio *p_pio, const uint32_t ul_mask, uint32_t ul_data)
{
	//pio_set_writeprotect(PIOC, 0);
	if (ul_data==1)
  40d2b8:	2a01      	cmp	r2, #1
  40d2ba:	d001      	beq.n	40d2c0 <pio_set_data+0x8>
	{
		p_pio->PIO_SODR = ul_mask;
	}
	else
	{
		p_pio->PIO_CODR = ul_mask;
  40d2bc:	6341      	str	r1, [r0, #52]	; 0x34
  40d2be:	4770      	bx	lr
		p_pio->PIO_SODR = ul_mask;
  40d2c0:	6301      	str	r1, [r0, #48]	; 0x30
  40d2c2:	4770      	bx	lr

0040d2c4 <pio_out_data>:
	}
	//if (lc_writeP) pio_set_writeprotect(PIOC, 1);
};
void pio_out_data(Pio *p_pio, uint32_t ul_mask, uint32_t ul_data, const uint32_t shift)
{
  40d2c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40d2c8:	461f      	mov	r7, r3
  40d2ca:	460c      	mov	r4, r1
  40d2cc:	4605      	mov	r5, r0
	pio_set_writeprotect(PIOC, 0);
  40d2ce:	2100      	movs	r1, #0
	
	p_pio->PIO_OWER = (ul_mask << shift);
  40d2d0:	40bc      	lsls	r4, r7
	pio_set_writeprotect(PIOC, 0);
  40d2d2:	480d      	ldr	r0, [pc, #52]	; (40d308 <pio_out_data+0x44>)
  40d2d4:	f8df 8038 	ldr.w	r8, [pc, #56]	; 40d310 <pio_out_data+0x4c>
{
  40d2d8:	4616      	mov	r6, r2
	pio_set_writeprotect(PIOC, 0);
  40d2da:	47c0      	blx	r8
	p_pio->PIO_OWER = (ul_mask << shift);
  40d2dc:	f8c5 40a0 	str.w	r4, [r5, #160]	; 0xa0
	p_pio->PIO_ODSR = (p_pio->PIO_ODSR & ~(ul_mask << shift))|(ul_data << shift);
  40d2e0:	6bab      	ldr	r3, [r5, #56]	; 0x38
  40d2e2:	40be      	lsls	r6, r7
	p_pio->PIO_OWDR = (ul_mask << shift);
	
	if (lc_writeP) pio_set_writeprotect(PIOC, 1);
  40d2e4:	4a09      	ldr	r2, [pc, #36]	; (40d30c <pio_out_data+0x48>)
	p_pio->PIO_ODSR = (p_pio->PIO_ODSR & ~(ul_mask << shift))|(ul_data << shift);
  40d2e6:	ea23 0304 	bic.w	r3, r3, r4
	if (lc_writeP) pio_set_writeprotect(PIOC, 1);
  40d2ea:	6812      	ldr	r2, [r2, #0]
	p_pio->PIO_ODSR = (p_pio->PIO_ODSR & ~(ul_mask << shift))|(ul_data << shift);
  40d2ec:	4333      	orrs	r3, r6
  40d2ee:	63ab      	str	r3, [r5, #56]	; 0x38
	p_pio->PIO_OWDR = (ul_mask << shift);
  40d2f0:	f8c5 40a4 	str.w	r4, [r5, #164]	; 0xa4
	if (lc_writeP) pio_set_writeprotect(PIOC, 1);
  40d2f4:	b90a      	cbnz	r2, 40d2fa <pio_out_data+0x36>
  40d2f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40d2fa:	4643      	mov	r3, r8
  40d2fc:	2101      	movs	r1, #1
  40d2fe:	4802      	ldr	r0, [pc, #8]	; (40d308 <pio_out_data+0x44>)
  40d300:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	if (lc_writeP) pio_set_writeprotect(PIOC, 1);
  40d304:	4718      	bx	r3
  40d306:	bf00      	nop
  40d308:	400e1200 	.word	0x400e1200
  40d30c:	20400908 	.word	0x20400908
  40d310:	00417551 	.word	0x00417551

0040d314 <io_interface_init>:
#define IO_Y7(x) ioport_set_pin_level(IOPORT_CREATE_PIN(PIOD, 25), x)
#define IO_Y8(x) ioport_set_pin_level(IOPORT_CREATE_PIN(PIOA, 27), x)


void io_interface_init(void)
{	
  40d314:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	//Set relay yERS pin out low
	pio_set_output(PIOB, PIO_PB2, LOW, DISABLE, ENABLE);
  40d318:	2300      	movs	r3, #0
{	
  40d31a:	b082      	sub	sp, #8
	pio_set_output(PIOB, PIO_PB2, LOW, DISABLE, ENABLE);
  40d31c:	2401      	movs	r4, #1
  40d31e:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 40d3c4 <io_interface_init+0xb0>
  40d322:	4f21      	ldr	r7, [pc, #132]	; (40d3a8 <io_interface_init+0x94>)
  40d324:	461a      	mov	r2, r3
  40d326:	4650      	mov	r0, sl
  40d328:	2104      	movs	r1, #4
  40d32a:	9400      	str	r4, [sp, #0]
  40d32c:	47b8      	blx	r7
	//Set relay y0,y7,y4 pin out low
	pio_set_output(PIOA, PIO_PA12|PIO_PA27, LOW, DISABLE, ENABLE);
  40d32e:	4e1f      	ldr	r6, [pc, #124]	; (40d3ac <io_interface_init+0x98>)
  40d330:	2300      	movs	r3, #0
  40d332:	9400      	str	r4, [sp, #0]
  40d334:	4630      	mov	r0, r6
  40d336:	491e      	ldr	r1, [pc, #120]	; (40d3b0 <io_interface_init+0x9c>)
  40d338:	461a      	mov	r2, r3
	//Set relay y1,y3,y4,y6 pin out low
	pio_set_output(PIOD, PIO_PD13|PIO_PD20|PIO_PD25|PIO_PD26, LOW, DISABLE, ENABLE);
  40d33a:	f8df 808c 	ldr.w	r8, [pc, #140]	; 40d3c8 <io_interface_init+0xb4>
	pio_set_output(PIOA, PIO_PA12|PIO_PA27, LOW, DISABLE, ENABLE);
  40d33e:	47b8      	blx	r7
	pio_set_output(PIOD, PIO_PD13|PIO_PD20|PIO_PD25|PIO_PD26, LOW, DISABLE, ENABLE);
  40d340:	2300      	movs	r3, #0
  40d342:	4640      	mov	r0, r8
  40d344:	9400      	str	r4, [sp, #0]
  40d346:	461a      	mov	r2, r3
  40d348:	491a      	ldr	r1, [pc, #104]	; (40d3b4 <io_interface_init+0xa0>)
  40d34a:	47b8      	blx	r7
	//Set relay Y2,Y4,Y5 pin out low
	pio_set_output(PIOC, PIO_PC10|PIO_PC9, LOW, DISABLE, ENABLE);
  40d34c:	f8df 907c 	ldr.w	r9, [pc, #124]	; 40d3cc <io_interface_init+0xb8>
  40d350:	2300      	movs	r3, #0
  40d352:	9400      	str	r4, [sp, #0]
  40d354:	4648      	mov	r0, r9
  40d356:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  40d35a:	461a      	mov	r2, r3
	//pio_set_output(PIOE, PIO_PE5, LOW, DISABLE, ENABLE);
	
	//set direct inputs pins
	pio_set_input(PIOA, PIO_PA14|PIO_PA15|PIO_PA23, PIO_PULLUP);
  40d35c:	4d16      	ldr	r5, [pc, #88]	; (40d3b8 <io_interface_init+0xa4>)
	pio_set_output(PIOC, PIO_PC10|PIO_PC9, LOW, DISABLE, ENABLE);
  40d35e:	47b8      	blx	r7
	pio_set_input(PIOA, PIO_PA14|PIO_PA15|PIO_PA23, PIO_PULLUP);
  40d360:	4622      	mov	r2, r4
  40d362:	4630      	mov	r0, r6
  40d364:	4915      	ldr	r1, [pc, #84]	; (40d3bc <io_interface_init+0xa8>)
  40d366:	47a8      	blx	r5
	pio_set_input(PIOB, PIO_PB3, PIO_PULLUP);
  40d368:	4622      	mov	r2, r4
  40d36a:	4650      	mov	r0, sl
  40d36c:	2108      	movs	r1, #8
  40d36e:	47a8      	blx	r5
	pio_set_input(PIOD, PIO_PD24|PIO_PD27, PIO_PULLUP);
  40d370:	4622      	mov	r2, r4
  40d372:	4640      	mov	r0, r8
  40d374:	f04f 6110 	mov.w	r1, #150994944	; 0x9000000
  40d378:	47a8      	blx	r5
	
	//set direct phase failure pins
	pio_set_input(PIOD, PIO_PD7, PIO_PULLUP);
  40d37a:	4622      	mov	r2, r4
  40d37c:	4640      	mov	r0, r8
  40d37e:	2180      	movs	r1, #128	; 0x80
  40d380:	47a8      	blx	r5
	pio_set_input(PIOA, PIO_PA28, PIO_PULLUP);
  40d382:	4622      	mov	r2, r4
  40d384:	4630      	mov	r0, r6
  40d386:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  40d38a:	47a8      	blx	r5
	pio_set_input(PIOC, PIO_PC18, PIO_PULLUP);
  40d38c:	4622      	mov	r2, r4
  40d38e:	4648      	mov	r0, r9
  40d390:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  40d394:	47a8      	blx	r5
	
	//set shift registers interface pins
	// HOIST1, HOIST0, HOIST2
	pio_set_input(PIOA, PIO_PA13|PIO_PA18|PIO_PA22, PIO_PULLUP);
  40d396:	4622      	mov	r2, r4
  40d398:	4630      	mov	r0, r6
  40d39a:	4909      	ldr	r1, [pc, #36]	; (40d3c0 <io_interface_init+0xac>)
  40d39c:	462b      	mov	r3, r5
} 
  40d39e:	b002      	add	sp, #8
  40d3a0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	pio_set_input(PIOA, PIO_PA13|PIO_PA18|PIO_PA22, PIO_PULLUP);
  40d3a4:	4718      	bx	r3
  40d3a6:	bf00      	nop
  40d3a8:	00417515 	.word	0x00417515
  40d3ac:	400e0e00 	.word	0x400e0e00
  40d3b0:	08001000 	.word	0x08001000
  40d3b4:	06102000 	.word	0x06102000
  40d3b8:	004174dd 	.word	0x004174dd
  40d3bc:	0080c000 	.word	0x0080c000
  40d3c0:	00442000 	.word	0x00442000
  40d3c4:	400e1000 	.word	0x400e1000
  40d3c8:	400e1400 	.word	0x400e1400
  40d3cc:	400e1200 	.word	0x400e1200

0040d3d0 <io_interface_integrate_enableIputs>:
  40d3d0:	4b0f      	ldr	r3, [pc, #60]	; (40d410 <io_interface_integrate_enableIputs+0x40>)
  40d3d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
#define IO_INTERFACE_INPUTCOUNT (24 + IO_INTERFACE_INPUTOFFSET)
char io_interface_filters[IO_INTERFACE_INPUTCOUNT + 5];

void io_interface_integrate_enableIputs(void)
{
	if (IO_X1)
  40d3d4:	f013 0f08 	tst.w	r3, #8
	{
		if (io_interface_filters[28] > 0)
  40d3d8:	4b0e      	ldr	r3, [pc, #56]	; (40d414 <io_interface_integrate_enableIputs+0x44>)
  40d3da:	7f1a      	ldrb	r2, [r3, #28]
	if (IO_X1)
  40d3dc:	d00f      	beq.n	40d3fe <io_interface_integrate_enableIputs+0x2e>
		if (io_interface_filters[28] > 0)
  40d3de:	b99a      	cbnz	r2, 40d408 <io_interface_integrate_enableIputs+0x38>
  40d3e0:	4a0d      	ldr	r2, [pc, #52]	; (40d418 <io_interface_integrate_enableIputs+0x48>)
  40d3e2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
		if (io_interface_filters[28] < IO_INTERFACE_FILTER_MAX)
		{
			io_interface_filters[28]++;
		}
	}
	if (IO_X2)
  40d3e4:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
	{
		if (io_interface_filters[29] > 0)
  40d3e8:	7f5a      	ldrb	r2, [r3, #29]
	if (IO_X2)
  40d3ea:	d003      	beq.n	40d3f4 <io_interface_integrate_enableIputs+0x24>
		if (io_interface_filters[29] > 0)
  40d3ec:	b132      	cbz	r2, 40d3fc <io_interface_integrate_enableIputs+0x2c>
		{
			io_interface_filters[29]--;
  40d3ee:	3a01      	subs	r2, #1
  40d3f0:	775a      	strb	r2, [r3, #29]
  40d3f2:	4770      	bx	lr
		}
	}
	else
	{
		if (io_interface_filters[29] < IO_INTERFACE_FILTER_MAX)
  40d3f4:	2a05      	cmp	r2, #5
  40d3f6:	d801      	bhi.n	40d3fc <io_interface_integrate_enableIputs+0x2c>
		{
			io_interface_filters[29]++;
  40d3f8:	3201      	adds	r2, #1
  40d3fa:	775a      	strb	r2, [r3, #29]
  40d3fc:	4770      	bx	lr
		if (io_interface_filters[28] < IO_INTERFACE_FILTER_MAX)
  40d3fe:	2a05      	cmp	r2, #5
  40d400:	d8ee      	bhi.n	40d3e0 <io_interface_integrate_enableIputs+0x10>
			io_interface_filters[28]++;
  40d402:	3201      	adds	r2, #1
  40d404:	771a      	strb	r2, [r3, #28]
  40d406:	e7eb      	b.n	40d3e0 <io_interface_integrate_enableIputs+0x10>
			io_interface_filters[28]--;
  40d408:	3a01      	subs	r2, #1
  40d40a:	771a      	strb	r2, [r3, #28]
  40d40c:	e7e8      	b.n	40d3e0 <io_interface_integrate_enableIputs+0x10>
  40d40e:	bf00      	nop
  40d410:	400e1000 	.word	0x400e1000
  40d414:	20406254 	.word	0x20406254
  40d418:	400e1400 	.word	0x400e1400

0040d41c <io_interface_integrate_iputs>:
		}
	}	
}

void io_interface_integrate_iputs(void)
{
  40d41c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40d420:	4b3b      	ldr	r3, [pc, #236]	; (40d510 <io_interface_integrate_iputs+0xf4>)
  40d422:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	uint32_t i;	
	if (IO_X3)
  40d424:	f413 4f80 	tst.w	r3, #16384	; 0x4000
	{
		if (io_interface_filters[0] > 0)
  40d428:	4b3a      	ldr	r3, [pc, #232]	; (40d514 <io_interface_integrate_iputs+0xf8>)
  40d42a:	781a      	ldrb	r2, [r3, #0]
	if (IO_X3)
  40d42c:	d05e      	beq.n	40d4ec <io_interface_integrate_iputs+0xd0>
		if (io_interface_filters[0] > 0)
  40d42e:	2a00      	cmp	r2, #0
  40d430:	d16a      	bne.n	40d508 <io_interface_integrate_iputs+0xec>
  40d432:	4a37      	ldr	r2, [pc, #220]	; (40d510 <io_interface_integrate_iputs+0xf4>)
  40d434:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
		{
			io_interface_filters[0]++;
		}
	}
	
	if (IO_X4)
  40d436:	f412 4f00 	tst.w	r2, #32768	; 0x8000
	{
		if (io_interface_filters[1] > 0)
  40d43a:	785a      	ldrb	r2, [r3, #1]
	if (IO_X4)
  40d43c:	d051      	beq.n	40d4e2 <io_interface_integrate_iputs+0xc6>
		if (io_interface_filters[1] > 0)
  40d43e:	2a00      	cmp	r2, #0
  40d440:	d15f      	bne.n	40d502 <io_interface_integrate_iputs+0xe6>
  40d442:	4a35      	ldr	r2, [pc, #212]	; (40d518 <io_interface_integrate_iputs+0xfc>)
  40d444:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
		if (io_interface_filters[1] < IO_INTERFACE_FILTER_MAX)
		{
			io_interface_filters[1]++;
		}
	}
	if (IO_X5)
  40d446:	f012 6f00 	tst.w	r2, #134217728	; 0x8000000
	{
		if (io_interface_filters[2] > 0)
  40d44a:	789a      	ldrb	r2, [r3, #2]
	if (IO_X5)
  40d44c:	d044      	beq.n	40d4d8 <io_interface_integrate_iputs+0xbc>
		if (io_interface_filters[2] > 0)
  40d44e:	2a00      	cmp	r2, #0
  40d450:	d154      	bne.n	40d4fc <io_interface_integrate_iputs+0xe0>
  40d452:	4a2f      	ldr	r2, [pc, #188]	; (40d510 <io_interface_integrate_iputs+0xf4>)
  40d454:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
		if (io_interface_filters[2] < IO_INTERFACE_FILTER_MAX)
		{
			io_interface_filters[2]++;
		}
	}
	if (IO_X6)
  40d456:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
	{
		if (io_interface_filters[3] > 0)
  40d45a:	78da      	ldrb	r2, [r3, #3]
	if (IO_X6)
  40d45c:	d037      	beq.n	40d4ce <io_interface_integrate_iputs+0xb2>
		if (io_interface_filters[3] > 0)
  40d45e:	2a00      	cmp	r2, #0
  40d460:	d149      	bne.n	40d4f6 <io_interface_integrate_iputs+0xda>
  40d462:	4d2e      	ldr	r5, [pc, #184]	; (40d51c <io_interface_integrate_iputs+0x100>)
{
  40d464:	2407      	movs	r4, #7
  40d466:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 40d520 <io_interface_integrate_iputs+0x104>
  40d46a:	f105 0608 	add.w	r6, r5, #8
	pio_out_data(PIOC, 0x7, bit_add, 1);
  40d46e:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 40d524 <io_interface_integrate_iputs+0x108>
  40d472:	4f27      	ldr	r7, [pc, #156]	; (40d510 <io_interface_integrate_iputs+0xf4>)
  40d474:	e011      	b.n	40d49a <io_interface_integrate_iputs+0x7e>
	for (i=0; i<8; i++)
	{
		io_interface_add_out(7 - i);// set the address to read the targeted pin
		if (HOIST0)
		{
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (0 * 8)] < IO_INTERFACE_FILTER_MAX)
  40d476:	2b05      	cmp	r3, #5
  40d478:	d801      	bhi.n	40d47e <io_interface_integrate_iputs+0x62>
			{
				io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (0 * 8)]++;
  40d47a:	3301      	adds	r3, #1
  40d47c:	702b      	strb	r3, [r5, #0]
  40d47e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
			{
				io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (0 * 8)]--;
			}
		}
		
		if (HOIST1)
  40d480:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
		{
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (1 * 8)] < IO_INTERFACE_FILTER_MAX)
  40d484:	7833      	ldrb	r3, [r6, #0]
		if (HOIST1)
  40d486:	d01b      	beq.n	40d4c0 <io_interface_integrate_iputs+0xa4>
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (1 * 8)] < IO_INTERFACE_FILTER_MAX)
  40d488:	2b05      	cmp	r3, #5
  40d48a:	d801      	bhi.n	40d490 <io_interface_integrate_iputs+0x74>
			{
				io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (1 * 8)]++;
  40d48c:	3301      	adds	r3, #1
  40d48e:	7033      	strb	r3, [r6, #0]
  40d490:	3c01      	subs	r4, #1
  40d492:	3501      	adds	r5, #1
  40d494:	3601      	adds	r6, #1
	for (i=0; i<8; i++)
  40d496:	1c63      	adds	r3, r4, #1
  40d498:	d017      	beq.n	40d4ca <io_interface_integrate_iputs+0xae>
	pio_out_data(PIOC, 0x7, bit_add, 1);
  40d49a:	2301      	movs	r3, #1
  40d49c:	4622      	mov	r2, r4
  40d49e:	2107      	movs	r1, #7
  40d4a0:	4640      	mov	r0, r8
  40d4a2:	47c8      	blx	r9
  40d4a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
		if (HOIST0)
  40d4a6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (0 * 8)] < IO_INTERFACE_FILTER_MAX)
  40d4aa:	782b      	ldrb	r3, [r5, #0]
		if (HOIST0)
  40d4ac:	d1e3      	bne.n	40d476 <io_interface_integrate_iputs+0x5a>
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (0 * 8)] > 0)
  40d4ae:	2b00      	cmp	r3, #0
  40d4b0:	d0e5      	beq.n	40d47e <io_interface_integrate_iputs+0x62>
				io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (0 * 8)]--;
  40d4b2:	3b01      	subs	r3, #1
  40d4b4:	702b      	strb	r3, [r5, #0]
  40d4b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
		if (HOIST1)
  40d4b8:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (1 * 8)] < IO_INTERFACE_FILTER_MAX)
  40d4bc:	7833      	ldrb	r3, [r6, #0]
		if (HOIST1)
  40d4be:	d1e3      	bne.n	40d488 <io_interface_integrate_iputs+0x6c>
			}
		}
		else
		{
			if (io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (1 * 8)] > 0)
  40d4c0:	2b00      	cmp	r3, #0
  40d4c2:	d0e5      	beq.n	40d490 <io_interface_integrate_iputs+0x74>
			{
				io_interface_filters[i + IO_INTERFACE_INPUTOFFSET + (1 * 8)]--;
  40d4c4:	3b01      	subs	r3, #1
  40d4c6:	7033      	strb	r3, [r6, #0]
  40d4c8:	e7e2      	b.n	40d490 <io_interface_integrate_iputs+0x74>
			}
		}	
#endif
	}
		
}
  40d4ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (io_interface_filters[3] < IO_INTERFACE_FILTER_MAX)
  40d4ce:	2a05      	cmp	r2, #5
  40d4d0:	d8c7      	bhi.n	40d462 <io_interface_integrate_iputs+0x46>
			io_interface_filters[3]++;
  40d4d2:	3201      	adds	r2, #1
  40d4d4:	70da      	strb	r2, [r3, #3]
  40d4d6:	e7c4      	b.n	40d462 <io_interface_integrate_iputs+0x46>
		if (io_interface_filters[2] < IO_INTERFACE_FILTER_MAX)
  40d4d8:	2a05      	cmp	r2, #5
  40d4da:	d8ba      	bhi.n	40d452 <io_interface_integrate_iputs+0x36>
			io_interface_filters[2]++;
  40d4dc:	3201      	adds	r2, #1
  40d4de:	709a      	strb	r2, [r3, #2]
  40d4e0:	e7b7      	b.n	40d452 <io_interface_integrate_iputs+0x36>
		if (io_interface_filters[1] < IO_INTERFACE_FILTER_MAX)
  40d4e2:	2a05      	cmp	r2, #5
  40d4e4:	d8ad      	bhi.n	40d442 <io_interface_integrate_iputs+0x26>
			io_interface_filters[1]++;
  40d4e6:	3201      	adds	r2, #1
  40d4e8:	705a      	strb	r2, [r3, #1]
  40d4ea:	e7aa      	b.n	40d442 <io_interface_integrate_iputs+0x26>
		if (io_interface_filters[0] < IO_INTERFACE_FILTER_MAX)
  40d4ec:	2a05      	cmp	r2, #5
  40d4ee:	d8a0      	bhi.n	40d432 <io_interface_integrate_iputs+0x16>
			io_interface_filters[0]++;
  40d4f0:	3201      	adds	r2, #1
  40d4f2:	701a      	strb	r2, [r3, #0]
  40d4f4:	e79d      	b.n	40d432 <io_interface_integrate_iputs+0x16>
			io_interface_filters[3]--;
  40d4f6:	3a01      	subs	r2, #1
  40d4f8:	70da      	strb	r2, [r3, #3]
  40d4fa:	e7b2      	b.n	40d462 <io_interface_integrate_iputs+0x46>
			io_interface_filters[2]--;
  40d4fc:	3a01      	subs	r2, #1
  40d4fe:	709a      	strb	r2, [r3, #2]
  40d500:	e7a7      	b.n	40d452 <io_interface_integrate_iputs+0x36>
			io_interface_filters[1]--;
  40d502:	3a01      	subs	r2, #1
  40d504:	705a      	strb	r2, [r3, #1]
  40d506:	e79c      	b.n	40d442 <io_interface_integrate_iputs+0x26>
			io_interface_filters[0]--;
  40d508:	3a01      	subs	r2, #1
  40d50a:	701a      	strb	r2, [r3, #0]
  40d50c:	e791      	b.n	40d432 <io_interface_integrate_iputs+0x16>
  40d50e:	bf00      	nop
  40d510:	400e0e00 	.word	0x400e0e00
  40d514:	20406254 	.word	0x20406254
  40d518:	400e1400 	.word	0x400e1400
  40d51c:	20406258 	.word	0x20406258
  40d520:	0040d2c5 	.word	0x0040d2c5
  40d524:	400e1200 	.word	0x400e1200

0040d528 <io_interface_translateCritical>:
	uint64_t f_mask;
	for (i=IO_INTERFACE_INPUTCOUNT; i<(IO_INTERFACE_INPUTCOUNT + 2); i++)
	{
		f_mask = IO_INTERFACE_MASKER(i);
		io_interface_pre_readout1 = io_interface_readout1; // copy the previous register sample
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d528:	4839      	ldr	r0, [pc, #228]	; (40d610 <io_interface_translateCritical+0xe8>)
  40d52a:	493a      	ldr	r1, [pc, #232]	; (40d614 <io_interface_translateCritical+0xec>)
{
  40d52c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40d530:	4f39      	ldr	r7, [pc, #228]	; (40d618 <io_interface_translateCritical+0xf0>)
  40d532:	b083      	sub	sp, #12
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d534:	7f04      	ldrb	r4, [r0, #28]
		{
			//pin set detected
			//set the respective bit
			io_interface_readout1 |= f_mask;
			//check rising edge flag
			if (!(io_interface_pre_readout1 & f_mask))
  40d536:	2500      	movs	r5, #0
  40d538:	4e38      	ldr	r6, [pc, #224]	; (40d61c <io_interface_translateCritical+0xf4>)
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d53a:	2c03      	cmp	r4, #3
  40d53c:	e9d1 2300 	ldrd	r2, r3, [r1]
  40d540:	e9d7 8900 	ldrd	r8, r9, [r7]
  40d544:	e9d6 ab00 	ldrd	sl, fp, [r6]
  40d548:	e9cd 8900 	strd	r8, r9, [sp]
			if (!(io_interface_pre_readout1 & f_mask))
  40d54c:	f002 5480 	and.w	r4, r2, #268435456	; 0x10000000
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d550:	d828      	bhi.n	40d5a4 <io_interface_translateCritical+0x7c>
		}
		else
		{
			//pin clear detected
			//check falling edge flag
			if ((io_interface_pre_readout1 & f_mask))
  40d552:	432c      	orrs	r4, r5
  40d554:	d154      	bne.n	40d600 <io_interface_translateCritical+0xd8>
  40d556:	f04f 0e00 	mov.w	lr, #0
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d55a:	7f40      	ldrb	r0, [r0, #29]
				//set the respective falling edge bit
				io_interface_fall_readout1 |= f_mask;
			}
			//clear the respective bit
			f_mask = ~f_mask;
			io_interface_readout1 &= f_mask;
  40d55c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  40d560:	f04f 0c00 	mov.w	ip, #0
			if (!(io_interface_pre_readout1 & f_mask))
  40d564:	2500      	movs	r5, #0
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d566:	2803      	cmp	r0, #3
			if (!(io_interface_pre_readout1 & f_mask))
  40d568:	f002 5400 	and.w	r4, r2, #536870912	; 0x20000000
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d56c:	d827      	bhi.n	40d5be <io_interface_translateCritical+0x96>
			if ((io_interface_pre_readout1 & f_mask))
  40d56e:	ea54 0005 	orrs.w	r0, r4, r5
  40d572:	d003      	beq.n	40d57c <io_interface_translateCritical+0x54>
				io_interface_fall_readout1 |= f_mask;
  40d574:	f04a 5a00 	orr.w	sl, sl, #536870912	; 0x20000000
  40d578:	f04f 0e01 	mov.w	lr, #1
			io_interface_readout1 &= f_mask;
  40d57c:	f022 5400 	bic.w	r4, r2, #536870912	; 0x20000000
  40d580:	4699      	mov	r9, r3
  40d582:	46a0      	mov	r8, r4
  40d584:	4826      	ldr	r0, [pc, #152]	; (40d620 <io_interface_translateCritical+0xf8>)
  40d586:	4644      	mov	r4, r8
  40d588:	464d      	mov	r5, r9
  40d58a:	e9c0 2300 	strd	r2, r3, [r0]
  40d58e:	e9c1 4500 	strd	r4, r5, [r1]
  40d592:	f1bc 0f00 	cmp.w	ip, #0
  40d596:	d123      	bne.n	40d5e0 <io_interface_translateCritical+0xb8>
  40d598:	f1be 0f00 	cmp.w	lr, #0
  40d59c:	d135      	bne.n	40d60a <io_interface_translateCritical+0xe2>
		}
	}
	
}
  40d59e:	b003      	add	sp, #12
  40d5a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (!(io_interface_pre_readout1 & f_mask))
  40d5a4:	432c      	orrs	r4, r5
			io_interface_readout1 |= f_mask;
  40d5a6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
			if (!(io_interface_pre_readout1 & f_mask))
  40d5aa:	d01e      	beq.n	40d5ea <io_interface_translateCritical+0xc2>
  40d5ac:	f04f 0e00 	mov.w	lr, #0
  40d5b0:	46f4      	mov	ip, lr
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d5b2:	7f40      	ldrb	r0, [r0, #29]
			if (!(io_interface_pre_readout1 & f_mask))
  40d5b4:	f002 5400 	and.w	r4, r2, #536870912	; 0x20000000
  40d5b8:	2500      	movs	r5, #0
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d5ba:	2803      	cmp	r0, #3
  40d5bc:	d9d7      	bls.n	40d56e <io_interface_translateCritical+0x46>
			if (!(io_interface_pre_readout1 & f_mask))
  40d5be:	ea54 0005 	orrs.w	r0, r4, r5
			io_interface_readout1 |= f_mask;
  40d5c2:	f042 5800 	orr.w	r8, r2, #536870912	; 0x20000000
  40d5c6:	4699      	mov	r9, r3
			if (!(io_interface_pre_readout1 & f_mask))
  40d5c8:	d1dc      	bne.n	40d584 <io_interface_translateCritical+0x5c>
  40d5ca:	4815      	ldr	r0, [pc, #84]	; (40d620 <io_interface_translateCritical+0xf8>)
				io_interface_rise_readout1 |= f_mask;
  40d5cc:	e9dd 4500 	ldrd	r4, r5, [sp]
  40d5d0:	e9c1 8900 	strd	r8, r9, [r1]
  40d5d4:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
  40d5d8:	e9c0 2300 	strd	r2, r3, [r0]
  40d5dc:	e9cd 4500 	strd	r4, r5, [sp]
  40d5e0:	e9dd 3400 	ldrd	r3, r4, [sp]
  40d5e4:	e9c7 3400 	strd	r3, r4, [r7]
  40d5e8:	e7d6      	b.n	40d598 <io_interface_translateCritical+0x70>
  40d5ea:	e9dd 4500 	ldrd	r4, r5, [sp]
  40d5ee:	f04f 0e00 	mov.w	lr, #0
  40d5f2:	f04f 0c01 	mov.w	ip, #1
  40d5f6:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
  40d5fa:	e9cd 4500 	strd	r4, r5, [sp]
  40d5fe:	e7d8      	b.n	40d5b2 <io_interface_translateCritical+0x8a>
				io_interface_fall_readout1 |= f_mask;
  40d600:	f04a 5a80 	orr.w	sl, sl, #268435456	; 0x10000000
  40d604:	f04f 0e01 	mov.w	lr, #1
  40d608:	e7a7      	b.n	40d55a <io_interface_translateCritical+0x32>
  40d60a:	e9c6 ab00 	strd	sl, fp, [r6]
}
  40d60e:	e7c6      	b.n	40d59e <io_interface_translateCritical+0x76>
  40d610:	20406254 	.word	0x20406254
  40d614:	20400940 	.word	0x20400940
  40d618:	20400948 	.word	0x20400948
  40d61c:	20400930 	.word	0x20400930
  40d620:	20400938 	.word	0x20400938

0040d624 <io_interface_translate1>:
void io_interface_translate1(void)
{
  40d624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40d628:	4c36      	ldr	r4, [pc, #216]	; (40d704 <io_interface_translate1+0xe0>)
  40d62a:	b087      	sub	sp, #28
  40d62c:	2100      	movs	r1, #0
	uint32_t i, f_mask;
	for (i=0; i<IO_INTERFACE_INPUTCOUNT; i++)
	{
		f_mask = IO_INTERFACE_MASKER(i);
  40d62e:	2001      	movs	r0, #1
  40d630:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 40d714 <io_interface_translate1+0xf0>
  40d634:	9105      	str	r1, [sp, #20]
  40d636:	9104      	str	r1, [sp, #16]
  40d638:	e9d4 4500 	ldrd	r4, r5, [r4]
  40d63c:	e9cd 4502 	strd	r4, r5, [sp, #8]
  40d640:	4c31      	ldr	r4, [pc, #196]	; (40d708 <io_interface_translate1+0xe4>)
  40d642:	e9d4 ab00 	ldrd	sl, fp, [r4]
  40d646:	4c31      	ldr	r4, [pc, #196]	; (40d70c <io_interface_translate1+0xe8>)
  40d648:	e9d4 4500 	ldrd	r4, r5, [r4]
  40d64c:	e9cd 4500 	strd	r4, r5, [sp]
  40d650:	e00f      	b.n	40d672 <io_interface_translate1+0x4e>
		{
			//pin set detected
			//set the respective bit
			io_interface_readout1 |= f_mask;
			//check rising edge flag
			if (!(io_interface_pre_readout1 & f_mask))
  40d652:	ea58 0609 	orrs.w	r6, r8, r9
  40d656:	d107      	bne.n	40d668 <io_interface_translate1+0x44>
			{
				//set the respective rising edge bit
				io_interface_rise_readout1 |= f_mask;
  40d658:	e9dd 6700 	ldrd	r6, r7, [sp]
  40d65c:	4316      	orrs	r6, r2
  40d65e:	431f      	orrs	r7, r3
  40d660:	e9cd 6700 	strd	r6, r7, [sp]
  40d664:	2601      	movs	r6, #1
  40d666:	9604      	str	r6, [sp, #16]
	for (i=0; i<IO_INTERFACE_INPUTCOUNT; i++)
  40d668:	3101      	adds	r1, #1
  40d66a:	291c      	cmp	r1, #28
  40d66c:	d031      	beq.n	40d6d2 <io_interface_translate1+0xae>
  40d66e:	46a2      	mov	sl, r4
  40d670:	46ab      	mov	fp, r5
		f_mask = IO_INTERFACE_MASKER(i);
  40d672:	f1a1 0520 	sub.w	r5, r1, #32
  40d676:	f1c1 0420 	rsb	r4, r1, #32
  40d67a:	fa00 f201 	lsl.w	r2, r0, r1
  40d67e:	fa00 f305 	lsl.w	r3, r0, r5
  40d682:	fa20 f404 	lsr.w	r4, r0, r4
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d686:	f81e 5f01 	ldrb.w	r5, [lr, #1]!
			if (!(io_interface_pre_readout1 & f_mask))
  40d68a:	ea02 080a 	and.w	r8, r2, sl
		f_mask = IO_INTERFACE_MASKER(i);
  40d68e:	4323      	orrs	r3, r4
			{
				//set the respective falling edge bit
				io_interface_fall_readout1 |= f_mask;
			}
			//clear the respective bit
			f_mask = ~f_mask;
  40d690:	ea6f 0c02 	mvn.w	ip, r2
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d694:	2d03      	cmp	r5, #3
			if ((io_interface_pre_readout1 & f_mask))
  40d696:	4646      	mov	r6, r8
			if (!(io_interface_pre_readout1 & f_mask))
  40d698:	ea03 090b 	and.w	r9, r3, fp
			io_interface_readout1 |= f_mask;
  40d69c:	ea42 040a 	orr.w	r4, r2, sl
  40d6a0:	ea43 050b 	orr.w	r5, r3, fp
			if ((io_interface_pre_readout1 & f_mask))
  40d6a4:	464f      	mov	r7, r9
		if (io_interface_filters[i] >= IO_INTERFACE_FILTER_VAL)
  40d6a6:	d8d4      	bhi.n	40d652 <io_interface_translate1+0x2e>
			if ((io_interface_pre_readout1 & f_mask))
  40d6a8:	ea56 0407 	orrs.w	r4, r6, r7
			io_interface_readout1 &= f_mask;
  40d6ac:	f04f 0500 	mov.w	r5, #0
  40d6b0:	ea0a 040c 	and.w	r4, sl, ip
			if ((io_interface_pre_readout1 & f_mask))
  40d6b4:	d0d8      	beq.n	40d668 <io_interface_translate1+0x44>
	for (i=0; i<IO_INTERFACE_INPUTCOUNT; i++)
  40d6b6:	3101      	adds	r1, #1
				io_interface_fall_readout1 |= f_mask;
  40d6b8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
	for (i=0; i<IO_INTERFACE_INPUTCOUNT; i++)
  40d6bc:	291c      	cmp	r1, #28
				io_interface_fall_readout1 |= f_mask;
  40d6be:	ea46 0602 	orr.w	r6, r6, r2
  40d6c2:	ea47 0703 	orr.w	r7, r7, r3
  40d6c6:	e9cd 6702 	strd	r6, r7, [sp, #8]
  40d6ca:	f04f 0601 	mov.w	r6, #1
  40d6ce:	9605      	str	r6, [sp, #20]
	for (i=0; i<IO_INTERFACE_INPUTCOUNT; i++)
  40d6d0:	d1cd      	bne.n	40d66e <io_interface_translate1+0x4a>
  40d6d2:	4b0f      	ldr	r3, [pc, #60]	; (40d710 <io_interface_translate1+0xec>)
  40d6d4:	4a0c      	ldr	r2, [pc, #48]	; (40d708 <io_interface_translate1+0xe4>)
  40d6d6:	e9c3 ab00 	strd	sl, fp, [r3]
  40d6da:	9b04      	ldr	r3, [sp, #16]
  40d6dc:	e9c2 4500 	strd	r4, r5, [r2]
  40d6e0:	b923      	cbnz	r3, 40d6ec <io_interface_translate1+0xc8>
  40d6e2:	9b05      	ldr	r3, [sp, #20]
  40d6e4:	b943      	cbnz	r3, 40d6f8 <io_interface_translate1+0xd4>
		}
	}
		
}
  40d6e6:	b007      	add	sp, #28
  40d6e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40d6ec:	4b07      	ldr	r3, [pc, #28]	; (40d70c <io_interface_translate1+0xe8>)
  40d6ee:	e9dd 1200 	ldrd	r1, r2, [sp]
  40d6f2:	e9c3 1200 	strd	r1, r2, [r3]
  40d6f6:	e7f4      	b.n	40d6e2 <io_interface_translate1+0xbe>
  40d6f8:	4b02      	ldr	r3, [pc, #8]	; (40d704 <io_interface_translate1+0xe0>)
  40d6fa:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
  40d6fe:	e9c3 1200 	strd	r1, r2, [r3]
  40d702:	e7f0      	b.n	40d6e6 <io_interface_translate1+0xc2>
  40d704:	20400930 	.word	0x20400930
  40d708:	20400940 	.word	0x20400940
  40d70c:	20400948 	.word	0x20400948
  40d710:	20400938 	.word	0x20400938
  40d714:	20406253 	.word	0x20406253

0040d718 <io_interface_get_ireq_val>:
}
//#pragma GCC optimize("O1")
uint32_t io_interface_get_ireq_val(uint32_t add,uint32_t data)
{
	
	volatile uint32_t tmp = mb_ireq;
  40d718:	4b0f      	ldr	r3, [pc, #60]	; (40d758 <io_interface_get_ireq_val+0x40>)
{
  40d71a:	b082      	sub	sp, #8
	volatile uint32_t tmp = mb_ireq;
  40d71c:	f8d3 3002 	ldr.w	r3, [r3, #2]
  40d720:	9301      	str	r3, [sp, #4]
	if(data) 
  40d722:	b171      	cbz	r1, 40d742 <io_interface_get_ireq_val+0x2a>
	{
		mb_ireq_led_port |= IO_INTERFACE_MASKER(add);
  40d724:	490d      	ldr	r1, [pc, #52]	; (40d75c <io_interface_get_ireq_val+0x44>)
  40d726:	2201      	movs	r2, #1
  40d728:	f8d1 3002 	ldr.w	r3, [r1, #2]
  40d72c:	4082      	lsls	r2, r0
  40d72e:	4313      	orrs	r3, r2
  40d730:	f8c1 3002 	str.w	r3, [r1, #2]
	}
	else mb_ireq_led_port &= ~IO_INTERFACE_MASKER(add);
	//mb_ireq = 0;
	if (tmp & IO_INTERFACE_MASKER(add))
  40d734:	9b01      	ldr	r3, [sp, #4]
  40d736:	fa23 f000 	lsr.w	r0, r3, r0
	}
	else
	{
		return 0;
	}
}
  40d73a:	f000 0001 	and.w	r0, r0, #1
  40d73e:	b002      	add	sp, #8
  40d740:	4770      	bx	lr
	else mb_ireq_led_port &= ~IO_INTERFACE_MASKER(add);
  40d742:	2301      	movs	r3, #1
  40d744:	4905      	ldr	r1, [pc, #20]	; (40d75c <io_interface_get_ireq_val+0x44>)
  40d746:	fa03 f200 	lsl.w	r2, r3, r0
  40d74a:	f8d1 3002 	ldr.w	r3, [r1, #2]
  40d74e:	ea23 0302 	bic.w	r3, r3, r2
  40d752:	f8c1 3002 	str.w	r3, [r1, #2]
  40d756:	e7ed      	b.n	40d734 <io_interface_get_ireq_val+0x1c>
  40d758:	204062c0 	.word	0x204062c0
  40d75c:	20406278 	.word	0x20406278

0040d760 <io_interface_get_ereq_val>:

uint32_t io_interface_get_ereq_val(uint32_t add, uint32_t data)
{
  40d760:	b082      	sub	sp, #8
	if(data) mb_ereq_led_port |= IO_INTERFACE_MASKER(add);
  40d762:	b181      	cbz	r1, 40d786 <io_interface_get_ereq_val+0x26>
  40d764:	490c      	ldr	r1, [pc, #48]	; (40d798 <io_interface_get_ereq_val+0x38>)
  40d766:	2201      	movs	r2, #1
  40d768:	680b      	ldr	r3, [r1, #0]
  40d76a:	4082      	lsls	r2, r0
  40d76c:	4313      	orrs	r3, r2
  40d76e:	600b      	str	r3, [r1, #0]
	else mb_ereq_led_port &= ~IO_INTERFACE_MASKER(add);
	
	volatile uint32_t tmp = mb_ereq;
  40d770:	4b0a      	ldr	r3, [pc, #40]	; (40d79c <io_interface_get_ereq_val+0x3c>)
  40d772:	f8d3 3006 	ldr.w	r3, [r3, #6]
  40d776:	9301      	str	r3, [sp, #4]
	if (tmp & IO_INTERFACE_MASKER(add))
  40d778:	9b01      	ldr	r3, [sp, #4]
  40d77a:	fa23 f000 	lsr.w	r0, r3, r0
	}
	else
	{
		return 0;
	}
}
  40d77e:	f000 0001 	and.w	r0, r0, #1
  40d782:	b002      	add	sp, #8
  40d784:	4770      	bx	lr
	else mb_ereq_led_port &= ~IO_INTERFACE_MASKER(add);
  40d786:	2301      	movs	r3, #1
  40d788:	4903      	ldr	r1, [pc, #12]	; (40d798 <io_interface_get_ereq_val+0x38>)
  40d78a:	fa03 f200 	lsl.w	r2, r3, r0
  40d78e:	680b      	ldr	r3, [r1, #0]
  40d790:	ea23 0302 	bic.w	r3, r3, r2
  40d794:	600b      	str	r3, [r1, #0]
  40d796:	e7eb      	b.n	40d770 <io_interface_get_ereq_val+0x10>
  40d798:	204062dc 	.word	0x204062dc
  40d79c:	204062c0 	.word	0x204062c0

0040d7a0 <io_interface_get_eereq_val>:

uint32_t io_interface_get_eereq_val(uint32_t add, uint32_t data)
{
  40d7a0:	b082      	sub	sp, #8
	if(data) mb_eereq_led_port |= IO_INTERFACE_MASKER(add);
  40d7a2:	b181      	cbz	r1, 40d7c6 <io_interface_get_eereq_val+0x26>
  40d7a4:	490c      	ldr	r1, [pc, #48]	; (40d7d8 <io_interface_get_eereq_val+0x38>)
  40d7a6:	2201      	movs	r2, #1
  40d7a8:	68cb      	ldr	r3, [r1, #12]
  40d7aa:	4082      	lsls	r2, r0
  40d7ac:	4313      	orrs	r3, r2
  40d7ae:	60cb      	str	r3, [r1, #12]
	else mb_eereq_led_port &= ~IO_INTERFACE_MASKER(add);
	
	volatile uint32_t tmp = mb_eereq;
  40d7b0:	4b0a      	ldr	r3, [pc, #40]	; (40d7dc <io_interface_get_eereq_val+0x3c>)
  40d7b2:	f8d3 300a 	ldr.w	r3, [r3, #10]
  40d7b6:	9301      	str	r3, [sp, #4]
	if (tmp & IO_INTERFACE_MASKER(add))
  40d7b8:	9b01      	ldr	r3, [sp, #4]
  40d7ba:	fa23 f000 	lsr.w	r0, r3, r0
	}
	else
	{
		return 0;
	}
}
  40d7be:	f000 0001 	and.w	r0, r0, #1
  40d7c2:	b002      	add	sp, #8
  40d7c4:	4770      	bx	lr
	else mb_eereq_led_port &= ~IO_INTERFACE_MASKER(add);
  40d7c6:	2301      	movs	r3, #1
  40d7c8:	4903      	ldr	r1, [pc, #12]	; (40d7d8 <io_interface_get_eereq_val+0x38>)
  40d7ca:	fa03 f200 	lsl.w	r2, r3, r0
  40d7ce:	68cb      	ldr	r3, [r1, #12]
  40d7d0:	ea23 0302 	bic.w	r3, r3, r2
  40d7d4:	60cb      	str	r3, [r1, #12]
  40d7d6:	e7eb      	b.n	40d7b0 <io_interface_get_eereq_val+0x10>
  40d7d8:	204062dc 	.word	0x204062dc
  40d7dc:	204062c0 	.word	0x204062c0

0040d7e0 <io_interface_set_out>:
	}
}

void io_interface_set_out(uint32_t address, uint32_t output)
{
	switch(address)
  40d7e0:	2807      	cmp	r0, #7
  40d7e2:	d80a      	bhi.n	40d7fa <io_interface_set_out+0x1a>
  40d7e4:	e8df f000 	tbb	[pc, r0]
  40d7e8:	1d17110a 	.word	0x1d17110a
  40d7ec:	042f2923 	.word	0x042f2923
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d7f0:	4b18      	ldr	r3, [pc, #96]	; (40d854 <io_interface_set_out+0x74>)
  40d7f2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
	if (level) {
  40d7f6:	b931      	cbnz	r1, 40d806 <io_interface_set_out+0x26>
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40d7f8:	635a      	str	r2, [r3, #52]	; 0x34
  40d7fa:	4770      	bx	lr
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d7fc:	4b15      	ldr	r3, [pc, #84]	; (40d854 <io_interface_set_out+0x74>)
  40d7fe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	if (level) {
  40d802:	2900      	cmp	r1, #0
  40d804:	d0f8      	beq.n	40d7f8 <io_interface_set_out+0x18>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d806:	631a      	str	r2, [r3, #48]	; 0x30
  40d808:	4770      	bx	lr
  40d80a:	4b13      	ldr	r3, [pc, #76]	; (40d858 <io_interface_set_out+0x78>)
  40d80c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
	if (level) {
  40d810:	2900      	cmp	r1, #0
  40d812:	d0f1      	beq.n	40d7f8 <io_interface_set_out+0x18>
  40d814:	e7f7      	b.n	40d806 <io_interface_set_out+0x26>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d816:	4b11      	ldr	r3, [pc, #68]	; (40d85c <io_interface_set_out+0x7c>)
  40d818:	f44f 6280 	mov.w	r2, #1024	; 0x400
	if (level) {
  40d81c:	2900      	cmp	r1, #0
  40d81e:	d0eb      	beq.n	40d7f8 <io_interface_set_out+0x18>
  40d820:	e7f1      	b.n	40d806 <io_interface_set_out+0x26>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d822:	4b0d      	ldr	r3, [pc, #52]	; (40d858 <io_interface_set_out+0x78>)
  40d824:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
	if (level) {
  40d828:	2900      	cmp	r1, #0
  40d82a:	d0e5      	beq.n	40d7f8 <io_interface_set_out+0x18>
  40d82c:	e7eb      	b.n	40d806 <io_interface_set_out+0x26>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d82e:	4b0a      	ldr	r3, [pc, #40]	; (40d858 <io_interface_set_out+0x78>)
  40d830:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
	if (level) {
  40d834:	2900      	cmp	r1, #0
  40d836:	d0df      	beq.n	40d7f8 <io_interface_set_out+0x18>
  40d838:	e7e5      	b.n	40d806 <io_interface_set_out+0x26>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d83a:	4b08      	ldr	r3, [pc, #32]	; (40d85c <io_interface_set_out+0x7c>)
  40d83c:	f44f 7200 	mov.w	r2, #512	; 0x200
	if (level) {
  40d840:	2900      	cmp	r1, #0
  40d842:	d0d9      	beq.n	40d7f8 <io_interface_set_out+0x18>
  40d844:	e7df      	b.n	40d806 <io_interface_set_out+0x26>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40d846:	4b04      	ldr	r3, [pc, #16]	; (40d858 <io_interface_set_out+0x78>)
  40d848:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
	if (level) {
  40d84c:	2900      	cmp	r1, #0
  40d84e:	d0d3      	beq.n	40d7f8 <io_interface_set_out+0x18>
  40d850:	e7d9      	b.n	40d806 <io_interface_set_out+0x26>
  40d852:	bf00      	nop
  40d854:	400e0e00 	.word	0x400e0e00
  40d858:	400e1400 	.word	0x400e1400
  40d85c:	400e1200 	.word	0x400e1200

0040d860 <io_interface_get_door_message>:
	mb_CTB_out = temp;
}

uint32_t io_interface_get_door_message(uint32_t door_add)
{
	uint32_t tmp = mb_CTB_in;
  40d860:	4b04      	ldr	r3, [pc, #16]	; (40d874 <io_interface_get_door_message+0x14>)
  40d862:	881b      	ldrh	r3, [r3, #0]
	if (door_add == 0)
  40d864:	b110      	cbz	r0, 40d86c <io_interface_get_door_message+0xc>
	{
		return ( (tmp >> 8) & 0x007 );
	} 
	else
	{
		return ( (tmp >> 11) & 0x007 );
  40d866:	f3c3 20c2 	ubfx	r0, r3, #11, #3
	}
		
}
  40d86a:	4770      	bx	lr
		return ( (tmp >> 8) & 0x007 );
  40d86c:	f3c3 2002 	ubfx	r0, r3, #8, #3
  40d870:	4770      	bx	lr
  40d872:	bf00      	nop
  40d874:	204062f0 	.word	0x204062f0

0040d878 <io_interface_update>:

uint32_t io_interface_update(uint32_t address, uint32_t set_val, uint32_t default_ret_val)
{
  40d878:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t group;
	
	group = address & IO_I_A_GR_MSK;
	group = group >> IO_I_A_GR_POS; //get io group category
	address &= ~IO_I_A_GR_MSK;
  40d87c:	f020 447f 	bic.w	r4, r0, #4278190080	; 0xff000000
	
	if (group == 0)
  40d880:	0e00      	lsrs	r0, r0, #24
  40d882:	d108      	bne.n	40d896 <io_interface_update+0x1e>
	if(val < 22)
  40d884:	2c15      	cmp	r4, #21
  40d886:	d826      	bhi.n	40d8d6 <io_interface_update+0x5e>
		temp = io_interface_readout1;
  40d888:	4b71      	ldr	r3, [pc, #452]	; (40da50 <io_interface_update+0x1d8>)
  40d88a:	6818      	ldr	r0, [r3, #0]
	if (temp & IO_INTERFACE_MASKER(val))
  40d88c:	40e0      	lsrs	r0, r4
		return 0;
  40d88e:	f000 0001 	and.w	r0, r0, #1
  40d892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
		// return hoist input type
		return io_interface_get_val(address);
	}
	if (group == 1)
  40d896:	2801      	cmp	r0, #1
  40d898:	d027      	beq.n	40d8ea <io_interface_update+0x72>
	{
		// return hoist input rising type
		return io_interface_get_rising_val(address);
	}
	if (group == 2)
  40d89a:	2802      	cmp	r0, #2
  40d89c:	d04e      	beq.n	40d93c <io_interface_update+0xc4>
	{
		// return hoist input falling type
		return io_interface_get_falling_val(address);
	}
	else if (group == 3)
  40d89e:	2803      	cmp	r0, #3
  40d8a0:	f000 80a7 	beq.w	40d9f2 <io_interface_update+0x17a>
	{
		//return internal service inputs
		io_interface_get_ireq_val(address, set_val);
		return;
	}
	else if (group == 4)
  40d8a4:	2804      	cmp	r0, #4
  40d8a6:	f000 80a9 	beq.w	40d9fc <io_interface_update+0x184>
	{
		//return external service inputs
		io_interface_get_ereq_val(address, set_val);
		return;
	}
	else if (group == 5)
  40d8aa:	2805      	cmp	r0, #5
  40d8ac:	d079      	beq.n	40d9a2 <io_interface_update+0x12a>
	{
		// set outputs
		io_interface_set_out(address, set_val);
		return;
	}
	else if (group == 6)
  40d8ae:	2806      	cmp	r0, #6
  40d8b0:	460b      	mov	r3, r1
  40d8b2:	d06b      	beq.n	40d98c <io_interface_update+0x114>
	{
		// set reqLed mask
		io_interface_set_reqLed_mask(address, set_val);
		return;
	}
	else if (group == 7)
  40d8b4:	2807      	cmp	r0, #7
  40d8b6:	f000 808c 	beq.w	40d9d2 <io_interface_update+0x15a>
	{
		// set outputs
		io_interface_set_out_CTB(address, set_val);
		return;
	}
	else if (group == 8)
  40d8ba:	2808      	cmp	r0, #8
  40d8bc:	f000 80b0 	beq.w	40da20 <io_interface_update+0x1a8>
	{
		//return extended external service inputs
		io_interface_get_eereq_val(address, set_val);
		return;
	}	
	else if (group == 9)
  40d8c0:	2809      	cmp	r0, #9
  40d8c2:	f000 808e 	beq.w	40d9e2 <io_interface_update+0x16a>
	{
		// set reqLed mask
		io_interface_set_ereqLed_mask(address, set_val);
		return;
	}
	else if (group == 10)
  40d8c6:	280a      	cmp	r0, #10
  40d8c8:	d06f      	beq.n	40d9aa <io_interface_update+0x132>
	{
		// set reqLed mask
		io_interface_set_eereqLed_mask(address, set_val);
		return;
	}
	else if (group == 11)
  40d8ca:	280b      	cmp	r0, #11
  40d8cc:	f000 809e 	beq.w	40da0c <io_interface_update+0x194>
		return;
	}
	
	else
	{
		return default_ret_val;
  40d8d0:	4610      	mov	r0, r2
	}
}
  40d8d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	else if(val < 30)
  40d8d6:	2c1d      	cmp	r4, #29
  40d8d8:	d8fb      	bhi.n	40d8d2 <io_interface_update+0x5a>
		temp = mb_CTB_in;
  40d8da:	4b5e      	ldr	r3, [pc, #376]	; (40da54 <io_interface_update+0x1dc>)
		val -= 22;
  40d8dc:	3c16      	subs	r4, #22
		temp = mb_CTB_in;
  40d8de:	8818      	ldrh	r0, [r3, #0]
	if (temp & IO_INTERFACE_MASKER(val))
  40d8e0:	40e0      	lsrs	r0, r4
		return 0;
  40d8e2:	f000 0001 	and.w	r0, r0, #1
  40d8e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (io_interface_rise_readout1 & IO_INTERFACE_MASKER(val))
  40d8ea:	f8df e184 	ldr.w	lr, [pc, #388]	; 40da70 <io_interface_update+0x1f8>
  40d8ee:	f1c4 0120 	rsb	r1, r4, #32
  40d8f2:	f1a4 0520 	sub.w	r5, r4, #32
  40d8f6:	2300      	movs	r3, #0
  40d8f8:	e9de 6700 	ldrd	r6, r7, [lr]
  40d8fc:	fa26 f204 	lsr.w	r2, r6, r4
  40d900:	fa07 f801 	lsl.w	r8, r7, r1
  40d904:	fa27 fc05 	lsr.w	ip, r7, r5
  40d908:	ea42 0208 	orr.w	r2, r2, r8
  40d90c:	ea42 020c 	orr.w	r2, r2, ip
  40d910:	f002 0201 	and.w	r2, r2, #1
  40d914:	4313      	orrs	r3, r2
  40d916:	d00e      	beq.n	40d936 <io_interface_update+0xbe>
		io_interface_rise_readout1 &= ~IO_INTERFACE_MASKER(val);
  40d918:	fa20 f101 	lsr.w	r1, r0, r1
  40d91c:	fa00 f305 	lsl.w	r3, r0, r5
  40d920:	fa00 f204 	lsl.w	r2, r0, r4
  40d924:	430b      	orrs	r3, r1
  40d926:	ea26 0602 	bic.w	r6, r6, r2
  40d92a:	ea27 0703 	bic.w	r7, r7, r3
  40d92e:	e9ce 6700 	strd	r6, r7, [lr]
  40d932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return 0;
  40d936:	2000      	movs	r0, #0
  40d938:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (io_interface_fall_readout1 & IO_INTERFACE_MASKER(val))
  40d93c:	f8df e134 	ldr.w	lr, [pc, #308]	; 40da74 <io_interface_update+0x1fc>
  40d940:	f1c4 0120 	rsb	r1, r4, #32
  40d944:	f1a4 0520 	sub.w	r5, r4, #32
  40d948:	2300      	movs	r3, #0
  40d94a:	e9de 6700 	ldrd	r6, r7, [lr]
  40d94e:	fa26 f204 	lsr.w	r2, r6, r4
  40d952:	fa07 fc01 	lsl.w	ip, r7, r1
  40d956:	fa27 f005 	lsr.w	r0, r7, r5
  40d95a:	ea42 020c 	orr.w	r2, r2, ip
  40d95e:	4302      	orrs	r2, r0
  40d960:	f002 0201 	and.w	r2, r2, #1
  40d964:	4313      	orrs	r3, r2
  40d966:	d0e6      	beq.n	40d936 <io_interface_update+0xbe>
		io_interface_fall_readout1 &= ~IO_INTERFACE_MASKER(val);
  40d968:	f04f 0c01 	mov.w	ip, #1
  40d96c:	fa2c f101 	lsr.w	r1, ip, r1
  40d970:	fa0c f305 	lsl.w	r3, ip, r5
  40d974:	fa0c f204 	lsl.w	r2, ip, r4
		return 1;
  40d978:	4660      	mov	r0, ip
		io_interface_fall_readout1 &= ~IO_INTERFACE_MASKER(val);
  40d97a:	430b      	orrs	r3, r1
  40d97c:	ea26 0602 	bic.w	r6, r6, r2
  40d980:	ea27 0703 	bic.w	r7, r7, r3
  40d984:	e9ce 6700 	strd	r6, r7, [lr]
  40d988:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == 0)
  40d98c:	b1b1      	cbz	r1, 40d9bc <io_interface_update+0x144>
		mb_req_led_disable_port |= IO_INTERFACE_MASKER(add);
  40d98e:	4a32      	ldr	r2, [pc, #200]	; (40da58 <io_interface_update+0x1e0>)
  40d990:	2001      	movs	r0, #1
  40d992:	f8d2 3006 	ldr.w	r3, [r2, #6]
  40d996:	40a0      	lsls	r0, r4
  40d998:	4318      	orrs	r0, r3
  40d99a:	f8c2 0006 	str.w	r0, [r2, #6]
  40d99e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		io_interface_set_out(address, set_val);
  40d9a2:	4620      	mov	r0, r4
  40d9a4:	4b2d      	ldr	r3, [pc, #180]	; (40da5c <io_interface_update+0x1e4>)
  40d9a6:	4798      	blx	r3
		return;
  40d9a8:	e7f9      	b.n	40d99e <io_interface_update+0x126>
	if (data == 0)
  40d9aa:	2900      	cmp	r1, #0
  40d9ac:	d046      	beq.n	40da3c <io_interface_update+0x1c4>
		mb_eereq_led_disable_port |= IO_INTERFACE_MASKER(add);
  40d9ae:	4a2c      	ldr	r2, [pc, #176]	; (40da60 <io_interface_update+0x1e8>)
  40d9b0:	2001      	movs	r0, #1
  40d9b2:	6913      	ldr	r3, [r2, #16]
  40d9b4:	40a0      	lsls	r0, r4
  40d9b6:	4303      	orrs	r3, r0
  40d9b8:	6113      	str	r3, [r2, #16]
  40d9ba:	e7f0      	b.n	40d99e <io_interface_update+0x126>
		mb_req_led_disable_port &= ~IO_INTERFACE_MASKER(add);
  40d9bc:	2301      	movs	r3, #1
  40d9be:	4a26      	ldr	r2, [pc, #152]	; (40da58 <io_interface_update+0x1e0>)
  40d9c0:	fa03 f004 	lsl.w	r0, r3, r4
  40d9c4:	f8d2 3006 	ldr.w	r3, [r2, #6]
  40d9c8:	ea23 0300 	bic.w	r3, r3, r0
  40d9cc:	f8c2 3006 	str.w	r3, [r2, #6]
  40d9d0:	e7e5      	b.n	40d99e <io_interface_update+0x126>
	uint32_t temp = mb_CTB_out;
  40d9d2:	4921      	ldr	r1, [pc, #132]	; (40da58 <io_interface_update+0x1e0>)
		temp |= IO_INTERFACE_MASKER(address);
  40d9d4:	2001      	movs	r0, #1
	uint32_t temp = mb_CTB_out;
  40d9d6:	880a      	ldrh	r2, [r1, #0]
		temp |= IO_INTERFACE_MASKER(address);
  40d9d8:	40a0      	lsls	r0, r4
	if (output)
  40d9da:	b1a3      	cbz	r3, 40da06 <io_interface_update+0x18e>
		temp |= IO_INTERFACE_MASKER(address);
  40d9dc:	4310      	orrs	r0, r2
	mb_CTB_out = temp;
  40d9de:	8008      	strh	r0, [r1, #0]
  40d9e0:	e7dd      	b.n	40d99e <io_interface_update+0x126>
	if (data == 0)
  40d9e2:	b311      	cbz	r1, 40da2a <io_interface_update+0x1b2>
		mb_ereq_led_disable_port |= IO_INTERFACE_MASKER(add);
  40d9e4:	4a1e      	ldr	r2, [pc, #120]	; (40da60 <io_interface_update+0x1e8>)
  40d9e6:	2001      	movs	r0, #1
  40d9e8:	6853      	ldr	r3, [r2, #4]
  40d9ea:	40a0      	lsls	r0, r4
  40d9ec:	4318      	orrs	r0, r3
  40d9ee:	6050      	str	r0, [r2, #4]
  40d9f0:	e7d5      	b.n	40d99e <io_interface_update+0x126>
		io_interface_get_ireq_val(address, set_val);
  40d9f2:	4620      	mov	r0, r4
  40d9f4:	4b1b      	ldr	r3, [pc, #108]	; (40da64 <io_interface_update+0x1ec>)
}
  40d9f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		io_interface_get_ireq_val(address, set_val);
  40d9fa:	4718      	bx	r3
		io_interface_get_ereq_val(address, set_val);
  40d9fc:	4620      	mov	r0, r4
  40d9fe:	4b1a      	ldr	r3, [pc, #104]	; (40da68 <io_interface_update+0x1f0>)
}
  40da00:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		io_interface_get_ereq_val(address, set_val);
  40da04:	4718      	bx	r3
		temp &= ~IO_INTERFACE_MASKER(address);
  40da06:	ea22 0000 	bic.w	r0, r2, r0
  40da0a:	e7e8      	b.n	40d9de <io_interface_update+0x166>
		if (mb_CTB_in & IO_INTERFACE_MASKER(address + 8))
  40da0c:	4b11      	ldr	r3, [pc, #68]	; (40da54 <io_interface_update+0x1dc>)
  40da0e:	f104 0008 	add.w	r0, r4, #8
  40da12:	881a      	ldrh	r2, [r3, #0]
  40da14:	fa22 f000 	lsr.w	r0, r2, r0
		return 0;
  40da18:	f000 0001 	and.w	r0, r0, #1
  40da1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		io_interface_get_eereq_val(address, set_val);
  40da20:	4620      	mov	r0, r4
  40da22:	4b12      	ldr	r3, [pc, #72]	; (40da6c <io_interface_update+0x1f4>)
}
  40da24:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		io_interface_get_eereq_val(address, set_val);
  40da28:	4718      	bx	r3
		mb_ereq_led_disable_port &= ~IO_INTERFACE_MASKER(add);
  40da2a:	2301      	movs	r3, #1
  40da2c:	4a0c      	ldr	r2, [pc, #48]	; (40da60 <io_interface_update+0x1e8>)
  40da2e:	fa03 f004 	lsl.w	r0, r3, r4
  40da32:	6853      	ldr	r3, [r2, #4]
  40da34:	ea23 0300 	bic.w	r3, r3, r0
  40da38:	6053      	str	r3, [r2, #4]
  40da3a:	e7b0      	b.n	40d99e <io_interface_update+0x126>
		mb_eereq_led_disable_port &= ~IO_INTERFACE_MASKER(add);
  40da3c:	2301      	movs	r3, #1
  40da3e:	4a08      	ldr	r2, [pc, #32]	; (40da60 <io_interface_update+0x1e8>)
  40da40:	fa03 f004 	lsl.w	r0, r3, r4
  40da44:	6913      	ldr	r3, [r2, #16]
  40da46:	ea23 0300 	bic.w	r3, r3, r0
  40da4a:	6113      	str	r3, [r2, #16]
  40da4c:	e7a7      	b.n	40d99e <io_interface_update+0x126>
  40da4e:	bf00      	nop
  40da50:	20400940 	.word	0x20400940
  40da54:	204062f0 	.word	0x204062f0
  40da58:	20406278 	.word	0x20406278
  40da5c:	0040d7e1 	.word	0x0040d7e1
  40da60:	204062dc 	.word	0x204062dc
  40da64:	0040d719 	.word	0x0040d719
  40da68:	0040d761 	.word	0x0040d761
  40da6c:	0040d7a1 	.word	0x0040d7a1
  40da70:	20400948 	.word	0x20400948
  40da74:	20400930 	.word	0x20400930

0040da78 <scan_buttons_handler>:
uint32_t button_left_increment	=	0;
uint32_t button_right_increment =	0;

uByte_t buttons=0xFF,buttons_read_status=0xFF;
void scan_buttons_handler(void)
{
  40da78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40da7a:	4eb0      	ldr	r6, [pc, #704]	; (40dd3c <scan_buttons_handler+0x2c4>)
  40da7c:	4633      	mov	r3, r6
  40da7e:	f106 010c 	add.w	r1, r6, #12
	uint32_t i;
	for (i=0; i<6; i++)
	{
		// a counter to prevent accidental multi-pres from switch debounce
		if (button_delay_to_repress_arr[i] < BUTTONS_DELAY_TO_REPRESS)
  40da82:	881a      	ldrh	r2, [r3, #0]
  40da84:	3302      	adds	r3, #2
  40da86:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
		{
			button_delay_to_repress_arr[i]++;
  40da8a:	f102 0201 	add.w	r2, r2, #1
  40da8e:	bf38      	it	cc
  40da90:	f823 2c02 	strhcc.w	r2, [r3, #-2]
	for (i=0; i<6; i++)
  40da94:	428b      	cmp	r3, r1
  40da96:	d1f4      	bne.n	40da82 <scan_buttons_handler+0xa>
		}
	}
////////////////////////////////////////////////////////////////////////////////
	
	//Enter button
	if((BUTTON_VAL_ENTER == 1))
  40da98:	2200      	movs	r2, #0
  40da9a:	200e      	movs	r0, #14
  40da9c:	4da8      	ldr	r5, [pc, #672]	; (40dd40 <scan_buttons_handler+0x2c8>)
  40da9e:	4611      	mov	r1, r2
	{
		if ((buttons & BUTTON_MASK_ENTER) && (BUTTON_ENTER_RE >= BUTTONS_DELAY_TO_REPRESS))
  40daa0:	4ca8      	ldr	r4, [pc, #672]	; (40dd44 <scan_buttons_handler+0x2cc>)
	if((BUTTON_VAL_ENTER == 1))
  40daa2:	47a8      	blx	r5
  40daa4:	2801      	cmp	r0, #1
  40daa6:	d04a      	beq.n	40db3e <scan_buttons_handler+0xc6>
		}
	}
	else
	{
		buttons|=BUTTON_MASK_ENTER; //reset button
		button_enter_increment=0;
  40daa8:	2100      	movs	r1, #0
  40daaa:	4aa7      	ldr	r2, [pc, #668]	; (40dd48 <scan_buttons_handler+0x2d0>)
		buttons|=BUTTON_MASK_ENTER; //reset button
  40daac:	6823      	ldr	r3, [r4, #0]
		button_enter_increment=0;
  40daae:	6011      	str	r1, [r2, #0]
		buttons|=BUTTON_MASK_ENTER; //reset button
  40dab0:	f043 0301 	orr.w	r3, r3, #1
  40dab4:	6023      	str	r3, [r4, #0]
	}
	/*####################################################################################	*/
	//Esc button
	if((BUTTON_VAL_ESC==1))
  40dab6:	2200      	movs	r2, #0
  40dab8:	2012      	movs	r0, #18
  40daba:	4611      	mov	r1, r2
  40dabc:	47a8      	blx	r5
  40dabe:	2801      	cmp	r0, #1
	{
		if ((buttons & BUTTON_MASK_ESC) && (BUTTON_ESC_RE >= BUTTONS_DELAY_TO_REPRESS))
  40dac0:	6823      	ldr	r3, [r4, #0]
	if((BUTTON_VAL_ESC==1))
  40dac2:	f000 80c5 	beq.w	40dc50 <scan_buttons_handler+0x1d8>
		}
	}
	else
	{
		buttons|=BUTTON_MASK_ESC; //reset button
		button_esc_increment=0;
  40dac6:	2100      	movs	r1, #0
  40dac8:	4aa0      	ldr	r2, [pc, #640]	; (40dd4c <scan_buttons_handler+0x2d4>)
		buttons|=BUTTON_MASK_ESC; //reset button
  40daca:	f043 0308 	orr.w	r3, r3, #8
		button_esc_increment=0;
  40dace:	6011      	str	r1, [r2, #0]
		buttons|=BUTTON_MASK_ESC; //reset button
  40dad0:	6023      	str	r3, [r4, #0]
	}
	/*####################################################################################	*/
	//up button
	if((BUTTON_VAL_UP==1))
  40dad2:	2200      	movs	r2, #0
  40dad4:	2010      	movs	r0, #16
  40dad6:	4611      	mov	r1, r2
  40dad8:	47a8      	blx	r5
  40dada:	2801      	cmp	r0, #1
	{
		if ((buttons & BUTTON_MASK_UP) && (BUTTON_UP_RE >= BUTTONS_DELAY_TO_REPRESS))
  40dadc:	6823      	ldr	r3, [r4, #0]
	if((BUTTON_VAL_UP==1))
  40dade:	f000 809c 	beq.w	40dc1a <scan_buttons_handler+0x1a2>
		}
	}
	else
	{
		buttons|=BUTTON_MASK_UP; //reset button
		button_up_increment=0;
  40dae2:	2100      	movs	r1, #0
  40dae4:	4a9a      	ldr	r2, [pc, #616]	; (40dd50 <scan_buttons_handler+0x2d8>)
		buttons|=BUTTON_MASK_UP; //reset button
  40dae6:	f043 0302 	orr.w	r3, r3, #2
		button_up_increment=0;
  40daea:	6011      	str	r1, [r2, #0]
		buttons|=BUTTON_MASK_UP; //reset button
  40daec:	6023      	str	r3, [r4, #0]
	}
	/*####################################################################################	*/
	//down button
	if((BUTTON_VAL_DOWN==1))
  40daee:	2200      	movs	r2, #0
  40daf0:	2011      	movs	r0, #17
  40daf2:	4611      	mov	r1, r2
  40daf4:	47a8      	blx	r5
  40daf6:	2801      	cmp	r0, #1
	{
		if ((buttons & BUTTON_MASK_DOWN) && (BUTTON_DOWN_RE >= BUTTONS_DELAY_TO_REPRESS))
  40daf8:	6823      	ldr	r3, [r4, #0]
	if((BUTTON_VAL_DOWN==1))
  40dafa:	d073      	beq.n	40dbe4 <scan_buttons_handler+0x16c>
		}
	}
	else
	{
		buttons|=BUTTON_MASK_DOWN; //reset button
		button_down_increment=0;
  40dafc:	2100      	movs	r1, #0
  40dafe:	4a95      	ldr	r2, [pc, #596]	; (40dd54 <scan_buttons_handler+0x2dc>)
		buttons|=BUTTON_MASK_DOWN; //reset button
  40db00:	f043 0304 	orr.w	r3, r3, #4
		button_down_increment=0;
  40db04:	6011      	str	r1, [r2, #0]
		buttons|=BUTTON_MASK_DOWN; //reset button
  40db06:	6023      	str	r3, [r4, #0]
	}
	/*####################################################################################	*/
	//left button
	if((BUTTON_VAL_LEFT==1))
  40db08:	2200      	movs	r2, #0
  40db0a:	2013      	movs	r0, #19
  40db0c:	4611      	mov	r1, r2
  40db0e:	47a8      	blx	r5
  40db10:	2801      	cmp	r0, #1
	{
		if ((buttons & BUTTON_MASK_LEFT) && (BUTTON_LEFT_RE >= BUTTONS_DELAY_TO_REPRESS))
  40db12:	6823      	ldr	r3, [r4, #0]
	if((BUTTON_VAL_LEFT==1))
  40db14:	d04a      	beq.n	40dbac <scan_buttons_handler+0x134>
		}
	}
	else
	{
		buttons|=BUTTON_MASK_LEFT; //reset button
		button_left_increment=0;
  40db16:	2100      	movs	r1, #0
  40db18:	4a8f      	ldr	r2, [pc, #572]	; (40dd58 <scan_buttons_handler+0x2e0>)
		buttons|=BUTTON_MASK_LEFT; //reset button
  40db1a:	f043 0310 	orr.w	r3, r3, #16
		button_left_increment=0;
  40db1e:	6011      	str	r1, [r2, #0]
		buttons|=BUTTON_MASK_LEFT; //reset button
  40db20:	6023      	str	r3, [r4, #0]
	}
	/*####################################################################################	*/
	//right button
	if((BUTTON_VAL_RIGHT==1))
  40db22:	2200      	movs	r2, #0
  40db24:	200f      	movs	r0, #15
  40db26:	4611      	mov	r1, r2
  40db28:	47a8      	blx	r5
  40db2a:	2801      	cmp	r0, #1
  40db2c:	d021      	beq.n	40db72 <scan_buttons_handler+0xfa>
			buttons|=BUTTON_MASK_RIGHT; //reset button
		}
	}
	else
	{
		buttons|=BUTTON_MASK_RIGHT; //reset button
  40db2e:	6823      	ldr	r3, [r4, #0]
		button_right_increment=0;
  40db30:	2100      	movs	r1, #0
  40db32:	4a8a      	ldr	r2, [pc, #552]	; (40dd5c <scan_buttons_handler+0x2e4>)
		buttons|=BUTTON_MASK_RIGHT; //reset button
  40db34:	f043 0320 	orr.w	r3, r3, #32
		button_right_increment=0;
  40db38:	6011      	str	r1, [r2, #0]
		buttons|=BUTTON_MASK_RIGHT; //reset button
  40db3a:	6023      	str	r3, [r4, #0]
	}
}
  40db3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((buttons & BUTTON_MASK_ENTER) && (BUTTON_ENTER_RE >= BUTTONS_DELAY_TO_REPRESS))
  40db3e:	6823      	ldr	r3, [r4, #0]
  40db40:	07da      	lsls	r2, r3, #31
  40db42:	f140 80e3 	bpl.w	40dd0c <scan_buttons_handler+0x294>
  40db46:	8832      	ldrh	r2, [r6, #0]
  40db48:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
  40db4c:	f0c0 8132 	bcc.w	40ddb4 <scan_buttons_handler+0x33c>
			buttons_read_status &= ~BUTTON_MASK_ENTER; //new value so set read status register
  40db50:	4983      	ldr	r1, [pc, #524]	; (40dd60 <scan_buttons_handler+0x2e8>)
		if(button_enter_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db52:	f240 2089 	movw	r0, #649	; 0x289
  40db56:	4f7c      	ldr	r7, [pc, #496]	; (40dd48 <scan_buttons_handler+0x2d0>)
			buttons &= ~BUTTON_MASK_ENTER;
  40db58:	f023 0301 	bic.w	r3, r3, #1
			buttons_read_status &= ~BUTTON_MASK_ENTER; //new value so set read status register
  40db5c:	680a      	ldr	r2, [r1, #0]
		if(button_enter_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db5e:	683f      	ldr	r7, [r7, #0]
			buttons_read_status &= ~BUTTON_MASK_ENTER; //new value so set read status register
  40db60:	f022 0201 	bic.w	r2, r2, #1
			buttons &= ~BUTTON_MASK_ENTER;
  40db64:	6023      	str	r3, [r4, #0]
		if(button_enter_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db66:	4287      	cmp	r7, r0
			buttons_read_status &= ~BUTTON_MASK_ENTER; //new value so set read status register
  40db68:	600a      	str	r2, [r1, #0]
		if(button_enter_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db6a:	d8a1      	bhi.n	40dab0 <scan_buttons_handler+0x38>
			if(BUTTON_ENTER_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_ENTER_RE = 0;
  40db6c:	2300      	movs	r3, #0
  40db6e:	8033      	strh	r3, [r6, #0]
  40db70:	e7a1      	b.n	40dab6 <scan_buttons_handler+0x3e>
		if ((buttons & BUTTON_MASK_RIGHT) && (BUTTON_RIGHT_RE >= BUTTONS_DELAY_TO_REPRESS))
  40db72:	6820      	ldr	r0, [r4, #0]
  40db74:	0683      	lsls	r3, r0, #26
  40db76:	f140 80ad 	bpl.w	40dcd4 <scan_buttons_handler+0x25c>
  40db7a:	8973      	ldrh	r3, [r6, #10]
  40db7c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
  40db80:	f0c0 810e 	bcc.w	40dda0 <scan_buttons_handler+0x328>
			buttons_read_status&=~BUTTON_MASK_RIGHT; //new value so set read status register
  40db84:	4976      	ldr	r1, [pc, #472]	; (40dd60 <scan_buttons_handler+0x2e8>)
		if(button_right_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db86:	f240 2789 	movw	r7, #649	; 0x289
  40db8a:	4d74      	ldr	r5, [pc, #464]	; (40dd5c <scan_buttons_handler+0x2e4>)
			buttons&=~BUTTON_MASK_RIGHT;
  40db8c:	f020 0020 	bic.w	r0, r0, #32
			buttons_read_status&=~BUTTON_MASK_RIGHT; //new value so set read status register
  40db90:	680b      	ldr	r3, [r1, #0]
		if(button_right_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db92:	682a      	ldr	r2, [r5, #0]
			buttons_read_status&=~BUTTON_MASK_RIGHT; //new value so set read status register
  40db94:	f023 0320 	bic.w	r3, r3, #32
			buttons&=~BUTTON_MASK_RIGHT;
  40db98:	6020      	str	r0, [r4, #0]
		if(button_right_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db9a:	42ba      	cmp	r2, r7
			buttons_read_status&=~BUTTON_MASK_RIGHT; //new value so set read status register
  40db9c:	600b      	str	r3, [r1, #0]
		if(button_right_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40db9e:	f200 8105 	bhi.w	40ddac <scan_buttons_handler+0x334>
			button_right_increment++;
  40dba2:	3201      	adds	r2, #1
  40dba4:	602a      	str	r2, [r5, #0]
			if(BUTTON_RIGHT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_RIGHT_RE = 0;
  40dba6:	2300      	movs	r3, #0
  40dba8:	8173      	strh	r3, [r6, #10]
  40dbaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((buttons & BUTTON_MASK_LEFT) && (BUTTON_LEFT_RE >= BUTTONS_DELAY_TO_REPRESS))
  40dbac:	06da      	lsls	r2, r3, #27
  40dbae:	f140 809f 	bpl.w	40dcf0 <scan_buttons_handler+0x278>
  40dbb2:	8932      	ldrh	r2, [r6, #8]
  40dbb4:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
  40dbb8:	f0c0 80b5 	bcc.w	40dd26 <scan_buttons_handler+0x2ae>
			buttons_read_status&=~BUTTON_MASK_LEFT; //new value so set read status register
  40dbbc:	4868      	ldr	r0, [pc, #416]	; (40dd60 <scan_buttons_handler+0x2e8>)
		if(button_left_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dbbe:	f240 2e89 	movw	lr, #649	; 0x289
  40dbc2:	4f65      	ldr	r7, [pc, #404]	; (40dd58 <scan_buttons_handler+0x2e0>)
			buttons&=~BUTTON_MASK_LEFT;
  40dbc4:	f023 0310 	bic.w	r3, r3, #16
			buttons_read_status&=~BUTTON_MASK_LEFT; //new value so set read status register
  40dbc8:	6802      	ldr	r2, [r0, #0]
		if(button_left_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dbca:	6839      	ldr	r1, [r7, #0]
			buttons_read_status&=~BUTTON_MASK_LEFT; //new value so set read status register
  40dbcc:	f022 0210 	bic.w	r2, r2, #16
			buttons&=~BUTTON_MASK_LEFT;
  40dbd0:	6023      	str	r3, [r4, #0]
		if(button_left_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dbd2:	4571      	cmp	r1, lr
			buttons_read_status&=~BUTTON_MASK_LEFT; //new value so set read status register
  40dbd4:	6002      	str	r2, [r0, #0]
		if(button_left_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dbd6:	f200 80ac 	bhi.w	40dd32 <scan_buttons_handler+0x2ba>
			button_left_increment++;
  40dbda:	3101      	adds	r1, #1
  40dbdc:	6039      	str	r1, [r7, #0]
			if(BUTTON_LEFT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_LEFT_RE = 0;
  40dbde:	2300      	movs	r3, #0
  40dbe0:	8133      	strh	r3, [r6, #8]
  40dbe2:	e79e      	b.n	40db22 <scan_buttons_handler+0xaa>
		if ((buttons & BUTTON_MASK_DOWN) && (BUTTON_DOWN_RE >= BUTTONS_DELAY_TO_REPRESS))
  40dbe4:	0759      	lsls	r1, r3, #29
  40dbe6:	d567      	bpl.n	40dcb8 <scan_buttons_handler+0x240>
  40dbe8:	88f2      	ldrh	r2, [r6, #6]
  40dbea:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
  40dbee:	f0c0 80c3 	bcc.w	40dd78 <scan_buttons_handler+0x300>
			buttons_read_status&=~BUTTON_MASK_DOWN; //new value so set read status register
  40dbf2:	485b      	ldr	r0, [pc, #364]	; (40dd60 <scan_buttons_handler+0x2e8>)
		if(button_down_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dbf4:	f240 2e89 	movw	lr, #649	; 0x289
  40dbf8:	4f56      	ldr	r7, [pc, #344]	; (40dd54 <scan_buttons_handler+0x2dc>)
			buttons&=~BUTTON_MASK_DOWN;
  40dbfa:	f023 0304 	bic.w	r3, r3, #4
			buttons_read_status&=~BUTTON_MASK_DOWN; //new value so set read status register
  40dbfe:	6802      	ldr	r2, [r0, #0]
		if(button_down_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc00:	6839      	ldr	r1, [r7, #0]
			buttons_read_status&=~BUTTON_MASK_DOWN; //new value so set read status register
  40dc02:	f022 0204 	bic.w	r2, r2, #4
			buttons&=~BUTTON_MASK_DOWN;
  40dc06:	6023      	str	r3, [r4, #0]
		if(button_down_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc08:	4571      	cmp	r1, lr
			buttons_read_status&=~BUTTON_MASK_DOWN; //new value so set read status register
  40dc0a:	6002      	str	r2, [r0, #0]
		if(button_down_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc0c:	f200 80ba 	bhi.w	40dd84 <scan_buttons_handler+0x30c>
			button_down_increment++;
  40dc10:	3101      	adds	r1, #1
  40dc12:	6039      	str	r1, [r7, #0]
			if(BUTTON_DOWN_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_DOWN_RE = 0;
  40dc14:	2300      	movs	r3, #0
  40dc16:	80f3      	strh	r3, [r6, #6]
  40dc18:	e776      	b.n	40db08 <scan_buttons_handler+0x90>
		if ((buttons & BUTTON_MASK_UP) && (BUTTON_UP_RE >= BUTTONS_DELAY_TO_REPRESS))
  40dc1a:	0798      	lsls	r0, r3, #30
  40dc1c:	d53f      	bpl.n	40dc9e <scan_buttons_handler+0x226>
  40dc1e:	88b2      	ldrh	r2, [r6, #4]
  40dc20:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
  40dc24:	f0c0 80b2 	bcc.w	40dd8c <scan_buttons_handler+0x314>
			buttons_read_status&=~BUTTON_MASK_UP; //new value so set read status register
  40dc28:	484d      	ldr	r0, [pc, #308]	; (40dd60 <scan_buttons_handler+0x2e8>)
		if(button_up_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc2a:	f240 2e89 	movw	lr, #649	; 0x289
  40dc2e:	4f48      	ldr	r7, [pc, #288]	; (40dd50 <scan_buttons_handler+0x2d8>)
			buttons&=~BUTTON_MASK_UP;
  40dc30:	f023 0302 	bic.w	r3, r3, #2
			buttons_read_status&=~BUTTON_MASK_UP; //new value so set read status register
  40dc34:	6802      	ldr	r2, [r0, #0]
		if(button_up_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc36:	6839      	ldr	r1, [r7, #0]
			buttons_read_status&=~BUTTON_MASK_UP; //new value so set read status register
  40dc38:	f022 0202 	bic.w	r2, r2, #2
			buttons&=~BUTTON_MASK_UP;
  40dc3c:	6023      	str	r3, [r4, #0]
		if(button_up_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc3e:	4571      	cmp	r1, lr
			buttons_read_status&=~BUTTON_MASK_UP; //new value so set read status register
  40dc40:	6002      	str	r2, [r0, #0]
		if(button_up_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc42:	f200 80a9 	bhi.w	40dd98 <scan_buttons_handler+0x320>
			button_up_increment++;
  40dc46:	3101      	adds	r1, #1
  40dc48:	6039      	str	r1, [r7, #0]
			if(BUTTON_UP_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_UP_RE = 0;
  40dc4a:	2300      	movs	r3, #0
  40dc4c:	80b3      	strh	r3, [r6, #4]
  40dc4e:	e74e      	b.n	40daee <scan_buttons_handler+0x76>
		if ((buttons & BUTTON_MASK_ESC) && (BUTTON_ESC_RE >= BUTTONS_DELAY_TO_REPRESS))
  40dc50:	071f      	lsls	r7, r3, #28
  40dc52:	d517      	bpl.n	40dc84 <scan_buttons_handler+0x20c>
  40dc54:	8872      	ldrh	r2, [r6, #2]
  40dc56:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
  40dc5a:	f0c0 8083 	bcc.w	40dd64 <scan_buttons_handler+0x2ec>
			buttons_read_status&=~BUTTON_MASK_ESC; //new value so set read status register
  40dc5e:	4840      	ldr	r0, [pc, #256]	; (40dd60 <scan_buttons_handler+0x2e8>)
		if(button_esc_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc60:	f240 2e89 	movw	lr, #649	; 0x289
  40dc64:	4f39      	ldr	r7, [pc, #228]	; (40dd4c <scan_buttons_handler+0x2d4>)
			buttons&=~BUTTON_MASK_ESC;
  40dc66:	f023 0308 	bic.w	r3, r3, #8
			buttons_read_status&=~BUTTON_MASK_ESC; //new value so set read status register
  40dc6a:	6802      	ldr	r2, [r0, #0]
		if(button_esc_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc6c:	6839      	ldr	r1, [r7, #0]
			buttons_read_status&=~BUTTON_MASK_ESC; //new value so set read status register
  40dc6e:	f022 0208 	bic.w	r2, r2, #8
			buttons&=~BUTTON_MASK_ESC;
  40dc72:	6023      	str	r3, [r4, #0]
		if(button_esc_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc74:	4571      	cmp	r1, lr
			buttons_read_status&=~BUTTON_MASK_ESC; //new value so set read status register
  40dc76:	6002      	str	r2, [r0, #0]
		if(button_esc_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc78:	d87a      	bhi.n	40dd70 <scan_buttons_handler+0x2f8>
			button_esc_increment++;
  40dc7a:	3101      	adds	r1, #1
  40dc7c:	6039      	str	r1, [r7, #0]
			if(BUTTON_ESC_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_ESC_RE = 0;
  40dc7e:	2300      	movs	r3, #0
  40dc80:	8073      	strh	r3, [r6, #2]
  40dc82:	e726      	b.n	40dad2 <scan_buttons_handler+0x5a>
		if(button_esc_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc84:	4931      	ldr	r1, [pc, #196]	; (40dd4c <scan_buttons_handler+0x2d4>)
  40dc86:	f240 2089 	movw	r0, #649	; 0x289
  40dc8a:	680a      	ldr	r2, [r1, #0]
  40dc8c:	4282      	cmp	r2, r0
  40dc8e:	d86f      	bhi.n	40dd70 <scan_buttons_handler+0x2f8>
			if(BUTTON_ESC_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_ESC_RE = 0;
  40dc90:	8873      	ldrh	r3, [r6, #2]
			button_esc_increment++;
  40dc92:	3201      	adds	r2, #1
			if(BUTTON_ESC_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_ESC_RE = 0;
  40dc94:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
			button_esc_increment++;
  40dc98:	600a      	str	r2, [r1, #0]
			if(BUTTON_ESC_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_ESC_RE = 0;
  40dc9a:	d2f0      	bcs.n	40dc7e <scan_buttons_handler+0x206>
  40dc9c:	e719      	b.n	40dad2 <scan_buttons_handler+0x5a>
		if(button_up_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dc9e:	492c      	ldr	r1, [pc, #176]	; (40dd50 <scan_buttons_handler+0x2d8>)
  40dca0:	f240 2089 	movw	r0, #649	; 0x289
  40dca4:	680a      	ldr	r2, [r1, #0]
  40dca6:	4282      	cmp	r2, r0
  40dca8:	d876      	bhi.n	40dd98 <scan_buttons_handler+0x320>
			if(BUTTON_UP_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_UP_RE = 0;
  40dcaa:	88b3      	ldrh	r3, [r6, #4]
			button_up_increment++;
  40dcac:	3201      	adds	r2, #1
			if(BUTTON_UP_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_UP_RE = 0;
  40dcae:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
			button_up_increment++;
  40dcb2:	600a      	str	r2, [r1, #0]
			if(BUTTON_UP_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_UP_RE = 0;
  40dcb4:	d2c9      	bcs.n	40dc4a <scan_buttons_handler+0x1d2>
  40dcb6:	e71a      	b.n	40daee <scan_buttons_handler+0x76>
		if(button_down_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dcb8:	4926      	ldr	r1, [pc, #152]	; (40dd54 <scan_buttons_handler+0x2dc>)
  40dcba:	f240 2089 	movw	r0, #649	; 0x289
  40dcbe:	680a      	ldr	r2, [r1, #0]
  40dcc0:	4282      	cmp	r2, r0
  40dcc2:	d85f      	bhi.n	40dd84 <scan_buttons_handler+0x30c>
			if(BUTTON_DOWN_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_DOWN_RE = 0;
  40dcc4:	88f3      	ldrh	r3, [r6, #6]
			button_down_increment++;
  40dcc6:	3201      	adds	r2, #1
			if(BUTTON_DOWN_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_DOWN_RE = 0;
  40dcc8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
			button_down_increment++;
  40dccc:	600a      	str	r2, [r1, #0]
			if(BUTTON_DOWN_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_DOWN_RE = 0;
  40dcce:	f4ff af1b 	bcc.w	40db08 <scan_buttons_handler+0x90>
  40dcd2:	e79f      	b.n	40dc14 <scan_buttons_handler+0x19c>
		if(button_right_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dcd4:	4a21      	ldr	r2, [pc, #132]	; (40dd5c <scan_buttons_handler+0x2e4>)
  40dcd6:	f240 2189 	movw	r1, #649	; 0x289
  40dcda:	6813      	ldr	r3, [r2, #0]
  40dcdc:	428b      	cmp	r3, r1
  40dcde:	d865      	bhi.n	40ddac <scan_buttons_handler+0x334>
			if(BUTTON_RIGHT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_RIGHT_RE = 0;
  40dce0:	8971      	ldrh	r1, [r6, #10]
			button_right_increment++;
  40dce2:	3301      	adds	r3, #1
			if(BUTTON_RIGHT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_RIGHT_RE = 0;
  40dce4:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
			button_right_increment++;
  40dce8:	6013      	str	r3, [r2, #0]
			if(BUTTON_RIGHT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_RIGHT_RE = 0;
  40dcea:	f4bf af5c 	bcs.w	40dba6 <scan_buttons_handler+0x12e>
  40dcee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if(button_left_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dcf0:	4919      	ldr	r1, [pc, #100]	; (40dd58 <scan_buttons_handler+0x2e0>)
  40dcf2:	f240 2089 	movw	r0, #649	; 0x289
  40dcf6:	680a      	ldr	r2, [r1, #0]
  40dcf8:	4282      	cmp	r2, r0
  40dcfa:	d81a      	bhi.n	40dd32 <scan_buttons_handler+0x2ba>
			if(BUTTON_LEFT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_LEFT_RE = 0;
  40dcfc:	8933      	ldrh	r3, [r6, #8]
			button_left_increment++;
  40dcfe:	3201      	adds	r2, #1
			if(BUTTON_LEFT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_LEFT_RE = 0;
  40dd00:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
			button_left_increment++;
  40dd04:	600a      	str	r2, [r1, #0]
			if(BUTTON_LEFT_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_LEFT_RE = 0;
  40dd06:	f4ff af0c 	bcc.w	40db22 <scan_buttons_handler+0xaa>
  40dd0a:	e768      	b.n	40dbde <scan_buttons_handler+0x166>
		if(button_enter_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dd0c:	490e      	ldr	r1, [pc, #56]	; (40dd48 <scan_buttons_handler+0x2d0>)
  40dd0e:	f240 2289 	movw	r2, #649	; 0x289
  40dd12:	6809      	ldr	r1, [r1, #0]
  40dd14:	4291      	cmp	r1, r2
  40dd16:	f63f aecb 	bhi.w	40dab0 <scan_buttons_handler+0x38>
			if(BUTTON_ENTER_RE >= BUTTONS_DELAY_TO_REPRESS) BUTTON_ENTER_RE = 0;
  40dd1a:	8833      	ldrh	r3, [r6, #0]
  40dd1c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
  40dd20:	f4ff aec9 	bcc.w	40dab6 <scan_buttons_handler+0x3e>
  40dd24:	e722      	b.n	40db6c <scan_buttons_handler+0xf4>
		if(button_left_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dd26:	490c      	ldr	r1, [pc, #48]	; (40dd58 <scan_buttons_handler+0x2e0>)
  40dd28:	f240 2089 	movw	r0, #649	; 0x289
  40dd2c:	680a      	ldr	r2, [r1, #0]
  40dd2e:	4282      	cmp	r2, r0
  40dd30:	d94e      	bls.n	40ddd0 <scan_buttons_handler+0x358>
			buttons|=BUTTON_MASK_LEFT; //reset button
  40dd32:	f043 0310 	orr.w	r3, r3, #16
  40dd36:	6023      	str	r3, [r4, #0]
  40dd38:	e6f3      	b.n	40db22 <scan_buttons_handler+0xaa>
  40dd3a:	bf00      	nop
  40dd3c:	2040090c 	.word	0x2040090c
  40dd40:	0040d879 	.word	0x0040d879
  40dd44:	20400350 	.word	0x20400350
  40dd48:	2040091c 	.word	0x2040091c
  40dd4c:	20400920 	.word	0x20400920
  40dd50:	2040092c 	.word	0x2040092c
  40dd54:	20400918 	.word	0x20400918
  40dd58:	20400924 	.word	0x20400924
  40dd5c:	20400928 	.word	0x20400928
  40dd60:	20400354 	.word	0x20400354
		if(button_esc_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dd64:	491f      	ldr	r1, [pc, #124]	; (40dde4 <scan_buttons_handler+0x36c>)
  40dd66:	f240 2089 	movw	r0, #649	; 0x289
  40dd6a:	680a      	ldr	r2, [r1, #0]
  40dd6c:	4282      	cmp	r2, r0
  40dd6e:	d932      	bls.n	40ddd6 <scan_buttons_handler+0x35e>
			buttons|=BUTTON_MASK_ESC; //reset button
  40dd70:	f043 0308 	orr.w	r3, r3, #8
  40dd74:	6023      	str	r3, [r4, #0]
  40dd76:	e6ac      	b.n	40dad2 <scan_buttons_handler+0x5a>
		if(button_down_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dd78:	491b      	ldr	r1, [pc, #108]	; (40dde8 <scan_buttons_handler+0x370>)
  40dd7a:	f240 2089 	movw	r0, #649	; 0x289
  40dd7e:	680a      	ldr	r2, [r1, #0]
  40dd80:	4282      	cmp	r2, r0
  40dd82:	d92b      	bls.n	40dddc <scan_buttons_handler+0x364>
			buttons|=BUTTON_MASK_DOWN; //reset button
  40dd84:	f043 0304 	orr.w	r3, r3, #4
  40dd88:	6023      	str	r3, [r4, #0]
  40dd8a:	e6bd      	b.n	40db08 <scan_buttons_handler+0x90>
		if(button_up_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dd8c:	4917      	ldr	r1, [pc, #92]	; (40ddec <scan_buttons_handler+0x374>)
  40dd8e:	f240 2089 	movw	r0, #649	; 0x289
  40dd92:	680a      	ldr	r2, [r1, #0]
  40dd94:	4282      	cmp	r2, r0
  40dd96:	d918      	bls.n	40ddca <scan_buttons_handler+0x352>
			buttons|=BUTTON_MASK_UP; //reset button
  40dd98:	f043 0302 	orr.w	r3, r3, #2
  40dd9c:	6023      	str	r3, [r4, #0]
  40dd9e:	e6a6      	b.n	40daee <scan_buttons_handler+0x76>
		if(button_right_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40dda0:	4a13      	ldr	r2, [pc, #76]	; (40ddf0 <scan_buttons_handler+0x378>)
  40dda2:	f240 2189 	movw	r1, #649	; 0x289
  40dda6:	6813      	ldr	r3, [r2, #0]
  40dda8:	428b      	cmp	r3, r1
  40ddaa:	d90b      	bls.n	40ddc4 <scan_buttons_handler+0x34c>
			buttons|=BUTTON_MASK_RIGHT; //reset button
  40ddac:	f040 0020 	orr.w	r0, r0, #32
  40ddb0:	6020      	str	r0, [r4, #0]
  40ddb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if(button_enter_increment<BUTTONS_DELAY_TO_AUTO_MULTI_PRESS)
  40ddb4:	490f      	ldr	r1, [pc, #60]	; (40ddf4 <scan_buttons_handler+0x37c>)
  40ddb6:	f240 2289 	movw	r2, #649	; 0x289
  40ddba:	6809      	ldr	r1, [r1, #0]
  40ddbc:	4291      	cmp	r1, r2
  40ddbe:	f67f ae7a 	bls.w	40dab6 <scan_buttons_handler+0x3e>
  40ddc2:	e675      	b.n	40dab0 <scan_buttons_handler+0x38>
			button_right_increment++;
  40ddc4:	3301      	adds	r3, #1
  40ddc6:	6013      	str	r3, [r2, #0]
  40ddc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			button_up_increment++;
  40ddca:	3201      	adds	r2, #1
  40ddcc:	600a      	str	r2, [r1, #0]
  40ddce:	e68e      	b.n	40daee <scan_buttons_handler+0x76>
			button_left_increment++;
  40ddd0:	3201      	adds	r2, #1
  40ddd2:	600a      	str	r2, [r1, #0]
  40ddd4:	e6a5      	b.n	40db22 <scan_buttons_handler+0xaa>
			button_esc_increment++;
  40ddd6:	3201      	adds	r2, #1
  40ddd8:	600a      	str	r2, [r1, #0]
  40ddda:	e67a      	b.n	40dad2 <scan_buttons_handler+0x5a>
			button_down_increment++;
  40dddc:	3201      	adds	r2, #1
  40ddde:	600a      	str	r2, [r1, #0]
  40dde0:	e692      	b.n	40db08 <scan_buttons_handler+0x90>
  40dde2:	bf00      	nop
  40dde4:	20400920 	.word	0x20400920
  40dde8:	20400918 	.word	0x20400918
  40ddec:	2040092c 	.word	0x2040092c
  40ddf0:	20400928 	.word	0x20400928
  40ddf4:	2040091c 	.word	0x2040091c

0040ddf8 <io_interface_handler>:
{
  40ddf8:	b510      	push	{r4, lr}
	io_interface_integrate_iputs();
  40ddfa:	4b06      	ldr	r3, [pc, #24]	; (40de14 <io_interface_handler+0x1c>)
  40ddfc:	4798      	blx	r3
	io_interface_translate1();
  40ddfe:	4b06      	ldr	r3, [pc, #24]	; (40de18 <io_interface_handler+0x20>)
  40de00:	4798      	blx	r3
	io_interface_integrate_enableIputs();
  40de02:	4b06      	ldr	r3, [pc, #24]	; (40de1c <io_interface_handler+0x24>)
  40de04:	4798      	blx	r3
	io_interface_translateCritical();
  40de06:	4b06      	ldr	r3, [pc, #24]	; (40de20 <io_interface_handler+0x28>)
  40de08:	4798      	blx	r3
	scan_buttons_handler();		
  40de0a:	4b06      	ldr	r3, [pc, #24]	; (40de24 <io_interface_handler+0x2c>)
}
  40de0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	scan_buttons_handler();		
  40de10:	4718      	bx	r3
  40de12:	bf00      	nop
  40de14:	0040d41d 	.word	0x0040d41d
  40de18:	0040d625 	.word	0x0040d625
  40de1c:	0040d3d1 	.word	0x0040d3d1
  40de20:	0040d529 	.word	0x0040d529
  40de24:	0040da79 	.word	0x0040da79

0040de28 <get_enter_button>:

uByte_t get_enter_button(void)
{
	if((buttons_read_status & BUTTON_MASK_ENTER)==0)
  40de28:	4a05      	ldr	r2, [pc, #20]	; (40de40 <get_enter_button+0x18>)
  40de2a:	6813      	ldr	r3, [r2, #0]
  40de2c:	07d9      	lsls	r1, r3, #31
  40de2e:	d404      	bmi.n	40de3a <get_enter_button+0x12>
	{
		buttons_read_status|=BUTTON_MASK_ENTER;
  40de30:	f043 0301 	orr.w	r3, r3, #1
		return 1;
  40de34:	2001      	movs	r0, #1
		buttons_read_status|=BUTTON_MASK_ENTER;
  40de36:	6013      	str	r3, [r2, #0]
		return 1;
  40de38:	4770      	bx	lr
	}
	return 0;
  40de3a:	2000      	movs	r0, #0
}
  40de3c:	4770      	bx	lr
  40de3e:	bf00      	nop
  40de40:	20400354 	.word	0x20400354

0040de44 <get_esc_button>:

uByte_t get_esc_button(void)
{
	if((buttons_read_status & BUTTON_MASK_ESC)==0)
  40de44:	4a05      	ldr	r2, [pc, #20]	; (40de5c <get_esc_button+0x18>)
  40de46:	6813      	ldr	r3, [r2, #0]
  40de48:	0719      	lsls	r1, r3, #28
  40de4a:	d404      	bmi.n	40de56 <get_esc_button+0x12>
	{
		buttons_read_status|=BUTTON_MASK_ESC;
  40de4c:	f043 0308 	orr.w	r3, r3, #8
		return 1;
  40de50:	2001      	movs	r0, #1
		buttons_read_status|=BUTTON_MASK_ESC;
  40de52:	6013      	str	r3, [r2, #0]
		return 1;
  40de54:	4770      	bx	lr
	}
	return 0;
  40de56:	2000      	movs	r0, #0
}
  40de58:	4770      	bx	lr
  40de5a:	bf00      	nop
  40de5c:	20400354 	.word	0x20400354

0040de60 <get_up_button>:

uByte_t get_up_button(void)
{
	if((buttons_read_status & BUTTON_MASK_UP)==0)
  40de60:	4a05      	ldr	r2, [pc, #20]	; (40de78 <get_up_button+0x18>)
  40de62:	6813      	ldr	r3, [r2, #0]
  40de64:	0799      	lsls	r1, r3, #30
  40de66:	d404      	bmi.n	40de72 <get_up_button+0x12>
	{
		buttons_read_status|=BUTTON_MASK_UP;
  40de68:	f043 0302 	orr.w	r3, r3, #2
		return 1;
  40de6c:	2001      	movs	r0, #1
		buttons_read_status|=BUTTON_MASK_UP;
  40de6e:	6013      	str	r3, [r2, #0]
		return 1;
  40de70:	4770      	bx	lr
	}
	return 0;
  40de72:	2000      	movs	r0, #0
}
  40de74:	4770      	bx	lr
  40de76:	bf00      	nop
  40de78:	20400354 	.word	0x20400354

0040de7c <get_down_button>:

uByte_t get_down_button(void)
{
	if((buttons_read_status & BUTTON_MASK_DOWN)==0)
  40de7c:	4a05      	ldr	r2, [pc, #20]	; (40de94 <get_down_button+0x18>)
  40de7e:	6813      	ldr	r3, [r2, #0]
  40de80:	0759      	lsls	r1, r3, #29
  40de82:	d404      	bmi.n	40de8e <get_down_button+0x12>
	{
		buttons_read_status|=BUTTON_MASK_DOWN;
  40de84:	f043 0304 	orr.w	r3, r3, #4
		return 1;
  40de88:	2001      	movs	r0, #1
		buttons_read_status|=BUTTON_MASK_DOWN;
  40de8a:	6013      	str	r3, [r2, #0]
		return 1;
  40de8c:	4770      	bx	lr
	}
	return 0;
  40de8e:	2000      	movs	r0, #0
}
  40de90:	4770      	bx	lr
  40de92:	bf00      	nop
  40de94:	20400354 	.word	0x20400354

0040de98 <get_left_button>:

uByte_t get_left_button(void)
{
	if((buttons_read_status & BUTTON_MASK_LEFT)==0)
  40de98:	4a05      	ldr	r2, [pc, #20]	; (40deb0 <get_left_button+0x18>)
  40de9a:	6813      	ldr	r3, [r2, #0]
  40de9c:	06d9      	lsls	r1, r3, #27
  40de9e:	d404      	bmi.n	40deaa <get_left_button+0x12>
	{
		buttons_read_status|=BUTTON_MASK_LEFT;
  40dea0:	f043 0310 	orr.w	r3, r3, #16
		return 1;
  40dea4:	2001      	movs	r0, #1
		buttons_read_status|=BUTTON_MASK_LEFT;
  40dea6:	6013      	str	r3, [r2, #0]
		return 1;
  40dea8:	4770      	bx	lr
	}
	return 0;
  40deaa:	2000      	movs	r0, #0
}
  40deac:	4770      	bx	lr
  40deae:	bf00      	nop
  40deb0:	20400354 	.word	0x20400354

0040deb4 <get_right_button>:

uByte_t get_right_button(void)
{
	if((buttons_read_status & BUTTON_MASK_RIGHT)==0)
  40deb4:	4a05      	ldr	r2, [pc, #20]	; (40decc <get_right_button+0x18>)
  40deb6:	6813      	ldr	r3, [r2, #0]
  40deb8:	0699      	lsls	r1, r3, #26
  40deba:	d404      	bmi.n	40dec6 <get_right_button+0x12>
	{
		buttons_read_status |= BUTTON_MASK_RIGHT;
  40debc:	f043 0320 	orr.w	r3, r3, #32
		return 1;
  40dec0:	2001      	movs	r0, #1
		buttons_read_status |= BUTTON_MASK_RIGHT;
  40dec2:	6013      	str	r3, [r2, #0]
		return 1;
  40dec4:	4770      	bx	lr
	}
	return 0;
  40dec6:	2000      	movs	r0, #0
}
  40dec8:	4770      	bx	lr
  40deca:	bf00      	nop
  40decc:	20400354 	.word	0x20400354

0040ded0 <drop_all_buttons>:

void drop_all_buttons(void)
{
	buttons_read_status = 0xFF;
  40ded0:	4b01      	ldr	r3, [pc, #4]	; (40ded8 <drop_all_buttons+0x8>)
  40ded2:	22ff      	movs	r2, #255	; 0xff
  40ded4:	601a      	str	r2, [r3, #0]
  40ded6:	4770      	bx	lr
  40ded8:	20400354 	.word	0x20400354

0040dedc <req_mb_setUpMotion>:

#define mb_display_manip *((uint8_t *)&mb_Holding_reg_car[5] + 1)
#define mb_fault_code *((uint8_t *)&mb_Holding_reg_car[6])
void req_mb_setUpMotion(void)
{
	uint8_t tmp_manip = mb_display_manip;
  40dedc:	4a03      	ldr	r2, [pc, #12]	; (40deec <req_mb_setUpMotion+0x10>)
  40dede:	7ad3      	ldrb	r3, [r2, #11]
	tmp_manip &= 0xF8;
  40dee0:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
	tmp_manip |= 5;
  40dee4:	f043 0305 	orr.w	r3, r3, #5
	mb_display_manip = tmp_manip;
  40dee8:	72d3      	strb	r3, [r2, #11]
  40deea:	4770      	bx	lr
  40deec:	20406278 	.word	0x20406278

0040def0 <req_mb_setDnMotion>:
}

void req_mb_setDnMotion(void)
{
	uint8_t tmp_manip = mb_display_manip;
  40def0:	4a03      	ldr	r2, [pc, #12]	; (40df00 <req_mb_setDnMotion+0x10>)
  40def2:	7ad3      	ldrb	r3, [r2, #11]
	tmp_manip &= 0xF8;
  40def4:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
	tmp_manip |= 6;
  40def8:	f043 0306 	orr.w	r3, r3, #6
	mb_display_manip = tmp_manip;
  40defc:	72d3      	strb	r3, [r2, #11]
  40defe:	4770      	bx	lr
  40df00:	20406278 	.word	0x20406278

0040df04 <req_mb_setStill>:
}
void req_mb_setStill(void)
{
	uint8_t tmp_manip = mb_display_manip;
  40df04:	4a02      	ldr	r2, [pc, #8]	; (40df10 <req_mb_setStill+0xc>)
  40df06:	7ad3      	ldrb	r3, [r2, #11]
	tmp_manip &= 0xF8;
  40df08:	f023 0307 	bic.w	r3, r3, #7
	mb_display_manip = tmp_manip;
  40df0c:	72d3      	strb	r3, [r2, #11]
  40df0e:	4770      	bx	lr
  40df10:	20406278 	.word	0x20406278

0040df14 <req_mb_setINS>:
}
void req_mb_setINS(void)
{
	uint8_t tmp_manip = mb_display_manip;
  40df14:	4a03      	ldr	r2, [pc, #12]	; (40df24 <req_mb_setINS+0x10>)
  40df16:	7ad3      	ldrb	r3, [r2, #11]
	tmp_manip &= 0xF7;
  40df18:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
	tmp_manip |= 8;
  40df1c:	f043 0308 	orr.w	r3, r3, #8
	mb_display_manip = tmp_manip;
  40df20:	72d3      	strb	r3, [r2, #11]
  40df22:	4770      	bx	lr
  40df24:	20406278 	.word	0x20406278

0040df28 <req_mb_setFault>:
	mb_display_manip = tmp_manip;
}

void req_mb_setFault(uint8_t fault_prefix, uint8_t fault_code)
{
	mb_fault_code = fault_code;
  40df28:	4b05      	ldr	r3, [pc, #20]	; (40df40 <req_mb_setFault+0x18>)
	
	uint8_t tmp_manip = mb_display_manip;
	tmp_manip &= 0xCF;
	tmp_manip |= (fault_prefix & 0x03) << 4;
  40df2a:	0100      	lsls	r0, r0, #4
	uint8_t tmp_manip = mb_display_manip;
  40df2c:	7ada      	ldrb	r2, [r3, #11]
	tmp_manip |= (fault_prefix & 0x03) << 4;
  40df2e:	f000 0030 	and.w	r0, r0, #48	; 0x30
	mb_fault_code = fault_code;
  40df32:	7319      	strb	r1, [r3, #12]
	tmp_manip &= 0xCF;
  40df34:	f022 0230 	bic.w	r2, r2, #48	; 0x30
	tmp_manip |= (fault_prefix & 0x03) << 4;
  40df38:	4310      	orrs	r0, r2
	mb_display_manip = tmp_manip;
  40df3a:	72d8      	strb	r0, [r3, #11]
  40df3c:	4770      	bx	lr
  40df3e:	bf00      	nop
  40df40:	20406278 	.word	0x20406278

0040df44 <comm_loss_monitor>:

#define INTERNAL_COMM_TIMEOUT (40000 / 80) //8sec delay
uint32_t ctb_counter = 0, ccb0_counter = 0, ccb1_counter = 0;
void comm_loss_monitor(void)
{
	if (ctb_counter < INTERNAL_COMM_TIMEOUT)
  40df44:	4a0c      	ldr	r2, [pc, #48]	; (40df78 <comm_loss_monitor+0x34>)
  40df46:	6813      	ldr	r3, [r2, #0]
  40df48:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  40df4c:	d210      	bcs.n	40df70 <comm_loss_monitor+0x2c>
	{
		ctb_counter++;
  40df4e:	3301      	adds	r3, #1
  40df50:	6013      	str	r3, [r2, #0]
	{
		if(mnt == 0) CTB_err_set;
		mb_CTB_in = 0;
	}
	
	if (ccb0_counter < (2 *INTERNAL_COMM_TIMEOUT))
  40df52:	4a0a      	ldr	r2, [pc, #40]	; (40df7c <comm_loss_monitor+0x38>)
  40df54:	6813      	ldr	r3, [r2, #0]
  40df56:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  40df5a:	d201      	bcs.n	40df60 <comm_loss_monitor+0x1c>
	{
		ccb0_counter++;
  40df5c:	3301      	adds	r3, #1
  40df5e:	6013      	str	r3, [r2, #0]
	else
	{
		if(mnt == 0) CCB0_err_set;
	}
	
	if (ccb1_counter < INTERNAL_COMM_TIMEOUT)
  40df60:	4a07      	ldr	r2, [pc, #28]	; (40df80 <comm_loss_monitor+0x3c>)
  40df62:	6813      	ldr	r3, [r2, #0]
  40df64:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  40df68:	d201      	bcs.n	40df6e <comm_loss_monitor+0x2a>
	{
		ccb1_counter++;
  40df6a:	3301      	adds	r3, #1
  40df6c:	6013      	str	r3, [r2, #0]
  40df6e:	4770      	bx	lr
		mb_CTB_in = 0;
  40df70:	4b04      	ldr	r3, [pc, #16]	; (40df84 <comm_loss_monitor+0x40>)
  40df72:	2200      	movs	r2, #0
  40df74:	801a      	strh	r2, [r3, #0]
  40df76:	e7ec      	b.n	40df52 <comm_loss_monitor+0xe>
  40df78:	20400958 	.word	0x20400958
  40df7c:	20400950 	.word	0x20400950
  40df80:	20400954 	.word	0x20400954
  40df84:	204062f0 	.word	0x204062f0

0040df88 <req_io_internal_reply_sub>:
	}
}

void req_io_internal_reply_sub(uint32_t slave_add)
{
	if (slave_add == 240)
  40df88:	28f0      	cmp	r0, #240	; 0xf0
  40df8a:	d00b      	beq.n	40dfa4 <req_io_internal_reply_sub+0x1c>
	{
		// rec ctb message
		ctb_counter = 0;
	} 
	if (slave_add == 241)
  40df8c:	28f1      	cmp	r0, #241	; 0xf1
  40df8e:	d005      	beq.n	40df9c <req_io_internal_reply_sub+0x14>
	{
		// rec ccb0 message
		ccb0_counter = 0;
	}
	if (slave_add == 242)
  40df90:	28f2      	cmp	r0, #242	; 0xf2
  40df92:	d102      	bne.n	40df9a <req_io_internal_reply_sub+0x12>
	{
		// rec ccb1 message
		ccb1_counter = 0;
  40df94:	4b05      	ldr	r3, [pc, #20]	; (40dfac <req_io_internal_reply_sub+0x24>)
  40df96:	2200      	movs	r2, #0
  40df98:	601a      	str	r2, [r3, #0]
  40df9a:	4770      	bx	lr
		ccb0_counter = 0;
  40df9c:	4b04      	ldr	r3, [pc, #16]	; (40dfb0 <req_io_internal_reply_sub+0x28>)
  40df9e:	2200      	movs	r2, #0
  40dfa0:	601a      	str	r2, [r3, #0]
  40dfa2:	4770      	bx	lr
		ctb_counter = 0;
  40dfa4:	4b03      	ldr	r3, [pc, #12]	; (40dfb4 <req_io_internal_reply_sub+0x2c>)
  40dfa6:	2200      	movs	r2, #0
  40dfa8:	601a      	str	r2, [r3, #0]
  40dfaa:	4770      	bx	lr
  40dfac:	20400954 	.word	0x20400954
  40dfb0:	20400950 	.word	0x20400950
  40dfb4:	20400958 	.word	0x20400958

0040dfb8 <req_io_mb_cabin_handler>:
	}
}

void req_io_mb_cabin_handler(void)
{
  40dfb8:	b5f0      	push	{r4, r5, r6, r7, lr}
	modbus_transaction_t req_transaction;
	
	
	if ( req_mb_stage == 0 )
  40dfba:	4c25      	ldr	r4, [pc, #148]	; (40e050 <req_io_mb_cabin_handler+0x98>)
{
  40dfbc:	b085      	sub	sp, #20
	if ( req_mb_stage == 0 )
  40dfbe:	7823      	ldrb	r3, [r4, #0]
  40dfc0:	b1c3      	cbz	r3, 40dff4 <req_io_mb_cabin_handler+0x3c>
		//read req inputs
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
			req_mb_stage++;
	}
	//send new requests
	else if ( req_mb_stage == 1 )
  40dfc2:	2b01      	cmp	r3, #1
  40dfc4:	d02d      	beq.n	40e022 <req_io_mb_cabin_handler+0x6a>
			req_mb_stage++;
	}
	else if ( req_mb_stage > 1 )
	{
		req_transaction.slave_add = 241;
		req_transaction.start_add = 0;
  40dfc6:	2500      	movs	r5, #0
		req_transaction.slave_add = 241;
  40dfc8:	23f1      	movs	r3, #241	; 0xf1
		req_transaction.entry_type = RD_IREG;
		req_transaction.buff_size = 1;
  40dfca:	2601      	movs	r6, #1
		req_transaction.data_buff = &mb_req_readout[1];
  40dfcc:	4a21      	ldr	r2, [pc, #132]	; (40e054 <req_io_mb_cabin_handler+0x9c>)
		req_transaction.entry_type = RD_IREG;
  40dfce:	2703      	movs	r7, #3
		req_transaction.slave_add = 241;
  40dfd0:	f88d 300e 	strb.w	r3, [sp, #14]
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40dfd4:	4628      	mov	r0, r5
  40dfd6:	a901      	add	r1, sp, #4
  40dfd8:	4b1f      	ldr	r3, [pc, #124]	; (40e058 <req_io_mb_cabin_handler+0xa0>)
		req_transaction.start_add = 0;
  40dfda:	f88d 500c 	strb.w	r5, [sp, #12]
		req_transaction.entry_type = RD_IREG;
  40dfde:	f88d 7004 	strb.w	r7, [sp, #4]
		req_transaction.buff_size = 1;
  40dfe2:	f88d 600d 	strb.w	r6, [sp, #13]
		req_transaction.data_buff = &mb_req_readout[1];
  40dfe6:	9202      	str	r2, [sp, #8]
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40dfe8:	4798      	blx	r3
  40dfea:	42b0      	cmp	r0, r6
			req_mb_stage = 0;
  40dfec:	bf08      	it	eq
  40dfee:	7025      	strbeq	r5, [r4, #0]
	}
	
}
  40dff0:	b005      	add	sp, #20
  40dff2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		req_transaction.buff_size = 1;
  40dff4:	2501      	movs	r5, #1
		req_transaction.data_buff = mb_Input_reg_car;
  40dff6:	4a19      	ldr	r2, [pc, #100]	; (40e05c <req_io_mb_cabin_handler+0xa4>)
		req_transaction.slave_add = 240;
  40dff8:	27f0      	movs	r7, #240	; 0xf0
		req_transaction.entry_type = RD_IREG;
  40dffa:	2603      	movs	r6, #3
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40dffc:	4618      	mov	r0, r3
		req_transaction.start_add = 0;
  40dffe:	f88d 300c 	strb.w	r3, [sp, #12]
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40e002:	a901      	add	r1, sp, #4
  40e004:	4b14      	ldr	r3, [pc, #80]	; (40e058 <req_io_mb_cabin_handler+0xa0>)
		req_transaction.slave_add = 240;
  40e006:	f88d 700e 	strb.w	r7, [sp, #14]
		req_transaction.entry_type = RD_IREG;
  40e00a:	f88d 6004 	strb.w	r6, [sp, #4]
		req_transaction.buff_size = 1;
  40e00e:	f88d 500d 	strb.w	r5, [sp, #13]
		req_transaction.data_buff = mb_Input_reg_car;
  40e012:	9202      	str	r2, [sp, #8]
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40e014:	4798      	blx	r3
  40e016:	42a8      	cmp	r0, r5
  40e018:	d1ea      	bne.n	40dff0 <req_io_mb_cabin_handler+0x38>
			req_mb_stage++;
  40e01a:	7823      	ldrb	r3, [r4, #0]
  40e01c:	442b      	add	r3, r5
  40e01e:	7023      	strb	r3, [r4, #0]
  40e020:	e7e6      	b.n	40dff0 <req_io_mb_cabin_handler+0x38>
		req_transaction.slave_add = 0;
  40e022:	2200      	movs	r2, #0
		req_transaction.buff_size = 7;
  40e024:	2707      	movs	r7, #7
		req_transaction.data_buff = mb_Holding_reg_car;
  40e026:	4e0e      	ldr	r6, [pc, #56]	; (40e060 <req_io_mb_cabin_handler+0xa8>)
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40e028:	a901      	add	r1, sp, #4
  40e02a:	4610      	mov	r0, r2
  40e02c:	4d0a      	ldr	r5, [pc, #40]	; (40e058 <req_io_mb_cabin_handler+0xa0>)
		req_transaction.entry_type = WR_HREG;
  40e02e:	f88d 3004 	strb.w	r3, [sp, #4]
		req_transaction.slave_add = 0;
  40e032:	f88d 200e 	strb.w	r2, [sp, #14]
		req_transaction.start_add = 0;;
  40e036:	f88d 200c 	strb.w	r2, [sp, #12]
		req_transaction.buff_size = 7;
  40e03a:	f88d 700d 	strb.w	r7, [sp, #13]
		req_transaction.data_buff = mb_Holding_reg_car;
  40e03e:	9602      	str	r6, [sp, #8]
		if (mb_add_transaction(0, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40e040:	47a8      	blx	r5
  40e042:	2801      	cmp	r0, #1
  40e044:	d1d4      	bne.n	40dff0 <req_io_mb_cabin_handler+0x38>
			req_mb_stage++;
  40e046:	7823      	ldrb	r3, [r4, #0]
  40e048:	3301      	adds	r3, #1
  40e04a:	7023      	strb	r3, [r4, #0]
  40e04c:	e7d0      	b.n	40dff0 <req_io_mb_cabin_handler+0x38>
  40e04e:	bf00      	nop
  40e050:	2040095e 	.word	0x2040095e
  40e054:	204062c2 	.word	0x204062c2
  40e058:	0040a769 	.word	0x0040a769
  40e05c:	204062f0 	.word	0x204062f0
  40e060:	20406278 	.word	0x20406278

0040e064 <req_io_mb_get_ereq>:

uint16_t ext_req_mb_hall_readout[28];

void req_io_mb_get_ereq(void)
{
  40e064:	4a13      	ldr	r2, [pc, #76]	; (40e0b4 <req_io_mb_get_ereq+0x50>)
	uint32_t i;
	uint16_t tmp;
	for (i=0; i<=f_max; i++)
  40e066:	2100      	movs	r1, #0
  40e068:	4b13      	ldr	r3, [pc, #76]	; (40e0b8 <req_io_mb_get_ereq+0x54>)
  40e06a:	f8df c050 	ldr.w	ip, [pc, #80]	; 40e0bc <req_io_mb_get_ereq+0x58>
{
  40e06e:	b5f0      	push	{r4, r5, r6, r7, lr}
  40e070:	1c97      	adds	r7, r2, #2
  40e072:	7a9b      	ldrb	r3, [r3, #10]
		{
			mb_ereq |= (1ul << i);
		} 
		else
		{
			mb_ereq &= ~(1ul << i);
  40e074:	2601      	movs	r6, #1
		else
		{
			mb_eereq &= ~(1ul << i);
		}
		
		ext_req_mb_hall_readout[i] = 0;
  40e076:	468e      	mov	lr, r1
  40e078:	f8dc 5006 	ldr.w	r5, [ip, #6]
  40e07c:	eb07 0743 	add.w	r7, r7, r3, lsl #1
  40e080:	f8dc 400a 	ldr.w	r4, [ip, #10]
		tmp = ext_req_mb_hall_readout[i] >> 1;
  40e084:	8853      	ldrh	r3, [r2, #2]
			mb_ereq &= ~(1ul << i);
  40e086:	fa06 f001 	lsl.w	r0, r6, r1
		ext_req_mb_hall_readout[i] = 0;
  40e08a:	f822 ef02 	strh.w	lr, [r2, #2]!
	for (i=0; i<=f_max; i++)
  40e08e:	3101      	adds	r1, #1
		tmp = ext_req_mb_hall_readout[i] >> 1;
  40e090:	085b      	lsrs	r3, r3, #1
		if(tmp & 1)
  40e092:	f013 0f01 	tst.w	r3, #1
			mb_ereq |= (1ul << i);
  40e096:	bf14      	ite	ne
  40e098:	4305      	orrne	r5, r0
			mb_ereq &= ~(1ul << i);
  40e09a:	4385      	biceq	r5, r0
		if(tmp & 2)
  40e09c:	079b      	lsls	r3, r3, #30
			mb_eereq |= (1ul << i);
  40e09e:	bf4c      	ite	mi
  40e0a0:	4304      	orrmi	r4, r0
			mb_eereq &= ~(1ul << i);
  40e0a2:	4384      	bicpl	r4, r0
	for (i=0; i<=f_max; i++)
  40e0a4:	42ba      	cmp	r2, r7
  40e0a6:	d1ed      	bne.n	40e084 <req_io_mb_get_ereq+0x20>
  40e0a8:	f8cc 5006 	str.w	r5, [ip, #6]
  40e0ac:	f8cc 400a 	str.w	r4, [ip, #10]
  40e0b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40e0b2:	bf00      	nop
  40e0b4:	20406286 	.word	0x20406286
  40e0b8:	204052b4 	.word	0x204052b4
  40e0bc:	204062c0 	.word	0x204062c0

0040e0c0 <req_io_mb_hall_handler>:
	}
}
uint8_t hall_broadcast = 0;
void req_io_mb_hall_handler(void)
{
  40e0c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	modbus_transaction_t req_transaction;
	
	if ( ((req_mb_hall_stage % 5) == 0 ) && (hall_broadcast) )
  40e0c2:	4d29      	ldr	r5, [pc, #164]	; (40e168 <req_io_mb_hall_handler+0xa8>)
{
  40e0c4:	b085      	sub	sp, #20
	if ( ((req_mb_hall_stage % 5) == 0 ) && (hall_broadcast) )
  40e0c6:	4b29      	ldr	r3, [pc, #164]	; (40e16c <req_io_mb_hall_handler+0xac>)
  40e0c8:	782a      	ldrb	r2, [r5, #0]
  40e0ca:	fba3 1302 	umull	r1, r3, r3, r2
  40e0ce:	089b      	lsrs	r3, r3, #2
  40e0d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40e0d4:	1ad3      	subs	r3, r2, r3
  40e0d6:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
  40e0da:	d102      	bne.n	40e0e2 <req_io_mb_hall_handler+0x22>
  40e0dc:	4e24      	ldr	r6, [pc, #144]	; (40e170 <req_io_mb_hall_handler+0xb0>)
  40e0de:	7833      	ldrb	r3, [r6, #0]
  40e0e0:	bb23      	cbnz	r3, 40e12c <req_io_mb_hall_handler+0x6c>
		req_transaction.buff_size = 10;
		//mb_display_data = 5;
		req_transaction.data_buff = mb_Holding_reg_hall;
		if (mb_add_transaction(1, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS) hall_broadcast = 0;
	}
	else if (req_mb_hall_stage <= f_max )
  40e0e2:	4b24      	ldr	r3, [pc, #144]	; (40e174 <req_io_mb_hall_handler+0xb4>)
  40e0e4:	7a9b      	ldrb	r3, [r3, #10]
  40e0e6:	4293      	cmp	r3, r2
  40e0e8:	d203      	bcs.n	40e0f2 <req_io_mb_hall_handler+0x32>
			hall_broadcast = 1;
		}
	}
	else
	{
		req_mb_hall_stage = 0;
  40e0ea:	2300      	movs	r3, #0
  40e0ec:	702b      	strb	r3, [r5, #0]
	}
	
}
  40e0ee:	b005      	add	sp, #20
  40e0f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		req_transaction.buff_size = 1;
  40e0f2:	2401      	movs	r4, #1
		req_transaction.data_buff = &ext_req_mb_hall_readout[req_mb_hall_stage];
  40e0f4:	4b20      	ldr	r3, [pc, #128]	; (40e178 <req_io_mb_hall_handler+0xb8>)
		req_transaction.start_add = 0;
  40e0f6:	2700      	movs	r7, #0
		req_transaction.entry_type = RD_IREG;
  40e0f8:	2603      	movs	r6, #3
		req_transaction.slave_add = req_mb_hall_stage + 1;
  40e0fa:	eb02 0e04 	add.w	lr, r2, r4
		req_transaction.data_buff = &ext_req_mb_hall_readout[req_mb_hall_stage];
  40e0fe:	eb03 0242 	add.w	r2, r3, r2, lsl #1
		if (mb_add_transaction(1, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40e102:	4620      	mov	r0, r4
  40e104:	a901      	add	r1, sp, #4
  40e106:	4b1d      	ldr	r3, [pc, #116]	; (40e17c <req_io_mb_hall_handler+0xbc>)
		req_transaction.data_buff = &ext_req_mb_hall_readout[req_mb_hall_stage];
  40e108:	9202      	str	r2, [sp, #8]
		req_transaction.slave_add = req_mb_hall_stage + 1;
  40e10a:	f88d e00e 	strb.w	lr, [sp, #14]
		req_transaction.buff_size = 1;
  40e10e:	f88d 400d 	strb.w	r4, [sp, #13]
		req_transaction.start_add = 0;
  40e112:	f88d 700c 	strb.w	r7, [sp, #12]
		req_transaction.entry_type = RD_IREG;
  40e116:	f88d 6004 	strb.w	r6, [sp, #4]
		if (mb_add_transaction(1, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS)
  40e11a:	4798      	blx	r3
  40e11c:	42a0      	cmp	r0, r4
  40e11e:	d1e6      	bne.n	40e0ee <req_io_mb_hall_handler+0x2e>
			req_mb_hall_stage++;
  40e120:	782b      	ldrb	r3, [r5, #0]
			hall_broadcast = 1;
  40e122:	4a13      	ldr	r2, [pc, #76]	; (40e170 <req_io_mb_hall_handler+0xb0>)
			req_mb_hall_stage++;
  40e124:	4423      	add	r3, r4
			hall_broadcast = 1;
  40e126:	7010      	strb	r0, [r2, #0]
			req_mb_hall_stage++;
  40e128:	702b      	strb	r3, [r5, #0]
  40e12a:	e7e0      	b.n	40e0ee <req_io_mb_hall_handler+0x2e>
		req_io_mb_get_ereq();
  40e12c:	4b14      	ldr	r3, [pc, #80]	; (40e180 <req_io_mb_hall_handler+0xc0>)
		req_transaction.buff_size = 10;
  40e12e:	270a      	movs	r7, #10
		req_io_mb_get_ereq();
  40e130:	4798      	blx	r3
		mb_Holding_reg_hall[4] = mb_Holding_reg_car[5];
  40e132:	4914      	ldr	r1, [pc, #80]	; (40e184 <req_io_mb_hall_handler+0xc4>)
		req_transaction.start_add = 1;;
  40e134:	2301      	movs	r3, #1
		mb_Holding_reg_hall[4] = mb_Holding_reg_car[5];
  40e136:	4a14      	ldr	r2, [pc, #80]	; (40e188 <req_io_mb_hall_handler+0xc8>)
		mb_Holding_reg_hall[5] = mb_Holding_reg_car[6];
  40e138:	898d      	ldrh	r5, [r1, #12]
		mb_Holding_reg_hall[4] = mb_Holding_reg_car[5];
  40e13a:	f8b1 e00a 	ldrh.w	lr, [r1, #10]
		if (mb_add_transaction(1, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS) hall_broadcast = 0;
  40e13e:	4618      	mov	r0, r3
		mb_Holding_reg_hall[5] = mb_Holding_reg_car[6];
  40e140:	8155      	strh	r5, [r2, #10]
		if (mb_add_transaction(1, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS) hall_broadcast = 0;
  40e142:	a901      	add	r1, sp, #4
  40e144:	4d0d      	ldr	r5, [pc, #52]	; (40e17c <req_io_mb_hall_handler+0xbc>)
		req_transaction.slave_add = 0;
  40e146:	f88d 400e 	strb.w	r4, [sp, #14]
		mb_Holding_reg_hall[4] = mb_Holding_reg_car[5];
  40e14a:	f8a2 e008 	strh.w	lr, [r2, #8]
		req_transaction.data_buff = mb_Holding_reg_hall;
  40e14e:	9202      	str	r2, [sp, #8]
		req_transaction.start_add = 1;;
  40e150:	f88d 300c 	strb.w	r3, [sp, #12]
		req_transaction.entry_type = WR_HREG;
  40e154:	f88d 3004 	strb.w	r3, [sp, #4]
		req_transaction.buff_size = 10;
  40e158:	f88d 700d 	strb.w	r7, [sp, #13]
		if (mb_add_transaction(1, &req_transaction) == MB_ADD_TRANSACTION_SUCCESS) hall_broadcast = 0;
  40e15c:	47a8      	blx	r5
  40e15e:	2801      	cmp	r0, #1
  40e160:	d1c5      	bne.n	40e0ee <req_io_mb_hall_handler+0x2e>
  40e162:	7034      	strb	r4, [r6, #0]
  40e164:	e7c3      	b.n	40e0ee <req_io_mb_hall_handler+0x2e>
  40e166:	bf00      	nop
  40e168:	2040095d 	.word	0x2040095d
  40e16c:	cccccccd 	.word	0xcccccccd
  40e170:	2040095c 	.word	0x2040095c
  40e174:	204052b4 	.word	0x204052b4
  40e178:	20406288 	.word	0x20406288
  40e17c:	0040a769 	.word	0x0040a769
  40e180:	0040e065 	.word	0x0040e065
  40e184:	20406278 	.word	0x20406278
  40e188:	204062dc 	.word	0x204062dc

0040e18c <req_io_mb_scan_handler>:

void req_io_mb_scan_handler(void)
{
  40e18c:	b510      	push	{r4, lr}
	req_io_mb_cabin_handler();
  40e18e:	4b04      	ldr	r3, [pc, #16]	; (40e1a0 <req_io_mb_scan_handler+0x14>)
  40e190:	4798      	blx	r3
	req_io_mb_hall_handler();	
  40e192:	4b04      	ldr	r3, [pc, #16]	; (40e1a4 <req_io_mb_scan_handler+0x18>)
  40e194:	4798      	blx	r3
	comm_loss_monitor();
  40e196:	4b04      	ldr	r3, [pc, #16]	; (40e1a8 <req_io_mb_scan_handler+0x1c>)
}
  40e198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	comm_loss_monitor();
  40e19c:	4718      	bx	r3
  40e19e:	bf00      	nop
  40e1a0:	0040dfb9 	.word	0x0040dfb9
  40e1a4:	0040e0c1 	.word	0x0040e0c1
  40e1a8:	0040df45 	.word	0x0040df45

0040e1ac <axt_clark_exe>:
float32_t axt_id, axt_iq;



void axt_clark_exe(void)
{
  40e1ac:	b500      	push	{lr}
  40e1ae:	b085      	sub	sp, #20
	float32_t ia, ib, ic;
	
	inverter_get_creadings(&ia, &ib, &ic);
  40e1b0:	4b0d      	ldr	r3, [pc, #52]	; (40e1e8 <axt_clark_exe+0x3c>)
  40e1b2:	aa03      	add	r2, sp, #12
  40e1b4:	a902      	add	r1, sp, #8
  40e1b6:	a801      	add	r0, sp, #4
  40e1b8:	4798      	blx	r3
	
	//if( fixedpt_abs(ia + ib + ic) >= M_PHFAIL_DEV) ophfail_err_set;
	axt_ialpha = ia;
  40e1ba:	ed9d 7a01 	vldr	s14, [sp, #4]
	axt_ibeta = ((ia + 2 * ib) * AXT_1OV_SQRT3);
  40e1be:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
  40e1c2:	ed9d 6a02 	vldr	s12, [sp, #8]
  40e1c6:	eef0 5a47 	vmov.f32	s11, s14
  40e1ca:	eddf 6a08 	vldr	s13, [pc, #32]	; 40e1ec <axt_clark_exe+0x40>
  40e1ce:	4b08      	ldr	r3, [pc, #32]	; (40e1f0 <axt_clark_exe+0x44>)
	axt_ialpha = ia;
  40e1d0:	4a08      	ldr	r2, [pc, #32]	; (40e1f4 <axt_clark_exe+0x48>)
	axt_ibeta = ((ia + 2 * ib) * AXT_1OV_SQRT3);
  40e1d2:	eee6 5a27 	vfma.f32	s11, s12, s15
	axt_ialpha = ia;
  40e1d6:	ed82 7a00 	vstr	s14, [r2]
	axt_ibeta = ((ia + 2 * ib) * AXT_1OV_SQRT3);
  40e1da:	ee65 7aa6 	vmul.f32	s15, s11, s13
  40e1de:	edc3 7a00 	vstr	s15, [r3]
}
  40e1e2:	b005      	add	sp, #20
  40e1e4:	f85d fb04 	ldr.w	pc, [sp], #4
  40e1e8:	004153c1 	.word	0x004153c1
  40e1ec:	3f13cd3a 	.word	0x3f13cd3a
  40e1f0:	204062fc 	.word	0x204062fc
  40e1f4:	20406310 	.word	0x20406310

0040e1f8 <axt_set_theta>:

void axt_set_theta(float32_t theta)
{
	axt_theta = (theta * AXT_2PI);
	axt_theta = (axt_theta / (360));
  40e1f8:	ee07 0a10 	vmov	s14, r0
  40e1fc:	eddf 7a09 	vldr	s15, [pc, #36]	; 40e224 <axt_set_theta+0x2c>
	
	axt_stheta = arm_sin_f32(axt_theta);
  40e200:	4b09      	ldr	r3, [pc, #36]	; (40e228 <axt_set_theta+0x30>)
	axt_theta = (axt_theta / (360));
  40e202:	ee67 7a27 	vmul.f32	s15, s14, s15
{
  40e206:	b510      	push	{r4, lr}
	axt_theta = (axt_theta / (360));
  40e208:	4c08      	ldr	r4, [pc, #32]	; (40e22c <axt_set_theta+0x34>)
	axt_stheta = arm_sin_f32(axt_theta);
  40e20a:	ee17 0a90 	vmov	r0, s15
	axt_theta = (axt_theta / (360));
  40e20e:	edc4 7a00 	vstr	s15, [r4]
	axt_stheta = arm_sin_f32(axt_theta);
  40e212:	4798      	blx	r3
  40e214:	4a06      	ldr	r2, [pc, #24]	; (40e230 <axt_set_theta+0x38>)
	axt_ctheta = arm_cos_f32(axt_theta);
  40e216:	4b07      	ldr	r3, [pc, #28]	; (40e234 <axt_set_theta+0x3c>)
	axt_stheta = arm_sin_f32(axt_theta);
  40e218:	6010      	str	r0, [r2, #0]
	axt_ctheta = arm_cos_f32(axt_theta);
  40e21a:	6820      	ldr	r0, [r4, #0]
  40e21c:	4798      	blx	r3
  40e21e:	4b06      	ldr	r3, [pc, #24]	; (40e238 <axt_set_theta+0x40>)
  40e220:	6018      	str	r0, [r3, #0]
  40e222:	bd10      	pop	{r4, pc}
  40e224:	3c8efa36 	.word	0x3c8efa36
  40e228:	00418141 	.word	0x00418141
  40e22c:	20406304 	.word	0x20406304
  40e230:	20406308 	.word	0x20406308
  40e234:	004181c1 	.word	0x004181c1
  40e238:	204062f4 	.word	0x204062f4

0040e23c <axt_park_exe>:
{
	
	float32_t tmp;

			
	axt_id = (axt_ialpha * axt_ctheta) + (axt_ibeta * axt_stheta);
  40e23c:	4a0d      	ldr	r2, [pc, #52]	; (40e274 <axt_park_exe+0x38>)
  40e23e:	4b0e      	ldr	r3, [pc, #56]	; (40e278 <axt_park_exe+0x3c>)
  40e240:	490e      	ldr	r1, [pc, #56]	; (40e27c <axt_park_exe+0x40>)
  40e242:	edd2 7a00 	vldr	s15, [r2]
  40e246:	edd3 6a00 	vldr	s13, [r3]
  40e24a:	edd1 5a00 	vldr	s11, [r1]
  40e24e:	4b0c      	ldr	r3, [pc, #48]	; (40e280 <axt_park_exe+0x44>)
	axt_iq = (axt_ibeta * axt_ctheta) - (axt_ialpha * axt_stheta);
  40e250:	ee27 7ae5 	vnmul.f32	s14, s15, s11
	axt_id = (axt_ialpha * axt_ctheta) + (axt_ibeta * axt_stheta);
  40e254:	4a0b      	ldr	r2, [pc, #44]	; (40e284 <axt_park_exe+0x48>)
  40e256:	ee66 7aa7 	vmul.f32	s15, s13, s15
  40e25a:	ed93 6a00 	vldr	s12, [r3]
	axt_iq = (axt_ibeta * axt_ctheta) - (axt_ialpha * axt_stheta);
  40e25e:	4b0a      	ldr	r3, [pc, #40]	; (40e288 <axt_park_exe+0x4c>)
  40e260:	eea6 7a26 	vfma.f32	s14, s12, s13
	axt_id = (axt_ialpha * axt_ctheta) + (axt_ibeta * axt_stheta);
  40e264:	eee5 7a86 	vfma.f32	s15, s11, s12
	axt_iq = (axt_ibeta * axt_ctheta) - (axt_ialpha * axt_stheta);
  40e268:	ed83 7a00 	vstr	s14, [r3]
	axt_id = (axt_ialpha * axt_ctheta) + (axt_ibeta * axt_stheta);
  40e26c:	edc2 7a00 	vstr	s15, [r2]
	axt_iq = (axt_ibeta * axt_ctheta) - (axt_ialpha * axt_stheta);
  40e270:	4770      	bx	lr
  40e272:	bf00      	nop
  40e274:	20406308 	.word	0x20406308
  40e278:	204062fc 	.word	0x204062fc
  40e27c:	20406310 	.word	0x20406310
  40e280:	204062f4 	.word	0x204062f4
  40e284:	2040630c 	.word	0x2040630c
  40e288:	204062f8 	.word	0x204062f8

0040e28c <axt_get_park_transform>:
}

void axt_get_park_transform(float ina, float inb, float *outd, float *outq)
{	
  40e28c:	b410      	push	{r4}
	*outd = (ina * axt_ctheta) + (inb * axt_stheta);
  40e28e:	4c0e      	ldr	r4, [pc, #56]	; (40e2c8 <axt_get_park_transform+0x3c>)
{	
  40e290:	ee06 1a90 	vmov	s13, r1
	*outd = (ina * axt_ctheta) + (inb * axt_stheta);
  40e294:	490d      	ldr	r1, [pc, #52]	; (40e2cc <axt_get_park_transform+0x40>)
{	
  40e296:	ee06 0a10 	vmov	s12, r0
	*outd = (ina * axt_ctheta) + (inb * axt_stheta);
  40e29a:	ed94 7a00 	vldr	s14, [r4]
  40e29e:	edd1 7a00 	vldr	s15, [r1]
  40e2a2:	ee26 7a87 	vmul.f32	s14, s13, s14
  40e2a6:	eea7 7a86 	vfma.f32	s14, s15, s12
  40e2aa:	ed82 7a00 	vstr	s14, [r2]
	*outq = (inb * axt_ctheta) - (ina * axt_stheta);
  40e2ae:	edd4 7a00 	vldr	s15, [r4]
  40e2b2:	ed91 7a00 	vldr	s14, [r1]
  40e2b6:	ee67 7ac6 	vnmul.f32	s15, s15, s12
}
  40e2ba:	f85d 4b04 	ldr.w	r4, [sp], #4
	*outq = (inb * axt_ctheta) - (ina * axt_stheta);
  40e2be:	eee6 7a87 	vfma.f32	s15, s13, s14
  40e2c2:	edc3 7a00 	vstr	s15, [r3]
}
  40e2c6:	4770      	bx	lr
  40e2c8:	20406308 	.word	0x20406308
  40e2cc:	204062f4 	.word	0x204062f4

0040e2d0 <axt_get_id>:

float32_t axt_get_id(void)
{
	//return iav;
	return axt_id;
  40e2d0:	4b01      	ldr	r3, [pc, #4]	; (40e2d8 <axt_get_id+0x8>)
}
  40e2d2:	6818      	ldr	r0, [r3, #0]
  40e2d4:	4770      	bx	lr
  40e2d6:	bf00      	nop
  40e2d8:	2040630c 	.word	0x2040630c

0040e2dc <axt_get_iq>:

float32_t axt_get_iq(void)
{
	return axt_iq;
  40e2dc:	4b01      	ldr	r3, [pc, #4]	; (40e2e4 <axt_get_iq+0x8>)
	//volatile float m = fixedpt_tofloat(axt_iq);
}
  40e2de:	6818      	ldr	r0, [r3, #0]
  40e2e0:	4770      	bx	lr
  40e2e2:	bf00      	nop
  40e2e4:	204062f8 	.word	0x204062f8

0040e2e8 <axt_get_ialpha>:

float32_t axt_get_ialpha(void)
{
	return axt_ialpha;
  40e2e8:	4b01      	ldr	r3, [pc, #4]	; (40e2f0 <axt_get_ialpha+0x8>)
}
  40e2ea:	6818      	ldr	r0, [r3, #0]
  40e2ec:	4770      	bx	lr
  40e2ee:	bf00      	nop
  40e2f0:	20406310 	.word	0x20406310

0040e2f4 <axt_get_ibeta>:

float32_t axt_get_ibeta(void)
{
	return axt_ibeta;
  40e2f4:	4b01      	ldr	r3, [pc, #4]	; (40e2fc <axt_get_ibeta+0x8>)
}
  40e2f6:	6818      	ldr	r0, [r3, #0]
  40e2f8:	4770      	bx	lr
  40e2fa:	bf00      	nop
  40e2fc:	204062fc 	.word	0x204062fc

0040e300 <axt_ipark_exe>:
void axt_ipark_exe(float32_t vd, float32_t vq, float32_t *valpha, float32_t *vbeta)
{
  40e300:	b410      	push	{r4}
	*valpha = (vd * axt_ctheta) - (vq * axt_stheta);
  40e302:	4c0e      	ldr	r4, [pc, #56]	; (40e33c <axt_ipark_exe+0x3c>)
{
  40e304:	ee06 1a90 	vmov	s13, r1
	*valpha = (vd * axt_ctheta) - (vq * axt_stheta);
  40e308:	490d      	ldr	r1, [pc, #52]	; (40e340 <axt_ipark_exe+0x40>)
{
  40e30a:	ee07 0a90 	vmov	s15, r0
	*valpha = (vd * axt_ctheta) - (vq * axt_stheta);
  40e30e:	ed94 7a00 	vldr	s14, [r4]
  40e312:	ed91 6a00 	vldr	s12, [r1]
  40e316:	ee27 7a66 	vnmul.f32	s14, s14, s13
  40e31a:	eea6 7a27 	vfma.f32	s14, s12, s15
  40e31e:	ed82 7a00 	vstr	s14, [r2]
	*vbeta = (vq * axt_ctheta) + (vd * axt_stheta);
  40e322:	ed94 6a00 	vldr	s12, [r4]
  40e326:	ed91 7a00 	vldr	s14, [r1]
  40e32a:	ee67 7a86 	vmul.f32	s15, s15, s12
}
  40e32e:	f85d 4b04 	ldr.w	r4, [sp], #4
	*vbeta = (vq * axt_ctheta) + (vd * axt_stheta);
  40e332:	eee6 7a87 	vfma.f32	s15, s13, s14
  40e336:	edc3 7a00 	vstr	s15, [r3]
}
  40e33a:	4770      	bx	lr
  40e33c:	20406308 	.word	0x20406308
  40e340:	204062f4 	.word	0x204062f4

0040e344 <axt_integrate_current>:
#define AXT_AVRAGE_ATTENUATION (0.09f)
float32_t axt_current = 0, axt_prev_sample = 0;
uint32_t n;
void axt_integrate_current(float32_t curr)
{
	axt_current += ((curr) - axt_current) * (TSAMPLE / AXT_AVRAGE_ATTENUATION);
  40e344:	4b09      	ldr	r3, [pc, #36]	; (40e36c <axt_integrate_current+0x28>)
  40e346:	eddf 6a0a 	vldr	s13, [pc, #40]	; 40e370 <axt_integrate_current+0x2c>
  40e34a:	edd3 7a00 	vldr	s15, [r3]
  40e34e:	4b09      	ldr	r3, [pc, #36]	; (40e374 <axt_integrate_current+0x30>)
  40e350:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  40e354:	ee06 0a90 	vmov	s13, r0
  40e358:	edd3 7a00 	vldr	s15, [r3]
  40e35c:	ee76 6ae7 	vsub.f32	s13, s13, s15
  40e360:	eee6 7a87 	vfma.f32	s15, s13, s14
  40e364:	edc3 7a00 	vstr	s15, [r3]
  40e368:	4770      	bx	lr
  40e36a:	bf00      	nop
  40e36c:	204003c8 	.word	0x204003c8
  40e370:	4131c71c 	.word	0x4131c71c
  40e374:	20400960 	.word	0x20400960

0040e378 <axt_get_current_avg>:
	
}

float32_t axt_get_current_avg(void)
{
	return axt_current;
  40e378:	4b01      	ldr	r3, [pc, #4]	; (40e380 <axt_get_current_avg+0x8>)
}
  40e37a:	6818      	ldr	r0, [r3, #0]
  40e37c:	4770      	bx	lr
  40e37e:	bf00      	nop
  40e380:	20400960 	.word	0x20400960

0040e384 <axt_reset_current_avg>:

void axt_reset_current_avg(void)
{
	axt_current = 0;
  40e384:	4b01      	ldr	r3, [pc, #4]	; (40e38c <axt_reset_current_avg+0x8>)
  40e386:	2200      	movs	r2, #0
  40e388:	601a      	str	r2, [r3, #0]
  40e38a:	4770      	bx	lr
  40e38c:	20400960 	.word	0x20400960

0040e390 <scurve_get_abs_from_relative>:

speedProfile_t scurve_speed[3];
speedProfile_t acc_profile[3], dec_profile[3], dec_profilez[3];

motion_dynamics_t scurve_get_abs_from_relative(motion_dynamics_t relative_motion)
{
  40e390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	motion_dynamics_t temp;
	
	temp.a  = fixedpt_div(motor_basefreq, relative_motion.a);
  40e394:	4c1a      	ldr	r4, [pc, #104]	; (40e400 <scurve_get_abs_from_relative+0x70>)
{
  40e396:	b085      	sub	sp, #20
  40e398:	4606      	mov	r6, r0
  40e39a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 40e404 <scurve_get_abs_from_relative+0x74>
  40e39e:	68a5      	ldr	r5, [r4, #8]
  40e3a0:	ac04      	add	r4, sp, #16
  40e3a2:	ea4f 7be5 	mov.w	fp, r5, asr #31
  40e3a6:	03e8      	lsls	r0, r5, #15
  40e3a8:	e904 000e 	stmdb	r4, {r1, r2, r3}
  40e3ac:	ea4f 31cb 	mov.w	r1, fp, lsl #15
  40e3b0:	9c01      	ldr	r4, [sp, #4]
  40e3b2:	ea41 4155 	orr.w	r1, r1, r5, lsr #17
  40e3b6:	4622      	mov	r2, r4
  40e3b8:	17e3      	asrs	r3, r4, #31
  40e3ba:	47c0      	blx	r8
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3bc:	9a02      	ldr	r2, [sp, #8]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3be:	ea4f 4a60 	mov.w	sl, r0, asr #17
  40e3c2:	4607      	mov	r7, r0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3c4:	fb84 2302 	smull	r2, r3, r4, r2
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3c8:	03c5      	lsls	r5, r0, #15
  40e3ca:	4651      	mov	r1, sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3cc:	0bd2      	lsrs	r2, r2, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3ce:	4628      	mov	r0, r5
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3d0:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3d4:	17d3      	asrs	r3, r2, #31
  40e3d6:	47c0      	blx	r8
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3d8:	9b03      	ldr	r3, [sp, #12]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3da:	4681      	mov	r9, r0
  40e3dc:	4628      	mov	r0, r5
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3de:	fb84 4503 	smull	r4, r5, r4, r3
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3e2:	4651      	mov	r1, sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e3e4:	0be2      	lsrs	r2, r4, #15
  40e3e6:	ea42 4245 	orr.w	r2, r2, r5, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e3ea:	17d3      	asrs	r3, r2, #31
  40e3ec:	47c0      	blx	r8
	temp.j1 = fixedpt_mul(relative_motion.a, relative_motion.j1);
	temp.j2 = fixedpt_mul(relative_motion.a, relative_motion.j2);
	temp.j1 = fixedpt_div(temp.a, temp.j1);
	temp.j2 = fixedpt_div(temp.a, temp.j2);
	temp.j2 *= -1;
  40e3ee:	4243      	negs	r3, r0
	
	return temp;
}
  40e3f0:	4630      	mov	r0, r6
	return temp;
  40e3f2:	f8c6 9004 	str.w	r9, [r6, #4]
  40e3f6:	60b3      	str	r3, [r6, #8]
  40e3f8:	6037      	str	r7, [r6, #0]
}
  40e3fa:	b005      	add	sp, #20
  40e3fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40e400:	20404ff0 	.word	0x20404ff0
  40e404:	0041905d 	.word	0x0041905d

0040e408 <get_displacement_from_sprofile>:
	
	return t_distance;
}

fixedpt get_displacement_from_sprofile(speedProfile_t *sprofile)
{
  40e408:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e40c:	68c3      	ldr	r3, [r0, #12]
  40e40e:	b085      	sub	sp, #20
  40e410:	f8d0 c02c 	ldr.w	ip, [r0, #44]	; 0x2c
  40e414:	fb83 6703 	smull	r6, r7, r3, r3
  40e418:	69c3      	ldr	r3, [r0, #28]
  40e41a:	fb8c 890c 	smull	r8, r9, ip, ip
  40e41e:	fb83 4503 	smull	r4, r5, r3, r3
  40e422:	0bf3      	lsrs	r3, r6, #15
  40e424:	0be2      	lsrs	r2, r4, #15
  40e426:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  40e42a:	4611      	mov	r1, r2
  40e42c:	68c2      	ldr	r2, [r0, #12]
  40e42e:	ea41 4445 	orr.w	r4, r1, r5, lsl #17
  40e432:	fb82 ab03 	smull	sl, fp, r2, r3
  40e436:	ea4f 32d8 	mov.w	r2, r8, lsr #15
  40e43a:	6801      	ldr	r1, [r0, #0]
  40e43c:	4625      	mov	r5, r4
  40e43e:	ea4f 36da 	mov.w	r6, sl, lsr #15
  40e442:	69c4      	ldr	r4, [r0, #28]
  40e444:	ea42 4249 	orr.w	r2, r2, r9, lsl #17
  40e448:	ea46 464b 	orr.w	r6, r6, fp, lsl #17
  40e44c:	9500      	str	r5, [sp, #0]
  40e44e:	fb84 8905 	smull	r8, r9, r4, r5
  40e452:	6904      	ldr	r4, [r0, #16]
  40e454:	fb81 6706 	smull	r6, r7, r1, r6
  40e458:	6845      	ldr	r5, [r0, #4]
  40e45a:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  40e45e:	0bf1      	lsrs	r1, r6, #15
  40e460:	fb83 ab05 	smull	sl, fp, r3, r5
  40e464:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
  40e468:	fb8c 8902 	smull	r8, r9, ip, r2
  40e46c:	ea41 4147 	orr.w	r1, r1, r7, lsl #17
  40e470:	6885      	ldr	r5, [r0, #8]
  40e472:	fb84 670e 	smull	r6, r7, r4, lr
	t_distance += (fixedpt_mul(sprofile.j, t_time)/6);
  40e476:	4c2f      	ldr	r4, [pc, #188]	; (40e534 <get_displacement_from_sprofile+0x12c>)
  40e478:	ea4f 33d8 	mov.w	r3, r8, lsr #15
  40e47c:	e9cd 6702 	strd	r6, r7, [sp, #8]
  40e480:	fb84 4601 	smull	r4, r6, r4, r1
  40e484:	68c4      	ldr	r4, [r0, #12]
  40e486:	ea43 4349 	orr.w	r3, r3, r9, lsl #17
  40e48a:	fb84 8905 	smull	r8, r9, r4, r5
  40e48e:	6945      	ldr	r5, [r0, #20]
  40e490:	9c00      	ldr	r4, [sp, #0]
  40e492:	ea4f 37da 	mov.w	r7, sl, lsr #15
  40e496:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  40e49a:	fb84 4505 	smull	r4, r5, r4, r5
  40e49e:	eba6 71e1 	sub.w	r1, r6, r1, asr #31
  40e4a2:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
  40e4a6:	6986      	ldr	r6, [r0, #24]
  40e4a8:	ea47 474b 	orr.w	r7, r7, fp, lsl #17
  40e4ac:	e9cd 4500 	strd	r4, r5, [sp]
  40e4b0:	69c4      	ldr	r4, [r0, #28]
	t_distance = fixedpt_mul(sprofile.w, sprofile.duration) + (fixedpt_mul(sprofile.a, t_time)>>1);
  40e4b2:	eb0e 0767 	add.w	r7, lr, r7, asr #1
  40e4b6:	fb84 8906 	smull	r8, r9, r4, r6
  40e4ba:	6a06      	ldr	r6, [r0, #32]
	t_distance += (fixedpt_mul(sprofile.j, t_time)/6);
  40e4bc:	4439      	add	r1, r7
  40e4be:	fb86 6703 	smull	r6, r7, r6, r3
  40e4c2:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40e4c4:	6a80      	ldr	r0, [r0, #40]	; 0x28
  40e4c6:	fb82 3403 	smull	r3, r4, r2, r3
  40e4ca:	0bf5      	lsrs	r5, r6, #15
  40e4cc:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
  40e4d0:	e9cd 3402 	strd	r3, r4, [sp, #8]
  40e4d4:	ea4f 3eda 	mov.w	lr, sl, lsr #15
  40e4d8:	4b16      	ldr	r3, [pc, #88]	; (40e534 <get_displacement_from_sprofile+0x12c>)
  40e4da:	ea45 4547 	orr.w	r5, r5, r7, lsl #17
  40e4de:	ea4e 4e4b 	orr.w	lr, lr, fp, lsl #17
  40e4e2:	fb8c ab00 	smull	sl, fp, ip, r0
  40e4e6:	fb83 300e 	smull	r3, r0, r3, lr
  40e4ea:	9b00      	ldr	r3, [sp, #0]
  40e4ec:	eba0 70ee 	sub.w	r0, r0, lr, asr #31
  40e4f0:	0bdc      	lsrs	r4, r3, #15
  40e4f2:	9b01      	ldr	r3, [sp, #4]
  40e4f4:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  40e4f8:	ea44 4443 	orr.w	r4, r4, r3, lsl #17
  40e4fc:	4b0d      	ldr	r3, [pc, #52]	; (40e534 <get_displacement_from_sprofile+0x12c>)
  40e4fe:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
  40e502:	fb83 3205 	smull	r3, r2, r3, r5
	t_distance = fixedpt_mul(sprofile.w, sprofile.duration) + (fixedpt_mul(sprofile.a, t_time)>>1);
  40e506:	eb0e 0e64 	add.w	lr, lr, r4, asr #1
  40e50a:	ea4f 34da 	mov.w	r4, sl, lsr #15
	t_distance += (fixedpt_mul(sprofile.j, t_time)/6);
  40e50e:	4470      	add	r0, lr
  40e510:	eba2 73e5 	sub.w	r3, r2, r5, asr #31
  40e514:	ea44 444b 	orr.w	r4, r4, fp, lsl #17
	fixedpt t_distance = get_displacement_from_sprofileUnit(*sprofile);
	t_distance += get_displacement_from_sprofileUnit(*(sprofile+1));
  40e518:	4408      	add	r0, r1
  40e51a:	e9dd 7802 	ldrd	r7, r8, [sp, #8]
  40e51e:	0bfe      	lsrs	r6, r7, #15
  40e520:	ea46 4648 	orr.w	r6, r6, r8, lsl #17
	t_distance = fixedpt_mul(sprofile.w, sprofile.duration) + (fixedpt_mul(sprofile.a, t_time)>>1);
  40e524:	eb04 0466 	add.w	r4, r4, r6, asr #1
	t_distance += (fixedpt_mul(sprofile.j, t_time)/6);
  40e528:	4423      	add	r3, r4
	t_distance += get_displacement_from_sprofileUnit(*(sprofile+2));
	
	return t_distance;
}
  40e52a:	4418      	add	r0, r3
  40e52c:	b005      	add	sp, #20
  40e52e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40e532:	bf00      	nop
  40e534:	2aaaaaab 	.word	0x2aaaaaab

0040e538 <scurve_apply_precalc_accel_profile>:

	//return 0;
}

void scurve_apply_precalc_accel_profile(void)
{
  40e538:	4b09      	ldr	r3, [pc, #36]	; (40e560 <scurve_apply_precalc_accel_profile+0x28>)
  40e53a:	4a0a      	ldr	r2, [pc, #40]	; (40e564 <scurve_apply_precalc_accel_profile+0x2c>)
  40e53c:	b470      	push	{r4, r5, r6}
  40e53e:	f103 0630 	add.w	r6, r3, #48	; 0x30
	uint32_t i;
	for (i=0; i<3; i++)
	{
		scurve_speed[i].a = acc_profile[i].a;
		scurve_speed[i].j = acc_profile[i].j;
		scurve_speed[i].w = acc_profile[i].w;
  40e542:	6898      	ldr	r0, [r3, #8]
		scurve_speed[i].duration = acc_profile[i].duration;
  40e544:	68d9      	ldr	r1, [r3, #12]
		scurve_speed[i].w = acc_profile[i].w;
  40e546:	6090      	str	r0, [r2, #8]
		scurve_speed[i].duration = acc_profile[i].duration;
  40e548:	60d1      	str	r1, [r2, #12]
		scurve_speed[i].j = acc_profile[i].j;
  40e54a:	e893 0030 	ldmia.w	r3, {r4, r5}
  40e54e:	3310      	adds	r3, #16
	for (i=0; i<3; i++)
  40e550:	42b3      	cmp	r3, r6
		scurve_speed[i].j = acc_profile[i].j;
  40e552:	e882 0030 	stmia.w	r2, {r4, r5}
  40e556:	f102 0210 	add.w	r2, r2, #16
	for (i=0; i<3; i++)
  40e55a:	d1f2      	bne.n	40e542 <scurve_apply_precalc_accel_profile+0xa>
	}
}
  40e55c:	bc70      	pop	{r4, r5, r6}
  40e55e:	4770      	bx	lr
  40e560:	20406314 	.word	0x20406314
  40e564:	20406344 	.word	0x20406344

0040e568 <scurve_generate_speed_profile>:
		scurve_speed[i].duration = dec_profilez[i].duration;
	}
}

void scurve_generate_speed_profile(fixedpt c_speed, fixedpt d_speed, fixedpt c_acceleration, motion_dynamics_t motion, speedProfile_t *speedprof )
{
  40e568:	b082      	sub	sp, #8
  40e56a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40e56e:	b08d      	sub	sp, #52	; 0x34
  40e570:	461f      	mov	r7, r3
  40e572:	9201      	str	r2, [sp, #4]
	fixedpt t0, t02, t1, t2, t22, del_w0, del_w1, del_w2;
	
	//finding the critical case where where there is no constant acceleration only jerks
	del_w1 = d_speed - c_speed; 
  40e574:	1a0a      	subs	r2, r1, r0
{
  40e576:	9317      	str	r3, [sp, #92]	; 0x5c
	del_w1 = d_speed - c_speed; 
  40e578:	4603      	mov	r3, r0
{
  40e57a:	9007      	str	r0, [sp, #28]
	del_w1 = d_speed - c_speed; 
  40e57c:	9203      	str	r2, [sp, #12]
	if (d_speed < c_speed)
  40e57e:	4299      	cmp	r1, r3
  40e580:	9a18      	ldr	r2, [sp, #96]	; 0x60
  40e582:	9819      	ldr	r0, [sp, #100]	; 0x64
{
  40e584:	9c1a      	ldr	r4, [sp, #104]	; 0x68
  40e586:	9200      	str	r2, [sp, #0]
  40e588:	9002      	str	r0, [sp, #8]
	if (d_speed < c_speed)
  40e58a:	da04      	bge.n	40e596 <scurve_generate_speed_profile+0x2e>
	{
		motion.a = -motion.a;
		motion.j1 = -motion.j1;
  40e58c:	4253      	negs	r3, r2
		motion.a = -motion.a;
  40e58e:	427f      	negs	r7, r7
		motion.j1 = -motion.j1;
  40e590:	9300      	str	r3, [sp, #0]
		motion.j2 = -motion.j2;
  40e592:	4243      	negs	r3, r0
  40e594:	9302      	str	r3, [sp, #8]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e596:	9e00      	ldr	r6, [sp, #0]
  40e598:	46b8      	mov	r8, r7
	}
	
	t0 = fixedpt_div ((motion.a - c_acceleration), motion.j1);
  40e59a:	9b01      	ldr	r3, [sp, #4]
  40e59c:	ea4f 79e6 	mov.w	r9, r6, asr #31
  40e5a0:	9d02      	ldr	r5, [sp, #8]
  40e5a2:	1af9      	subs	r1, r7, r3
  40e5a4:	4632      	mov	r2, r6
  40e5a6:	464b      	mov	r3, r9
  40e5a8:	ea4f 79e7 	mov.w	r9, r7, asr #31
  40e5ac:	46aa      	mov	sl, r5
  40e5ae:	ea4f 7be5 	mov.w	fp, r5, asr #31

		
	t02 = fixedpt_mul(t0, t0);
	t22 = fixedpt_mul(t2, t2);
	
	del_w0 = fixedpt_mul((motion.j1>>1),t02) + fixedpt_mul(c_acceleration,t0);
  40e5b2:	1076      	asrs	r6, r6, #1
  40e5b4:	03c8      	lsls	r0, r1, #15
  40e5b6:	9606      	str	r6, [sp, #24]
  40e5b8:	4ea6      	ldr	r6, [pc, #664]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e5ba:	e9cd 8904 	strd	r8, r9, [sp, #16]
  40e5be:	ea4f 79e1 	mov.w	r9, r1, asr #31
  40e5c2:	ea4f 35c9 	mov.w	r5, r9, lsl #15
  40e5c6:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  40e5ca:	ea45 4151 	orr.w	r1, r5, r1, lsr #17
  40e5ce:	4da1      	ldr	r5, [pc, #644]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e5d0:	47a8      	blx	r5
  40e5d2:	9d05      	ldr	r5, [sp, #20]
  40e5d4:	4652      	mov	r2, sl
  40e5d6:	465b      	mov	r3, fp
  40e5d8:	03e9      	lsls	r1, r5, #15
	t0 = fixedpt_abs(t0);
  40e5da:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
  40e5de:	ea41 4157 	orr.w	r1, r1, r7, lsr #17
  40e5e2:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
  40e5e6:	03f8      	lsls	r0, r7, #15
  40e5e8:	e9cd ab08 	strd	sl, fp, [sp, #32]
  40e5ec:	47b0      	blx	r6
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e5ee:	fb85 ab05 	smull	sl, fp, r5, r5
	t2 = fixedpt_abs(t2);
  40e5f2:	ea80 76e0 	eor.w	r6, r0, r0, asr #31
  40e5f6:	9901      	ldr	r1, [sp, #4]
  40e5f8:	ea4f 38da 	mov.w	r8, sl, lsr #15
  40e5fc:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
	del_w2 = fixedpt_mul((motion.j2>>1),t22) + fixedpt_mul(motion.a,t2);
  40e600:	9802      	ldr	r0, [sp, #8]
  40e602:	ea48 484b 	orr.w	r8, r8, fp, lsl #17
  40e606:	fb81 ab05 	smull	sl, fp, r1, r5
  40e60a:	fb86 2306 	smull	r2, r3, r6, r6
  40e60e:	9906      	ldr	r1, [sp, #24]
  40e610:	1040      	asrs	r0, r0, #1
  40e612:	0bd2      	lsrs	r2, r2, #15
  40e614:	fb81 8908 	smull	r8, r9, r1, r8
  40e618:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  40e61c:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  40e620:	fb80 0102 	smull	r0, r1, r0, r2
  40e624:	fb86 2307 	smull	r2, r3, r6, r7
  40e628:	ea4f 37da 	mov.w	r7, sl, lsr #15
  40e62c:	0bc0      	lsrs	r0, r0, #15
  40e62e:	0bd2      	lsrs	r2, r2, #15
  40e630:	ea47 474b 	orr.w	r7, r7, fp, lsl #17
  40e634:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  40e638:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
  40e63c:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
  40e640:	4410      	add	r0, r2
	del_w0 = fixedpt_mul((motion.j1>>1),t02) + fixedpt_mul(c_acceleration,t0);
  40e642:	eb07 0b0e 	add.w	fp, r7, lr

	if (fixedpt_abs(del_w1) <= fixedpt_abs(del_w0) + fixedpt_abs(del_w2))
  40e646:	9f03      	ldr	r7, [sp, #12]
  40e648:	ea80 72e0 	eor.w	r2, r0, r0, asr #31
  40e64c:	ea8b 73eb 	eor.w	r3, fp, fp, asr #31
  40e650:	2f00      	cmp	r7, #0
  40e652:	eba2 72e0 	sub.w	r2, r2, r0, asr #31
  40e656:	4639      	mov	r1, r7
  40e658:	eba3 73eb 	sub.w	r3, r3, fp, asr #31
  40e65c:	bfb8      	it	lt
  40e65e:	4279      	neglt	r1, r7
  40e660:	4413      	add	r3, r2
  40e662:	4299      	cmp	r1, r3
  40e664:	f300 80a2 	bgt.w	40e7ac <scurve_generate_speed_profile+0x244>
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e668:	9e00      	ldr	r6, [sp, #0]
  40e66a:	e9dd 890a 	ldrd	r8, r9, [sp, #40]	; 0x28
  40e66e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
  40e672:	4648      	mov	r0, r9
  40e674:	03c1      	lsls	r1, r0, #15
  40e676:	03f0      	lsls	r0, r6, #15
  40e678:	ea41 4156 	orr.w	r1, r1, r6, lsr #17
  40e67c:	4e75      	ldr	r6, [pc, #468]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e67e:	47b0      	blx	r6
	{
		fixedpt m = (fixedpt_rconst(1) - fixedpt_div(motion.j1, motion.j2));
		fixedpt D = fixedpt_div(-c_acceleration, motion.j1);
  40e680:	9b01      	ldr	r3, [sp, #4]
  40e682:	9003      	str	r0, [sp, #12]
  40e684:	4642      	mov	r2, r8
  40e686:	4259      	negs	r1, r3
  40e688:	464b      	mov	r3, r9
  40e68a:	03ce      	lsls	r6, r1, #15
  40e68c:	ea4f 4b61 	mov.w	fp, r1, asr #17
  40e690:	9604      	str	r6, [sp, #16]
  40e692:	4630      	mov	r0, r6
  40e694:	4659      	mov	r1, fp
  40e696:	4e6f      	ldr	r6, [pc, #444]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e698:	47b0      	blx	r6
  40e69a:	4682      	mov	sl, r0
		t0 = fixedpt_div(del_w1*2, motion.j1);
  40e69c:	0079      	lsls	r1, r7, #1
  40e69e:	4642      	mov	r2, r8
  40e6a0:	0438      	lsls	r0, r7, #16
  40e6a2:	464b      	mov	r3, r9
  40e6a4:	17cf      	asrs	r7, r1, #31
  40e6a6:	03fd      	lsls	r5, r7, #15
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e6a8:	fb8a 670a 	smull	r6, r7, sl, sl
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e6ac:	ea45 4151 	orr.w	r1, r5, r1, lsr #17
  40e6b0:	4d68      	ldr	r5, [pc, #416]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e6b2:	47a8      	blx	r5
		fixedpt m = (fixedpt_rconst(1) - fixedpt_div(motion.j1, motion.j2));
  40e6b4:	9b03      	ldr	r3, [sp, #12]
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e6b6:	0bf1      	lsrs	r1, r6, #15
  40e6b8:	f5c3 4200 	rsb	r2, r3, #32768	; 0x8000
  40e6bc:	ea41 4147 	orr.w	r1, r1, r7, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e6c0:	17d3      	asrs	r3, r2, #31
		t0 = t0 + fixedpt_mul(D, D);
  40e6c2:	4401      	add	r1, r0
  40e6c4:	17cf      	asrs	r7, r1, #31
  40e6c6:	03c8      	lsls	r0, r1, #15
  40e6c8:	03fd      	lsls	r5, r7, #15
  40e6ca:	ea45 4151 	orr.w	r1, r5, r1, lsr #17
  40e6ce:	4d61      	ldr	r5, [pc, #388]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e6d0:	47a8      	blx	r5
{
	int invert = 0;
	int iter = FIXEDPT_FBITS;
	int l, i;

	if (A < 0)
  40e6d2:	2800      	cmp	r0, #0
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e6d4:	4607      	mov	r7, r0
	if (A < 0)
  40e6d6:	f2c0 80ba 	blt.w	40e84e <scurve_generate_speed_profile+0x2e6>
		return (-1);
	if (A == 0 || A == FIXEDPT_ONE)
  40e6da:	f430 4300 	bics.w	r3, r0, #32768	; 0x8000
  40e6de:	d032      	beq.n	40e746 <scurve_generate_speed_profile+0x1de>
		return (A);
	if (A < FIXEDPT_ONE && A > 6) {
  40e6e0:	1fc2      	subs	r2, r0, #7
  40e6e2:	f647 73f8 	movw	r3, #32760	; 0x7ff8
  40e6e6:	429a      	cmp	r2, r3
  40e6e8:	f240 809d 	bls.w	40e826 <scurve_generate_speed_profile+0x2be>
	int invert = 0;
  40e6ec:	2300      	movs	r3, #0
		invert = 1;
		A = fixedpt_div(FIXEDPT_ONE, A);
	}
	if (A > FIXEDPT_ONE) {
  40e6ee:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
	int invert = 0;
  40e6f2:	930a      	str	r3, [sp, #40]	; 0x28
	if (A > FIXEDPT_ONE) {
  40e6f4:	f340 80a4 	ble.w	40e840 <scurve_generate_speed_profile+0x2d8>
  40e6f8:	463b      	mov	r3, r7
  40e6fa:	f04f 0800 	mov.w	r8, #0
		int s = A;

		iter = 0;
		while (s > 0) {
  40e6fe:	109b      	asrs	r3, r3, #2
			s >>= 2;
			iter++;
  40e700:	f108 0801 	add.w	r8, r8, #1
		while (s > 0) {
  40e704:	d1fb      	bne.n	40e6fe <scurve_generate_speed_profile+0x196>
		}
	}

	/* Newton's iterations */
	l = (A >> 1) + 1;
  40e706:	107d      	asrs	r5, r7, #1
  40e708:	3501      	adds	r5, #1
  40e70a:	ea4f 4967 	mov.w	r9, r7, asr #17
	int iter = FIXEDPT_FBITS;
  40e70e:	2600      	movs	r6, #0
  40e710:	03ff      	lsls	r7, r7, #15
  40e712:	941a      	str	r4, [sp, #104]	; 0x68
	for (i = 0; i < iter; i++)
  40e714:	3601      	adds	r6, #1
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e716:	462a      	mov	r2, r5
  40e718:	17eb      	asrs	r3, r5, #31
  40e71a:	4638      	mov	r0, r7
  40e71c:	4649      	mov	r1, r9
  40e71e:	4c4d      	ldr	r4, [pc, #308]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e720:	47a0      	blx	r4
	for (i = 0; i < iter; i++)
  40e722:	4546      	cmp	r6, r8
		l = (l + fixedpt_div(A, l)) >> 1;
  40e724:	4405      	add	r5, r0
  40e726:	ea4f 0565 	mov.w	r5, r5, asr #1
	for (i = 0; i < iter; i++)
  40e72a:	dbf3      	blt.n	40e714 <scurve_generate_speed_profile+0x1ac>
	if (invert)
  40e72c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  40e72e:	9c1a      	ldr	r4, [sp, #104]	; 0x68
  40e730:	2b00      	cmp	r3, #0
  40e732:	f000 808a 	beq.w	40e84a <scurve_generate_speed_profile+0x2e2>
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e736:	462a      	mov	r2, r5
  40e738:	17eb      	asrs	r3, r5, #31
  40e73a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  40e73e:	2100      	movs	r1, #0
  40e740:	4d44      	ldr	r5, [pc, #272]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e742:	47a8      	blx	r5
  40e744:	4607      	mov	r7, r0
		t0 = fixedpt_sqrt(t0);
		
		t1 = D - t0;
		t0 = D + t0;
// 		volatile float ft0 = fixedpt_tofloat(t0);
 		if(t1 >= 0) t0 = t1; //get the lowest value
  40e746:	ebba 0507 	subs.w	r5, sl, r7
// 		ft0 = fixedpt_tofloat(t0);
		
		D = fixedpt_div(-c_acceleration, motion.j2); //calculate D2
		t2 = D + fixedpt_mul((m - fixedpt_rconst(1)), t0);
  40e74a:	9b03      	ldr	r3, [sp, #12]
  40e74c:	4659      	mov	r1, fp
  40e74e:	9804      	ldr	r0, [sp, #16]
		t0 = D + t0;
  40e750:	bf48      	it	mi
  40e752:	eb0a 0507 	addmi.w	r5, sl, r7
		t2 = D + fixedpt_mul((m - fixedpt_rconst(1)), t0);
  40e756:	425e      	negs	r6, r3
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e758:	fb86 6705 	smull	r6, r7, r6, r5
  40e75c:	fb85 8905 	smull	r8, r9, r5, r5
  40e760:	0bf6      	lsrs	r6, r6, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e762:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e766:	ea46 4647 	orr.w	r6, r6, r7, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e76a:	4f3a      	ldr	r7, [pc, #232]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e76c:	47b8      	blx	r7
  40e76e:	9b01      	ldr	r3, [sp, #4]
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e770:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  40e774:	4406      	add	r6, r0
  40e776:	fb83 2305 	smull	r2, r3, r3, r5
  40e77a:	9800      	ldr	r0, [sp, #0]
  40e77c:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
  40e780:	2100      	movs	r1, #0
  40e782:	0bd7      	lsrs	r7, r2, #15
  40e784:	9a06      	ldr	r2, [sp, #24]
  40e786:	fb80 8905 	smull	r8, r9, r0, r5
// 		volatile float fm = fixedpt_tofloat(m);
// 		volatile float fd = fixedpt_tofloat(D);
// 		volatile float fa0 = fixedpt_tofloat(c_acceleration);
// 		volatile float fcs = fixedpt_tofloat(c_speed);
// 		volatile float fds = fixedpt_tofloat(d_speed);
		t1 = 0;
  40e78a:	4608      	mov	r0, r1
  40e78c:	ea47 4743 	orr.w	r7, r7, r3, lsl #17
  40e790:	fb82 230e 	smull	r2, r3, r2, lr
  40e794:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  40e798:	0bd2      	lsrs	r2, r2, #15
  40e79a:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
  40e79e:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  40e7a2:	9b01      	ldr	r3, [sp, #4]
  40e7a4:	eb07 0b02 	add.w	fp, r7, r2
  40e7a8:	449e      	add	lr, r3
  40e7aa:	e01f      	b.n	40e7ec <scurve_generate_speed_profile+0x284>
		del_w1 =0;
	} 
	else if (fixedpt_abs(del_w1) > fixedpt_abs(del_w0) + fixedpt_abs(del_w2))
	{
		del_w1 = del_w1 - del_w0 - del_w2; //set w1 to be the difference between dw and dw0,2
  40e7ac:	9b03      	ldr	r3, [sp, #12]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e7ae:	4f29      	ldr	r7, [pc, #164]	; (40e854 <scurve_generate_speed_profile+0x2ec>)
  40e7b0:	eba3 010b 	sub.w	r1, r3, fp
  40e7b4:	1a09      	subs	r1, r1, r0
  40e7b6:	ea4f 79e1 	mov.w	r9, r1, asr #31
  40e7ba:	03c8      	lsls	r0, r1, #15
  40e7bc:	ea4f 3ec9 	mov.w	lr, r9, lsl #15
  40e7c0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  40e7c4:	ea4e 4151 	orr.w	r1, lr, r1, lsr #17
  40e7c8:	47b8      	blx	r7
  40e7ca:	9b00      	ldr	r3, [sp, #0]
		t1 = fixedpt_div(del_w1, motion.a);
		t1 = fixedpt_abs(t1);
  40e7cc:	2800      	cmp	r0, #0
  40e7ce:	fb85 2303 	smull	r2, r3, r5, r3
  40e7d2:	bfb8      	it	lt
  40e7d4:	4240      	neglt	r0, r0
  40e7d6:	ea4f 3ed2 	mov.w	lr, r2, lsr #15
  40e7da:	ea4e 4e43 	orr.w	lr, lr, r3, lsl #17
  40e7de:	9b01      	ldr	r3, [sp, #4]
  40e7e0:	449e      	add	lr, r3
  40e7e2:	fb80 230e 	smull	r2, r3, r0, lr
  40e7e6:	0bd1      	lsrs	r1, r2, #15
  40e7e8:	ea41 4143 	orr.w	r1, r1, r3, lsl #17
	speedprof->w = c_speed;
	speedprof->duration = t0;

	(speedprof+1)->a = c_acceleration + fixedpt_mul (speedprof->j, speedprof->duration);
	(speedprof+1)->j = 0;
	(speedprof+1)->w = fixedpt_mul (motion.j1 >> 1, t02) + fixedpt_mul (c_acceleration, t0) + c_speed;
  40e7ec:	9a07      	ldr	r2, [sp, #28]
	(speedprof+1)->j = 0;
  40e7ee:	f04f 0c00 	mov.w	ip, #0
	speedprof->a = c_acceleration;
  40e7f2:	9b01      	ldr	r3, [sp, #4]
	(speedprof+1)->w = fixedpt_mul (motion.j1 >> 1, t02) + fixedpt_mul (c_acceleration, t0) + c_speed;
  40e7f4:	eb0b 0702 	add.w	r7, fp, r2
	speedprof->w = c_speed;
  40e7f8:	60a2      	str	r2, [r4, #8]
	speedprof->a = c_acceleration;
  40e7fa:	6063      	str	r3, [r4, #4]
	speedprof->j = motion.j1;
  40e7fc:	9b00      	ldr	r3, [sp, #0]
	(speedprof+1)->duration = t1;
	
	(speedprof+2)->a = (speedprof+1)->a;
	(speedprof+2)->j = motion.j2;
	(speedprof+2)->w = fixedpt_mul ((speedprof+1)->a, t1) + (speedprof+1)->w;
  40e7fe:	4439      	add	r1, r7
	(speedprof+1)->w = fixedpt_mul (motion.j1 >> 1, t02) + fixedpt_mul (c_acceleration, t0) + c_speed;
  40e800:	61a7      	str	r7, [r4, #24]
	speedprof->j = motion.j1;
  40e802:	6023      	str	r3, [r4, #0]
	(speedprof+2)->j = motion.j2;
  40e804:	9b02      	ldr	r3, [sp, #8]
	(speedprof+2)->w = fixedpt_mul ((speedprof+1)->a, t1) + (speedprof+1)->w;
  40e806:	62a1      	str	r1, [r4, #40]	; 0x28
	speedprof->duration = t0;
  40e808:	60e5      	str	r5, [r4, #12]
	(speedprof+1)->a = c_acceleration + fixedpt_mul (speedprof->j, speedprof->duration);
  40e80a:	f8c4 e014 	str.w	lr, [r4, #20]
	(speedprof+1)->duration = t1;
  40e80e:	61e0      	str	r0, [r4, #28]
	(speedprof+2)->a = (speedprof+1)->a;
  40e810:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
	(speedprof+2)->j = motion.j2;
  40e814:	6223      	str	r3, [r4, #32]
	(speedprof+2)->duration = t2;
  40e816:	62e6      	str	r6, [r4, #44]	; 0x2c
	(speedprof+1)->j = 0;
  40e818:	f8c4 c010 	str.w	ip, [r4, #16]
// 	volatile float f_del_w2 = fixedpt_tofloat(del_w2);
// 	volatile float f_w00 = fixedpt_tofloat((speedprof+0)->w);
// 	volatile float f_w01 = fixedpt_tofloat((speedprof+1)->w);
// 	volatile float f_w02 = fixedpt_tofloat((speedprof+2)->w);	

}
  40e81c:	b00d      	add	sp, #52	; 0x34
  40e81e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40e822:	b002      	add	sp, #8
  40e824:	4770      	bx	lr
  40e826:	17c3      	asrs	r3, r0, #31
  40e828:	4602      	mov	r2, r0
  40e82a:	2100      	movs	r1, #0
  40e82c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  40e830:	47a8      	blx	r5
  40e832:	4607      	mov	r7, r0
		invert = 1;
  40e834:	2301      	movs	r3, #1
	if (A > FIXEDPT_ONE) {
  40e836:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
		invert = 1;
  40e83a:	930a      	str	r3, [sp, #40]	; 0x28
	if (A > FIXEDPT_ONE) {
  40e83c:	f73f af5c 	bgt.w	40e6f8 <scurve_generate_speed_profile+0x190>
	l = (A >> 1) + 1;
  40e840:	107d      	asrs	r5, r7, #1
	int iter = FIXEDPT_FBITS;
  40e842:	f04f 080f 	mov.w	r8, #15
	l = (A >> 1) + 1;
  40e846:	3501      	adds	r5, #1
  40e848:	e75f      	b.n	40e70a <scurve_generate_speed_profile+0x1a2>
	if (invert)
  40e84a:	462f      	mov	r7, r5
  40e84c:	e77b      	b.n	40e746 <scurve_generate_speed_profile+0x1de>
		return (-1);
  40e84e:	f04f 37ff 	mov.w	r7, #4294967295
  40e852:	e778      	b.n	40e746 <scurve_generate_speed_profile+0x1de>
  40e854:	0041905d 	.word	0x0041905d

0040e858 <scurve_get_maximumSpeed_fromDisplacement>:
{
  40e858:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	temp.a  = fixedpt_div(motor_basefreq, relative_motion.a);
  40e85c:	f8df c23c 	ldr.w	ip, [pc, #572]	; 40ea9c <scurve_get_maximumSpeed_fromDisplacement+0x244>
{
  40e860:	b093      	sub	sp, #76	; 0x4c
	if(acc_motion.j1 == 0) acc_motion.j1 = fixedpt_rconst(0.1);
  40e862:	f640 4ecd 	movw	lr, #3277	; 0xccd
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e866:	f8df a238 	ldr.w	sl, [pc, #568]	; 40eaa0 <scurve_get_maximumSpeed_fromDisplacement+0x248>
{
  40e86a:	9010      	str	r0, [sp, #64]	; 0x40
  40e86c:	910e      	str	r1, [sp, #56]	; 0x38
  40e86e:	9821      	ldr	r0, [sp, #132]	; 0x84
  40e870:	f8dc 1008 	ldr.w	r1, [ip, #8]
  40e874:	9e1c      	ldr	r6, [sp, #112]	; 0x70
  40e876:	9005      	str	r0, [sp, #20]
  40e878:	1448      	asrs	r0, r1, #17
  40e87a:	03c9      	lsls	r1, r1, #15
  40e87c:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
	if(acc_motion.a == 0)  acc_motion.a  = fixedpt_rconst(2.5);
  40e87e:	2e00      	cmp	r6, #0
  40e880:	9f20      	ldr	r7, [sp, #128]	; 0x80
  40e882:	900d      	str	r0, [sp, #52]	; 0x34
  40e884:	4608      	mov	r0, r1
  40e886:	f8dd 8074 	ldr.w	r8, [sp, #116]	; 0x74
  40e88a:	bf08      	it	eq
  40e88c:	f44f 36a0 	moveq.w	r6, #81920	; 0x14000
  40e890:	9923      	ldr	r1, [sp, #140]	; 0x8c
	if(dec_motion.j1 == 0) dec_motion.j1 = fixedpt_rconst(0.1);
  40e892:	46bc      	mov	ip, r7
  40e894:	9c1e      	ldr	r4, [sp, #120]	; 0x78
	if(acc_motion.j1 == 0) acc_motion.j1 = fixedpt_rconst(0.1);
  40e896:	f1b8 0f00 	cmp.w	r8, #0
  40e89a:	bf08      	it	eq
  40e89c:	46f0      	moveq	r8, lr
  40e89e:	9108      	str	r1, [sp, #32]
	if(acc_motion.j2 == 0) acc_motion.j2 = fixedpt_rconst(0.1);
  40e8a0:	2c00      	cmp	r4, #0
  40e8a2:	bf08      	it	eq
  40e8a4:	4674      	moveq	r4, lr
	if(dec_motion.j2 == 0) dec_motion.j2 = fixedpt_rconst(0.1);
  40e8a6:	9905      	ldr	r1, [sp, #20]
	if(dec_motion.a == 0)  dec_motion.a  = fixedpt_rconst(2.5);
  40e8a8:	2d00      	cmp	r5, #0
{
  40e8aa:	9209      	str	r2, [sp, #36]	; 0x24
	if(acc_motion.j2 == 0) acc_motion.j2 = fixedpt_rconst(0.1);
  40e8ac:	9404      	str	r4, [sp, #16]
  40e8ae:	4632      	mov	r2, r6
	if(dec_motion.a == 0)  dec_motion.a  = fixedpt_rconst(2.5);
  40e8b0:	bf08      	it	eq
  40e8b2:	f44f 35a0 	moveq.w	r5, #81920	; 0x14000
	if(dec_motion.j1 == 0) dec_motion.j1 = fixedpt_rconst(0.1);
  40e8b6:	2f00      	cmp	r7, #0
  40e8b8:	bf08      	it	eq
  40e8ba:	46f4      	moveq	ip, lr
	if(dec_motion.j2 == 0) dec_motion.j2 = fixedpt_rconst(0.1);
  40e8bc:	460f      	mov	r7, r1
  40e8be:	9c22      	ldr	r4, [sp, #136]	; 0x88
	if(dec_motion.j1 == 0) dec_motion.j1 = fixedpt_rconst(0.1);
  40e8c0:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
	if(dec_motion.j2 == 0) dec_motion.j2 = fixedpt_rconst(0.1);
  40e8c4:	2900      	cmp	r1, #0
  40e8c6:	bf08      	it	eq
  40e8c8:	4677      	moveq	r7, lr
	if(dec_motionz.a == 0)  dec_motionz.a  = fixedpt_rconst(2.5);
  40e8ca:	2c00      	cmp	r4, #0
  40e8cc:	46a4      	mov	ip, r4
{
  40e8ce:	930a      	str	r3, [sp, #40]	; 0x28
	if(dec_motion.j2 == 0) dec_motion.j2 = fixedpt_rconst(0.1);
  40e8d0:	9705      	str	r7, [sp, #20]
	if(dec_motionz.a == 0)  dec_motionz.a  = fixedpt_rconst(2.5);
  40e8d2:	bf08      	it	eq
  40e8d4:	f44f 3ca0 	moveq.w	ip, #81920	; 0x14000
  40e8d8:	9f24      	ldr	r7, [sp, #144]	; 0x90
  40e8da:	17f3      	asrs	r3, r6, #31
  40e8dc:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
  40e8e0:	970b      	str	r7, [sp, #44]	; 0x2c
	if(dec_motionz.j1 == 0) dec_motionz.j1 = fixedpt_rconst(0.1);
  40e8e2:	9f08      	ldr	r7, [sp, #32]
  40e8e4:	990d      	ldr	r1, [sp, #52]	; 0x34
  40e8e6:	46bc      	mov	ip, r7
  40e8e8:	9011      	str	r0, [sp, #68]	; 0x44
  40e8ea:	2f00      	cmp	r7, #0
  40e8ec:	bf08      	it	eq
  40e8ee:	46f4      	moveq	ip, lr
	if(dec_motionz.j2 == 0) dec_motionz.j2 = fixedpt_rconst(0.1);
  40e8f0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
	if(dec_motionz.j1 == 0) dec_motionz.j1 = fixedpt_rconst(0.1);
  40e8f2:	f8cd c020 	str.w	ip, [sp, #32]
	if(dec_motionz.j2 == 0) dec_motionz.j2 = fixedpt_rconst(0.1);
  40e8f6:	46bc      	mov	ip, r7
  40e8f8:	2f00      	cmp	r7, #0
  40e8fa:	bf08      	it	eq
  40e8fc:	46f4      	moveq	ip, lr
  40e8fe:	17ef      	asrs	r7, r5, #31
  40e900:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40e904:	47d0      	blx	sl
  40e906:	4681      	mov	r9, r0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e908:	fb86 0108 	smull	r0, r1, r6, r8
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e90c:	ea4f 4b69 	mov.w	fp, r9, asr #17
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e910:	0bc2      	lsrs	r2, r0, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e912:	ea4f 38c9 	mov.w	r8, r9, lsl #15
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e916:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e91a:	4659      	mov	r1, fp
  40e91c:	4640      	mov	r0, r8
  40e91e:	17d3      	asrs	r3, r2, #31
  40e920:	47d0      	blx	sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e922:	9c04      	ldr	r4, [sp, #16]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e924:	9006      	str	r0, [sp, #24]
  40e926:	4659      	mov	r1, fp
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e928:	fb86 2304 	smull	r2, r3, r6, r4
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e92c:	4640      	mov	r0, r8
	scurve_generate_speed_profile(creep_speed, 0, 0, dec_motionz, &dec_profilez);
  40e92e:	f8df 8174 	ldr.w	r8, [pc, #372]	; 40eaa4 <scurve_get_maximumSpeed_fromDisplacement+0x24c>
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e932:	0bd2      	lsrs	r2, r2, #15
  40e934:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e938:	17d3      	asrs	r3, r2, #31
  40e93a:	47d0      	blx	sl
  40e93c:	9c11      	ldr	r4, [sp, #68]	; 0x44
	temp.j2 *= -1;
  40e93e:	4246      	negs	r6, r0
  40e940:	462a      	mov	r2, r5
  40e942:	463b      	mov	r3, r7
  40e944:	990d      	ldr	r1, [sp, #52]	; 0x34
  40e946:	9607      	str	r6, [sp, #28]
  40e948:	4620      	mov	r0, r4
  40e94a:	47d0      	blx	sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e94c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e94e:	4683      	mov	fp, r0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e950:	fb85 0103 	smull	r0, r1, r5, r3
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e954:	ea4f 476b 	mov.w	r7, fp, asr #17
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e958:	0bc2      	lsrs	r2, r0, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e95a:	ea4f 36cb 	mov.w	r6, fp, lsl #15
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e95e:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e962:	4639      	mov	r1, r7
  40e964:	4630      	mov	r0, r6
  40e966:	17d3      	asrs	r3, r2, #31
  40e968:	47d0      	blx	sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e96a:	9b05      	ldr	r3, [sp, #20]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e96c:	9004      	str	r0, [sp, #16]
  40e96e:	4639      	mov	r1, r7
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e970:	fb85 2303 	smull	r2, r3, r5, r3
  40e974:	9d0c      	ldr	r5, [sp, #48]	; 0x30
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e976:	4630      	mov	r0, r6
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e978:	0bd2      	lsrs	r2, r2, #15
  40e97a:	17ef      	asrs	r7, r5, #31
  40e97c:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e980:	17d3      	asrs	r3, r2, #31
  40e982:	47d0      	blx	sl
  40e984:	4243      	negs	r3, r0
  40e986:	462a      	mov	r2, r5
  40e988:	990d      	ldr	r1, [sp, #52]	; 0x34
  40e98a:	9305      	str	r3, [sp, #20]
  40e98c:	4620      	mov	r0, r4
  40e98e:	463b      	mov	r3, r7
  40e990:	47d0      	blx	sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e992:	9c08      	ldr	r4, [sp, #32]
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e994:	4607      	mov	r7, r0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e996:	950c      	str	r5, [sp, #48]	; 0x30
  40e998:	fb85 0104 	smull	r0, r1, r5, r4
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e99c:	147e      	asrs	r6, r7, #17
	scurve_generate_speed_profile(creep_speed, 0, 0, dec_motionz, &dec_profilez);
  40e99e:	9722      	str	r7, [sp, #136]	; 0x88
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e9a0:	0bc2      	lsrs	r2, r0, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e9a2:	03fd      	lsls	r5, r7, #15
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e9a4:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e9a8:	4631      	mov	r1, r6
  40e9aa:	4628      	mov	r0, r5
  40e9ac:	17d3      	asrs	r3, r2, #31
  40e9ae:	47d0      	blx	sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e9b0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40e9b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e9b4:	4631      	mov	r1, r6
  40e9b6:	9023      	str	r0, [sp, #140]	; 0x8c
  40e9b8:	4628      	mov	r0, r5
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40e9ba:	fb82 2304 	smull	r2, r3, r2, r4
  40e9be:	4c32      	ldr	r4, [pc, #200]	; (40ea88 <scurve_get_maximumSpeed_fromDisplacement+0x230>)
	*decel_distancez = get_displacement_from_sprofile(&dec_profilez);
  40e9c0:	4e32      	ldr	r6, [pc, #200]	; (40ea8c <scurve_get_maximumSpeed_fromDisplacement+0x234>)
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40e9c2:	2514      	movs	r5, #20
  40e9c4:	0bd2      	lsrs	r2, r2, #15
  40e9c6:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  40e9ca:	17d3      	asrs	r3, r2, #31
  40e9cc:	47d0      	blx	sl
	scurve_generate_speed_profile(creep_speed, 0, 0, dec_motionz, &dec_profilez);
  40e9ce:	a923      	add	r1, sp, #140	; 0x8c
	temp.j2 *= -1;
  40e9d0:	4240      	negs	r0, r0
	scurve_generate_speed_profile(creep_speed, 0, 0, dec_motionz, &dec_profilez);
  40e9d2:	2200      	movs	r2, #0
  40e9d4:	9402      	str	r4, [sp, #8]
  40e9d6:	463b      	mov	r3, r7
  40e9d8:	9024      	str	r0, [sp, #144]	; 0x90
  40e9da:	4f2d      	ldr	r7, [pc, #180]	; (40ea90 <scurve_get_maximumSpeed_fromDisplacement+0x238>)
  40e9dc:	c903      	ldmia	r1, {r0, r1}
  40e9de:	e88d 0003 	stmia.w	sp, {r0, r1}
  40e9e2:	4611      	mov	r1, r2
  40e9e4:	9825      	ldr	r0, [sp, #148]	; 0x94
  40e9e6:	47c0      	blx	r8
	*decel_distancez = get_displacement_from_sprofile(&dec_profilez);
  40e9e8:	4620      	mov	r0, r4
  40e9ea:	47b0      	blx	r6
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40e9ec:	9a0e      	ldr	r2, [sp, #56]	; 0x38
	*decel_distancez = get_displacement_from_sprofile(&dec_profilez);
  40e9ee:	9c27      	ldr	r4, [sp, #156]	; 0x9c
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40e9f0:	17d1      	asrs	r1, r2, #31
	displacement -= *decel_distancez;
  40e9f2:	9a10      	ldr	r2, [sp, #64]	; 0x40
	*decel_distancez = get_displacement_from_sprofile(&dec_profilez);
  40e9f4:	6020      	str	r0, [r4, #0]
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40e9f6:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	displacement -= *decel_distancez;
  40e9f8:	1a12      	subs	r2, r2, r0
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40e9fa:	4b26      	ldr	r3, [pc, #152]	; (40ea94 <scurve_get_maximumSpeed_fromDisplacement+0x23c>)
  40e9fc:	4620      	mov	r0, r4
  40e9fe:	2a00      	cmp	r2, #0
  40ea00:	fb83 0300 	smull	r0, r3, r3, r0
  40ea04:	bfb8      	it	lt
  40ea06:	4252      	neglt	r2, r2
  40ea08:	eba1 03e3 	sub.w	r3, r1, r3, asr #3
  40ea0c:	9208      	str	r2, [sp, #32]
  40ea0e:	930b      	str	r3, [sp, #44]	; 0x2c
		scurve_generate_speed_profile(c_speed, d_speed, c_acceleration, acc_motion, &acc_profile);
  40ea10:	4921      	ldr	r1, [pc, #132]	; (40ea98 <scurve_get_maximumSpeed_fromDisplacement+0x240>)
  40ea12:	9b06      	ldr	r3, [sp, #24]
  40ea14:	9a07      	ldr	r2, [sp, #28]
  40ea16:	9102      	str	r1, [sp, #8]
  40ea18:	a91d      	add	r1, sp, #116	; 0x74
  40ea1a:	931d      	str	r3, [sp, #116]	; 0x74
  40ea1c:	464b      	mov	r3, r9
  40ea1e:	921e      	str	r2, [sp, #120]	; 0x78
  40ea20:	f8cd 9070 	str.w	r9, [sp, #112]	; 0x70
  40ea24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  40ea26:	c903      	ldmia	r1, {r0, r1}
  40ea28:	e88d 0003 	stmia.w	sp, {r0, r1}
  40ea2c:	4621      	mov	r1, r4
  40ea2e:	9809      	ldr	r0, [sp, #36]	; 0x24
  40ea30:	47c0      	blx	r8
		scurve_generate_speed_profile(d_speed, creep_speed, 0, dec_motion, &dec_profile);
  40ea32:	9b04      	ldr	r3, [sp, #16]
  40ea34:	a920      	add	r1, sp, #128	; 0x80
  40ea36:	9702      	str	r7, [sp, #8]
  40ea38:	9320      	str	r3, [sp, #128]	; 0x80
  40ea3a:	2200      	movs	r2, #0
  40ea3c:	9b05      	ldr	r3, [sp, #20]
  40ea3e:	f8cd b07c 	str.w	fp, [sp, #124]	; 0x7c
  40ea42:	9321      	str	r3, [sp, #132]	; 0x84
  40ea44:	465b      	mov	r3, fp
  40ea46:	c903      	ldmia	r1, {r0, r1}
  40ea48:	e88d 0003 	stmia.w	sp, {r0, r1}
  40ea4c:	9925      	ldr	r1, [sp, #148]	; 0x94
  40ea4e:	4620      	mov	r0, r4
  40ea50:	47c0      	blx	r8
		decel_displacement = get_displacement_from_sprofile(&dec_profile);
  40ea52:	480f      	ldr	r0, [pc, #60]	; (40ea90 <scurve_get_maximumSpeed_fromDisplacement+0x238>)
  40ea54:	47b0      	blx	r6
  40ea56:	4682      	mov	sl, r0
		AccDec_displacement = get_displacement_from_sprofile(&acc_profile) + decel_displacement;
  40ea58:	480f      	ldr	r0, [pc, #60]	; (40ea98 <scurve_get_maximumSpeed_fromDisplacement+0x240>)
  40ea5a:	47b0      	blx	r6
  40ea5c:	4450      	add	r0, sl
		if (fixedpt_abs(AccDec_displacement) < fixedpt_abs(displacement))
  40ea5e:	9b08      	ldr	r3, [sp, #32]
  40ea60:	2800      	cmp	r0, #0
  40ea62:	bfb8      	it	lt
  40ea64:	4240      	neglt	r0, r0
  40ea66:	4298      	cmp	r0, r3
  40ea68:	db07      	blt.n	40ea7a <scurve_get_maximumSpeed_fromDisplacement+0x222>
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40ea6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	for (i=0; i<SPEED_DIVISION; i++)
  40ea6c:	3d01      	subs	r5, #1
		d_speed  -=  (Mspeed / SPEED_DIVISION);
  40ea6e:	441c      	add	r4, r3
	for (i=0; i<SPEED_DIVISION; i++)
  40ea70:	d1ce      	bne.n	40ea10 <scurve_get_maximumSpeed_fromDisplacement+0x1b8>
}
  40ea72:	4650      	mov	r0, sl
  40ea74:	b013      	add	sp, #76	; 0x4c
  40ea76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			*r_speed = d_speed; //return running speed
  40ea7a:	9b26      	ldr	r3, [sp, #152]	; 0x98
}
  40ea7c:	4650      	mov	r0, sl
			*r_speed = d_speed; //return running speed
  40ea7e:	601c      	str	r4, [r3, #0]
}
  40ea80:	b013      	add	sp, #76	; 0x4c
  40ea82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40ea86:	bf00      	nop
  40ea88:	204063a4 	.word	0x204063a4
  40ea8c:	0040e409 	.word	0x0040e409
  40ea90:	20406374 	.word	0x20406374
  40ea94:	66666667 	.word	0x66666667
  40ea98:	20406314 	.word	0x20406314
  40ea9c:	20404ff0 	.word	0x20404ff0
  40eaa0:	0041905d 	.word	0x0041905d
  40eaa4:	0040e569 	.word	0x0040e569

0040eaa8 <scurve_exe>:
fixedpt d0 = 0;
fixedpt d1 = 0;
fixedpt d2 = 0;
void scurve_exe(speedProfile_t *speedprof, fixedpt t, fixedpt *speed, fixedpt *distance, fixedpt *acc, uint32_t *prof_end)
{
  40eaa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40eaac:	b087      	sub	sp, #28
  40eaae:	9303      	str	r3, [sp, #12]
	fixedpt t2, t3;
	if (t <= (speedprof->duration ))
  40eab0:	68c3      	ldr	r3, [r0, #12]
{
  40eab2:	9202      	str	r2, [sp, #8]
	if (t <= (speedprof->duration ))
  40eab4:	428b      	cmp	r3, r1
  40eab6:	f2c0 8084 	blt.w	40ebc2 <scurve_exe+0x11a>
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  40eaba:	fb81 4501 	smull	r4, r5, r1, r1
  40eabe:	6882      	ldr	r2, [r0, #8]
	{
		t2 = fixedpt_mul(t,t);
		t3 = fixedpt_mul(t2,t);		
		d0 = (fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40eac0:	f8d0 c004 	ldr.w	ip, [r0, #4]
		d1 = 0;
  40eac4:	f04f 0a00 	mov.w	sl, #0
  40eac8:	ea4f 3ed4 	mov.w	lr, r4, lsr #15
		d0 = (fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40eacc:	4c86      	ldr	r4, [pc, #536]	; (40ece8 <scurve_exe+0x240>)
  40eace:	4b87      	ldr	r3, [pc, #540]	; (40ecec <scurve_exe+0x244>)
  40ead0:	ea4f 066c 	mov.w	r6, ip, asr #1
  40ead4:	ea4e 4e45 	orr.w	lr, lr, r5, lsl #17
  40ead8:	9404      	str	r4, [sp, #16]
  40eada:	6805      	ldr	r5, [r0, #0]
  40eadc:	ea4f 7be1 	mov.w	fp, r1, asr #31
  40eae0:	fb8e 8901 	smull	r8, r9, lr, r1
  40eae4:	fb86 670e 	smull	r6, r7, r6, lr
  40eae8:	ea4f 34d8 	mov.w	r4, r8, lsr #15
  40eaec:	ea44 4449 	orr.w	r4, r4, r9, lsl #17
  40eaf0:	fb85 4504 	smull	r4, r5, r5, r4
  40eaf4:	ea4f 38d4 	mov.w	r8, r4, lsr #15
  40eaf8:	ea48 4845 	orr.w	r8, r8, r5, lsl #17
  40eafc:	fb81 4502 	smull	r4, r5, r1, r2
  40eb00:	0bf2      	lsrs	r2, r6, #15
		d1 = 0;
  40eb02:	4e7b      	ldr	r6, [pc, #492]	; (40ecf0 <scurve_exe+0x248>)
  40eb04:	e9cd 4500 	strd	r4, r5, [sp]
		d0 = (fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40eb08:	fb83 5308 	smull	r5, r3, r3, r8
  40eb0c:	ea42 4247 	orr.w	r2, r2, r7, lsl #17
		d2 = 0;
  40eb10:	4f78      	ldr	r7, [pc, #480]	; (40ecf4 <scurve_exe+0x24c>)
		d0 = (fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40eb12:	eba3 73e8 	sub.w	r3, r3, r8, asr #31
		d1 = 0;
  40eb16:	f8c6 a000 	str.w	sl, [r6]
		d2 = 0;
  40eb1a:	f8c7 a000 	str.w	sl, [r7]
  40eb1e:	468a      	mov	sl, r1
		d0 = (fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40eb20:	4413      	add	r3, r2
  40eb22:	e9dd 8900 	ldrd	r8, r9, [sp]
  40eb26:	4644      	mov	r4, r8
  40eb28:	46f0      	mov	r8, lr
  40eb2a:	0be4      	lsrs	r4, r4, #15
  40eb2c:	ea44 4449 	orr.w	r4, r4, r9, lsl #17
  40eb30:	ea4f 79ee 	mov.w	r9, lr, asr #31
  40eb34:	4423      	add	r3, r4
  40eb36:	4c6c      	ldr	r4, [pc, #432]	; (40ece8 <scurve_exe+0x240>)
  40eb38:	6023      	str	r3, [r4, #0]
  40eb3a:	6802      	ldr	r2, [r0, #0]
  40eb3c:	17d3      	asrs	r3, r2, #31
  40eb3e:	e9cd 8900 	strd	r8, r9, [sp]
  40eb42:	fb02 f10b 	mul.w	r1, r2, fp
  40eb46:	fba2 450a 	umull	r4, r5, r2, sl
		*prof_end = 0;
		return;
	}
		
	
	*acc = speedprof->a + fixedpt_mul(speedprof->j, t);
  40eb4a:	9a10      	ldr	r2, [sp, #64]	; 0x40
  40eb4c:	fb0a 1103 	mla	r1, sl, r3, r1
  40eb50:	0be3      	lsrs	r3, r4, #15
  40eb52:	440d      	add	r5, r1
  40eb54:	ea43 4345 	orr.w	r3, r3, r5, lsl #17
  40eb58:	4463      	add	r3, ip
  40eb5a:	6013      	str	r3, [r2, #0]
	*speed = fixedpt_mul (speedprof->j >> 1, t2) + fixedpt_mul (speedprof->a, t) + speedprof->w;
  40eb5c:	6802      	ldr	r2, [r0, #0]
  40eb5e:	9b01      	ldr	r3, [sp, #4]
  40eb60:	1052      	asrs	r2, r2, #1
  40eb62:	6841      	ldr	r1, [r0, #4]
  40eb64:	f8d0 8008 	ldr.w	r8, [r0, #8]
  40eb68:	17d5      	asrs	r5, r2, #31
  40eb6a:	fb02 f903 	mul.w	r9, r2, r3
  40eb6e:	9b00      	ldr	r3, [sp, #0]
  40eb70:	fb01 fc0b 	mul.w	ip, r1, fp
  40eb74:	fb03 9905 	mla	r9, r3, r5, r9
  40eb78:	17cd      	asrs	r5, r1, #31
  40eb7a:	fba2 2303 	umull	r2, r3, r2, r3
  40eb7e:	fb0a cc05 	mla	ip, sl, r5, ip
  40eb82:	e9cd 2300 	strd	r2, r3, [sp]
  40eb86:	9a01      	ldr	r2, [sp, #4]
  40eb88:	fba1 340a 	umull	r3, r4, r1, sl
  40eb8c:	444a      	add	r2, r9
  40eb8e:	0bd8      	lsrs	r0, r3, #15
  40eb90:	4464      	add	r4, ip
  40eb92:	9b02      	ldr	r3, [sp, #8]
  40eb94:	9201      	str	r2, [sp, #4]
  40eb96:	ea40 4044 	orr.w	r0, r0, r4, lsl #17
  40eb9a:	e9dd 9a00 	ldrd	r9, sl, [sp]
  40eb9e:	464a      	mov	r2, r9
  40eba0:	0bd2      	lsrs	r2, r2, #15
  40eba2:	ea42 424a 	orr.w	r2, r2, sl, lsl #17
  40eba6:	4402      	add	r2, r0
  40eba8:	4442      	add	r2, r8
  40ebaa:	601a      	str	r2, [r3, #0]
	*distance = d0 + d1 + d2;
  40ebac:	9b04      	ldr	r3, [sp, #16]
  40ebae:	6831      	ldr	r1, [r6, #0]
  40ebb0:	681b      	ldr	r3, [r3, #0]
  40ebb2:	683a      	ldr	r2, [r7, #0]
  40ebb4:	440b      	add	r3, r1
  40ebb6:	4413      	add	r3, r2
  40ebb8:	9a03      	ldr	r2, [sp, #12]
  40ebba:	6013      	str	r3, [r2, #0]
	/*volatile float f_speed = fixedpt_tofloat(*speed);*/
		
	return;
	
	
  40ebbc:	b007      	add	sp, #28
  40ebbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	else if  (t <= (speedprof->duration + (speedprof+1)->duration))
  40ebc2:	69c2      	ldr	r2, [r0, #28]
  40ebc4:	441a      	add	r2, r3
  40ebc6:	4291      	cmp	r1, r2
  40ebc8:	dc47      	bgt.n	40ec5a <scurve_exe+0x1b2>
		t -= speedprof->duration;
  40ebca:	1ac9      	subs	r1, r1, r3
  40ebcc:	6982      	ldr	r2, [r0, #24]
		d1 = ( fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40ebce:	f8d0 8010 	ldr.w	r8, [r0, #16]
		d2 = 0;
  40ebd2:	f04f 0b00 	mov.w	fp, #0
  40ebd6:	fb81 4501 	smull	r4, r5, r1, r1
		d1 = ( fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40ebda:	f8d0 c014 	ldr.w	ip, [r0, #20]
  40ebde:	f8df 910c 	ldr.w	r9, [pc, #268]	; 40ecec <scurve_exe+0x244>
		speedprof++;
  40ebe2:	3010      	adds	r0, #16
  40ebe4:	ea4f 3ed4 	mov.w	lr, r4, lsr #15
  40ebe8:	fb81 3402 	smull	r3, r4, r1, r2
		d1 = ( fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40ebec:	ea4f 0a6c 	mov.w	sl, ip, asr #1
  40ebf0:	ea4e 4e45 	orr.w	lr, lr, r5, lsl #17
  40ebf4:	fb8e 6701 	smull	r6, r7, lr, r1
  40ebf8:	e9cd 3400 	strd	r3, r4, [sp]
  40ebfc:	0bf4      	lsrs	r4, r6, #15
  40ebfe:	fb8a 230e 	smull	r2, r3, sl, lr
  40ec02:	468a      	mov	sl, r1
  40ec04:	ea44 4447 	orr.w	r4, r4, r7, lsl #17
		d2 = 0;
  40ec08:	4f3a      	ldr	r7, [pc, #232]	; (40ecf4 <scurve_exe+0x24c>)
  40ec0a:	fb88 4504 	smull	r4, r5, r8, r4
  40ec0e:	f8c7 b000 	str.w	fp, [r7]
  40ec12:	ea4f 7be1 	mov.w	fp, r1, asr #31
  40ec16:	0be6      	lsrs	r6, r4, #15
  40ec18:	4614      	mov	r4, r2
  40ec1a:	4933      	ldr	r1, [pc, #204]	; (40ece8 <scurve_exe+0x240>)
  40ec1c:	ea46 4645 	orr.w	r6, r6, r5, lsl #17
  40ec20:	461d      	mov	r5, r3
  40ec22:	e9cd 4504 	strd	r4, r5, [sp, #16]
		d1 = ( fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40ec26:	fb89 3906 	smull	r3, r9, r9, r6
  40ec2a:	0be4      	lsrs	r4, r4, #15
  40ec2c:	9b05      	ldr	r3, [sp, #20]
  40ec2e:	eba9 79e6 	sub.w	r9, r9, r6, asr #31
  40ec32:	4e2f      	ldr	r6, [pc, #188]	; (40ecf0 <scurve_exe+0x248>)
  40ec34:	ea44 4443 	orr.w	r4, r4, r3, lsl #17
  40ec38:	9b00      	ldr	r3, [sp, #0]
  40ec3a:	9104      	str	r1, [sp, #16]
  40ec3c:	0bda      	lsrs	r2, r3, #15
  40ec3e:	9b01      	ldr	r3, [sp, #4]
  40ec40:	44a1      	add	r9, r4
  40ec42:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  40ec46:	4673      	mov	r3, lr
  40ec48:	17dc      	asrs	r4, r3, #31
  40ec4a:	e9cd 3400 	strd	r3, r4, [sp]
  40ec4e:	eb09 0402 	add.w	r4, r9, r2
  40ec52:	4642      	mov	r2, r8
  40ec54:	6034      	str	r4, [r6, #0]
  40ec56:	17d3      	asrs	r3, r2, #31
  40ec58:	e773      	b.n	40eb42 <scurve_exe+0x9a>
	else if (t <= (speedprof->duration + (speedprof+1)->duration + (speedprof+2)->duration))
  40ec5a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  40ec5c:	4413      	add	r3, r2
  40ec5e:	4299      	cmp	r1, r3
  40ec60:	dc3e      	bgt.n	40ece0 <scurve_exe+0x238>
		t -= (speedprof->duration + (speedprof+1)->duration);
  40ec62:	1a89      	subs	r1, r1, r2
  40ec64:	6a84      	ldr	r4, [r0, #40]	; 0x28
		d2 = ( fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40ec66:	6a06      	ldr	r6, [r0, #32]
		speedprof += 2;
  40ec68:	3020      	adds	r0, #32
  40ec6a:	fb81 2301 	smull	r2, r3, r1, r1
		d2 = ( fixedpt_mul (speedprof->j, t3) / 6) + fixedpt_mul (speedprof->a >> 1, t2) + fixedpt_mul (speedprof->w, t);
  40ec6e:	f8d0 c004 	ldr.w	ip, [r0, #4]
  40ec72:	fb81 4504 	smull	r4, r5, r1, r4
  40ec76:	f8df a074 	ldr.w	sl, [pc, #116]	; 40ecec <scurve_exe+0x244>
  40ec7a:	ea4f 3ed2 	mov.w	lr, r2, lsr #15
  40ec7e:	4f1d      	ldr	r7, [pc, #116]	; (40ecf4 <scurve_exe+0x24c>)
  40ec80:	ea4f 0b6c 	mov.w	fp, ip, asr #1
  40ec84:	ea4e 4e43 	orr.w	lr, lr, r3, lsl #17
  40ec88:	fb8e 8901 	smull	r8, r9, lr, r1
  40ec8c:	e9cd 4504 	strd	r4, r5, [sp, #16]
  40ec90:	ea4f 34d8 	mov.w	r4, r8, lsr #15
  40ec94:	ea44 4449 	orr.w	r4, r4, r9, lsl #17
  40ec98:	fb86 4504 	smull	r4, r5, r6, r4
  40ec9c:	0be3      	lsrs	r3, r4, #15
  40ec9e:	ea43 4345 	orr.w	r3, r3, r5, lsl #17
  40eca2:	fb8b 450e 	smull	r4, r5, fp, lr
  40eca6:	ea4f 7be1 	mov.w	fp, r1, asr #31
  40ecaa:	fb8a 2803 	smull	r2, r8, sl, r3
  40ecae:	0be2      	lsrs	r2, r4, #15
  40ecb0:	4674      	mov	r4, lr
  40ecb2:	468a      	mov	sl, r1
  40ecb4:	ea42 4245 	orr.w	r2, r2, r5, lsl #17
  40ecb8:	490b      	ldr	r1, [pc, #44]	; (40ece8 <scurve_exe+0x240>)
  40ecba:	17e5      	asrs	r5, r4, #31
  40ecbc:	eba8 73e3 	sub.w	r3, r8, r3, asr #31
  40ecc0:	e9cd 4500 	strd	r4, r5, [sp]
  40ecc4:	9c04      	ldr	r4, [sp, #16]
  40ecc6:	eb03 0802 	add.w	r8, r3, r2
  40ecca:	9b05      	ldr	r3, [sp, #20]
  40eccc:	4632      	mov	r2, r6
  40ecce:	0be4      	lsrs	r4, r4, #15
  40ecd0:	9104      	str	r1, [sp, #16]
  40ecd2:	ea44 4443 	orr.w	r4, r4, r3, lsl #17
  40ecd6:	17f3      	asrs	r3, r6, #31
  40ecd8:	4e05      	ldr	r6, [pc, #20]	; (40ecf0 <scurve_exe+0x248>)
  40ecda:	4444      	add	r4, r8
  40ecdc:	603c      	str	r4, [r7, #0]
  40ecde:	e730      	b.n	40eb42 <scurve_exe+0x9a>
		*prof_end = 0;
  40ece0:	2300      	movs	r3, #0
  40ece2:	9a11      	ldr	r2, [sp, #68]	; 0x44
  40ece4:	6013      	str	r3, [r2, #0]
		return;
  40ece6:	e769      	b.n	40ebbc <scurve_exe+0x114>
  40ece8:	20400964 	.word	0x20400964
  40ecec:	2aaaaaab 	.word	0x2aaaaaab
  40ecf0:	20400968 	.word	0x20400968
  40ecf4:	2040096c 	.word	0x2040096c

0040ecf8 <arb_eso_init>:
	return z;
}

void arb_eso_init(void)
{
	if(J == 0) J = 1;
  40ecf8:	4b2b      	ldr	r3, [pc, #172]	; (40eda8 <arb_eso_init+0xb0>)
{
  40ecfa:	b570      	push	{r4, r5, r6, lr}
  40ecfc:	ed2d 8b02 	vpush	{d8}
	if(J == 0) J = 1;
  40ed00:	edd3 7a3d 	vldr	s15, [r3, #244]	; 0xf4
  40ed04:	eef5 7a40 	vcmp.f32	s15, #0.0
  40ed08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40ed0c:	d103      	bne.n	40ed16 <arb_eso_init+0x1e>
  40ed0e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  40ed12:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
	
	c1 = l2 * T * T;
  40ed16:	edd3 8a19 	vldr	s17, [r3, #100]	; 0x64
  40ed1a:	4e24      	ldr	r6, [pc, #144]	; (40edac <arb_eso_init+0xb4>)
  40ed1c:	ee68 7aa8 	vmul.f32	s15, s17, s17
  40ed20:	4d23      	ldr	r5, [pc, #140]	; (40edb0 <arb_eso_init+0xb8>)
  40ed22:	4c24      	ldr	r4, [pc, #144]	; (40edb4 <arb_eso_init+0xbc>)
  40ed24:	ee17 0a90 	vmov	r0, s15
  40ed28:	47b0      	blx	r6
  40ed2a:	a31b      	add	r3, pc, #108	; (adr r3, 40ed98 <arb_eso_init+0xa0>)
  40ed2c:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ed30:	47a8      	blx	r5
  40ed32:	47a0      	blx	r4
	c2 = 2 + l1 * T;
  40ed34:	ee78 7aa8 	vadd.f32	s15, s17, s17
	c1 = l2 * T * T;
  40ed38:	ee08 0a10 	vmov	s16, r0
  40ed3c:	4b1e      	ldr	r3, [pc, #120]	; (40edb8 <arb_eso_init+0xc0>)
	c2 = 2 + l1 * T;
  40ed3e:	ee17 0a90 	vmov	r0, s15
	c1 = l2 * T * T;
  40ed42:	ed83 8a00 	vstr	s16, [r3]
	c2 = 2 + l1 * T;
  40ed46:	47b0      	blx	r6
  40ed48:	4e1c      	ldr	r6, [pc, #112]	; (40edbc <arb_eso_init+0xc4>)
  40ed4a:	a315      	add	r3, pc, #84	; (adr r3, 40eda0 <arb_eso_init+0xa8>)
  40ed4c:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ed50:	47a8      	blx	r5
  40ed52:	2200      	movs	r2, #0
  40ed54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  40ed58:	4d19      	ldr	r5, [pc, #100]	; (40edc0 <arb_eso_init+0xc8>)
  40ed5a:	47a8      	blx	r5
	c3 = c2 + c1 - 1;
  40ed5c:	4d19      	ldr	r5, [pc, #100]	; (40edc4 <arb_eso_init+0xcc>)
	c2 = 2 + l1 * T;
  40ed5e:	47a0      	blx	r4
	c3 = c2 + c1 - 1;
  40ed60:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	c2 = 2 + l1 * T;
  40ed64:	ee07 0a90 	vmov	s15, r0
	
	zm21.zm1 = 0;
  40ed68:	2300      	movs	r3, #0
  40ed6a:	4917      	ldr	r1, [pc, #92]	; (40edc8 <arb_eso_init+0xd0>)
	c3 = c2 + c1 - 1;
  40ed6c:	ee38 8a47 	vsub.f32	s16, s16, s14
	zm21.zm2 = 0;
	z2 = 0;
	
	zm22.zm1 = 0;
  40ed70:	4a16      	ldr	r2, [pc, #88]	; (40edcc <arb_eso_init+0xd4>)
	z2 = 0;
  40ed72:	4c17      	ldr	r4, [pc, #92]	; (40edd0 <arb_eso_init+0xd8>)
	zm22.zm2 = 0;
	
	omgm1 = 0;
  40ed74:	4817      	ldr	r0, [pc, #92]	; (40edd4 <arb_eso_init+0xdc>)
	c3 = c2 + c1 - 1;
  40ed76:	ee38 8a27 	vadd.f32	s16, s16, s15
	zm21.zm1 = 0;
  40ed7a:	600b      	str	r3, [r1, #0]
	c2 = 2 + l1 * T;
  40ed7c:	edc6 7a00 	vstr	s15, [r6]
	zm21.zm2 = 0;
  40ed80:	604b      	str	r3, [r1, #4]
	c3 = c2 + c1 - 1;
  40ed82:	ed85 8a00 	vstr	s16, [r5]
	z2 = 0;
  40ed86:	6023      	str	r3, [r4, #0]
	zm22.zm1 = 0;
  40ed88:	6013      	str	r3, [r2, #0]
	zm22.zm2 = 0;
  40ed8a:	6053      	str	r3, [r2, #4]
	omgm1 = 0;
  40ed8c:	6003      	str	r3, [r0, #0]
}
  40ed8e:	ecbd 8b02 	vpop	{d8}
  40ed92:	bd70      	pop	{r4, r5, r6, pc}
  40ed94:	f3af 8000 	nop.w
  40ed98:	a0b5ed8d 	.word	0xa0b5ed8d
  40ed9c:	3eb0c6f7 	.word	0x3eb0c6f7
  40eda0:	d2f1a9fc 	.word	0xd2f1a9fc
  40eda4:	3f50624d 	.word	0x3f50624d
  40eda8:	20404ff0 	.word	0x20404ff0
  40edac:	00418749 	.word	0x00418749
  40edb0:	004187f1 	.word	0x004187f1
  40edb4:	00418da1 	.word	0x00418da1
  40edb8:	204063e4 	.word	0x204063e4
  40edbc:	204063d4 	.word	0x204063d4
  40edc0:	0041848d 	.word	0x0041848d
  40edc4:	204063f4 	.word	0x204063f4
  40edc8:	204063dc 	.word	0x204063dc
  40edcc:	204063e8 	.word	0x204063e8
  40edd0:	204063d8 	.word	0x204063d8
  40edd4:	204063f0 	.word	0x204063f0

0040edd8 <arb_eso_exe>:

float arb_eso_exe(float tdot, float omega)
{
  40edd8:	b510      	push	{r4, lr}
	volatile float z21, z22, ta;
	
	//ta = omega - omgm1;
	//ta /= T;
	ta = enc_get_acc_shaft_rad_hat();
  40edda:	4b29      	ldr	r3, [pc, #164]	; (40ee80 <arb_eso_exe+0xa8>)
{
  40eddc:	460c      	mov	r4, r1
  40edde:	ed2d 8b02 	vpush	{d8}
  40ede2:	b084      	sub	sp, #16
  40ede4:	ee08 0a10 	vmov	s16, r0
	ta = enc_get_acc_shaft_rad_hat();
  40ede8:	4798      	blx	r3
	ta *= J; // multiply by system inertia to get the torque
  40edea:	4b26      	ldr	r3, [pc, #152]	; (40ee84 <arb_eso_exe+0xac>)
	ta = enc_get_acc_shaft_rad_hat();
  40edec:	9003      	str	r0, [sp, #12]
	ta *= J; // multiply by system inertia to get the torque
  40edee:	eddd 7a03 	vldr	s15, [sp, #12]
  40edf2:	ed93 7a3d 	vldr	s14, [r3, #244]	; 0xf4
	
	omgm1 = omega;
  40edf6:	4b24      	ldr	r3, [pc, #144]	; (40ee88 <arb_eso_exe+0xb0>)
	ta *= J; // multiply by system inertia to get the torque
  40edf8:	ee67 7a87 	vmul.f32	s15, s15, s14
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40edfc:	4a23      	ldr	r2, [pc, #140]	; (40ee8c <arb_eso_exe+0xb4>)
  40edfe:	4924      	ldr	r1, [pc, #144]	; (40ee90 <arb_eso_exe+0xb8>)
	ta *= J; // multiply by system inertia to get the torque
  40ee00:	edcd 7a03 	vstr	s15, [sp, #12]
	omgm1 = omega;
  40ee04:	601c      	str	r4, [r3, #0]
	
	z21 = z_calc(ta, &zm21);
  40ee06:	eddd 6a03 	vldr	s13, [sp, #12]
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40ee0a:	ed91 6a00 	vldr	s12, [r1]
  40ee0e:	edd2 5a00 	vldr	s11, [r2]
  40ee12:	4b20      	ldr	r3, [pc, #128]	; (40ee94 <arb_eso_exe+0xbc>)
  40ee14:	ee65 7a86 	vmul.f32	s15, s11, s12
  40ee18:	ed92 5a01 	vldr	s10, [r2, #4]
  40ee1c:	ed93 7a00 	vldr	s14, [r3]
	z /= c3;
  40ee20:	491d      	ldr	r1, [pc, #116]	; (40ee98 <arb_eso_exe+0xc0>)
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40ee22:	eee6 7a87 	vfma.f32	s15, s13, s14
	zmem->zm2 = zmem->zm1;
  40ee26:	edc2 5a01 	vstr	s11, [r2, #4]
	z /= c3;
  40ee2a:	edd1 6a00 	vldr	s13, [r1]
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40ee2e:	4b1b      	ldr	r3, [pc, #108]	; (40ee9c <arb_eso_exe+0xc4>)
	
	z22 = z_calc(-tdot, &zm22);
	z2 = z22 + z21;
  40ee30:	491b      	ldr	r1, [pc, #108]	; (40eea0 <arb_eso_exe+0xc8>)
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40ee32:	ee77 7ac5 	vsub.f32	s15, s15, s10
	z /= c3;
  40ee36:	eec7 5aa6 	vdiv.f32	s11, s15, s13
	zmem->zm1 = z;
  40ee3a:	edc2 5a00 	vstr	s11, [r2]
	z21 = z_calc(ta, &zm21);
  40ee3e:	edcd 5a01 	vstr	s11, [sp, #4]
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40ee42:	edd3 5a00 	vldr	s11, [r3]
  40ee46:	edd3 7a01 	vldr	s15, [r3, #4]
	zmem->zm2 = zmem->zm1;
  40ee4a:	edc3 5a01 	vstr	s11, [r3, #4]
	float z = (c1 * x) + (c2 * zmem->zm1) - zmem->zm2;
  40ee4e:	eed5 7a86 	vfnms.f32	s15, s11, s12
  40ee52:	eee8 7a47 	vfms.f32	s15, s16, s14
	z /= c3;
  40ee56:	ee87 7aa6 	vdiv.f32	s14, s15, s13
	zmem->zm1 = z;
  40ee5a:	ed83 7a00 	vstr	s14, [r3]
	z22 = z_calc(-tdot, &zm22);
  40ee5e:	ed8d 7a02 	vstr	s14, [sp, #8]
	z2 = z22 + z21;
  40ee62:	eddd 7a02 	vldr	s15, [sp, #8]
  40ee66:	ed9d 7a01 	vldr	s14, [sp, #4]
  40ee6a:	ee77 7a87 	vadd.f32	s15, s15, s14
  40ee6e:	edc1 7a00 	vstr	s15, [r1]
	
	return (-z2);
  40ee72:	6808      	ldr	r0, [r1, #0]
}
  40ee74:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  40ee78:	b004      	add	sp, #16
  40ee7a:	ecbd 8b02 	vpop	{d8}
  40ee7e:	bd10      	pop	{r4, pc}
  40ee80:	00413d09 	.word	0x00413d09
  40ee84:	20404ff0 	.word	0x20404ff0
  40ee88:	204063f0 	.word	0x204063f0
  40ee8c:	204063dc 	.word	0x204063dc
  40ee90:	204063d4 	.word	0x204063d4
  40ee94:	204063e4 	.word	0x204063e4
  40ee98:	204063f4 	.word	0x204063f4
  40ee9c:	204063e8 	.word	0x204063e8
  40eea0:	204063d8 	.word	0x204063d8
  40eea4:	00000000 	.word	0x00000000

0040eea8 <nlef_exe>:
#define reg_sign(x) ((x<0)?(-1):1)

#define alpha (0.5f)
#define segma (0.05f) //accuracy (0.0002) rad/sec
float nlef_exe(float err, float ff, float kp)
{
  40eea8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40eeac:	ed2d 8b04 	vpush	{d8-d9}
  40eeb0:	ee08 0a10 	vmov	s16, r0
// 	if (err_abs >= 1)
// 	{
// 		reg_out = (kp * err);
// 	} 
// 	else 
	if (err_abs > segma)
  40eeb4:	eddf 7a2a 	vldr	s15, [pc, #168]	; 40ef60 <nlef_exe+0xb8>
{
  40eeb8:	ee09 1a10 	vmov	s18, r1
	{
		reg_out = kp * (sqrt(err_abs) * reg_sign(err));
  40eebc:	4610      	mov	r0, r2
	float reg_out, err_abs = fixedpt_abs(err);
  40eebe:	eef0 8ac8 	vabs.f32	s17, s16
	if (err_abs > segma)
  40eec2:	eef4 8ae7 	vcmpe.f32	s17, s15
  40eec6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40eeca:	dd28      	ble.n	40ef1e <nlef_exe+0x76>
		reg_out = kp * (sqrt(err_abs) * reg_sign(err));
  40eecc:	4c25      	ldr	r4, [pc, #148]	; (40ef64 <nlef_exe+0xbc>)
  40eece:	f04f 0800 	mov.w	r8, #0
  40eed2:	47a0      	blx	r4
  40eed4:	4606      	mov	r6, r0
  40eed6:	ee18 0a90 	vmov	r0, s17
  40eeda:	460f      	mov	r7, r1
  40eedc:	47a0      	blx	r4
  40eede:	4b22      	ldr	r3, [pc, #136]	; (40ef68 <nlef_exe+0xc0>)
  40eee0:	4798      	blx	r3
  40eee2:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  40eee6:	4602      	mov	r2, r0
  40eee8:	460b      	mov	r3, r1
  40eeea:	4c20      	ldr	r4, [pc, #128]	; (40ef6c <nlef_exe+0xc4>)
  40eeec:	4630      	mov	r0, r6
  40eeee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40eef2:	4639      	mov	r1, r7
  40eef4:	bf54      	ite	pl
  40eef6:	f8df 907c 	ldrpl.w	r9, [pc, #124]	; 40ef74 <nlef_exe+0xcc>
  40eefa:	f8df 907c 	ldrmi.w	r9, [pc, #124]	; 40ef78 <nlef_exe+0xd0>
  40eefe:	47a0      	blx	r4
  40ef00:	4642      	mov	r2, r8
  40ef02:	464b      	mov	r3, r9
  40ef04:	47a0      	blx	r4
  40ef06:	4b1a      	ldr	r3, [pc, #104]	; (40ef70 <nlef_exe+0xc8>)
  40ef08:	4798      	blx	r3
  40ef0a:	ee07 0a90 	vmov	s15, r0
	}
	
	reg_out += ff;
	
	return reg_out;
}
  40ef0e:	ee77 7a89 	vadd.f32	s15, s15, s18
  40ef12:	ecbd 8b04 	vpop	{d8-d9}
  40ef16:	ee17 0a90 	vmov	r0, s15
  40ef1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		reg_out = kp * (err / sqrt(segma));
  40ef1e:	4d11      	ldr	r5, [pc, #68]	; (40ef64 <nlef_exe+0xbc>)
  40ef20:	47a8      	blx	r5
  40ef22:	4c12      	ldr	r4, [pc, #72]	; (40ef6c <nlef_exe+0xc4>)
  40ef24:	a30c      	add	r3, pc, #48	; (adr r3, 40ef58 <nlef_exe+0xb0>)
  40ef26:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ef2a:	47a0      	blx	r4
  40ef2c:	4606      	mov	r6, r0
  40ef2e:	460f      	mov	r7, r1
  40ef30:	ee18 0a10 	vmov	r0, s16
  40ef34:	47a8      	blx	r5
  40ef36:	4602      	mov	r2, r0
  40ef38:	460b      	mov	r3, r1
  40ef3a:	4630      	mov	r0, r6
  40ef3c:	4639      	mov	r1, r7
  40ef3e:	47a0      	blx	r4
  40ef40:	4b0b      	ldr	r3, [pc, #44]	; (40ef70 <nlef_exe+0xc8>)
  40ef42:	4798      	blx	r3
  40ef44:	ee07 0a90 	vmov	s15, r0
}
  40ef48:	ee77 7a89 	vadd.f32	s15, s15, s18
  40ef4c:	ecbd 8b04 	vpop	{d8-d9}
  40ef50:	ee17 0a90 	vmov	r0, s15
  40ef54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40ef58:	995b85b5 	.word	0x995b85b5
  40ef5c:	4011e377 	.word	0x4011e377
  40ef60:	3d4ccccd 	.word	0x3d4ccccd
  40ef64:	00418749 	.word	0x00418749
  40ef68:	00418249 	.word	0x00418249
  40ef6c:	004187f1 	.word	0x004187f1
  40ef70:	00418da1 	.word	0x00418da1
  40ef74:	3ff00000 	.word	0x3ff00000
  40ef78:	bff00000 	.word	0xbff00000

0040ef7c <nlef_saturation_trim>:

float nlef_saturation_trim(float sat_limit, float val)
{
  40ef7c:	ee07 1a90 	vmov	s15, r1
  40ef80:	ee07 0a10 	vmov	s14, r0
	if (fixedpt_abs(val) > sat_limit)
  40ef84:	eef0 6ae7 	vabs.f32	s13, s15
  40ef88:	eef4 6ac7 	vcmpe.f32	s13, s14
  40ef8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40ef90:	dd0c      	ble.n	40efac <nlef_saturation_trim+0x30>
	{
		return reg_sign(val) * sat_limit;
  40ef92:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40ef96:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  40ef9a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
  40ef9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40efa2:	bf58      	it	pl
  40efa4:	eef0 7a66 	vmovpl.f32	s15, s13
  40efa8:	ee67 7a87 	vmul.f32	s15, s15, s14
	}
	return val;
  40efac:	ee17 0a90 	vmov	r0, s15
  40efb0:	4770      	bx	lr
  40efb2:	bf00      	nop

0040efb4 <distance_regulator_exe>:

uint8_t distance_regulation_enable = 0;

int64_t encoder_distance_offset = 0;
float distance_regulator_exe(void)
{
  40efb4:	b5d0      	push	{r4, r6, r7, lr}
	float distance_error, tmp;
	
	distance_error = vfd_get_desired_distance();
	distance_error /= FIXEDPT_ONE;
	distance_error /= MOTOR_POLEPAIR; //distance_error = motor desired shaft distance in revolutions
  40efb6:	4c2b      	ldr	r4, [pc, #172]	; (40f064 <distance_regulator_exe+0xb0>)
	distance_error = vfd_get_desired_distance();
  40efb8:	4b2b      	ldr	r3, [pc, #172]	; (40f068 <distance_regulator_exe+0xb4>)
{
  40efba:	ed2d 8b02 	vpush	{d8}
	distance_error = vfd_get_desired_distance();
  40efbe:	4798      	blx	r3
	distance_error /= MOTOR_POLEPAIR; //distance_error = motor desired shaft distance in revolutions
  40efc0:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
	distance_error /= FIXEDPT_ONE;
  40efc4:	ee07 0a10 	vmov	s14, r0
	distance_error /= MOTOR_POLEPAIR; //distance_error = motor desired shaft distance in revolutions
  40efc8:	ee07 3a90 	vmov	s15, r3
	
	tmp = enc_get_lin_theta() - encoder_distance_offset;
  40efcc:	4b27      	ldr	r3, [pc, #156]	; (40f06c <distance_regulator_exe+0xb8>)
	distance_error /= FIXEDPT_ONE;
  40efce:	eeba 7ae8 	vcvt.f32.s32	s14, s14, #15
	distance_error /= MOTOR_POLEPAIR; //distance_error = motor desired shaft distance in revolutions
  40efd2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40efd6:	ee87 8a27 	vdiv.f32	s16, s14, s15
	tmp = enc_get_lin_theta() - encoder_distance_offset;
  40efda:	4798      	blx	r3
  40efdc:	4a24      	ldr	r2, [pc, #144]	; (40f070 <distance_regulator_exe+0xbc>)
  40efde:	4b25      	ldr	r3, [pc, #148]	; (40f074 <distance_regulator_exe+0xc0>)
  40efe0:	e9d2 6700 	ldrd	r6, r7, [r2]
  40efe4:	1b80      	subs	r0, r0, r6
  40efe6:	eb61 0107 	sbc.w	r1, r1, r7
  40efea:	4798      	blx	r3
	tmp /= ENCODER_COUNTREV; // tmp = motor real shaft distance in revolutions
  40efec:	f8b4 30ae 	ldrh.w	r3, [r4, #174]	; 0xae
  40eff0:	ee07 0a90 	vmov	s15, r0
	
	distance_error -= tmp; //get distance error
	
	tmp = hoist_info.enc_count_per_meter;
  40eff4:	4a20      	ldr	r2, [pc, #128]	; (40f078 <distance_regulator_exe+0xc4>)
	tmp /= ENCODER_COUNTREV; // tmp = motor real shaft distance in revolutions
  40eff6:	0059      	lsls	r1, r3, #1
	tmp /= ENCODER_COUNTREV * 10; //10 cm error
  40eff8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	tmp = hoist_info.enc_count_per_meter;
  40effc:	ed92 6a67 	vldr	s12, [r2, #412]	; 0x19c
	tmp /= ENCODER_COUNTREV; // tmp = motor real shaft distance in revolutions
  40f000:	ee06 1a90 	vmov	s13, r1
	tmp /= ENCODER_COUNTREV * 10; //10 cm error
  40f004:	009b      	lsls	r3, r3, #2
	tmp = hoist_info.enc_count_per_meter;
  40f006:	eeb8 6a46 	vcvt.f32.u32	s12, s12
	tmp /= ENCODER_COUNTREV; // tmp = motor real shaft distance in revolutions
  40f00a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  40f00e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
	tmp /= ENCODER_COUNTREV * 10; //10 cm error
  40f012:	ee07 3a90 	vmov	s15, r3
  40f016:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40f01a:	eec6 6a27 	vdiv.f32	s13, s12, s15
	distance_error -= tmp; //get distance error
  40f01e:	ee38 7a47 	vsub.f32	s14, s16, s14
	
	if(fixedpt_abs(distance_error)  >= fixedpt_abs(tmp))
  40f022:	eeb0 6ac7 	vabs.f32	s12, s14
  40f026:	eef0 7ae6 	vabs.f32	s15, s13
  40f02a:	eeb4 6ae7 	vcmpe.f32	s12, s15
  40f02e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f032:	da0c      	bge.n	40f04e <distance_regulator_exe+0x9a>
		dev_dis_err_set;
		return 0;
	}
	distance_error *= M_TWO_PI; //convert error to radian
	
	return (distance_error * DKP); //return feed forward speed;
  40f034:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
  40f038:	eddf 6a10 	vldr	s13, [pc, #64]	; 40f07c <distance_regulator_exe+0xc8>
  40f03c:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
  40f040:	ecbd 8b02 	vpop	{d8}
	return (distance_error * DKP); //return feed forward speed;
  40f044:	ee67 7a87 	vmul.f32	s15, s15, s14
}
  40f048:	ee17 0a90 	vmov	r0, s15
  40f04c:	bdd0      	pop	{r4, r6, r7, pc}
		dev_dis_err_set;
  40f04e:	4a0c      	ldr	r2, [pc, #48]	; (40f080 <distance_regulator_exe+0xcc>)
  40f050:	4b0c      	ldr	r3, [pc, #48]	; (40f084 <distance_regulator_exe+0xd0>)
  40f052:	7810      	ldrb	r0, [r2, #0]
  40f054:	4798      	blx	r3
  40f056:	eddf 7a0c 	vldr	s15, [pc, #48]	; 40f088 <distance_regulator_exe+0xd4>
}
  40f05a:	ecbd 8b02 	vpop	{d8}
  40f05e:	ee17 0a90 	vmov	r0, s15
  40f062:	bdd0      	pop	{r4, r6, r7, pc}
  40f064:	20404ff0 	.word	0x20404ff0
  40f068:	004169a1 	.word	0x004169a1
  40f06c:	00413b0d 	.word	0x00413b0d
  40f070:	20400978 	.word	0x20400978
  40f074:	00418fe1 	.word	0x00418fe1
  40f078:	20400c80 	.word	0x20400c80
  40f07c:	40c90fdb 	.word	0x40c90fdb
  40f080:	20406ca2 	.word	0x20406ca2
  40f084:	0041282d 	.word	0x0041282d
  40f088:	00000000 	.word	0x00000000

0040f08c <distance_regulator_get_ffspeed>:

float distance_regulator_get_ffspeed(void)
{
	if (ENABLE_REG)
  40f08c:	4b03      	ldr	r3, [pc, #12]	; (40f09c <distance_regulator_get_ffspeed+0x10>)
  40f08e:	781b      	ldrb	r3, [r3, #0]
  40f090:	2b01      	cmp	r3, #1
  40f092:	d001      	beq.n	40f098 <distance_regulator_get_ffspeed+0xc>
	} 
	else
	{
		return 0;
	}
}
  40f094:	2000      	movs	r0, #0
  40f096:	4770      	bx	lr
		return distance_regulator_exe();
  40f098:	4b01      	ldr	r3, [pc, #4]	; (40f0a0 <distance_regulator_get_ffspeed+0x14>)
  40f09a:	4718      	bx	r3
  40f09c:	20400970 	.word	0x20400970
  40f0a0:	0040efb5 	.word	0x0040efb5

0040f0a4 <distance_regulator_enable>:

void distance_regulator_enable(void)
{
  40f0a4:	b510      	push	{r4, lr}
	encoder_distance_offset = enc_get_lin_theta();
  40f0a6:	4b04      	ldr	r3, [pc, #16]	; (40f0b8 <distance_regulator_enable+0x14>)
  40f0a8:	4798      	blx	r3
  40f0aa:	4c04      	ldr	r4, [pc, #16]	; (40f0bc <distance_regulator_enable+0x18>)
	distance_regulation_enable = 1;
  40f0ac:	4b04      	ldr	r3, [pc, #16]	; (40f0c0 <distance_regulator_enable+0x1c>)
  40f0ae:	2201      	movs	r2, #1
	encoder_distance_offset = enc_get_lin_theta();
  40f0b0:	e9c4 0100 	strd	r0, r1, [r4]
	distance_regulation_enable = 1;
  40f0b4:	701a      	strb	r2, [r3, #0]
  40f0b6:	bd10      	pop	{r4, pc}
  40f0b8:	00413b0d 	.word	0x00413b0d
  40f0bc:	20400978 	.word	0x20400978
  40f0c0:	20400970 	.word	0x20400970

0040f0c4 <distance_regulator_correct_offset>:
}

void distance_regulator_correct_offset(int64_t new_offset)
{
  40f0c4:	b410      	push	{r4}
	encoder_distance_offset += new_offset;
  40f0c6:	4c05      	ldr	r4, [pc, #20]	; (40f0dc <distance_regulator_correct_offset+0x18>)
  40f0c8:	e9d4 2300 	ldrd	r2, r3, [r4]
  40f0cc:	1880      	adds	r0, r0, r2
  40f0ce:	4159      	adcs	r1, r3
  40f0d0:	e9c4 0100 	strd	r0, r1, [r4]
}
  40f0d4:	f85d 4b04 	ldr.w	r4, [sp], #4
  40f0d8:	4770      	bx	lr
  40f0da:	bf00      	nop
  40f0dc:	20400978 	.word	0x20400978

0040f0e0 <distance_regulator_disable>:

void distance_regulator_disable(void)
{
	distance_regulation_enable = 0;
  40f0e0:	4b01      	ldr	r3, [pc, #4]	; (40f0e8 <distance_regulator_disable+0x8>)
  40f0e2:	2200      	movs	r2, #0
  40f0e4:	701a      	strb	r2, [r3, #0]
  40f0e6:	4770      	bx	lr
  40f0e8:	20400970 	.word	0x20400970

0040f0ec <pos_zs_regulate.part.0>:
void pos_zs_regulate(void)
{
	if (pos_zs_shutdown) return;
	float tmp;
	
	pos_err = pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f0ec:	4a14      	ldr	r2, [pc, #80]	; (40f140 <pos_zs_regulate.part.0+0x54>)
  40f0ee:	4b15      	ldr	r3, [pc, #84]	; (40f144 <pos_zs_regulate.part.0+0x58>)
void pos_zs_regulate(void)
  40f0f0:	b5d0      	push	{r4, r6, r7, lr}
	pos_err = pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f0f2:	e9d2 6700 	ldrd	r6, r7, [r2]
  40f0f6:	4798      	blx	r3
  40f0f8:	4c13      	ldr	r4, [pc, #76]	; (40f148 <pos_zs_regulate.part.0+0x5c>)
  40f0fa:	1a30      	subs	r0, r6, r0
  40f0fc:	4b13      	ldr	r3, [pc, #76]	; (40f14c <pos_zs_regulate.part.0+0x60>)
  40f0fe:	eb67 0101 	sbc.w	r1, r7, r1
  40f102:	4798      	blx	r3
	tmp = -enc_get_phase();
  40f104:	4b12      	ldr	r3, [pc, #72]	; (40f150 <pos_zs_regulate.part.0+0x64>)
	pos_err = pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f106:	6020      	str	r0, [r4, #0]
	tmp = -enc_get_phase();
  40f108:	4798      	blx	r3
	tmp /= FIXEDPT_ONE;
	tmp += phase_to_keep;
  40f10a:	4b12      	ldr	r3, [pc, #72]	; (40f154 <pos_zs_regulate.part.0+0x68>)
	tmp = -enc_get_phase();
  40f10c:	4240      	negs	r0, r0
	pos_err += tmp;
  40f10e:	ed94 7a00 	vldr	s14, [r4]
  40f112:	edd3 7a00 	vldr	s15, [r3]
	tmp = -enc_get_phase();
  40f116:	ee06 0a90 	vmov	s13, r0
	pos_err += tmp;
  40f11a:	ed9f 6a0f 	vldr	s12, [pc, #60]	; 40f158 <pos_zs_regulate.part.0+0x6c>
  40f11e:	ee77 7a87 	vadd.f32	s15, s15, s14
	
	tmp = PKP_ZEROSERVO * pos_err;
  40f122:	4a0e      	ldr	r2, [pc, #56]	; (40f15c <pos_zs_regulate.part.0+0x70>)
	tmp = -enc_get_phase();
  40f124:	eef8 6ae6 	vcvt.f32.s32	s13, s13
	
	pos_zs_contribution = tmp;
  40f128:	4b0d      	ldr	r3, [pc, #52]	; (40f160 <pos_zs_regulate.part.0+0x74>)
	tmp = PKP_ZEROSERVO * pos_err;
  40f12a:	ed92 7a18 	vldr	s14, [r2, #96]	; 0x60
	pos_err += tmp;
  40f12e:	eee6 7a86 	vfma.f32	s15, s13, s12
	tmp = PKP_ZEROSERVO * pos_err;
  40f132:	ee27 7a27 	vmul.f32	s14, s14, s15
	pos_err += tmp;
  40f136:	edc4 7a00 	vstr	s15, [r4]
	pos_zs_contribution = tmp;
  40f13a:	ed83 7a00 	vstr	s14, [r3]
  40f13e:	bdd0      	pop	{r4, r6, r7, pc}
  40f140:	20400988 	.word	0x20400988
  40f144:	00413b0d 	.word	0x00413b0d
  40f148:	2040640c 	.word	0x2040640c
  40f14c:	00418fe1 	.word	0x00418fe1
  40f150:	004138c9 	.word	0x004138c9
  40f154:	20406408 	.word	0x20406408
  40f158:	38000000 	.word	0x38000000
  40f15c:	20404ff0 	.word	0x20404ff0
  40f160:	20400990 	.word	0x20400990

0040f164 <pos_regulator_reset_keeping_pos>:
{
  40f164:	b510      	push	{r4, lr}
	pos_to_keep = pos_err + enc_get_lin_theta();
  40f166:	4b09      	ldr	r3, [pc, #36]	; (40f18c <pos_regulator_reset_keeping_pos+0x28>)
  40f168:	4798      	blx	r3
  40f16a:	4b09      	ldr	r3, [pc, #36]	; (40f190 <pos_regulator_reset_keeping_pos+0x2c>)
  40f16c:	4798      	blx	r3
  40f16e:	4b09      	ldr	r3, [pc, #36]	; (40f194 <pos_regulator_reset_keeping_pos+0x30>)
  40f170:	ee07 0a10 	vmov	s14, r0
  40f174:	4c08      	ldr	r4, [pc, #32]	; (40f198 <pos_regulator_reset_keeping_pos+0x34>)
  40f176:	edd3 7a00 	vldr	s15, [r3]
  40f17a:	4b08      	ldr	r3, [pc, #32]	; (40f19c <pos_regulator_reset_keeping_pos+0x38>)
  40f17c:	ee77 7a27 	vadd.f32	s15, s14, s15
  40f180:	ee17 0a90 	vmov	r0, s15
  40f184:	4798      	blx	r3
  40f186:	e9c4 0100 	strd	r0, r1, [r4]
  40f18a:	bd10      	pop	{r4, pc}
  40f18c:	00413b0d 	.word	0x00413b0d
  40f190:	00418fe1 	.word	0x00418fe1
  40f194:	2040640c 	.word	0x2040640c
  40f198:	20400988 	.word	0x20400988
  40f19c:	0041912d 	.word	0x0041912d

0040f1a0 <get_zs_displacement>:
#define ENC_LSPEED_FILTER_TIME (menue_drive_data_applied.m_enc_filter_low)
struct pi_t pi_s; 

float get_zs_displacement(void)
{	
	return -pos_err;
  40f1a0:	4b02      	ldr	r3, [pc, #8]	; (40f1ac <get_zs_displacement+0xc>)
  40f1a2:	6818      	ldr	r0, [r3, #0]
}
  40f1a4:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  40f1a8:	4770      	bx	lr
  40f1aa:	bf00      	nop
  40f1ac:	2040640c 	.word	0x2040640c

0040f1b0 <speed_regulator_setKt>:

float KT = 1;
float speed_regulator_setKt(float kt)
{
	KT = kt;
  40f1b0:	4a01      	ldr	r2, [pc, #4]	; (40f1b8 <speed_regulator_setKt+0x8>)
  40f1b2:	6010      	str	r0, [r2, #0]
}
  40f1b4:	4618      	mov	r0, r3
  40f1b6:	4770      	bx	lr
  40f1b8:	20400358 	.word	0x20400358

0040f1bc <speed_regulate>:
#define ZS_TORQUE_MEM_GAIN (1 / (1 + (1 / ZS_TORQUE_TC)))
#define ZS_TORQUE_NEW_GAIN (1 / (1 + ZS_TORQUE_TC))

float prev_com_torque = 0 , pit = 0;
float speed_regulate(float cmd_speed, float current_speed, uint32_t accel)
{
  40f1bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	volatile float tmp, cmd_speed_ele_hz = cmd_speed * MOTOR_POLEPAIR / M_TWO_PI;
  40f1be:	4cb9      	ldr	r4, [pc, #740]	; (40f4a4 <speed_regulate+0x2e8>)
  40f1c0:	ed9f 7ab9 	vldr	s14, [pc, #740]	; 40f4a8 <speed_regulate+0x2ec>
{
  40f1c4:	ed2d 8b04 	vpush	{d8-d9}
	volatile float tmp, cmd_speed_ele_hz = cmd_speed * MOTOR_POLEPAIR / M_TWO_PI;
  40f1c8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
{
  40f1cc:	ee08 0a90 	vmov	s17, r0
  40f1d0:	b085      	sub	sp, #20
  40f1d2:	ee09 1a10 	vmov	s18, r1
	volatile float tmp, cmd_speed_ele_hz = cmd_speed * MOTOR_POLEPAIR / M_TWO_PI;
  40f1d6:	ee07 3a90 	vmov	s15, r3
	if (MOTOR_IM)
  40f1da:	7823      	ldrb	r3, [r4, #0]
	volatile float tmp, cmd_speed_ele_hz = cmd_speed * MOTOR_POLEPAIR / M_TWO_PI;
  40f1dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40f1e0:	ee67 7a87 	vmul.f32	s15, s15, s14
  40f1e4:	ee67 7aa8 	vmul.f32	s15, s15, s17
  40f1e8:	edcd 7a03 	vstr	s15, [sp, #12]
	if (MOTOR_IM)
  40f1ec:	b90b      	cbnz	r3, 40f1f2 <speed_regulate+0x36>
	{
		cmd_speed_ele_hz *= GB_REDUCTION_RATIO;
  40f1ee:	9b03      	ldr	r3, [sp, #12]
  40f1f0:	9303      	str	r3, [sp, #12]
	
	uint32_t cmd_tourque_filter = 1;
	float s_ff;
	float tmp_torque_lmt ;
	
	if (vfd_is_motor_regen()) tmp_torque_lmt = DRIVE_UPPER_CURRENT_LIMIT * KT;
  40f1f2:	4bae      	ldr	r3, [pc, #696]	; (40f4ac <speed_regulate+0x2f0>)
  40f1f4:	4798      	blx	r3
  40f1f6:	2800      	cmp	r0, #0
  40f1f8:	f000 8081 	beq.w	40f2fe <speed_regulate+0x142>
  40f1fc:	4dac      	ldr	r5, [pc, #688]	; (40f4b0 <speed_regulate+0x2f4>)
  40f1fe:	eddf 7aad 	vldr	s15, [pc, #692]	; 40f4b4 <speed_regulate+0x2f8>
  40f202:	ed95 8a00 	vldr	s16, [r5]
  40f206:	ee28 8a27 	vmul.f32	s16, s16, s15
	else tmp_torque_lmt = current_limit * KT;
	
	if(vfd_states_allowedtomove())
  40f20a:	4bab      	ldr	r3, [pc, #684]	; (40f4b8 <speed_regulate+0x2fc>)
  40f20c:	4798      	blx	r3
  40f20e:	2800      	cmp	r0, #0
  40f210:	d042      	beq.n	40f298 <speed_regulate+0xdc>
	{
		if(fixedpt_abs(cmd_speed_ele_hz) <= ASR_SW_FREQLS) 
  40f212:	eddd 7a03 	vldr	s15, [sp, #12]
  40f216:	ed9d 7a03 	vldr	s14, [sp, #12]
  40f21a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40f21e:	edd4 7a1b 	vldr	s15, [r4, #108]	; 0x6c
  40f222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f226:	bf48      	it	mi
  40f228:	eeb1 7a47 	vnegmi.f32	s14, s14
  40f22c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  40f230:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f234:	f240 812c 	bls.w	40f490 <speed_regulate+0x2d4>
			//Set LS PI controller coef
			reg_pi_change_kp(SKP_LS, &pi_s);
			reg_pi_change_ki(SKI_LS, &pi_s);
			enc_set_filter_timeconst(ENC_LSPEED_FILTER_TIME);
		}
		else if((fixedpt_abs(cmd_speed_ele_hz) > ASR_SW_FREQLS) && (fixedpt_abs(cmd_speed_ele_hz) <= ASR_SW_FREQHS))
  40f238:	ed9d 7a03 	vldr	s14, [sp, #12]
  40f23c:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
  40f240:	ed9d 7a03 	vldr	s14, [sp, #12]
  40f244:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f248:	bf48      	it	mi
  40f24a:	eeb1 7a47 	vnegmi.f32	s14, s14
  40f24e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  40f252:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f256:	f300 80d4 	bgt.w	40f402 <speed_regulate+0x246>
  40f25a:	ed94 7a1a 	vldr	s14, [r4, #104]	; 0x68
			//gradually increase PI controller coef
			tmp = (fixedpt_abs(cmd_speed_ele_hz) - ASR_SW_FREQLS) / (ASR_SW_FREQHS - ASR_SW_FREQLS);
			reg_pi_change_kp(SKP_LS + tmp * (SKP_HS - SKP_LS), &pi_s);
			reg_pi_change_ki(SKI_LS + tmp * (SKI_HS - SKI_LS), &pi_s);
		}
		else if(fixedpt_abs(cmd_speed_ele_hz) > ASR_SW_FREQHS)
  40f25e:	eddd 7a03 	vldr	s15, [sp, #12]
  40f262:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40f266:	eddd 7a03 	vldr	s15, [sp, #12]
  40f26a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f26e:	bf48      	it	mi
  40f270:	eef1 7a67 	vnegmi.f32	s15, s15
  40f274:	eef4 7ac7 	vcmpe.f32	s15, s14
  40f278:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f27c:	dd0c      	ble.n	40f298 <speed_regulate+0xdc>
		{
			reg_pi_change_kp(SKP_HS, &pi_s);
  40f27e:	4b8f      	ldr	r3, [pc, #572]	; (40f4bc <speed_regulate+0x300>)
  40f280:	498f      	ldr	r1, [pc, #572]	; (40f4c0 <speed_regulate+0x304>)
  40f282:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  40f284:	4798      	blx	r3
			reg_pi_change_ki(SKI_HS, &pi_s);
  40f286:	4b8f      	ldr	r3, [pc, #572]	; (40f4c4 <speed_regulate+0x308>)
  40f288:	6818      	ldr	r0, [r3, #0]
  40f28a:	498d      	ldr	r1, [pc, #564]	; (40f4c0 <speed_regulate+0x304>)
  40f28c:	4b8e      	ldr	r3, [pc, #568]	; (40f4c8 <speed_regulate+0x30c>)
  40f28e:	4798      	blx	r3
			//if (accel == 0) cmd_tourque_filter = 100;//ENC_HSPEED_FILTER_TIME;
			enc_set_filter_timeconst(ENC_LSPEED_FILTER_TIME);
  40f290:	f8d4 00b8 	ldr.w	r0, [r4, #184]	; 0xb8
  40f294:	4b8d      	ldr	r3, [pc, #564]	; (40f4cc <speed_regulate+0x310>)
  40f296:	4798      	blx	r3
	}
	

	//current_speed /= (MOTOR_POLEPAIR); //convert to shaft speed in rad/sec
	//current_speed *= 2 * PI;
	if (pos_zs_shutdown)
  40f298:	4e8d      	ldr	r6, [pc, #564]	; (40f4d0 <speed_regulate+0x314>)
  40f29a:	7833      	ldrb	r3, [r6, #0]
  40f29c:	2b00      	cmp	r3, #0
  40f29e:	d037      	beq.n	40f310 <speed_regulate+0x154>
	{
		tmp = cmd_speed - current_speed; //generate error signal 
  40f2a0:	ee78 7ac9 	vsub.f32	s15, s17, s18
		tmp += distance_regulator_get_ffspeed(); //add distance control speed feed forward
  40f2a4:	4b8b      	ldr	r3, [pc, #556]	; (40f4d4 <speed_regulate+0x318>)
		tmp = cmd_speed - current_speed; //generate error signal 
  40f2a6:	edcd 7a02 	vstr	s15, [sp, #8]
		tmp += distance_regulator_get_ffspeed(); //add distance control speed feed forward
  40f2aa:	4798      	blx	r3
  40f2ac:	eddd 7a02 	vldr	s15, [sp, #8]
  40f2b0:	ee07 0a10 	vmov	s14, r0
		if (MOTOR_PM_CVC) s_ff = load_torque ;//- (current_speed * B_FRICTION)/*actuve damping*/;
  40f2b4:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
		tmp += distance_regulator_get_ffspeed(); //add distance control speed feed forward
  40f2b8:	ee77 7a27 	vadd.f32	s15, s14, s15
		if (MOTOR_PM_CVC) s_ff = load_torque ;//- (current_speed * B_FRICTION)/*actuve damping*/;
  40f2bc:	2b01      	cmp	r3, #1
		tmp += distance_regulator_get_ffspeed(); //add distance control speed feed forward
  40f2be:	edcd 7a02 	vstr	s15, [sp, #8]
		if (MOTOR_PM_CVC) s_ff = load_torque ;//- (current_speed * B_FRICTION)/*actuve damping*/;
  40f2c2:	f000 8097 	beq.w	40f3f4 <speed_regulate+0x238>
		else s_ff = 0;
  40f2c6:	2200      	movs	r2, #0
		tmp = reg_pi_exe(tmp_torque_lmt, tmp, s_ff, 0.001, &pi_s);
  40f2c8:	4c7d      	ldr	r4, [pc, #500]	; (40f4c0 <speed_regulate+0x304>)
  40f2ca:	ee18 0a10 	vmov	r0, s16
  40f2ce:	9902      	ldr	r1, [sp, #8]
  40f2d0:	4b81      	ldr	r3, [pc, #516]	; (40f4d8 <speed_regulate+0x31c>)
  40f2d2:	9400      	str	r4, [sp, #0]
  40f2d4:	4c81      	ldr	r4, [pc, #516]	; (40f4dc <speed_regulate+0x320>)
  40f2d6:	47a0      	blx	r4
  40f2d8:	9002      	str	r0, [sp, #8]
		}
		else
		{
			prev_com_torque = 0;
		}
		pit = tmp;
  40f2da:	4981      	ldr	r1, [pc, #516]	; (40f4e0 <speed_regulate+0x324>)
			prev_com_torque = 0;
  40f2dc:	2200      	movs	r2, #0
		pit = tmp;
  40f2de:	9802      	ldr	r0, [sp, #8]
			prev_com_torque = 0;
  40f2e0:	4b80      	ldr	r3, [pc, #512]	; (40f4e4 <speed_regulate+0x328>)
  40f2e2:	edd5 7a00 	vldr	s15, [r5]
		pit = tmp;
  40f2e6:	6008      	str	r0, [r1, #0]
			prev_com_torque = 0;
  40f2e8:	601a      	str	r2, [r3, #0]
			//arb_eso_exe(tmp, 0);
			spt_tourque = tmp;
		}
	}

	return tmp / KT; //convert torque to current
  40f2ea:	ed9d 7a02 	vldr	s14, [sp, #8]
}
  40f2ee:	eec7 6a27 	vdiv.f32	s13, s14, s15
  40f2f2:	ee16 0a90 	vmov	r0, s13
  40f2f6:	b005      	add	sp, #20
  40f2f8:	ecbd 8b04 	vpop	{d8-d9}
  40f2fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else tmp_torque_lmt = current_limit * KT;
  40f2fe:	4b7a      	ldr	r3, [pc, #488]	; (40f4e8 <speed_regulate+0x32c>)
  40f300:	4d6b      	ldr	r5, [pc, #428]	; (40f4b0 <speed_regulate+0x2f4>)
  40f302:	ed93 8a00 	vldr	s16, [r3]
  40f306:	edd5 7a00 	vldr	s15, [r5]
  40f30a:	ee28 8a27 	vmul.f32	s16, s16, s15
  40f30e:	e77c      	b.n	40f20a <speed_regulate+0x4e>
		if (spt_permission_brake_open())
  40f310:	4b76      	ldr	r3, [pc, #472]	; (40f4ec <speed_regulate+0x330>)
  40f312:	4798      	blx	r3
  40f314:	2800      	cmp	r0, #0
  40f316:	d064      	beq.n	40f3e2 <speed_regulate+0x226>
			tmp = 0 - current_speed; //generate error signal
  40f318:	eef1 7a49 	vneg.f32	s15, s18
			reg_temp_torque = arb_eso_exe(s_ff + reg_temp_torque, current_speed);
  40f31c:	4f74      	ldr	r7, [pc, #464]	; (40f4f0 <speed_regulate+0x334>)
			s_ff = nlef_exe(tmp, 0, SKP_ZEROSERVO);
  40f31e:	6da2      	ldr	r2, [r4, #88]	; 0x58
  40f320:	2100      	movs	r1, #0
  40f322:	4b74      	ldr	r3, [pc, #464]	; (40f4f4 <speed_regulate+0x338>)
			tmp = 0 - current_speed; //generate error signal
  40f324:	edcd 7a02 	vstr	s15, [sp, #8]
			s_ff = nlef_exe(tmp, 0, SKP_ZEROSERVO);
  40f328:	9802      	ldr	r0, [sp, #8]
  40f32a:	4798      	blx	r3
			reg_temp_torque = arb_eso_exe(s_ff + reg_temp_torque, current_speed);
  40f32c:	edd7 7a00 	vldr	s15, [r7]
			s_ff = nlef_exe(tmp, 0, SKP_ZEROSERVO);
  40f330:	ee08 0a90 	vmov	s17, r0
			reg_temp_torque = arb_eso_exe(s_ff + reg_temp_torque, current_speed);
  40f334:	4b70      	ldr	r3, [pc, #448]	; (40f4f8 <speed_regulate+0x33c>)
  40f336:	ee19 1a10 	vmov	r1, s18
  40f33a:	ee78 7aa7 	vadd.f32	s15, s17, s15
  40f33e:	ee17 0a90 	vmov	r0, s15
  40f342:	4798      	blx	r3
  40f344:	6038      	str	r0, [r7, #0]
			s_ff += reg_temp_torque;
  40f346:	edd7 7a00 	vldr	s15, [r7]
	if (pos_zs_shutdown) return;
  40f34a:	7833      	ldrb	r3, [r6, #0]
			s_ff += reg_temp_torque;
  40f34c:	ee78 8aa7 	vadd.f32	s17, s17, s15
			tmp = s_ff;
  40f350:	edcd 8a02 	vstr	s17, [sp, #8]
	if (pos_zs_shutdown) return;
  40f354:	2b00      	cmp	r3, #0
  40f356:	f000 80a1 	beq.w	40f49c <speed_regulate+0x2e0>
			tmp += pos_zs_contribution;
  40f35a:	4b68      	ldr	r3, [pc, #416]	; (40f4fc <speed_regulate+0x340>)
			tmp = nlef_saturation_trim(tmp_torque_lmt, tmp);
  40f35c:	ee18 0a10 	vmov	r0, s16
			tmp += pos_zs_contribution;
  40f360:	eddd 7a02 	vldr	s15, [sp, #8]
  40f364:	ed93 7a00 	vldr	s14, [r3]
			tmp += spt_tourque;
  40f368:	4a65      	ldr	r2, [pc, #404]	; (40f500 <speed_regulate+0x344>)
			tmp += pos_zs_contribution;
  40f36a:	ee77 7a87 	vadd.f32	s15, s15, s14
			tmp = nlef_saturation_trim(tmp_torque_lmt, tmp);
  40f36e:	4b65      	ldr	r3, [pc, #404]	; (40f504 <speed_regulate+0x348>)
			tmp += pos_zs_contribution;
  40f370:	edcd 7a02 	vstr	s15, [sp, #8]
			tmp += spt_tourque;
  40f374:	edd2 7a00 	vldr	s15, [r2]
  40f378:	ed9d 7a02 	vldr	s14, [sp, #8]
  40f37c:	ee77 7a87 	vadd.f32	s15, s15, s14
  40f380:	edcd 7a02 	vstr	s15, [sp, #8]
			tmp = nlef_saturation_trim(tmp_torque_lmt, tmp);
  40f384:	9902      	ldr	r1, [sp, #8]
  40f386:	4798      	blx	r3
			load_torque = (load_torque * ZS_TORQUE_MEM_GAIN) + (tmp * ZS_TORQUE_NEW_GAIN);
  40f388:	4b5f      	ldr	r3, [pc, #380]	; (40f508 <speed_regulate+0x34c>)
			tmp = nlef_saturation_trim(tmp_torque_lmt, tmp);
  40f38a:	9002      	str	r0, [sp, #8]
			load_torque = (load_torque * ZS_TORQUE_MEM_GAIN) + (tmp * ZS_TORQUE_NEW_GAIN);
  40f38c:	ed9f 6a5f 	vldr	s12, [pc, #380]	; 40f50c <speed_regulate+0x350>
  40f390:	edd3 6a00 	vldr	s13, [r3]
  40f394:	eddd 7a02 	vldr	s15, [sp, #8]
  40f398:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 40f510 <speed_regulate+0x354>
  40f39c:	ee67 7a86 	vmul.f32	s15, s15, s12
  40f3a0:	eee6 7a87 	vfma.f32	s15, s13, s14
			if (fixedpt_abs(tmp) >= (DRIVE_UPPER_CURRENT_LIMIT * KT))
  40f3a4:	ed9f 7a43 	vldr	s14, [pc, #268]	; 40f4b4 <speed_regulate+0x2f8>
			load_torque = (load_torque * ZS_TORQUE_MEM_GAIN) + (tmp * ZS_TORQUE_NEW_GAIN);
  40f3a8:	edc3 7a00 	vstr	s15, [r3]
			if (fixedpt_abs(tmp) >= (DRIVE_UPPER_CURRENT_LIMIT * KT))
  40f3ac:	eddd 7a02 	vldr	s15, [sp, #8]
  40f3b0:	eddd 6a02 	vldr	s13, [sp, #8]
  40f3b4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40f3b8:	edd5 7a00 	vldr	s15, [r5]
  40f3bc:	ee27 7a87 	vmul.f32	s14, s15, s14
  40f3c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f3c4:	bf48      	it	mi
  40f3c6:	eef1 6a66 	vnegmi.f32	s13, s13
  40f3ca:	eef4 6ac7 	vcmpe.f32	s13, s14
  40f3ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f3d2:	db8a      	blt.n	40f2ea <speed_regulate+0x12e>
				zs_servo_err_set;
  40f3d4:	4a4f      	ldr	r2, [pc, #316]	; (40f514 <speed_regulate+0x358>)
  40f3d6:	4b50      	ldr	r3, [pc, #320]	; (40f518 <speed_regulate+0x35c>)
  40f3d8:	7810      	ldrb	r0, [r2, #0]
  40f3da:	4798      	blx	r3
  40f3dc:	edd5 7a00 	vldr	s15, [r5]
  40f3e0:	e783      	b.n	40f2ea <speed_regulate+0x12e>
			tmp = spt_perform();
  40f3e2:	4b4e      	ldr	r3, [pc, #312]	; (40f51c <speed_regulate+0x360>)
  40f3e4:	4798      	blx	r3
  40f3e6:	9002      	str	r0, [sp, #8]
			spt_tourque = tmp;
  40f3e8:	4b45      	ldr	r3, [pc, #276]	; (40f500 <speed_regulate+0x344>)
  40f3ea:	9a02      	ldr	r2, [sp, #8]
  40f3ec:	edd5 7a00 	vldr	s15, [r5]
  40f3f0:	601a      	str	r2, [r3, #0]
  40f3f2:	e77a      	b.n	40f2ea <speed_regulate+0x12e>
		if (MOTOR_PM_CVC) s_ff = load_torque ;//- (current_speed * B_FRICTION)/*actuve damping*/;
  40f3f4:	7823      	ldrb	r3, [r4, #0]
  40f3f6:	2b01      	cmp	r3, #1
  40f3f8:	f47f af65 	bne.w	40f2c6 <speed_regulate+0x10a>
  40f3fc:	4b42      	ldr	r3, [pc, #264]	; (40f508 <speed_regulate+0x34c>)
  40f3fe:	681a      	ldr	r2, [r3, #0]
  40f400:	e762      	b.n	40f2c8 <speed_regulate+0x10c>
		else if((fixedpt_abs(cmd_speed_ele_hz) > ASR_SW_FREQLS) && (fixedpt_abs(cmd_speed_ele_hz) <= ASR_SW_FREQHS))
  40f402:	ed9d 7a03 	vldr	s14, [sp, #12]
  40f406:	eddd 6a03 	vldr	s13, [sp, #12]
  40f40a:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
  40f40e:	ed94 7a1a 	vldr	s14, [r4, #104]	; 0x68
  40f412:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f416:	bf48      	it	mi
  40f418:	eef1 6a66 	vnegmi.f32	s13, s13
  40f41c:	eef4 6ac7 	vcmpe.f32	s13, s14
  40f420:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f424:	f63f af1b 	bhi.w	40f25e <speed_regulate+0xa2>
			tmp = (fixedpt_abs(cmd_speed_ele_hz) - ASR_SW_FREQLS) / (ASR_SW_FREQHS - ASR_SW_FREQLS);
  40f428:	eddd 6a03 	vldr	s13, [sp, #12]
			reg_pi_change_kp(SKP_LS + tmp * (SKP_HS - SKP_LS), &pi_s);
  40f42c:	ed94 6a10 	vldr	s12, [r4, #64]	; 0x40
			tmp = (fixedpt_abs(cmd_speed_ele_hz) - ASR_SW_FREQLS) / (ASR_SW_FREQHS - ASR_SW_FREQLS);
  40f430:	eef5 6ac0 	vcmpe.f32	s13, #0.0
  40f434:	eddd 6a03 	vldr	s13, [sp, #12]
			reg_pi_change_kp(SKP_LS + tmp * (SKP_HS - SKP_LS), &pi_s);
  40f438:	4921      	ldr	r1, [pc, #132]	; (40f4c0 <speed_regulate+0x304>)
  40f43a:	4b20      	ldr	r3, [pc, #128]	; (40f4bc <speed_regulate+0x300>)
			tmp = (fixedpt_abs(cmd_speed_ele_hz) - ASR_SW_FREQLS) / (ASR_SW_FREQHS - ASR_SW_FREQLS);
  40f43c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f440:	bf48      	it	mi
  40f442:	eef1 6a66 	vnegmi.f32	s13, s13
  40f446:	ee76 6ae7 	vsub.f32	s13, s13, s15
  40f44a:	ee77 7a67 	vsub.f32	s15, s14, s15
			reg_pi_change_kp(SKP_LS + tmp * (SKP_HS - SKP_LS), &pi_s);
  40f44e:	ed94 7a12 	vldr	s14, [r4, #72]	; 0x48
  40f452:	ee37 7a46 	vsub.f32	s14, s14, s12
			tmp = (fixedpt_abs(cmd_speed_ele_hz) - ASR_SW_FREQLS) / (ASR_SW_FREQHS - ASR_SW_FREQLS);
  40f456:	eec6 5aa7 	vdiv.f32	s11, s13, s15
  40f45a:	edcd 5a02 	vstr	s11, [sp, #8]
			reg_pi_change_kp(SKP_LS + tmp * (SKP_HS - SKP_LS), &pi_s);
  40f45e:	eddd 7a02 	vldr	s15, [sp, #8]
  40f462:	eea7 6a27 	vfma.f32	s12, s14, s15
  40f466:	ee16 0a10 	vmov	r0, s12
  40f46a:	4798      	blx	r3
			reg_pi_change_ki(SKI_LS + tmp * (SKI_HS - SKI_LS), &pi_s);
  40f46c:	4a2c      	ldr	r2, [pc, #176]	; (40f520 <speed_regulate+0x364>)
  40f46e:	4b15      	ldr	r3, [pc, #84]	; (40f4c4 <speed_regulate+0x308>)
  40f470:	ed92 7a00 	vldr	s14, [r2]
  40f474:	edd3 7a00 	vldr	s15, [r3]
  40f478:	eddd 6a02 	vldr	s13, [sp, #8]
  40f47c:	ee77 7ac7 	vsub.f32	s15, s15, s14
  40f480:	490f      	ldr	r1, [pc, #60]	; (40f4c0 <speed_regulate+0x304>)
  40f482:	4b11      	ldr	r3, [pc, #68]	; (40f4c8 <speed_regulate+0x30c>)
  40f484:	eea7 7aa6 	vfma.f32	s14, s15, s13
  40f488:	ee17 0a10 	vmov	r0, s14
  40f48c:	4798      	blx	r3
  40f48e:	e703      	b.n	40f298 <speed_regulate+0xdc>
			reg_pi_change_kp(SKP_LS, &pi_s);
  40f490:	4b0a      	ldr	r3, [pc, #40]	; (40f4bc <speed_regulate+0x300>)
  40f492:	490b      	ldr	r1, [pc, #44]	; (40f4c0 <speed_regulate+0x304>)
  40f494:	6c20      	ldr	r0, [r4, #64]	; 0x40
  40f496:	4798      	blx	r3
			reg_pi_change_ki(SKI_LS, &pi_s);
  40f498:	4b21      	ldr	r3, [pc, #132]	; (40f520 <speed_regulate+0x364>)
  40f49a:	e6f5      	b.n	40f288 <speed_regulate+0xcc>
  40f49c:	4b21      	ldr	r3, [pc, #132]	; (40f524 <speed_regulate+0x368>)
  40f49e:	4798      	blx	r3
  40f4a0:	e75b      	b.n	40f35a <speed_regulate+0x19e>
  40f4a2:	bf00      	nop
  40f4a4:	20404ff0 	.word	0x20404ff0
  40f4a8:	3e22f983 	.word	0x3e22f983
  40f4ac:	00416c75 	.word	0x00416c75
  40f4b0:	20400358 	.word	0x20400358
  40f4b4:	425c0000 	.word	0x425c0000
  40f4b8:	00416305 	.word	0x00416305
  40f4bc:	0040a8f9 	.word	0x0040a8f9
  40f4c0:	204063f8 	.word	0x204063f8
  40f4c4:	20400364 	.word	0x20400364
  40f4c8:	0040a8dd 	.word	0x0040a8dd
  40f4cc:	00413de1 	.word	0x00413de1
  40f4d0:	20400360 	.word	0x20400360
  40f4d4:	0040f08d 	.word	0x0040f08d
  40f4d8:	3a83126f 	.word	0x3a83126f
  40f4dc:	0040a935 	.word	0x0040a935
  40f4e0:	20400984 	.word	0x20400984
  40f4e4:	20400994 	.word	0x20400994
  40f4e8:	2040035c 	.word	0x2040035c
  40f4ec:	0040f9d5 	.word	0x0040f9d5
  40f4f0:	20400998 	.word	0x20400998
  40f4f4:	0040eea9 	.word	0x0040eea9
  40f4f8:	0040edd9 	.word	0x0040edd9
  40f4fc:	20400990 	.word	0x20400990
  40f500:	2040099c 	.word	0x2040099c
  40f504:	0040ef7d 	.word	0x0040ef7d
  40f508:	20400980 	.word	0x20400980
  40f50c:	3d800000 	.word	0x3d800000
  40f510:	3f6fffff 	.word	0x3f6fffff
  40f514:	20406ca8 	.word	0x20406ca8
  40f518:	0041282d 	.word	0x0041282d
  40f51c:	0040f831 	.word	0x0040f831
  40f520:	20400368 	.word	0x20400368
  40f524:	0040f0ed 	.word	0x0040f0ed

0040f528 <start_zero_servo>:

void start_zero_servo(void)
{
  40f528:	b570      	push	{r4, r5, r6, lr}
	if(pos_zs_shutdown != 0)
  40f52a:	4c17      	ldr	r4, [pc, #92]	; (40f588 <start_zero_servo+0x60>)
  40f52c:	7823      	ldrb	r3, [r4, #0]
{
  40f52e:	ed2d 8b02 	vpush	{d8}
	if(pos_zs_shutdown != 0)
  40f532:	b31b      	cbz	r3, 40f57c <start_zero_servo+0x54>
	{
		float tmp;
		tmp = MOTOR_RATED_TORQUE;
  40f534:	4b15      	ldr	r3, [pc, #84]	; (40f58c <start_zero_servo+0x64>)
  40f536:	4a16      	ldr	r2, [pc, #88]	; (40f590 <start_zero_servo+0x68>)
  40f538:	edd3 6a05 	vldr	s13, [r3, #20]
		tmp /= FIXEDPT_ONE;
  40f53c:	ed9f 7a15 	vldr	s14, [pc, #84]	; 40f594 <start_zero_servo+0x6c>
  40f540:	edd2 7a00 	vldr	s15, [r2]
		tmp = MOTOR_RATED_TORQUE;
  40f544:	eeb8 8ae6 	vcvt.f32.s32	s16, s13
		reg_pi_init(SKP_ZEROSERVO, SKI_ZEROSERVO, &pi_s);
  40f548:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
		tmp /= FIXEDPT_ONE;
  40f54a:	ee67 7a87 	vmul.f32	s15, s15, s14
		reg_pi_init(SKP_ZEROSERVO, SKI_ZEROSERVO, &pi_s);
  40f54e:	6d98      	ldr	r0, [r3, #88]	; 0x58
  40f550:	4a11      	ldr	r2, [pc, #68]	; (40f598 <start_zero_servo+0x70>)
  40f552:	4b12      	ldr	r3, [pc, #72]	; (40f59c <start_zero_servo+0x74>)
		tmp /= FIXEDPT_ONE;
  40f554:	ee28 8a27 	vmul.f32	s16, s16, s15
		reg_pi_init(SKP_ZEROSERVO, SKI_ZEROSERVO, &pi_s);
  40f558:	4798      	blx	r3
		arb_eso_init();
  40f55a:	4b11      	ldr	r3, [pc, #68]	; (40f5a0 <start_zero_servo+0x78>)
  40f55c:	4798      	blx	r3
		spt_init(tmp);
  40f55e:	4b11      	ldr	r3, [pc, #68]	; (40f5a4 <start_zero_servo+0x7c>)
  40f560:	ee18 0a10 	vmov	r0, s16
		load_torque = 0;
  40f564:	4e10      	ldr	r6, [pc, #64]	; (40f5a8 <start_zero_servo+0x80>)
		spt_init(tmp);
  40f566:	4798      	blx	r3
		reg_temp_torque = 0;
		spt_tourque = 0;
		pos_zs_contribution = 0;
  40f568:	4d10      	ldr	r5, [pc, #64]	; (40f5ac <start_zero_servo+0x84>)
		load_torque = 0;
  40f56a:	2300      	movs	r3, #0
		reg_temp_torque = 0;
  40f56c:	4810      	ldr	r0, [pc, #64]	; (40f5b0 <start_zero_servo+0x88>)
		spt_tourque = 0;
  40f56e:	4911      	ldr	r1, [pc, #68]	; (40f5b4 <start_zero_servo+0x8c>)
		distance_regulator_disable();
  40f570:	4a11      	ldr	r2, [pc, #68]	; (40f5b8 <start_zero_servo+0x90>)
		load_torque = 0;
  40f572:	6033      	str	r3, [r6, #0]
		pos_zs_contribution = 0;
  40f574:	602b      	str	r3, [r5, #0]
		reg_temp_torque = 0;
  40f576:	6003      	str	r3, [r0, #0]
		spt_tourque = 0;
  40f578:	600b      	str	r3, [r1, #0]
		distance_regulator_disable();
  40f57a:	4790      	blx	r2
	}
		
	pos_zs_shutdown = 0;
  40f57c:	2300      	movs	r3, #0
}
  40f57e:	ecbd 8b02 	vpop	{d8}
	pos_zs_shutdown = 0;
  40f582:	7023      	strb	r3, [r4, #0]
}
  40f584:	bd70      	pop	{r4, r5, r6, pc}
  40f586:	bf00      	nop
  40f588:	20400360 	.word	0x20400360
  40f58c:	20404ff0 	.word	0x20404ff0
  40f590:	20400358 	.word	0x20400358
  40f594:	38000000 	.word	0x38000000
  40f598:	204063f8 	.word	0x204063f8
  40f59c:	0040a8fd 	.word	0x0040a8fd
  40f5a0:	0040ecf9 	.word	0x0040ecf9
  40f5a4:	0040fa0d 	.word	0x0040fa0d
  40f5a8:	20400980 	.word	0x20400980
  40f5ac:	20400990 	.word	0x20400990
  40f5b0:	20400998 	.word	0x20400998
  40f5b4:	2040099c 	.word	0x2040099c
  40f5b8:	0040f0e1 	.word	0x0040f0e1

0040f5bc <stop_zero_servo>:

void stop_zero_servo(void)
{
	pos_zs_shutdown = 1;
  40f5bc:	4b01      	ldr	r3, [pc, #4]	; (40f5c4 <stop_zero_servo+0x8>)
  40f5be:	2201      	movs	r2, #1
  40f5c0:	701a      	strb	r2, [r3, #0]
  40f5c2:	4770      	bx	lr
  40f5c4:	20400360 	.word	0x20400360

0040f5c8 <speed_PI_init>:
}

void speed_PI_init(void)
{
  40f5c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ( (ersd_isOff()) || (UPS_UPPER_CURRENT_LIMIT == 0) )
  40f5cc:	4b2c      	ldr	r3, [pc, #176]	; (40f680 <speed_PI_init+0xb8>)
  40f5ce:	4798      	blx	r3
  40f5d0:	4c2c      	ldr	r4, [pc, #176]	; (40f684 <speed_PI_init+0xbc>)
  40f5d2:	b930      	cbnz	r0, 40f5e2 <speed_PI_init+0x1a>
  40f5d4:	edd4 7a37 	vldr	s15, [r4, #220]	; 0xdc
  40f5d8:	eef5 7a40 	vcmp.f32	s15, #0.0
  40f5dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f5e0:	d148      	bne.n	40f674 <speed_PI_init+0xac>
	{
		current_limit = DRIVE_UPPER_CURRENT_LIMIT;
  40f5e2:	4b29      	ldr	r3, [pc, #164]	; (40f688 <speed_PI_init+0xc0>)
  40f5e4:	4a29      	ldr	r2, [pc, #164]	; (40f68c <speed_PI_init+0xc4>)
  40f5e6:	601a      	str	r2, [r3, #0]
	} 
	else
	{
		current_limit = UPS_UPPER_CURRENT_LIMIT;
	}
	pos_to_keep = enc_get_lin_theta();
  40f5e8:	4b29      	ldr	r3, [pc, #164]	; (40f690 <speed_PI_init+0xc8>)
		trq_in_weignt = 1;
  40f5ea:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
	pos_to_keep = enc_get_lin_theta();
  40f5ee:	4798      	blx	r3
  40f5f0:	4a28      	ldr	r2, [pc, #160]	; (40f694 <speed_PI_init+0xcc>)
	phase_to_keep = enc_get_phase();
  40f5f2:	4b29      	ldr	r3, [pc, #164]	; (40f698 <speed_PI_init+0xd0>)
	phase_to_keep /= FIXEDPT_ONE;
  40f5f4:	4f29      	ldr	r7, [pc, #164]	; (40f69c <speed_PI_init+0xd4>)
		trq_in_weignt = 1;
  40f5f6:	4d2a      	ldr	r5, [pc, #168]	; (40f6a0 <speed_PI_init+0xd8>)
	pos_to_keep = enc_get_lin_theta();
  40f5f8:	e9c2 0100 	strd	r0, r1, [r2]
	phase_to_keep = enc_get_phase();
  40f5fc:	4798      	blx	r3
	phase_to_keep /= FIXEDPT_ONE;
  40f5fe:	ee07 0a90 	vmov	s15, r0
		trq_memory_weight = 0;
  40f602:	2300      	movs	r3, #0
  40f604:	4827      	ldr	r0, [pc, #156]	; (40f6a4 <speed_PI_init+0xdc>)
	phase_to_keep /= FIXEDPT_ONE;
  40f606:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
	
	calc_torque_filter_constants();
	prev_com_torque = 0;
  40f60a:	4927      	ldr	r1, [pc, #156]	; (40f6a8 <speed_PI_init+0xe0>)
	distance_regulator_disable();
  40f60c:	4a27      	ldr	r2, [pc, #156]	; (40f6ac <speed_PI_init+0xe4>)
		trq_memory_weight = 0;
  40f60e:	6003      	str	r3, [r0, #0]
	prev_com_torque = 0;
  40f610:	600b      	str	r3, [r1, #0]
	phase_to_keep /= FIXEDPT_ONE;
  40f612:	edc7 7a00 	vstr	s15, [r7]
		trq_in_weignt = 1;
  40f616:	602e      	str	r6, [r5, #0]
	distance_regulator_disable();
  40f618:	4790      	blx	r2
	if(menue_drive_data_applied.m_motor_type == 0)
  40f61a:	7823      	ldrb	r3, [r4, #0]
  40f61c:	bb73      	cbnz	r3, 40f67c <speed_PI_init+0xb4>
	{
		//IM motor
		if(menue_drive_data_applied.m_ASR_lows_i != 0) ski_ls_var = (menue_drive_data_applied.m_ASR_lows_p / menue_drive_data_applied.m_ASR_lows_i);
  40f61e:	edd4 6a11 	vldr	s13, [r4, #68]	; 0x44
  40f622:	eef5 6a40 	vcmp.f32	s13, #0.0
  40f626:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f62a:	d11b      	bne.n	40f664 <speed_PI_init+0x9c>
  40f62c:	4b20      	ldr	r3, [pc, #128]	; (40f6b0 <speed_PI_init+0xe8>)
  40f62e:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
  40f632:	ed93 7a00 	vldr	s14, [r3]
		if(menue_drive_data_applied.m_ASR_highs_i != 0) ski_hs_var = (menue_drive_data_applied.m_ASR_highs_p / menue_drive_data_applied.m_ASR_highs_i);
  40f636:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
  40f63a:	eef5 6a40 	vcmp.f32	s13, #0.0
  40f63e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f642:	d006      	beq.n	40f652 <speed_PI_init+0x8a>
  40f644:	edd4 5a12 	vldr	s11, [r4, #72]	; 0x48
  40f648:	4b1a      	ldr	r3, [pc, #104]	; (40f6b4 <speed_PI_init+0xec>)
  40f64a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
  40f64e:	ed83 6a00 	vstr	s12, [r3]
		reg_pi_init(SKP_LS, SKI_LS, &pi_s);
  40f652:	4a19      	ldr	r2, [pc, #100]	; (40f6b8 <speed_PI_init+0xf0>)
  40f654:	ee17 1a10 	vmov	r1, s14
  40f658:	ee17 0a90 	vmov	r0, s15
  40f65c:	4b17      	ldr	r3, [pc, #92]	; (40f6bc <speed_PI_init+0xf4>)
	}
}
  40f65e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		reg_pi_init(SKP_LS, SKI_LS, &pi_s);
  40f662:	4718      	bx	r3
		if(menue_drive_data_applied.m_ASR_lows_i != 0) ski_ls_var = (menue_drive_data_applied.m_ASR_lows_p / menue_drive_data_applied.m_ASR_lows_i);
  40f664:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
  40f668:	4b11      	ldr	r3, [pc, #68]	; (40f6b0 <speed_PI_init+0xe8>)
  40f66a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  40f66e:	ed83 7a00 	vstr	s14, [r3]
  40f672:	e7e0      	b.n	40f636 <speed_PI_init+0x6e>
		current_limit = UPS_UPPER_CURRENT_LIMIT;
  40f674:	4b04      	ldr	r3, [pc, #16]	; (40f688 <speed_PI_init+0xc0>)
  40f676:	edc3 7a00 	vstr	s15, [r3]
  40f67a:	e7b5      	b.n	40f5e8 <speed_PI_init+0x20>
  40f67c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40f680:	00414531 	.word	0x00414531
  40f684:	20404ff0 	.word	0x20404ff0
  40f688:	2040035c 	.word	0x2040035c
  40f68c:	425c0000 	.word	0x425c0000
  40f690:	00413b0d 	.word	0x00413b0d
  40f694:	20400988 	.word	0x20400988
  40f698:	004138c9 	.word	0x004138c9
  40f69c:	20406408 	.word	0x20406408
  40f6a0:	2040036c 	.word	0x2040036c
  40f6a4:	204009a0 	.word	0x204009a0
  40f6a8:	20400994 	.word	0x20400994
  40f6ac:	0040f0e1 	.word	0x0040f0e1
  40f6b0:	20400368 	.word	0x20400368
  40f6b4:	20400364 	.word	0x20400364
  40f6b8:	204063f8 	.word	0x204063f8
  40f6bc:	0040a8fd 	.word	0x0040a8fd

0040f6c0 <speed_PI_changeLSGains>:

void speed_PI_changeLSGains(void)
{
	pos_zs_shutdown = 1;
	if(menue_drive_data_applied.m_ASR_lows_i != 0) ski_ls_var = (menue_drive_data_applied.m_ASR_lows_p / menue_drive_data_applied.m_ASR_lows_i);
  40f6c0:	4b14      	ldr	r3, [pc, #80]	; (40f714 <speed_PI_changeLSGains+0x54>)
	pos_zs_shutdown = 1;
  40f6c2:	2101      	movs	r1, #1
  40f6c4:	4a14      	ldr	r2, [pc, #80]	; (40f718 <speed_PI_changeLSGains+0x58>)
	if(menue_drive_data_applied.m_ASR_lows_i != 0) ski_ls_var = (menue_drive_data_applied.m_ASR_lows_p / menue_drive_data_applied.m_ASR_lows_i);
  40f6c6:	edd3 7a11 	vldr	s15, [r3, #68]	; 0x44
	pos_zs_shutdown = 1;
  40f6ca:	7011      	strb	r1, [r2, #0]
	if(menue_drive_data_applied.m_ASR_lows_i != 0) ski_ls_var = (menue_drive_data_applied.m_ASR_lows_p / menue_drive_data_applied.m_ASR_lows_i);
  40f6cc:	eef5 7a40 	vcmp.f32	s15, #0.0
  40f6d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f6d4:	d006      	beq.n	40f6e4 <speed_PI_changeLSGains+0x24>
  40f6d6:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
  40f6da:	4a10      	ldr	r2, [pc, #64]	; (40f71c <speed_PI_changeLSGains+0x5c>)
  40f6dc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  40f6e0:	ed82 7a00 	vstr	s14, [r2]
	if(menue_drive_data_applied.m_ASR_highs_i != 0) ski_hs_var = (menue_drive_data_applied.m_ASR_highs_p / menue_drive_data_applied.m_ASR_highs_i);
  40f6e4:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
  40f6e8:	eef5 7a40 	vcmp.f32	s15, #0.0
  40f6ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f6f0:	d006      	beq.n	40f700 <speed_PI_changeLSGains+0x40>
  40f6f2:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
  40f6f6:	4a0a      	ldr	r2, [pc, #40]	; (40f720 <speed_PI_changeLSGains+0x60>)
  40f6f8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
  40f6fc:	ed82 7a00 	vstr	s14, [r2]
	//reg_pi_change_gains(SKP_LS, SKI_LS, &pi_s);
	//reg_pi_add_i_memory_val(pos_zs_contribution, &pi_s);
	//load_torque +=  pos_zs_contribution + spt_tourque;
	if(menue_drive_data_applied.m_motor_type == 1) reg_pi_init(SKP_LS, SKI_LS, &pi_s); //PM motor
  40f700:	781a      	ldrb	r2, [r3, #0]
  40f702:	2a01      	cmp	r2, #1
  40f704:	d000      	beq.n	40f708 <speed_PI_changeLSGains+0x48>
  40f706:	4770      	bx	lr
  40f708:	4a04      	ldr	r2, [pc, #16]	; (40f71c <speed_PI_changeLSGains+0x5c>)
  40f70a:	6c18      	ldr	r0, [r3, #64]	; 0x40
  40f70c:	6811      	ldr	r1, [r2, #0]
  40f70e:	4b05      	ldr	r3, [pc, #20]	; (40f724 <speed_PI_changeLSGains+0x64>)
  40f710:	4a05      	ldr	r2, [pc, #20]	; (40f728 <speed_PI_changeLSGains+0x68>)
  40f712:	4718      	bx	r3
  40f714:	20404ff0 	.word	0x20404ff0
  40f718:	20400360 	.word	0x20400360
  40f71c:	20400368 	.word	0x20400368
  40f720:	20400364 	.word	0x20400364
  40f724:	0040a8fd 	.word	0x0040a8fd
  40f728:	204063f8 	.word	0x204063f8

0040f72c <get_pzs>:
	return spt_tourque;
}

float get_pzs(void)
{
	return pos_zs_contribution;
  40f72c:	4b01      	ldr	r3, [pc, #4]	; (40f734 <get_pzs+0x8>)
}
  40f72e:	6818      	ldr	r0, [r3, #0]
  40f730:	4770      	bx	lr
  40f732:	bf00      	nop
  40f734:	20400990 	.word	0x20400990

0040f738 <get_loadtorque>:

float get_loadtorque(void)
{
	return load_torque;
  40f738:	4b01      	ldr	r3, [pc, #4]	; (40f740 <get_loadtorque+0x8>)
  40f73a:	6818      	ldr	r0, [r3, #0]
}
  40f73c:	4770      	bx	lr
  40f73e:	bf00      	nop
  40f740:	20400980 	.word	0x20400980

0040f744 <get_pit>:

float get_pit(void)
{
	return pit;
  40f744:	4b01      	ldr	r3, [pc, #4]	; (40f74c <get_pit+0x8>)
  40f746:	6818      	ldr	r0, [r3, #0]
  40f748:	4770      	bx	lr
  40f74a:	bf00      	nop
  40f74c:	20400984 	.word	0x20400984

0040f750 <spt_reset_zero_servo>:

float spt_phase_to_keep;
int64_t spt_pos_to_keep = 0;
float spt_pos_err = 0;
void spt_reset_zero_servo(void)
{
  40f750:	b508      	push	{r3, lr}
	spt_pos_to_keep = enc_get_lin_theta();
  40f752:	4b09      	ldr	r3, [pc, #36]	; (40f778 <spt_reset_zero_servo+0x28>)
  40f754:	4798      	blx	r3
  40f756:	4a09      	ldr	r2, [pc, #36]	; (40f77c <spt_reset_zero_servo+0x2c>)
	spt_phase_to_keep = enc_get_phase();
  40f758:	4b09      	ldr	r3, [pc, #36]	; (40f780 <spt_reset_zero_servo+0x30>)
	spt_pos_to_keep = enc_get_lin_theta();
  40f75a:	e9c2 0100 	strd	r0, r1, [r2]
	spt_phase_to_keep = enc_get_phase();
  40f75e:	4798      	blx	r3
	spt_phase_to_keep /= FIXEDPT_ONE;
  40f760:	ee07 0a90 	vmov	s15, r0
  40f764:	4907      	ldr	r1, [pc, #28]	; (40f784 <spt_reset_zero_servo+0x34>)
	spt_pos_err = 0;	
  40f766:	2200      	movs	r2, #0
	spt_phase_to_keep /= FIXEDPT_ONE;
  40f768:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
	spt_pos_err = 0;	
  40f76c:	4b06      	ldr	r3, [pc, #24]	; (40f788 <spt_reset_zero_servo+0x38>)
  40f76e:	601a      	str	r2, [r3, #0]
	spt_phase_to_keep /= FIXEDPT_ONE;
  40f770:	edc1 7a00 	vstr	s15, [r1]
	spt_pos_err = 0;	
  40f774:	bd08      	pop	{r3, pc}
  40f776:	bf00      	nop
  40f778:	00413b0d 	.word	0x00413b0d
  40f77c:	204009b0 	.word	0x204009b0
  40f780:	004138c9 	.word	0x004138c9
  40f784:	20406410 	.word	0x20406410
  40f788:	204009a8 	.word	0x204009a8

0040f78c <spt_check_pos_shift_limit>:

int8_t spt_check_pos_shift_limit(void)
{
	float tmp, tmp_spt_pos_err;
	
	tmp_spt_pos_err = spt_pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f78c:	4a1f      	ldr	r2, [pc, #124]	; (40f80c <spt_check_pos_shift_limit+0x80>)
  40f78e:	4b20      	ldr	r3, [pc, #128]	; (40f810 <spt_check_pos_shift_limit+0x84>)
{
  40f790:	e92d 43d0 	stmdb	sp!, {r4, r6, r7, r8, r9, lr}
  40f794:	ed2d 8b02 	vpush	{d8}
	tmp_spt_pos_err = spt_pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f798:	e9d2 8900 	ldrd	r8, r9, [r2]
  40f79c:	4798      	blx	r3
  40f79e:	4606      	mov	r6, r0
	tmp = -enc_get_phase();
  40f7a0:	4b1c      	ldr	r3, [pc, #112]	; (40f814 <spt_check_pos_shift_limit+0x88>)
	tmp_spt_pos_err = spt_pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f7a2:	460f      	mov	r7, r1
	tmp = -enc_get_phase();
  40f7a4:	4798      	blx	r3
  40f7a6:	4243      	negs	r3, r0
	tmp_spt_pos_err = spt_pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f7a8:	ebb8 0006 	subs.w	r0, r8, r6
	tmp /= FIXEDPT_ONE;
	tmp += spt_phase_to_keep;
	tmp_spt_pos_err += tmp;
	
	spt_pos_err += (tmp_spt_pos_err - spt_pos_err) / SPT_FILTER;
  40f7ac:	4c1a      	ldr	r4, [pc, #104]	; (40f818 <spt_check_pos_shift_limit+0x8c>)
	tmp = -enc_get_phase();
  40f7ae:	ee08 3a10 	vmov	s16, r3
	tmp_spt_pos_err = spt_pos_to_keep - enc_get_lin_theta(); //generate error signal
  40f7b2:	4b1a      	ldr	r3, [pc, #104]	; (40f81c <spt_check_pos_shift_limit+0x90>)
  40f7b4:	eb69 0107 	sbc.w	r1, r9, r7
  40f7b8:	4798      	blx	r3
	tmp += spt_phase_to_keep;
  40f7ba:	4b19      	ldr	r3, [pc, #100]	; (40f820 <spt_check_pos_shift_limit+0x94>)
	spt_pos_err += (tmp_spt_pos_err - spt_pos_err) / SPT_FILTER;
  40f7bc:	ed94 7a00 	vldr	s14, [r4]
  40f7c0:	ee05 0a10 	vmov	s10, r0
  40f7c4:	edd3 7a00 	vldr	s15, [r3]
	tmp = -enc_get_phase();
  40f7c8:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
	spt_pos_err += (tmp_spt_pos_err - spt_pos_err) / SPT_FILTER;
  40f7cc:	eddf 5a15 	vldr	s11, [pc, #84]	; 40f824 <spt_check_pos_shift_limit+0x98>
  40f7d0:	ee77 7ac7 	vsub.f32	s15, s15, s14
  40f7d4:	ed9f 6a14 	vldr	s12, [pc, #80]	; 40f828 <spt_check_pos_shift_limit+0x9c>
	if (fixedpt_abs(spt_pos_err) >= SPT__ENC_STEP)
  40f7d8:	eddf 6a14 	vldr	s13, [pc, #80]	; 40f82c <spt_check_pos_shift_limit+0xa0>
	spt_pos_err += (tmp_spt_pos_err - spt_pos_err) / SPT_FILTER;
  40f7dc:	ee75 7a27 	vadd.f32	s15, s10, s15
  40f7e0:	eee8 7a25 	vfma.f32	s15, s16, s11
	} 
	else
	{
		return 0;
	}
}
  40f7e4:	ecbd 8b02 	vpop	{d8}
	spt_pos_err += (tmp_spt_pos_err - spt_pos_err) / SPT_FILTER;
  40f7e8:	eea7 7a86 	vfma.f32	s14, s15, s12
  40f7ec:	eef0 7a47 	vmov.f32	s15, s14
	if (fixedpt_abs(spt_pos_err) >= SPT__ENC_STEP)
  40f7f0:	eeb0 7ac7 	vabs.f32	s14, s14
	spt_pos_err += (tmp_spt_pos_err - spt_pos_err) / SPT_FILTER;
  40f7f4:	edc4 7a00 	vstr	s15, [r4]
	if (fixedpt_abs(spt_pos_err) >= SPT__ENC_STEP)
  40f7f8:	eeb4 7ae6 	vcmpe.f32	s14, s13
  40f7fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
}
  40f800:	bfac      	ite	ge
  40f802:	2001      	movge	r0, #1
  40f804:	2000      	movlt	r0, #0
  40f806:	e8bd 83d0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, pc}
  40f80a:	bf00      	nop
  40f80c:	204009b0 	.word	0x204009b0
  40f810:	00413b0d 	.word	0x00413b0d
  40f814:	004138c9 	.word	0x004138c9
  40f818:	204009a8 	.word	0x204009a8
  40f81c:	00418fe1 	.word	0x00418fe1
  40f820:	20406410 	.word	0x20406410
  40f824:	38000000 	.word	0x38000000
  40f828:	3eaaaaab 	.word	0x3eaaaaab
  40f82c:	3ecccccd 	.word	0x3ecccccd

0040f830 <spt_perform>:

uint8_t spt_stage = 0;
uint16_t spt_wait_counter = 0;
float spt_perform(void)
{
  40f830:	b538      	push	{r3, r4, r5, lr}
	uint8_t pos_shifted = 0;
	if (spt_stage == 0)
  40f832:	4d5d      	ldr	r5, [pc, #372]	; (40f9a8 <spt_perform+0x178>)
  40f834:	782c      	ldrb	r4, [r5, #0]
  40f836:	b174      	cbz	r4, 40f856 <spt_perform+0x26>
			trq_neatural = trq_neg;
			spt_stage++;
		}
		return trq_neg;
	} 
	else if (spt_stage == 1)
  40f838:	2c01      	cmp	r4, #1
  40f83a:	d059      	beq.n	40f8f0 <spt_perform+0xc0>
				spt_stage++;
			}
		}
		return trq_neatural;
	}
	else if (spt_stage == 2)
  40f83c:	2c02      	cmp	r4, #2
  40f83e:	d030      	beq.n	40f8a2 <spt_perform+0x72>
			trq_neatural = trq_neg + trq_pos;
			spt_stage++;
		}
		return trq_pos;
	}
	else if (spt_stage == 3)
  40f840:	2c03      	cmp	r4, #3
  40f842:	d06f      	beq.n	40f924 <spt_perform+0xf4>
		return trq_pos;
	}
	else if (spt_stage >= 4)
	{
		pre_torque_ready = 1;
		return trq_neatural;
  40f844:	4959      	ldr	r1, [pc, #356]	; (40f9ac <spt_perform+0x17c>)
		pre_torque_ready = 1;
  40f846:	2201      	movs	r2, #1
  40f848:	4b59      	ldr	r3, [pc, #356]	; (40f9b0 <spt_perform+0x180>)
		return trq_neatural;
  40f84a:	edd1 7a00 	vldr	s15, [r1]
		pre_torque_ready = 1;
  40f84e:	701a      	strb	r2, [r3, #0]
	}
}
  40f850:	ee17 0a90 	vmov	r0, s15
  40f854:	bd38      	pop	{r3, r4, r5, pc}
		pos_shifted = spt_check_pos_shift_limit();
  40f856:	4b57      	ldr	r3, [pc, #348]	; (40f9b4 <spt_perform+0x184>)
  40f858:	4798      	blx	r3
		if ( (fixedpt_abs(trq_neg) <= rated_torque) && (pos_shifted == 0) )
  40f85a:	4b57      	ldr	r3, [pc, #348]	; (40f9b8 <spt_perform+0x188>)
  40f85c:	4a57      	ldr	r2, [pc, #348]	; (40f9bc <spt_perform+0x18c>)
  40f85e:	edd3 7a00 	vldr	s15, [r3]
  40f862:	ed92 7a00 	vldr	s14, [r2]
  40f866:	eef0 6ae7 	vabs.f32	s13, s15
		spt_wait_counter = 0;
  40f86a:	4a55      	ldr	r2, [pc, #340]	; (40f9c0 <spt_perform+0x190>)
  40f86c:	8014      	strh	r4, [r2, #0]
		if ( (fixedpt_abs(trq_neg) <= rated_torque) && (pos_shifted == 0) )
  40f86e:	eef4 6a47 	vcmp.f32	s13, s14
  40f872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f876:	d80b      	bhi.n	40f890 <spt_perform+0x60>
  40f878:	b950      	cbnz	r0, 40f890 <spt_perform+0x60>
			trq_neg -= fixedpt_abs(rated_torque / SPT_TIME_MS);
  40f87a:	eddf 6a52 	vldr	s13, [pc, #328]	; 40f9c4 <spt_perform+0x194>
  40f87e:	ee27 7a26 	vmul.f32	s14, s14, s13
  40f882:	eeb0 7ac7 	vabs.f32	s14, s14
  40f886:	ee77 7ac7 	vsub.f32	s15, s15, s14
  40f88a:	edc3 7a00 	vstr	s15, [r3]
  40f88e:	e7df      	b.n	40f850 <spt_perform+0x20>
			spt_stage++;
  40f890:	782b      	ldrb	r3, [r5, #0]
}
  40f892:	ee17 0a90 	vmov	r0, s15
			trq_neatural = trq_neg;
  40f896:	4a45      	ldr	r2, [pc, #276]	; (40f9ac <spt_perform+0x17c>)
			spt_stage++;
  40f898:	3301      	adds	r3, #1
			trq_neatural = trq_neg;
  40f89a:	edc2 7a00 	vstr	s15, [r2]
			spt_stage++;
  40f89e:	702b      	strb	r3, [r5, #0]
}
  40f8a0:	bd38      	pop	{r3, r4, r5, pc}
		pos_shifted = spt_check_pos_shift_limit();
  40f8a2:	4b44      	ldr	r3, [pc, #272]	; (40f9b4 <spt_perform+0x184>)
  40f8a4:	4798      	blx	r3
		if ( (fixedpt_abs(trq_pos) <= rated_torque) && (pos_shifted == 0) )
  40f8a6:	4b48      	ldr	r3, [pc, #288]	; (40f9c8 <spt_perform+0x198>)
  40f8a8:	4a44      	ldr	r2, [pc, #272]	; (40f9bc <spt_perform+0x18c>)
  40f8aa:	edd3 7a00 	vldr	s15, [r3]
  40f8ae:	ed92 7a00 	vldr	s14, [r2]
  40f8b2:	eef0 6ae7 	vabs.f32	s13, s15
  40f8b6:	eef4 6a47 	vcmp.f32	s13, s14
  40f8ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f8be:	d80b      	bhi.n	40f8d8 <spt_perform+0xa8>
  40f8c0:	b950      	cbnz	r0, 40f8d8 <spt_perform+0xa8>
			trq_pos += fixedpt_abs(rated_torque / SPT_TIME_MS);
  40f8c2:	eddf 6a40 	vldr	s13, [pc, #256]	; 40f9c4 <spt_perform+0x194>
  40f8c6:	ee27 7a26 	vmul.f32	s14, s14, s13
  40f8ca:	eeb0 7ac7 	vabs.f32	s14, s14
  40f8ce:	ee77 7a87 	vadd.f32	s15, s15, s14
  40f8d2:	edc3 7a00 	vstr	s15, [r3]
  40f8d6:	e7bb      	b.n	40f850 <spt_perform+0x20>
			trq_neatural = trq_neg + trq_pos;
  40f8d8:	4a37      	ldr	r2, [pc, #220]	; (40f9b8 <spt_perform+0x188>)
			spt_stage++;
  40f8da:	782b      	ldrb	r3, [r5, #0]
			trq_neatural = trq_neg + trq_pos;
  40f8dc:	ed92 7a00 	vldr	s14, [r2]
			spt_stage++;
  40f8e0:	3301      	adds	r3, #1
			trq_neatural = trq_neg + trq_pos;
  40f8e2:	4a32      	ldr	r2, [pc, #200]	; (40f9ac <spt_perform+0x17c>)
  40f8e4:	ee37 7a27 	vadd.f32	s14, s14, s15
			spt_stage++;
  40f8e8:	702b      	strb	r3, [r5, #0]
			trq_neatural = trq_neg + trq_pos;
  40f8ea:	ed82 7a00 	vstr	s14, [r2]
		return trq_pos;
  40f8ee:	e7af      	b.n	40f850 <spt_perform+0x20>
		if (trq_neatural < 0)
  40f8f0:	4c2e      	ldr	r4, [pc, #184]	; (40f9ac <spt_perform+0x17c>)
  40f8f2:	edd4 7a00 	vldr	s15, [r4]
  40f8f6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40f8fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f8fe:	d444      	bmi.n	40f98a <spt_perform+0x15a>
			if(++spt_wait_counter > SPT_WAIT_TIME_MS)
  40f900:	4a2f      	ldr	r2, [pc, #188]	; (40f9c0 <spt_perform+0x190>)
  40f902:	8813      	ldrh	r3, [r2, #0]
  40f904:	3301      	adds	r3, #1
  40f906:	b29b      	uxth	r3, r3
  40f908:	2b64      	cmp	r3, #100	; 0x64
  40f90a:	8013      	strh	r3, [r2, #0]
  40f90c:	d9a0      	bls.n	40f850 <spt_perform+0x20>
				trq_pos = trq_neatural;
  40f90e:	4a2e      	ldr	r2, [pc, #184]	; (40f9c8 <spt_perform+0x198>)
				spt_reset_zero_servo();
  40f910:	4b2e      	ldr	r3, [pc, #184]	; (40f9cc <spt_perform+0x19c>)
				trq_pos = trq_neatural;
  40f912:	edc2 7a00 	vstr	s15, [r2]
				spt_reset_zero_servo();
  40f916:	4798      	blx	r3
				spt_stage++;
  40f918:	782b      	ldrb	r3, [r5, #0]
  40f91a:	edd4 7a00 	vldr	s15, [r4]
  40f91e:	3301      	adds	r3, #1
  40f920:	702b      	strb	r3, [r5, #0]
		return trq_neatural;
  40f922:	e795      	b.n	40f850 <spt_perform+0x20>
		if (trq_pos < trq_neatural)
  40f924:	4b28      	ldr	r3, [pc, #160]	; (40f9c8 <spt_perform+0x198>)
  40f926:	4a21      	ldr	r2, [pc, #132]	; (40f9ac <spt_perform+0x17c>)
  40f928:	edd3 7a00 	vldr	s15, [r3]
  40f92c:	ed92 7a00 	vldr	s14, [r2]
  40f930:	eef4 7ac7 	vcmpe.f32	s15, s14
  40f934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f938:	d519      	bpl.n	40f96e <spt_perform+0x13e>
			trq_pos += fixedpt_abs(rated_torque / SPT_REGRESS_TIME_MS);
  40f93a:	4a20      	ldr	r2, [pc, #128]	; (40f9bc <spt_perform+0x18c>)
  40f93c:	ed9f 6a24 	vldr	s12, [pc, #144]	; 40f9d0 <spt_perform+0x1a0>
  40f940:	edd2 6a00 	vldr	s13, [r2]
  40f944:	ee66 6a86 	vmul.f32	s13, s13, s12
  40f948:	eef0 6ae6 	vabs.f32	s13, s13
  40f94c:	ee77 7aa6 	vadd.f32	s15, s15, s13
			if (fixedpt_abs(trq_pos - trq_neatural) < fixedpt_abs(rated_torque / SPT_REGRESS_TIME_MS))
  40f950:	ee37 7ac7 	vsub.f32	s14, s15, s14
			trq_pos -= fixedpt_abs(rated_torque / SPT_REGRESS_TIME_MS);
  40f954:	edc3 7a00 	vstr	s15, [r3]
			if (fixedpt_abs(trq_pos - trq_neatural) < fixedpt_abs(rated_torque / SPT_REGRESS_TIME_MS))
  40f958:	eeb0 7ac7 	vabs.f32	s14, s14
  40f95c:	eef4 6ac7 	vcmpe.f32	s13, s14
  40f960:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f964:	f77f af74 	ble.w	40f850 <spt_perform+0x20>
				spt_stage++;
  40f968:	2304      	movs	r3, #4
  40f96a:	702b      	strb	r3, [r5, #0]
		return trq_pos;
  40f96c:	e770      	b.n	40f850 <spt_perform+0x20>
		else if (trq_pos > trq_neatural)
  40f96e:	f77f af6f 	ble.w	40f850 <spt_perform+0x20>
			trq_pos -= fixedpt_abs(rated_torque / SPT_REGRESS_TIME_MS);
  40f972:	4a12      	ldr	r2, [pc, #72]	; (40f9bc <spt_perform+0x18c>)
  40f974:	ed9f 6a16 	vldr	s12, [pc, #88]	; 40f9d0 <spt_perform+0x1a0>
  40f978:	edd2 6a00 	vldr	s13, [r2]
  40f97c:	ee66 6a86 	vmul.f32	s13, s13, s12
  40f980:	eef0 6ae6 	vabs.f32	s13, s13
  40f984:	ee77 7ae6 	vsub.f32	s15, s15, s13
  40f988:	e7e2      	b.n	40f950 <spt_perform+0x120>
			trq_neatural += fixedpt_abs(rated_torque / SPT_REGRESS_TIME_MS);
  40f98a:	4b0c      	ldr	r3, [pc, #48]	; (40f9bc <spt_perform+0x18c>)
  40f98c:	eddf 6a10 	vldr	s13, [pc, #64]	; 40f9d0 <spt_perform+0x1a0>
  40f990:	ed93 7a00 	vldr	s14, [r3]
  40f994:	ee27 7a26 	vmul.f32	s14, s14, s13
  40f998:	eeb0 7ac7 	vabs.f32	s14, s14
  40f99c:	ee77 7a87 	vadd.f32	s15, s15, s14
  40f9a0:	edc4 7a00 	vstr	s15, [r4]
  40f9a4:	e754      	b.n	40f850 <spt_perform+0x20>
  40f9a6:	bf00      	nop
  40f9a8:	204009b8 	.word	0x204009b8
  40f9ac:	20406414 	.word	0x20406414
  40f9b0:	204009a5 	.word	0x204009a5
  40f9b4:	0040f78d 	.word	0x0040f78d
  40f9b8:	204009bc 	.word	0x204009bc
  40f9bc:	20406418 	.word	0x20406418
  40f9c0:	204009ba 	.word	0x204009ba
  40f9c4:	3b3b3ee7 	.word	0x3b3b3ee7
  40f9c8:	204009c0 	.word	0x204009c0
  40f9cc:	0040f751 	.word	0x0040f751
  40f9d0:	3c4ccccd 	.word	0x3c4ccccd

0040f9d4 <spt_permission_brake_open>:

uint8_t spt_permission_brake_open(void)
{
	if(SPT_ACTIVE == 0) return 1;
	if (!MOTOR_PM_CVC) return 1;
  40f9d4:	4b07      	ldr	r3, [pc, #28]	; (40f9f4 <spt_permission_brake_open+0x20>)
  40f9d6:	f893 00c5 	ldrb.w	r0, [r3, #197]	; 0xc5
  40f9da:	2801      	cmp	r0, #1
  40f9dc:	d001      	beq.n	40f9e2 <spt_permission_brake_open+0xe>
  40f9de:	2001      	movs	r0, #1
	return (brake_allow_to_open & pre_torque_ready);
}
  40f9e0:	4770      	bx	lr
	if (!MOTOR_PM_CVC) return 1;
  40f9e2:	781b      	ldrb	r3, [r3, #0]
  40f9e4:	2b01      	cmp	r3, #1
  40f9e6:	d1fb      	bne.n	40f9e0 <spt_permission_brake_open+0xc>
	return (brake_allow_to_open & pre_torque_ready);
  40f9e8:	4a03      	ldr	r2, [pc, #12]	; (40f9f8 <spt_permission_brake_open+0x24>)
  40f9ea:	4b04      	ldr	r3, [pc, #16]	; (40f9fc <spt_permission_brake_open+0x28>)
  40f9ec:	7810      	ldrb	r0, [r2, #0]
  40f9ee:	781b      	ldrb	r3, [r3, #0]
  40f9f0:	4018      	ands	r0, r3
  40f9f2:	4770      	bx	lr
  40f9f4:	20404ff0 	.word	0x20404ff0
  40f9f8:	204009a4 	.word	0x204009a4
  40f9fc:	204009a5 	.word	0x204009a5

0040fa00 <spt_vfd_set_ready_to_open_brake>:

void spt_vfd_set_ready_to_open_brake(void)
{
	brake_allow_to_open = 1;
  40fa00:	4b01      	ldr	r3, [pc, #4]	; (40fa08 <spt_vfd_set_ready_to_open_brake+0x8>)
  40fa02:	2201      	movs	r2, #1
  40fa04:	701a      	strb	r2, [r3, #0]
  40fa06:	4770      	bx	lr
  40fa08:	204009a4 	.word	0x204009a4

0040fa0c <spt_init>:
}

void spt_init(float r_torque)
{
  40fa0c:	b4f0      	push	{r4, r5, r6, r7}
	brake_allow_to_open = 0;
  40fa0e:	2200      	movs	r2, #0
  40fa10:	4c08      	ldr	r4, [pc, #32]	; (40fa34 <spt_init+0x28>)
	pre_torque_ready = 0;
  40fa12:	4909      	ldr	r1, [pc, #36]	; (40fa38 <spt_init+0x2c>)
	rated_torque = r_torque;
	
	trq_neg = 0;
  40fa14:	2300      	movs	r3, #0
	brake_allow_to_open = 0;
  40fa16:	7022      	strb	r2, [r4, #0]
	pre_torque_ready = 0;
  40fa18:	700a      	strb	r2, [r1, #0]
	trq_pos = 0; 
	trq_neatural = 0;
	
	spt_stage = 0;
  40fa1a:	4f08      	ldr	r7, [pc, #32]	; (40fa3c <spt_init+0x30>)
	rated_torque = r_torque;
  40fa1c:	4e08      	ldr	r6, [pc, #32]	; (40fa40 <spt_init+0x34>)
	trq_neg = 0;
  40fa1e:	4d09      	ldr	r5, [pc, #36]	; (40fa44 <spt_init+0x38>)
	trq_pos = 0; 
  40fa20:	4c09      	ldr	r4, [pc, #36]	; (40fa48 <spt_init+0x3c>)
	trq_neatural = 0;
  40fa22:	490a      	ldr	r1, [pc, #40]	; (40fa4c <spt_init+0x40>)
	spt_stage = 0;
  40fa24:	703a      	strb	r2, [r7, #0]
	rated_torque = r_torque;
  40fa26:	6030      	str	r0, [r6, #0]
	trq_neg = 0;
  40fa28:	602b      	str	r3, [r5, #0]
	trq_pos = 0; 
  40fa2a:	6023      	str	r3, [r4, #0]
	trq_neatural = 0;
  40fa2c:	600b      	str	r3, [r1, #0]
	
	spt_reset_zero_servo();
  40fa2e:	4a08      	ldr	r2, [pc, #32]	; (40fa50 <spt_init+0x44>)
  40fa30:	bcf0      	pop	{r4, r5, r6, r7}
	spt_reset_zero_servo();
  40fa32:	4710      	bx	r2
  40fa34:	204009a4 	.word	0x204009a4
  40fa38:	204009a5 	.word	0x204009a5
  40fa3c:	204009b8 	.word	0x204009b8
  40fa40:	20406418 	.word	0x20406418
  40fa44:	204009bc 	.word	0x204009bc
  40fa48:	204009c0 	.word	0x204009c0
  40fa4c:	20406414 	.word	0x20406414
  40fa50:	0040f751 	.word	0x0040f751

0040fa54 <update_measured_data_vector1>:
float pa[2][2], pb[2][2]; //covariance matricies
float phi_a[2], phi_b[2]; //measured data vectors
float g_a[2], g_b[2]; //gains vecotrs

void update_measured_data_vector1(float v, float i)
{
  40fa54:	b410      	push	{r4}
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40fa56:	4a15      	ldr	r2, [pc, #84]	; (40faac <update_measured_data_vector1+0x58>)
{
  40fa58:	ee06 1a90 	vmov	s13, r1
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  40fa5c:	4c14      	ldr	r4, [pc, #80]	; (40fab0 <update_measured_data_vector1+0x5c>)
{
  40fa5e:	ee05 0a90 	vmov	s11, r0
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40fa62:	edd2 7a00 	vldr	s15, [r2]
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  40fa66:	ed94 7a00 	vldr	s14, [r4]
  40fa6a:	4b12      	ldr	r3, [pc, #72]	; (40fab4 <update_measured_data_vector1+0x60>)
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40fa6c:	ee76 7aa7 	vadd.f32	s15, s13, s15
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  40fa70:	ee35 7a87 	vadd.f32	s14, s11, s14
  40fa74:	4910      	ldr	r1, [pc, #64]	; (40fab8 <update_measured_data_vector1+0x64>)
  40fa76:	ed93 5a00 	vldr	s10, [r3]
  40fa7a:	4b10      	ldr	r3, [pc, #64]	; (40fabc <update_measured_data_vector1+0x68>)
  40fa7c:	ee27 7a05 	vmul.f32	s14, s14, s10
  40fa80:	ed91 6a00 	vldr	s12, [r1]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40fa84:	ee67 7a85 	vmul.f32	s15, s15, s10
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  40fa88:	edd3 4a00 	vldr	s9, [r3]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40fa8c:	ed93 5a01 	vldr	s10, [r3, #4]
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  40fa90:	eea4 7a86 	vfma.f32	s14, s9, s12
	
	prev_i = i;
  40fa94:	edc2 6a00 	vstr	s13, [r2]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40fa98:	eee6 7a05 	vfma.f32	s15, s12, s10
	prev_v = v;
  40fa9c:	6020      	str	r0, [r4, #0]
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  40fa9e:	ed83 7a00 	vstr	s14, [r3]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  40faa2:	edc3 7a01 	vstr	s15, [r3, #4]
}
  40faa6:	f85d 4b04 	ldr.w	r4, [sp], #4
  40faaa:	4770      	bx	lr
  40faac:	20406468 	.word	0x20406468
  40fab0:	20406460 	.word	0x20406460
  40fab4:	2040647c 	.word	0x2040647c
  40fab8:	20406478 	.word	0x20406478
  40fabc:	20406488 	.word	0x20406488

0040fac0 <update_measured_data_vector2>:

void update_measured_data_vector2(float v, float i)
{
  40fac0:	ee05 0a10 	vmov	s10, r0
	phi_a[0] = (c10 * phi_a[0]) + (c11 * i) - (c11 * prev_i);
  40fac4:	4b15      	ldr	r3, [pc, #84]	; (40fb1c <update_measured_data_vector2+0x5c>)
  40fac6:	4816      	ldr	r0, [pc, #88]	; (40fb20 <update_measured_data_vector2+0x60>)
{
  40fac8:	ee06 1a10 	vmov	s12, r1
	phi_a[0] = (c10 * phi_a[0]) + (c11 * i) - (c11 * prev_i);
  40facc:	edd3 5a00 	vldr	s11, [r3]
  40fad0:	ed90 7a00 	vldr	s14, [r0]
  40fad4:	4b13      	ldr	r3, [pc, #76]	; (40fb24 <update_measured_data_vector2+0x64>)
  40fad6:	4914      	ldr	r1, [pc, #80]	; (40fb28 <update_measured_data_vector2+0x68>)
  40fad8:	ee27 7a65 	vnmul.f32	s14, s14, s11
	phi_a[1] = (c10 * phi_a[1]) + (c12 * v) + (c12 * prev_v);
  40fadc:	4a13      	ldr	r2, [pc, #76]	; (40fb2c <update_measured_data_vector2+0x6c>)
	phi_a[0] = (c10 * phi_a[0]) + (c11 * i) - (c11 * prev_i);
  40fade:	edd1 6a00 	vldr	s13, [r1]
  40fae2:	edd3 4a00 	vldr	s9, [r3]
	phi_a[1] = (c10 * phi_a[1]) + (c12 * v) + (c12 * prev_v);
  40fae6:	edd2 7a00 	vldr	s15, [r2]
  40faea:	4911      	ldr	r1, [pc, #68]	; (40fb30 <update_measured_data_vector2+0x70>)
	phi_a[0] = (c10 * phi_a[0]) + (c11 * i) - (c11 * prev_i);
  40faec:	eea4 7aa6 	vfma.f32	s14, s9, s13
	phi_a[1] = (c10 * phi_a[1]) + (c12 * v) + (c12 * prev_v);
  40faf0:	ee75 7a27 	vadd.f32	s15, s10, s15
  40faf4:	edd3 4a01 	vldr	s9, [r3, #4]
  40faf8:	ed91 4a00 	vldr	s8, [r1]
	
	prev_i = i;
  40fafc:	ed80 6a00 	vstr	s12, [r0]
	phi_a[1] = (c10 * phi_a[1]) + (c12 * v) + (c12 * prev_v);
  40fb00:	ee67 7a84 	vmul.f32	s15, s15, s8
	prev_v = v;
  40fb04:	ed82 5a00 	vstr	s10, [r2]
	phi_a[0] = (c10 * phi_a[0]) + (c11 * i) - (c11 * prev_i);
  40fb08:	eea5 7a86 	vfma.f32	s14, s11, s12
	phi_a[1] = (c10 * phi_a[1]) + (c12 * v) + (c12 * prev_v);
  40fb0c:	eee6 7aa4 	vfma.f32	s15, s13, s9
	phi_a[0] = (c10 * phi_a[0]) + (c11 * i) - (c11 * prev_i);
  40fb10:	ed83 7a00 	vstr	s14, [r3]
	phi_a[1] = (c10 * phi_a[1]) + (c12 * v) + (c12 * prev_v);
  40fb14:	edc3 7a01 	vstr	s15, [r3, #4]
  40fb18:	4770      	bx	lr
  40fb1a:	bf00      	nop
  40fb1c:	20406464 	.word	0x20406464
  40fb20:	20406468 	.word	0x20406468
  40fb24:	20406488 	.word	0x20406488
  40fb28:	20406458 	.word	0x20406458
  40fb2c:	20406460 	.word	0x20406460
  40fb30:	20406424 	.word	0x20406424

0040fb34 <update_gains_vector>:
void update_gains_vector(void)
{
	float tmp[2], tmp1;
	
	//update gain1
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  40fb34:	4b13      	ldr	r3, [pc, #76]	; (40fb84 <update_gains_vector+0x50>)
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
	
	tmp1 = ((phi_a[0] * tmp[0]) + (phi_a[1] * tmp[1]));
	tmp1 += (1.0f);
  40fb36:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  40fb3a:	4a13      	ldr	r2, [pc, #76]	; (40fb88 <update_gains_vector+0x54>)
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  40fb3c:	ed93 7a03 	vldr	s14, [r3, #12]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  40fb40:	edd2 7a01 	vldr	s15, [r2, #4]
  40fb44:	ed92 6a00 	vldr	s12, [r2]
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  40fb48:	ee27 7a87 	vmul.f32	s14, s15, s14
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  40fb4c:	edd3 6a01 	vldr	s13, [r3, #4]
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  40fb50:	edd3 4a02 	vldr	s9, [r3, #8]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  40fb54:	ee67 6aa6 	vmul.f32	s13, s15, s13
  40fb58:	ed93 5a00 	vldr	s10, [r3]
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  40fb5c:	eea6 7a24 	vfma.f32	s14, s12, s9
	
	g_a[0] = tmp[0] / tmp1;
  40fb60:	4b0a      	ldr	r3, [pc, #40]	; (40fb8c <update_gains_vector+0x58>)
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  40fb62:	eee6 6a05 	vfma.f32	s13, s12, s10
	tmp1 = ((phi_a[0] * tmp[0]) + (phi_a[1] * tmp[1]));
  40fb66:	ee67 7a87 	vmul.f32	s15, s15, s14
  40fb6a:	eee6 7a26 	vfma.f32	s15, s12, s13
	tmp1 += (1.0f);
  40fb6e:	ee77 7aa5 	vadd.f32	s15, s15, s11
	g_a[0] = tmp[0] / tmp1;
  40fb72:	ee86 6aa7 	vdiv.f32	s12, s13, s15
	g_a[1] = tmp[1] / tmp1;
  40fb76:	eec7 6a27 	vdiv.f32	s13, s14, s15
	g_a[0] = tmp[0] / tmp1;
  40fb7a:	ed83 6a00 	vstr	s12, [r3]
	g_a[1] = tmp[1] / tmp1;
  40fb7e:	edc3 6a01 	vstr	s13, [r3, #4]
  40fb82:	4770      	bx	lr
  40fb84:	2040649c 	.word	0x2040649c
  40fb88:	20406488 	.word	0x20406488
  40fb8c:	20406490 	.word	0x20406490

0040fb90 <update_covariance_matrix>:
void update_covariance_matrix(void)
{
	float tmp[2];
	
	//update cov1
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  40fb90:	4b17      	ldr	r3, [pc, #92]	; (40fbf0 <update_covariance_matrix+0x60>)
  40fb92:	4a18      	ldr	r2, [pc, #96]	; (40fbf4 <update_covariance_matrix+0x64>)
  40fb94:	edd3 5a02 	vldr	s11, [r3, #8]
  40fb98:	edd2 7a01 	vldr	s15, [r2, #4]
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  40fb9c:	edd3 6a03 	vldr	s13, [r3, #12]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  40fba0:	ee27 7aa5 	vmul.f32	s14, s15, s11
  40fba4:	edd2 4a00 	vldr	s9, [r2]
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  40fba8:	ee67 7aa6 	vmul.f32	s15, s15, s13
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  40fbac:	ed93 5a00 	vldr	s10, [r3]
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  40fbb0:	ed93 6a01 	vldr	s12, [r3, #4]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  40fbb4:	eea4 7a85 	vfma.f32	s14, s9, s10
	
	pa[0][0] -= tmp[0] * g_a[0];
  40fbb8:	4a0f      	ldr	r2, [pc, #60]	; (40fbf8 <update_covariance_matrix+0x68>)
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  40fbba:	eee4 7a86 	vfma.f32	s15, s9, s12
	pa[0][0] -= tmp[0] * g_a[0];
  40fbbe:	ed92 4a00 	vldr	s8, [r2]
	pa[0][1] -= tmp[1] * g_a[0];
	pa[1][0] -= tmp[0] * g_a[1];
  40fbc2:	edd2 4a01 	vldr	s9, [r2, #4]
	pa[0][0] -= tmp[0] * g_a[0];
  40fbc6:	eeb1 7a47 	vneg.f32	s14, s14
	pa[0][1] -= tmp[1] * g_a[0];
  40fbca:	eef1 7a67 	vneg.f32	s15, s15
	pa[0][0] -= tmp[0] * g_a[0];
  40fbce:	eea7 5a04 	vfma.f32	s10, s14, s8
	pa[1][0] -= tmp[0] * g_a[1];
  40fbd2:	eee7 5a24 	vfma.f32	s11, s14, s9
	pa[0][1] -= tmp[1] * g_a[0];
  40fbd6:	eea7 6a84 	vfma.f32	s12, s15, s8
	pa[1][1] -= tmp[1] * g_a[1];
  40fbda:	eee7 6aa4 	vfma.f32	s13, s15, s9
	pa[0][0] -= tmp[0] * g_a[0];
  40fbde:	ed83 5a00 	vstr	s10, [r3]
	pa[1][0] -= tmp[0] * g_a[1];
  40fbe2:	edc3 5a02 	vstr	s11, [r3, #8]
	pa[0][1] -= tmp[1] * g_a[0];
  40fbe6:	ed83 6a01 	vstr	s12, [r3, #4]
	pa[1][1] -= tmp[1] * g_a[1];
  40fbea:	edc3 6a03 	vstr	s13, [r3, #12]
  40fbee:	4770      	bx	lr
  40fbf0:	2040649c 	.word	0x2040649c
  40fbf4:	20406488 	.word	0x20406488
  40fbf8:	20406490 	.word	0x20406490

0040fbfc <update_parameters_vector>:
}

void update_parameters_vector(float output)
{
	float oerr;
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  40fbfc:	4b11      	ldr	r3, [pc, #68]	; (40fc44 <update_parameters_vector+0x48>)
  40fbfe:	4a12      	ldr	r2, [pc, #72]	; (40fc48 <update_parameters_vector+0x4c>)
  40fc00:	ed93 7a01 	vldr	s14, [r3, #4]
  40fc04:	edd2 7a01 	vldr	s15, [r2, #4]
  40fc08:	edd3 6a00 	vldr	s13, [r3]
  40fc0c:	ee67 7a27 	vmul.f32	s15, s14, s15
  40fc10:	ed92 6a00 	vldr	s12, [r2]
	//est_out = output;
	//oerr = output - oerr;
	est_out = oerr;
	oerr = output - oerr;

	param_a[0] += g_a[0] * oerr;
  40fc14:	4a0d      	ldr	r2, [pc, #52]	; (40fc4c <update_parameters_vector+0x50>)
	est_out = oerr;
  40fc16:	490e      	ldr	r1, [pc, #56]	; (40fc50 <update_parameters_vector+0x54>)
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  40fc18:	eee6 7a26 	vfma.f32	s15, s12, s13
	oerr = output - oerr;
  40fc1c:	ee06 0a10 	vmov	s12, r0
	param_a[0] += g_a[0] * oerr;
  40fc20:	ed92 5a00 	vldr	s10, [r2]
	param_a[1] += g_a[1] * oerr;
  40fc24:	edd2 5a01 	vldr	s11, [r2, #4]
	oerr = output - oerr;
  40fc28:	ee36 6a67 	vsub.f32	s12, s12, s15
	est_out = oerr;
  40fc2c:	edc1 7a00 	vstr	s15, [r1]
	param_a[0] += g_a[0] * oerr;
  40fc30:	eee6 6a05 	vfma.f32	s13, s12, s10
	param_a[1] += g_a[1] * oerr;
  40fc34:	eea6 7a25 	vfma.f32	s14, s12, s11
	param_a[0] += g_a[0] * oerr;
  40fc38:	edc3 6a00 	vstr	s13, [r3]
	param_a[1] += g_a[1] * oerr;
  40fc3c:	ed83 7a01 	vstr	s14, [r3, #4]
  40fc40:	4770      	bx	lr
  40fc42:	bf00      	nop
  40fc44:	20406480 	.word	0x20406480
  40fc48:	20406488 	.word	0x20406488
  40fc4c:	20406490 	.word	0x20406490
  40fc50:	2040641c 	.word	0x2040641c
  40fc54:	00000000 	.word	0x00000000

0040fc58 <save_estimated_motor_parameters>:
}

uint8_t im_tune1_comm = 0;
float lm_dev, rr_dev;
void save_estimated_motor_parameters(void)
{
  40fc58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	menue_drive_data_setup.m_motor_stator_resistance = rs_h  * (sqrt3 / 1.5 );
  40fc5c:	f8df a168 	ldr.w	sl, [pc, #360]	; 40fdc8 <save_estimated_motor_parameters+0x170>
  40fc60:	4f4f      	ldr	r7, [pc, #316]	; (40fda0 <save_estimated_motor_parameters+0x148>)
  40fc62:	f8da 0000 	ldr.w	r0, [sl]
  40fc66:	4e4f      	ldr	r6, [pc, #316]	; (40fda4 <save_estimated_motor_parameters+0x14c>)
	menue_drive_data_setup.m_motor_leakage_inductance = ls_h * 1000 * (sqrt3 / 1.5 );
  40fc68:	f8df 8160 	ldr.w	r8, [pc, #352]	; 40fdcc <save_estimated_motor_parameters+0x174>
	menue_drive_data_setup.m_motor_stator_resistance = rs_h  * (sqrt3 / 1.5 );
  40fc6c:	4d4e      	ldr	r5, [pc, #312]	; (40fda8 <save_estimated_motor_parameters+0x150>)
  40fc6e:	4c4f      	ldr	r4, [pc, #316]	; (40fdac <save_estimated_motor_parameters+0x154>)
	menue_drive_data_setup.m_motor_rotor_resistance = rr_h * (sqrt3 / 1.5 );
	menue_drive_data_setup.m_motor_magnetizing_inductance = lm_h * 1000 * (sqrt3 / 1.5 );	
  40fc70:	f8df 915c 	ldr.w	r9, [pc, #348]	; 40fdd0 <save_estimated_motor_parameters+0x178>
{
  40fc74:	ed2d 8b02 	vpush	{d8}
  40fc78:	b083      	sub	sp, #12
	menue_drive_data_setup.m_motor_leakage_inductance = ls_h * 1000 * (sqrt3 / 1.5 );
  40fc7a:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 40fdb0 <save_estimated_motor_parameters+0x158>
	menue_drive_data_setup.m_motor_stator_resistance = rs_h  * (sqrt3 / 1.5 );
  40fc7e:	47b8      	blx	r7
  40fc80:	a341      	add	r3, pc, #260	; (adr r3, 40fd88 <save_estimated_motor_parameters+0x130>)
  40fc82:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fc86:	47b0      	blx	r6
  40fc88:	47a8      	blx	r5
	menue_drive_data_setup.m_motor_leakage_inductance = ls_h * 1000 * (sqrt3 / 1.5 );
  40fc8a:	edd8 7a00 	vldr	s15, [r8]
	menue_drive_data_setup.m_motor_stator_resistance = rs_h  * (sqrt3 / 1.5 );
  40fc8e:	61e0      	str	r0, [r4, #28]
	menue_drive_data_setup.m_motor_leakage_inductance = ls_h * 1000 * (sqrt3 / 1.5 );
  40fc90:	ee67 7a88 	vmul.f32	s15, s15, s16
  40fc94:	ee17 0a90 	vmov	r0, s15
  40fc98:	47b8      	blx	r7
  40fc9a:	a33b      	add	r3, pc, #236	; (adr r3, 40fd88 <save_estimated_motor_parameters+0x130>)
  40fc9c:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fca0:	47b0      	blx	r6
  40fca2:	47a8      	blx	r5
	menue_drive_data_setup.m_motor_rotor_resistance = rr_h * (sqrt3 / 1.5 );
  40fca4:	4b43      	ldr	r3, [pc, #268]	; (40fdb4 <save_estimated_motor_parameters+0x15c>)
	menue_drive_data_setup.m_motor_leakage_inductance = ls_h * 1000 * (sqrt3 / 1.5 );
  40fca6:	4683      	mov	fp, r0
	menue_drive_data_setup.m_motor_rotor_resistance = rr_h * (sqrt3 / 1.5 );
  40fca8:	6818      	ldr	r0, [r3, #0]
	menue_drive_data_setup.m_motor_leakage_inductance = ls_h * 1000 * (sqrt3 / 1.5 );
  40fcaa:	f8c4 b024 	str.w	fp, [r4, #36]	; 0x24
	menue_drive_data_setup.m_motor_rotor_resistance = rr_h * (sqrt3 / 1.5 );
  40fcae:	47b8      	blx	r7
  40fcb0:	a335      	add	r3, pc, #212	; (adr r3, 40fd88 <save_estimated_motor_parameters+0x130>)
  40fcb2:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fcb6:	47b0      	blx	r6
  40fcb8:	47a8      	blx	r5
	menue_drive_data_setup.m_motor_magnetizing_inductance = lm_h * 1000 * (sqrt3 / 1.5 );	
  40fcba:	edd9 7a00 	vldr	s15, [r9]
	menue_drive_data_setup.m_motor_rotor_resistance = rr_h * (sqrt3 / 1.5 );
  40fcbe:	6220      	str	r0, [r4, #32]
	menue_drive_data_setup.m_motor_magnetizing_inductance = lm_h * 1000 * (sqrt3 / 1.5 );	
  40fcc0:	ee67 7a88 	vmul.f32	s15, s15, s16
  40fcc4:	ee17 0a90 	vmov	r0, s15
  40fcc8:	47b8      	blx	r7
  40fcca:	a32f      	add	r3, pc, #188	; (adr r3, 40fd88 <save_estimated_motor_parameters+0x130>)
  40fccc:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fcd0:	47b0      	blx	r6
  40fcd2:	47a8      	blx	r5
	
 	if (im_tune1_comm > 1) im_tune1_calc_PI();
  40fcd4:	4b38      	ldr	r3, [pc, #224]	; (40fdb8 <save_estimated_motor_parameters+0x160>)
	menue_drive_data_setup.m_motor_magnetizing_inductance = lm_h * 1000 * (sqrt3 / 1.5 );	
  40fcd6:	6320      	str	r0, [r4, #48]	; 0x30
 	if (im_tune1_comm > 1) im_tune1_calc_PI();
  40fcd8:	781b      	ldrb	r3, [r3, #0]
  40fcda:	2b01      	cmp	r3, #1
  40fcdc:	9301      	str	r3, [sp, #4]
  40fcde:	d949      	bls.n	40fd74 <save_estimated_motor_parameters+0x11c>
	menue_drive_data_setup.m_ACRD_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * rs_h * 10000;
  40fce0:	f8da 0000 	ldr.w	r0, [sl]
  40fce4:	47b8      	blx	r7
  40fce6:	a32a      	add	r3, pc, #168	; (adr r3, 40fd90 <save_estimated_motor_parameters+0x138>)
  40fce8:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fcec:	47b0      	blx	r6
  40fcee:	47a8      	blx	r5
  40fcf0:	6760      	str	r0, [r4, #116]	; 0x74
	menue_drive_data_setup.m_ACRD_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_leakage_inductance * 1000;
  40fcf2:	4658      	mov	r0, fp
  40fcf4:	47b8      	blx	r7
  40fcf6:	a328      	add	r3, pc, #160	; (adr r3, 40fd98 <save_estimated_motor_parameters+0x140>)
  40fcf8:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fcfc:	47b0      	blx	r6
  40fcfe:	47a8      	blx	r5
	menue_drive_data_setup.m_ACRQ_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * (rs_h + rr_h) * 10000;
  40fd00:	4a2c      	ldr	r2, [pc, #176]	; (40fdb4 <save_estimated_motor_parameters+0x15c>)
  40fd02:	ed9a 7a00 	vldr	s14, [sl]
	menue_drive_data_setup.m_ACRD_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_leakage_inductance * 1000;
  40fd06:	4683      	mov	fp, r0
	menue_drive_data_setup.m_ACRQ_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * (rs_h + rr_h) * 10000;
  40fd08:	edd2 7a00 	vldr	s15, [r2]
	menue_drive_data_setup.m_ACRD_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_leakage_inductance * 1000;
  40fd0c:	6720      	str	r0, [r4, #112]	; 0x70
	menue_drive_data_setup.m_ACRQ_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * (rs_h + rr_h) * 10000;
  40fd0e:	ee77 7a27 	vadd.f32	s15, s14, s15
  40fd12:	ee17 0a90 	vmov	r0, s15
  40fd16:	47b8      	blx	r7
  40fd18:	a31d      	add	r3, pc, #116	; (adr r3, 40fd90 <save_estimated_motor_parameters+0x138>)
  40fd1a:	e9d3 2300 	ldrd	r2, r3, [r3]
  40fd1e:	47b0      	blx	r6
  40fd20:	47a8      	blx	r5
 	if (im_tune1_comm > 2) im_tune1_calc_i0();
  40fd22:	9b01      	ldr	r3, [sp, #4]
	menue_drive_data_setup.m_ACRQ_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_leakage_inductance * 1000;
  40fd24:	f8c4 b078 	str.w	fp, [r4, #120]	; 0x78
 	if (im_tune1_comm > 2) im_tune1_calc_i0();
  40fd28:	2b02      	cmp	r3, #2
	menue_drive_data_setup.m_ACRQ_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * (rs_h + rr_h) * 10000;
  40fd2a:	67e0      	str	r0, [r4, #124]	; 0x7c
 	if (im_tune1_comm > 2) im_tune1_calc_i0();
  40fd2c:	d022      	beq.n	40fd74 <save_estimated_motor_parameters+0x11c>
	float iasqr, rated_omega = menue_drive_data_applied.m_motor_rated_speed;
  40fd2e:	4a23      	ldr	r2, [pc, #140]	; (40fdbc <save_estimated_motor_parameters+0x164>)
	rated_omega /= (FIXEDPT_ONE * 60 / menue_drive_data_applied.m_motor_pole_pair_count);
  40fd30:	f44f 13f0 	mov.w	r3, #1966080	; 0x1e0000
	tmp /= lm_h * rated_omega;
  40fd34:	f8d9 1000 	ldr.w	r1, [r9]
	rated_omega /= (FIXEDPT_ONE * 60 / menue_drive_data_applied.m_motor_pole_pair_count);
  40fd38:	f892 103c 	ldrb.w	r1, [r2, #60]	; 0x3c
	float iasqr, rated_omega = menue_drive_data_applied.m_motor_rated_speed;
  40fd3c:	ed92 6a03 	vldr	s12, [r2, #12]
		tmp = MAX_BEMF / (lm_h * rated_omega);
  40fd40:	eddf 6a1f 	vldr	s13, [pc, #124]	; 40fdc0 <save_estimated_motor_parameters+0x168>
	bemf = lm_h * tmp * rated_omega;
  40fd44:	f8d9 2000 	ldr.w	r2, [r9]
	float iasqr, rated_omega = menue_drive_data_applied.m_motor_rated_speed;
  40fd48:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
		tmp = MAX_BEMF / (lm_h * rated_omega);
  40fd4c:	edd9 7a00 	vldr	s15, [r9]
  40fd50:	eddf 5a1c 	vldr	s11, [pc, #112]	; 40fdc4 <save_estimated_motor_parameters+0x16c>
  40fd54:	ee67 6aa6 	vmul.f32	s13, s15, s13
	rated_omega /= (FIXEDPT_ONE * 60 / menue_drive_data_applied.m_motor_pole_pair_count);
  40fd58:	fb93 f3f1 	sdiv	r3, r3, r1
  40fd5c:	ee07 3a90 	vmov	s15, r3
  40fd60:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40fd64:	ee86 7a27 	vdiv.f32	s14, s12, s15
		tmp = MAX_BEMF / (lm_h * rated_omega);
  40fd68:	ee67 7a26 	vmul.f32	s15, s14, s13
  40fd6c:	ee85 7aa7 	vdiv.f32	s14, s11, s15
	menue_drive_data_setup.m_motor_noload_current = tmp;
  40fd70:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
	
	//lm_dev = (lm - lm_h)*100 / lm;
	//rr_dev = (rr - rr_h)*100 / rr;
	ls_h *= 1;
  40fd74:	f8d8 3000 	ldr.w	r3, [r8]
  40fd78:	f8c8 3000 	str.w	r3, [r8]
}
  40fd7c:	b003      	add	sp, #12
  40fd7e:	ecbd 8b02 	vpop	{d8}
  40fd82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40fd86:	bf00      	nop
  40fd88:	4590331c 	.word	0x4590331c
  40fd8c:	3ff279a7 	.word	0x3ff279a7
  40fd90:	90000000 	.word	0x90000000
  40fd94:	404197c9 	.word	0x404197c9
  40fd98:	4ccccccc 	.word	0x4ccccccc
  40fd9c:	400c260f 	.word	0x400c260f
  40fda0:	00418749 	.word	0x00418749
  40fda4:	004187f1 	.word	0x004187f1
  40fda8:	00418da1 	.word	0x00418da1
  40fdac:	204050e8 	.word	0x204050e8
  40fdb0:	447a0000 	.word	0x447a0000
  40fdb4:	20406428 	.word	0x20406428
  40fdb8:	204009cc 	.word	0x204009cc
  40fdbc:	20404ff0 	.word	0x20404ff0
  40fdc0:	40c90fdb 	.word	0x40c90fdb
  40fdc4:	43870000 	.word	0x43870000
  40fdc8:	20406420 	.word	0x20406420
  40fdcc:	20406474 	.word	0x20406474
  40fdd0:	20406498 	.word	0x20406498

0040fdd4 <IM_stage1_tune>:
}


#define RS_FILTER (2)
void IM_stage1_tune(void)
{
  40fdd4:	b510      	push	{r4, lr}
	float com_ia, ia;
	ia = axt_get_ialpha();
  40fdd6:	4b14      	ldr	r3, [pc, #80]	; (40fe28 <IM_stage1_tune+0x54>)
	//va = motor_sim(ia);
	
	//ia = com_ia;
	//va = motor_sim(ia);
	//rs_h += ((va/ia) - rs_h) * (TSAMPLE / RS_FILTER);
	update_measured_data_vector1(va, ia);
  40fdd8:	4c14      	ldr	r4, [pc, #80]	; (40fe2c <IM_stage1_tune+0x58>)
{
  40fdda:	ed2d 8b02 	vpush	{d8}
	ia = axt_get_ialpha();
  40fdde:	4798      	blx	r3
	com_ia = rated_c * 1.0;//1.5;
  40fde0:	4a13      	ldr	r2, [pc, #76]	; (40fe30 <IM_stage1_tune+0x5c>)
	update_measured_data_vector1(va, ia);
  40fde2:	4601      	mov	r1, r0
	ia = axt_get_ialpha();
  40fde4:	ee08 0a10 	vmov	s16, r0
	update_measured_data_vector1(va, ia);
  40fde8:	4b12      	ldr	r3, [pc, #72]	; (40fe34 <IM_stage1_tune+0x60>)
  40fdea:	6820      	ldr	r0, [r4, #0]
	com_ia = rated_c * 1.0;//1.5;
  40fdec:	edd2 3a00 	vldr	s7, [r2]
	update_measured_data_vector1(va, ia);
  40fdf0:	4798      	blx	r3
	update_gains_vector();
  40fdf2:	4b11      	ldr	r3, [pc, #68]	; (40fe38 <IM_stage1_tune+0x64>)
  40fdf4:	4798      	blx	r3
	update_covariance_matrix();
  40fdf6:	4b11      	ldr	r3, [pc, #68]	; (40fe3c <IM_stage1_tune+0x68>)
  40fdf8:	4798      	blx	r3
	update_parameters_vector(ia);
  40fdfa:	ee18 0a10 	vmov	r0, s16
  40fdfe:	4b10      	ldr	r3, [pc, #64]	; (40fe40 <IM_stage1_tune+0x6c>)
  40fe00:	4798      	blx	r3
	
	va = (com_ia - ia) * Pgain;
  40fe02:	ee73 7ac8 	vsub.f32	s15, s7, s16
  40fe06:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 40fe44 <IM_stage1_tune+0x70>
	//va = ia;
	//dacc_interface_writeData(0, com_ia/*est_out*/, 10, 1);
	
	inverter_out_single_axis(va);
  40fe0a:	4b0f      	ldr	r3, [pc, #60]	; (40fe48 <IM_stage1_tune+0x74>)
	va = (com_ia - ia) * Pgain;
  40fe0c:	ee67 7a87 	vmul.f32	s15, s15, s14
	inverter_out_single_axis(va);
  40fe10:	ee17 0a90 	vmov	r0, s15
	va = (com_ia - ia) * Pgain;
  40fe14:	edc4 7a00 	vstr	s15, [r4]
	inverter_out_single_axis(va);
  40fe18:	4798      	blx	r3
	//inverter_out_rect((va * FIXEDPT_ONE), 0);
	prev_ia = ia;
  40fe1a:	4b0c      	ldr	r3, [pc, #48]	; (40fe4c <IM_stage1_tune+0x78>)
  40fe1c:	ed83 8a00 	vstr	s16, [r3]
}
  40fe20:	ecbd 8b02 	vpop	{d8}
  40fe24:	bd10      	pop	{r4, pc}
  40fe26:	bf00      	nop
  40fe28:	0040e2e9 	.word	0x0040e2e9
  40fe2c:	20406454 	.word	0x20406454
  40fe30:	20400370 	.word	0x20400370
  40fe34:	0040fa55 	.word	0x0040fa55
  40fe38:	0040fb35 	.word	0x0040fb35
  40fe3c:	0040fb91 	.word	0x0040fb91
  40fe40:	0040fbfd 	.word	0x0040fbfd
  40fe44:	42200000 	.word	0x42200000
  40fe48:	00414e3d 	.word	0x00414e3d
  40fe4c:	20400a10 	.word	0x20400a10

0040fe50 <IM_stage2_tune>:
void IM_stage2_tune(void)
{
  40fe50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	float com_ia, ia, im;
	float dia, vma = 0;
	ia = axt_get_ialpha();
  40fe54:	4b28      	ldr	r3, [pc, #160]	; (40fef8 <IM_stage2_tune+0xa8>)
	
	com_ia = 1.8;
	com_ia = com_ia + 1 * arm_sin_f32(SIG2_FREQ * time_lapse);
	
	com_ia *= rated_c * 0.5;
  40fe56:	4e29      	ldr	r6, [pc, #164]	; (40fefc <IM_stage2_tune+0xac>)
  40fe58:	4d29      	ldr	r5, [pc, #164]	; (40ff00 <IM_stage2_tune+0xb0>)
	
	//va = motor_sim(ia);
	//ia = com_ia;
	//va = motor_sim(ia);
	
	update_measured_data_vector1(va, ia);
  40fe5a:	4c2a      	ldr	r4, [pc, #168]	; (40ff04 <IM_stage2_tune+0xb4>)
{
  40fe5c:	ed2d 8b02 	vpush	{d8}
	ia = axt_get_ialpha();
  40fe60:	4798      	blx	r3
	com_ia = com_ia + 1 * arm_sin_f32(SIG2_FREQ * time_lapse);
  40fe62:	4b29      	ldr	r3, [pc, #164]	; (40ff08 <IM_stage2_tune+0xb8>)
  40fe64:	eddf 7a29 	vldr	s15, [pc, #164]	; 40ff0c <IM_stage2_tune+0xbc>
	ia = axt_get_ialpha();
  40fe68:	ee08 0a10 	vmov	s16, r0
	com_ia = com_ia + 1 * arm_sin_f32(SIG2_FREQ * time_lapse);
  40fe6c:	ed93 7a00 	vldr	s14, [r3]
  40fe70:	4b27      	ldr	r3, [pc, #156]	; (40ff10 <IM_stage2_tune+0xc0>)
  40fe72:	ee67 7a27 	vmul.f32	s15, s14, s15
  40fe76:	ee17 0a90 	vmov	r0, s15
  40fe7a:	4798      	blx	r3
	com_ia *= rated_c * 0.5;
  40fe7c:	4b25      	ldr	r3, [pc, #148]	; (40ff14 <IM_stage2_tune+0xc4>)
	com_ia = com_ia + 1 * arm_sin_f32(SIG2_FREQ * time_lapse);
  40fe7e:	ee08 0a90 	vmov	s17, r0
	com_ia *= rated_c * 0.5;
  40fe82:	6818      	ldr	r0, [r3, #0]
  40fe84:	47b0      	blx	r6
  40fe86:	2200      	movs	r2, #0
  40fe88:	4b23      	ldr	r3, [pc, #140]	; (40ff18 <IM_stage2_tune+0xc8>)
  40fe8a:	47a8      	blx	r5
	com_ia = com_ia + 1 * arm_sin_f32(SIG2_FREQ * time_lapse);
  40fe8c:	eddf 7a23 	vldr	s15, [pc, #140]	; 40ff1c <IM_stage2_tune+0xcc>
	com_ia *= rated_c * 0.5;
  40fe90:	4680      	mov	r8, r0
  40fe92:	4689      	mov	r9, r1
  40fe94:	ee78 7aa7 	vadd.f32	s15, s17, s15
  40fe98:	ee17 0a90 	vmov	r0, s15
  40fe9c:	47b0      	blx	r6
  40fe9e:	4602      	mov	r2, r0
  40fea0:	460b      	mov	r3, r1
  40fea2:	4640      	mov	r0, r8
  40fea4:	4649      	mov	r1, r9
  40fea6:	47a8      	blx	r5
	update_measured_data_vector1(va, ia);
  40fea8:	4b1d      	ldr	r3, [pc, #116]	; (40ff20 <IM_stage2_tune+0xd0>)
	com_ia *= rated_c * 0.5;
  40feaa:	4606      	mov	r6, r0
  40feac:	460f      	mov	r7, r1
	update_measured_data_vector1(va, ia);
  40feae:	6820      	ldr	r0, [r4, #0]
  40feb0:	ee18 1a10 	vmov	r1, s16
  40feb4:	4798      	blx	r3
	update_gains_vector();
  40feb6:	4b1b      	ldr	r3, [pc, #108]	; (40ff24 <IM_stage2_tune+0xd4>)
  40feb8:	4798      	blx	r3
	update_covariance_matrix();
  40feba:	4b1b      	ldr	r3, [pc, #108]	; (40ff28 <IM_stage2_tune+0xd8>)
  40febc:	4798      	blx	r3
	update_parameters_vector(ia);
  40febe:	ee18 0a10 	vmov	r0, s16
  40fec2:	4b1a      	ldr	r3, [pc, #104]	; (40ff2c <IM_stage2_tune+0xdc>)
  40fec4:	4798      	blx	r3
	com_ia *= rated_c * 0.5;
  40fec6:	4b1a      	ldr	r3, [pc, #104]	; (40ff30 <IM_stage2_tune+0xe0>)
  40fec8:	4639      	mov	r1, r7
  40feca:	4630      	mov	r0, r6
  40fecc:	4798      	blx	r3
	
	va = (com_ia - ia) * Pgain;
  40fece:	ee07 0a90 	vmov	s15, r0
  40fed2:	ed9f 7a18 	vldr	s14, [pc, #96]	; 40ff34 <IM_stage2_tune+0xe4>
  40fed6:	ee77 7ac8 	vsub.f32	s15, s15, s16
	
	//dacc_interface_writeData(0, com_ia/*est_out*/, 20, 1);
	
	inverter_out_single_axis(va);
  40feda:	4b17      	ldr	r3, [pc, #92]	; (40ff38 <IM_stage2_tune+0xe8>)
	va = (com_ia - ia) * Pgain;
  40fedc:	ee67 7a87 	vmul.f32	s15, s15, s14
	inverter_out_single_axis(va);
  40fee0:	ee17 0a90 	vmov	r0, s15
	va = (com_ia - ia) * Pgain;
  40fee4:	edc4 7a00 	vstr	s15, [r4]
	inverter_out_single_axis(va);
  40fee8:	4798      	blx	r3
	//inverter_out_rect((va * FIXEDPT_ONE), 0);
	prev_ia = ia;
  40feea:	4b14      	ldr	r3, [pc, #80]	; (40ff3c <IM_stage2_tune+0xec>)
  40feec:	ed83 8a00 	vstr	s16, [r3]
}
  40fef0:	ecbd 8b02 	vpop	{d8}
  40fef4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40fef8:	0040e2e9 	.word	0x0040e2e9
  40fefc:	00418749 	.word	0x00418749
  40ff00:	004187f1 	.word	0x004187f1
  40ff04:	20406454 	.word	0x20406454
  40ff08:	204009d4 	.word	0x204009d4
  40ff0c:	44c4597c 	.word	0x44c4597c
  40ff10:	00418141 	.word	0x00418141
  40ff14:	20400370 	.word	0x20400370
  40ff18:	3fe00000 	.word	0x3fe00000
  40ff1c:	3fe66666 	.word	0x3fe66666
  40ff20:	0040fa55 	.word	0x0040fa55
  40ff24:	0040fb35 	.word	0x0040fb35
  40ff28:	0040fb91 	.word	0x0040fb91
  40ff2c:	0040fbfd 	.word	0x0040fbfd
  40ff30:	00418da1 	.word	0x00418da1
  40ff34:	42200000 	.word	0x42200000
  40ff38:	00414e3d 	.word	0x00414e3d
  40ff3c:	20400a10 	.word	0x20400a10

0040ff40 <IM_stage3_tune>:
float vfa = 0;
#define	VFA_FILTER (0.01)
void IM_stage3_tune(void)
{
  40ff40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	com_ia = 0;
	//com_ia = 0.2;
	//com_ia = (1.0f/IM_stage_period);
	//com_ia *= time_lapse;
	com_ia = com_ia + 1 * arm_sin_f32(SIG1_FREQ * time_lapse);
  40ff44:	4d4a      	ldr	r5, [pc, #296]	; (410070 <IM_stage3_tune+0x130>)
	ia = axt_get_ialpha();
  40ff46:	4b4b      	ldr	r3, [pc, #300]	; (410074 <IM_stage3_tune+0x134>)
	com_ia = com_ia + 1 * arm_sin_f32(SIG1_FREQ * time_lapse);
  40ff48:	4e4b      	ldr	r6, [pc, #300]	; (410078 <IM_stage3_tune+0x138>)
	com_ia = com_ia + 1 * arm_sin_f32(SIG3_FREQ * time_lapse);
	//com_ia = com_ia + 1 * arm_sin_f32(SIG4_FREQ * time_lapse);
	
	com_ia *= rated_c * 0.6;
  40ff4a:	4c4c      	ldr	r4, [pc, #304]	; (41007c <IM_stage3_tune+0x13c>)
  40ff4c:	f8df a170 	ldr.w	sl, [pc, #368]	; 4100c0 <IM_stage3_tune+0x180>
{
  40ff50:	ed2d 8b04 	vpush	{d8-d9}
	ia = axt_get_ialpha();
  40ff54:	4798      	blx	r3
	com_ia = com_ia + 1 * arm_sin_f32(SIG1_FREQ * time_lapse);
  40ff56:	ed95 7a00 	vldr	s14, [r5]
  40ff5a:	eddf 7a49 	vldr	s15, [pc, #292]	; 410080 <IM_stage3_tune+0x140>
	ia = axt_get_ialpha();
  40ff5e:	ee08 0a10 	vmov	s16, r0
	com_ia = com_ia + 1 * arm_sin_f32(SIG1_FREQ * time_lapse);
  40ff62:	ee67 7a27 	vmul.f32	s15, s14, s15
  40ff66:	ee17 0a90 	vmov	r0, s15
  40ff6a:	47b0      	blx	r6
	com_ia = com_ia + 1 * arm_sin_f32(SIG3_FREQ * time_lapse);
  40ff6c:	ed95 7a00 	vldr	s14, [r5]
  40ff70:	eddf 7a44 	vldr	s15, [pc, #272]	; 410084 <IM_stage3_tune+0x144>
	com_ia = com_ia + 1 * arm_sin_f32(SIG1_FREQ * time_lapse);
  40ff74:	ee09 0a10 	vmov	s18, r0
	com_ia *= rated_c * 0.6;
  40ff78:	4d43      	ldr	r5, [pc, #268]	; (410088 <IM_stage3_tune+0x148>)
	com_ia = com_ia + 1 * arm_sin_f32(SIG3_FREQ * time_lapse);
  40ff7a:	ee67 7a27 	vmul.f32	s15, s14, s15
  40ff7e:	ee17 0a90 	vmov	r0, s15
  40ff82:	47b0      	blx	r6
	com_ia *= rated_c * 0.6;
  40ff84:	4b41      	ldr	r3, [pc, #260]	; (41008c <IM_stage3_tune+0x14c>)
	com_ia = com_ia + 1 * arm_sin_f32(SIG3_FREQ * time_lapse);
  40ff86:	ee08 0a90 	vmov	s17, r0
	com_ia *= rated_c * 0.6;
  40ff8a:	6818      	ldr	r0, [r3, #0]
  40ff8c:	47a0      	blx	r4
  40ff8e:	ee79 7a28 	vadd.f32	s15, s18, s17
  40ff92:	4606      	mov	r6, r0
  40ff94:	460f      	mov	r7, r1
  40ff96:	ee17 0a90 	vmov	r0, s15
  40ff9a:	47a0      	blx	r4
  40ff9c:	4680      	mov	r8, r0
  40ff9e:	4689      	mov	r9, r1
  40ffa0:	4630      	mov	r0, r6
  40ffa2:	4639      	mov	r1, r7
  40ffa4:	a32e      	add	r3, pc, #184	; (adr r3, 410060 <IM_stage3_tune+0x120>)
  40ffa6:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ffaa:	47a8      	blx	r5
  40ffac:	4602      	mov	r2, r0
  40ffae:	460b      	mov	r3, r1
  40ffb0:	4640      	mov	r0, r8
  40ffb2:	4649      	mov	r1, r9
  40ffb4:	47a8      	blx	r5
  40ffb6:	4680      	mov	r8, r0
  40ffb8:	4689      	mov	r9, r1
	com_ia += rated_c * 0.7;
  40ffba:	4630      	mov	r0, r6
  40ffbc:	4639      	mov	r1, r7
  40ffbe:	a32a      	add	r3, pc, #168	; (adr r3, 410068 <IM_stage3_tune+0x128>)
  40ffc0:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ffc4:	47a8      	blx	r5
  40ffc6:	4606      	mov	r6, r0
  40ffc8:	460f      	mov	r7, r1
	com_ia *= rated_c * 0.6;
  40ffca:	4640      	mov	r0, r8
  40ffcc:	4649      	mov	r1, r9
	
	//va = motor_sim(ia);
	//ia = com_ia;
	//va = motor_sim(ia);
	
	dia += (ia - prev_ia) / TSAMPLE;
  40ffce:	4d30      	ldr	r5, [pc, #192]	; (410090 <IM_stage3_tune+0x150>)
	com_ia *= rated_c * 0.6;
  40ffd0:	47d0      	blx	sl
	com_ia += rated_c * 0.7;
  40ffd2:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 4100c4 <IM_stage3_tune+0x184>
  40ffd6:	47a0      	blx	r4
  40ffd8:	4602      	mov	r2, r0
  40ffda:	460b      	mov	r3, r1
  40ffdc:	4630      	mov	r0, r6
  40ffde:	4639      	mov	r1, r7
	vma = va - /*(RS * RS_err)*/ rs_h * ia - /*(LS * LS_err)*/ ls_h * dia;
  40ffe0:	4c2c      	ldr	r4, [pc, #176]	; (410094 <IM_stage3_tune+0x154>)
	com_ia += rated_c * 0.7;
  40ffe2:	47c0      	blx	r8
	dia += (ia - prev_ia) / TSAMPLE;
  40ffe4:	ed95 7a00 	vldr	s14, [r5]
	vma = va - /*(RS * RS_err)*/ rs_h * ia - /*(LS * LS_err)*/ ls_h * dia;
  40ffe8:	4a2b      	ldr	r2, [pc, #172]	; (410098 <IM_stage3_tune+0x158>)
	com_ia += rated_c * 0.7;
  40ffea:	4606      	mov	r6, r0
	dia += (ia - prev_ia) / TSAMPLE;
  40ffec:	4b2b      	ldr	r3, [pc, #172]	; (41009c <IM_stage3_tune+0x15c>)
  40ffee:	ee38 7a47 	vsub.f32	s14, s16, s14
	vma = va - /*(RS * RS_err)*/ rs_h * ia - /*(LS * LS_err)*/ ls_h * dia;
  40fff2:	ed92 6a00 	vldr	s12, [r2]
	com_ia += rated_c * 0.7;
  40fff6:	460f      	mov	r7, r1
	dia += (ia - prev_ia) / TSAMPLE;
  40fff8:	edd3 6a00 	vldr	s13, [r3]
/*	vma = motor_sim2(ia);*/
	//vfa += (vma - vfa) * VFA_FILTER;
	//vma = vfa;
	update_measured_data_vector2(vma, ia);
  40fffc:	ee18 1a10 	vmov	r1, s16
	vma = va - /*(RS * RS_err)*/ rs_h * ia - /*(LS * LS_err)*/ ls_h * dia;
  410000:	edd4 3a00 	vldr	s7, [r4]
	dia += (ia - prev_ia) / TSAMPLE;
  410004:	eddf 7a26 	vldr	s15, [pc, #152]	; 4100a0 <IM_stage3_tune+0x160>
	vma = va - /*(RS * RS_err)*/ rs_h * ia - /*(LS * LS_err)*/ ls_h * dia;
  410008:	eee8 3a46 	vfms.f32	s7, s16, s12
  41000c:	4a25      	ldr	r2, [pc, #148]	; (4100a4 <IM_stage3_tune+0x164>)
	dia += (ia - prev_ia) / TSAMPLE;
  41000e:	eee7 7a26 	vfma.f32	s15, s14, s13
	update_measured_data_vector2(vma, ia);
  410012:	4b25      	ldr	r3, [pc, #148]	; (4100a8 <IM_stage3_tune+0x168>)
	vma = va - /*(RS * RS_err)*/ rs_h * ia - /*(LS * LS_err)*/ ls_h * dia;
  410014:	ed92 7a00 	vldr	s14, [r2]
  410018:	eee7 3ac7 	vfms.f32	s7, s15, s14
	update_measured_data_vector2(vma, ia);
  41001c:	ee13 0a90 	vmov	r0, s7
  410020:	4798      	blx	r3
	update_gains_vector();
  410022:	4b22      	ldr	r3, [pc, #136]	; (4100ac <IM_stage3_tune+0x16c>)
  410024:	4798      	blx	r3
	update_covariance_matrix();
  410026:	4b22      	ldr	r3, [pc, #136]	; (4100b0 <IM_stage3_tune+0x170>)
  410028:	4798      	blx	r3
	update_parameters_vector(vma);
  41002a:	4b22      	ldr	r3, [pc, #136]	; (4100b4 <IM_stage3_tune+0x174>)
  41002c:	ee13 0a90 	vmov	r0, s7
  410030:	4798      	blx	r3
	com_ia += rated_c * 0.7;
  410032:	4639      	mov	r1, r7
  410034:	4630      	mov	r0, r6
  410036:	47d0      	blx	sl
	
	va = (com_ia - ia) * Pgain;
  410038:	ee07 0a90 	vmov	s15, r0
  41003c:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 4100b8 <IM_stage3_tune+0x178>
  410040:	ee77 7ac8 	vsub.f32	s15, s15, s16
	//va = com_ia;
	
	//dacc_interface_writeData(0, com_ia/*est_out*/, 20, 1);
	
	inverter_out_single_axis(va);
  410044:	4b1d      	ldr	r3, [pc, #116]	; (4100bc <IM_stage3_tune+0x17c>)
	va = (com_ia - ia) * Pgain;
  410046:	ee67 7a87 	vmul.f32	s15, s15, s14
	inverter_out_single_axis(va);
  41004a:	ee17 0a90 	vmov	r0, s15
	va = (com_ia - ia) * Pgain;
  41004e:	edc4 7a00 	vstr	s15, [r4]
	inverter_out_single_axis(va);
  410052:	4798      	blx	r3
	//inverter_out_rect((va * FIXEDPT_ONE), 0);
	//inverter_out_polar(0, va * FIXEDPT_ONE);
	prev_ia = ia;
  410054:	ed85 8a00 	vstr	s16, [r5]
}
  410058:	ecbd 8b04 	vpop	{d8-d9}
  41005c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  410060:	33333333 	.word	0x33333333
  410064:	3fe33333 	.word	0x3fe33333
  410068:	66666666 	.word	0x66666666
  41006c:	3fe66666 	.word	0x3fe66666
  410070:	204009d4 	.word	0x204009d4
  410074:	0040e2e9 	.word	0x0040e2e9
  410078:	00418141 	.word	0x00418141
  41007c:	00418749 	.word	0x00418749
  410080:	41fb53d2 	.word	0x41fb53d2
  410084:	427b53d2 	.word	0x427b53d2
  410088:	004187f1 	.word	0x004187f1
  41008c:	20400370 	.word	0x20400370
  410090:	20400a10 	.word	0x20400a10
  410094:	20406454 	.word	0x20406454
  410098:	20406420 	.word	0x20406420
  41009c:	204003c8 	.word	0x204003c8
  4100a0:	00000000 	.word	0x00000000
  4100a4:	20406474 	.word	0x20406474
  4100a8:	0040fac1 	.word	0x0040fac1
  4100ac:	0040fb35 	.word	0x0040fb35
  4100b0:	0040fb91 	.word	0x0040fb91
  4100b4:	0040fbfd 	.word	0x0040fbfd
  4100b8:	42200000 	.word	0x42200000
  4100bc:	00414e3d 	.word	0x00414e3d
  4100c0:	00418da1 	.word	0x00418da1
  4100c4:	0041848d 	.word	0x0041848d

004100c8 <IM_stage4_tune>:
#define FLUX_CHARGE_TIME (3)
char im_lm_stage = 0;
float im_stage4_flux = 0, ia_final;
char zero_current_timeout = 0;
void IM_stage4_tune(void)
{
  4100c8:	b538      	push	{r3, r4, r5, lr}
	float com_ia, ia , im, rotor_flux;
	
	ia = axt_get_ialpha();
	
	if (im_lm_stage == 0)
  4100ca:	4c3b      	ldr	r4, [pc, #236]	; (4101b8 <IM_stage4_tune+0xf0>)
	ia = axt_get_ialpha();
  4100cc:	4b3b      	ldr	r3, [pc, #236]	; (4101bc <IM_stage4_tune+0xf4>)
{
  4100ce:	ed2d 8b02 	vpush	{d8}
	ia = axt_get_ialpha();
  4100d2:	4798      	blx	r3
	if (im_lm_stage == 0)
  4100d4:	7823      	ldrb	r3, [r4, #0]
	ia = axt_get_ialpha();
  4100d6:	ee08 0a10 	vmov	s16, r0
	if (im_lm_stage == 0)
  4100da:	bb63      	cbnz	r3, 410136 <IM_stage4_tune+0x6e>
	{
		com_ia = (rated_c * 0.6);
  4100dc:	4a38      	ldr	r2, [pc, #224]	; (4101c0 <IM_stage4_tune+0xf8>)
  4100de:	4b39      	ldr	r3, [pc, #228]	; (4101c4 <IM_stage4_tune+0xfc>)
  4100e0:	6810      	ldr	r0, [r2, #0]
  4100e2:	4798      	blx	r3
  4100e4:	4d38      	ldr	r5, [pc, #224]	; (4101c8 <IM_stage4_tune+0x100>)
  4100e6:	a332      	add	r3, pc, #200	; (adr r3, 4101b0 <IM_stage4_tune+0xe8>)
  4100e8:	e9d3 2300 	ldrd	r2, r3, [r3]
  4100ec:	47a8      	blx	r5
  4100ee:	4b37      	ldr	r3, [pc, #220]	; (4101cc <IM_stage4_tune+0x104>)
  4100f0:	4798      	blx	r3
		va = (com_ia - ia) * Pgain;
  4100f2:	ee07 0a90 	vmov	s15, r0
  4100f6:	eddf 6a36 	vldr	s13, [pc, #216]	; 4101d0 <IM_stage4_tune+0x108>
		ia_final = ia;
		if(time_lapse >= FLUX_CHARGE_TIME) im_lm_stage = 1;
  4100fa:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
		va = (com_ia - ia) * Pgain;
  4100fe:	ee77 7ac8 	vsub.f32	s15, s15, s16
		if(time_lapse >= FLUX_CHARGE_TIME) im_lm_stage = 1;
  410102:	4b34      	ldr	r3, [pc, #208]	; (4101d4 <IM_stage4_tune+0x10c>)
		va = (com_ia - ia) * Pgain;
  410104:	4a34      	ldr	r2, [pc, #208]	; (4101d8 <IM_stage4_tune+0x110>)
  410106:	ee67 7aa6 	vmul.f32	s15, s15, s13
		if(time_lapse >= FLUX_CHARGE_TIME) im_lm_stage = 1;
  41010a:	edd3 6a00 	vldr	s13, [r3]
		ia_final = ia;
  41010e:	4b33      	ldr	r3, [pc, #204]	; (4101dc <IM_stage4_tune+0x114>)
		if(time_lapse >= FLUX_CHARGE_TIME) im_lm_stage = 1;
  410110:	eef4 6ac7 	vcmpe.f32	s13, s14
		va = (com_ia - ia) * Pgain;
  410114:	edc2 7a00 	vstr	s15, [r2]
		ia_final = ia;
  410118:	ed83 8a00 	vstr	s16, [r3]
		if(time_lapse >= FLUX_CHARGE_TIME) im_lm_stage = 1;
  41011c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410120:	da36      	bge.n	410190 <IM_stage4_tune+0xc8>
		lm_h -= ls_h;
		va = 0;
		
	}
	
	inverter_out_single_axis(va);
  410122:	4b2f      	ldr	r3, [pc, #188]	; (4101e0 <IM_stage4_tune+0x118>)
  410124:	ee17 0a90 	vmov	r0, s15
  410128:	4798      	blx	r3
	prev_ia = ia;
  41012a:	4b2e      	ldr	r3, [pc, #184]	; (4101e4 <IM_stage4_tune+0x11c>)
  41012c:	ed83 8a00 	vstr	s16, [r3]
}
  410130:	ecbd 8b02 	vpop	{d8}
  410134:	bd38      	pop	{r3, r4, r5, pc}
		if(ia <= 0) 
  410136:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  41013a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41013e:	d92a      	bls.n	410196 <IM_stage4_tune+0xce>
		im_stage4_flux += rs_h * ia * TSAMPLE;
  410140:	4a29      	ldr	r2, [pc, #164]	; (4101e8 <IM_stage4_tune+0x120>)
  410142:	4b2a      	ldr	r3, [pc, #168]	; (4101ec <IM_stage4_tune+0x124>)
  410144:	ed92 7a00 	vldr	s14, [r2]
  410148:	edd3 7a00 	vldr	s15, [r3]
  41014c:	4a28      	ldr	r2, [pc, #160]	; (4101f0 <IM_stage4_tune+0x128>)
  41014e:	eec7 5a27 	vdiv.f32	s11, s14, s15
		lm_h = im_stage4_flux / ia_final;//(lm_h - rotor_flux / im) * (0.01);///TSAMPLE;
  410152:	4b22      	ldr	r3, [pc, #136]	; (4101dc <IM_stage4_tune+0x114>)
		im_stage4_flux += rs_h * ia * TSAMPLE;
  410154:	ed92 7a00 	vldr	s14, [r2]
		lm_h = im_stage4_flux / ia_final;//(lm_h - rotor_flux / im) * (0.01);///TSAMPLE;
  410158:	ed93 6a00 	vldr	s12, [r3]
		va = 0;
  41015c:	eddf 6a25 	vldr	s13, [pc, #148]	; 4101f4 <IM_stage4_tune+0x12c>
  410160:	481d      	ldr	r0, [pc, #116]	; (4101d8 <IM_stage4_tune+0x110>)
  410162:	eef0 7a66 	vmov.f32	s15, s13
		lm_h = im_stage4_flux / ia_final;//(lm_h - rotor_flux / im) * (0.01);///TSAMPLE;
  410166:	4b24      	ldr	r3, [pc, #144]	; (4101f8 <IM_stage4_tune+0x130>)
		va = 0;
  410168:	edc0 6a00 	vstr	s13, [r0]
		lm_h -= ls_h;
  41016c:	4923      	ldr	r1, [pc, #140]	; (4101fc <IM_stage4_tune+0x134>)
		im_stage4_flux += rs_h * ia * TSAMPLE;
  41016e:	eea8 7a25 	vfma.f32	s14, s16, s11
		lm_h = im_stage4_flux / ia_final;//(lm_h - rotor_flux / im) * (0.01);///TSAMPLE;
  410172:	eec7 6a06 	vdiv.f32	s13, s14, s12
		im_stage4_flux += rs_h * ia * TSAMPLE;
  410176:	ed82 7a00 	vstr	s14, [r2]
		lm_h = im_stage4_flux / ia_final;//(lm_h - rotor_flux / im) * (0.01);///TSAMPLE;
  41017a:	edc3 6a00 	vstr	s13, [r3]
		lm_h -= ls_h;
  41017e:	edd1 6a00 	vldr	s13, [r1]
  410182:	ed93 7a00 	vldr	s14, [r3]
  410186:	ee37 7a66 	vsub.f32	s14, s14, s13
  41018a:	ed83 7a00 	vstr	s14, [r3]
  41018e:	e7c8      	b.n	410122 <IM_stage4_tune+0x5a>
		if(time_lapse >= FLUX_CHARGE_TIME) im_lm_stage = 1;
  410190:	2301      	movs	r3, #1
  410192:	7023      	strb	r3, [r4, #0]
  410194:	e7c5      	b.n	410122 <IM_stage4_tune+0x5a>
			if(++zero_current_timeout > 100)
  410196:	4a1a      	ldr	r2, [pc, #104]	; (410200 <IM_stage4_tune+0x138>)
  410198:	7813      	ldrb	r3, [r2, #0]
  41019a:	3301      	adds	r3, #1
  41019c:	b2db      	uxtb	r3, r3
  41019e:	2b64      	cmp	r3, #100	; 0x64
  4101a0:	7013      	strb	r3, [r2, #0]
  4101a2:	d9cd      	bls.n	410140 <IM_stage4_tune+0x78>
				time_lapse = IM_stage_period;
  4101a4:	4a17      	ldr	r2, [pc, #92]	; (410204 <IM_stage4_tune+0x13c>)
  4101a6:	4b0b      	ldr	r3, [pc, #44]	; (4101d4 <IM_stage4_tune+0x10c>)
  4101a8:	6812      	ldr	r2, [r2, #0]
  4101aa:	601a      	str	r2, [r3, #0]
				return;	
  4101ac:	e7c0      	b.n	410130 <IM_stage4_tune+0x68>
  4101ae:	bf00      	nop
  4101b0:	33333333 	.word	0x33333333
  4101b4:	3fe33333 	.word	0x3fe33333
  4101b8:	204009c5 	.word	0x204009c5
  4101bc:	0040e2e9 	.word	0x0040e2e9
  4101c0:	20400370 	.word	0x20400370
  4101c4:	00418749 	.word	0x00418749
  4101c8:	004187f1 	.word	0x004187f1
  4101cc:	00418da1 	.word	0x00418da1
  4101d0:	42200000 	.word	0x42200000
  4101d4:	204009d4 	.word	0x204009d4
  4101d8:	20406454 	.word	0x20406454
  4101dc:	20406434 	.word	0x20406434
  4101e0:	00414e3d 	.word	0x00414e3d
  4101e4:	20400a10 	.word	0x20400a10
  4101e8:	20406420 	.word	0x20406420
  4101ec:	204003c8 	.word	0x204003c8
  4101f0:	204009c8 	.word	0x204009c8
  4101f4:	00000000 	.word	0x00000000
  4101f8:	20406498 	.word	0x20406498
  4101fc:	20406474 	.word	0x20406474
  410200:	204009d8 	.word	0x204009d8
  410204:	2040645c 	.word	0x2040645c

00410208 <IM_init_tune_param>:
	prev_v = 0;
	prev_i = 0;
	va = 0;
	
	//init constants
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410208:	4b28      	ldr	r3, [pc, #160]	; (4102ac <IM_init_tune_param+0xa4>)
  41020a:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
  41020e:	eddf 6a28 	vldr	s13, [pc, #160]	; 4102b0 <IM_init_tune_param+0xa8>
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410212:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	cc3 = ((2 - h0*TSAMPLE) / (2 + h0*TSAMPLE));
  410216:	ed9f 5a27 	vldr	s10, [pc, #156]	; 4102b4 <IM_init_tune_param+0xac>
	time_lapse = 0;
  41021a:	4a27      	ldr	r2, [pc, #156]	; (4102b8 <IM_init_tune_param+0xb0>)
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  41021c:	4927      	ldr	r1, [pc, #156]	; (4102bc <IM_init_tune_param+0xb4>)
	cc4 = ((2) / (2 + h0*TSAMPLE));
  41021e:	4828      	ldr	r0, [pc, #160]	; (4102c0 <IM_init_tune_param+0xb8>)
{
  410220:	b4f0      	push	{r4, r5, r6, r7}
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410222:	edd3 7a00 	vldr	s15, [r3]
	time_lapse = 0;
  410226:	2300      	movs	r3, #0
	
	phi_a[0] = 0;
	phi_a[1] = 0;
	
	im_stage4_flux = 0;
	zero_current_timeout = 0;
  410228:	2600      	movs	r6, #0
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  41022a:	4f26      	ldr	r7, [pc, #152]	; (4102c4 <IM_init_tune_param+0xbc>)
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  41022c:	ee86 6aa7 	vdiv.f32	s12, s13, s15
	time_lapse = 0;
  410230:	6013      	str	r3, [r2, #0]
	prev_v = 0;
  410232:	4a25      	ldr	r2, [pc, #148]	; (4102c8 <IM_init_tune_param+0xc0>)
	cc5 = ((TSAMPLE) / (2 + h0*TSAMPLE));
  410234:	4c25      	ldr	r4, [pc, #148]	; (4102cc <IM_init_tune_param+0xc4>)
	prev_v = 0;
  410236:	6013      	str	r3, [r2, #0]
	prev_i = 0;
  410238:	4a25      	ldr	r2, [pc, #148]	; (4102d0 <IM_init_tune_param+0xc8>)
	cc3 = ((2 - h0*TSAMPLE) / (2 + h0*TSAMPLE));
  41023a:	eec5 6a27 	vdiv.f32	s13, s10, s15
  41023e:	4d25      	ldr	r5, [pc, #148]	; (4102d4 <IM_init_tune_param+0xcc>)
	prev_i = 0;
  410240:	6013      	str	r3, [r2, #0]
	va = 0;
  410242:	4a25      	ldr	r2, [pc, #148]	; (4102d8 <IM_init_tune_param+0xd0>)
  410244:	6013      	str	r3, [r2, #0]
	im_stage4_flux = 0;
  410246:	4a25      	ldr	r2, [pc, #148]	; (4102dc <IM_init_tune_param+0xd4>)
  410248:	6013      	str	r3, [r2, #0]
	param_a[0] = 0;
  41024a:	4a25      	ldr	r2, [pc, #148]	; (4102e0 <IM_init_tune_param+0xd8>)
  41024c:	6013      	str	r3, [r2, #0]
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  41024e:	ee36 5a07 	vadd.f32	s10, s12, s14
	param_a[1] = 0;
  410252:	6053      	str	r3, [r2, #4]
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410254:	ee37 6a46 	vsub.f32	s12, s14, s12
	pa[0][0] = seg_sqr;
  410258:	4a22      	ldr	r2, [pc, #136]	; (4102e4 <IM_init_tune_param+0xdc>)
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  41025a:	ee67 3a85 	vmul.f32	s7, s15, s10
	pa[0][1] = 0;
  41025e:	6053      	str	r3, [r2, #4]
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410260:	ee86 4a05 	vdiv.f32	s8, s12, s10
	pa[1][0] = 0;
  410264:	6093      	str	r3, [r2, #8]
	cc3 = ((2 - h0*TSAMPLE) / (2 + h0*TSAMPLE));
  410266:	ee36 6a87 	vadd.f32	s12, s13, s14
  41026a:	ee77 6a66 	vsub.f32	s13, s14, s13
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  41026e:	eec5 4aa3 	vdiv.f32	s9, s11, s7
	cc5 = ((TSAMPLE) / (2 + h0*TSAMPLE));
  410272:	ee67 7a86 	vmul.f32	s15, s15, s12
	cc3 = ((2 - h0*TSAMPLE) / (2 + h0*TSAMPLE));
  410276:	ee86 5a86 	vdiv.f32	s10, s13, s12
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  41027a:	ed81 4a00 	vstr	s8, [r1]
	pa[0][0] = seg_sqr;
  41027e:	491a      	ldr	r1, [pc, #104]	; (4102e8 <IM_init_tune_param+0xe0>)
	cc5 = ((TSAMPLE) / (2 + h0*TSAMPLE));
  410280:	eec5 6aa7 	vdiv.f32	s13, s11, s15
	pa[0][0] = seg_sqr;
  410284:	6011      	str	r1, [r2, #0]
	pa[1][1] = seg_sqr;
  410286:	60d1      	str	r1, [r2, #12]
	phi_a[0] = 0;
  410288:	4a18      	ldr	r2, [pc, #96]	; (4102ec <IM_init_tune_param+0xe4>)
	zero_current_timeout = 0;
  41028a:	4919      	ldr	r1, [pc, #100]	; (4102f0 <IM_init_tune_param+0xe8>)
	cc4 = ((2) / (2 + h0*TSAMPLE));
  41028c:	eec7 7a06 	vdiv.f32	s15, s14, s12
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410290:	edc7 4a00 	vstr	s9, [r7]
	phi_a[0] = 0;
  410294:	6013      	str	r3, [r2, #0]
	phi_a[1] = 0;
  410296:	6053      	str	r3, [r2, #4]
	zero_current_timeout = 0;
  410298:	700e      	strb	r6, [r1, #0]
	cc3 = ((2 - h0*TSAMPLE) / (2 + h0*TSAMPLE));
  41029a:	ed85 5a00 	vstr	s10, [r5]
	cc5 = ((TSAMPLE) / (2 + h0*TSAMPLE));
  41029e:	edc4 6a00 	vstr	s13, [r4]
	cc4 = ((2) / (2 + h0*TSAMPLE));
  4102a2:	edc0 7a00 	vstr	s15, [r0]
}
  4102a6:	bcf0      	pop	{r4, r5, r6, r7}
  4102a8:	4770      	bx	lr
  4102aa:	bf00      	nop
  4102ac:	204003c8 	.word	0x204003c8
  4102b0:	42b40000 	.word	0x42b40000
  4102b4:	42200000 	.word	0x42200000
  4102b8:	204009d4 	.word	0x204009d4
  4102bc:	20406478 	.word	0x20406478
  4102c0:	20406464 	.word	0x20406464
  4102c4:	2040647c 	.word	0x2040647c
  4102c8:	20406460 	.word	0x20406460
  4102cc:	20406424 	.word	0x20406424
  4102d0:	20406468 	.word	0x20406468
  4102d4:	20406458 	.word	0x20406458
  4102d8:	20406454 	.word	0x20406454
  4102dc:	204009c8 	.word	0x204009c8
  4102e0:	20406480 	.word	0x20406480
  4102e4:	2040649c 	.word	0x2040649c
  4102e8:	4b095440 	.word	0x4b095440
  4102ec:	20406488 	.word	0x20406488
  4102f0:	204009d8 	.word	0x204009d8

004102f4 <IM_param_tune1_current_handler>:
#define IM_TUNE_PERIOD (IM_stage_period)
float intermediate_time = 0;

uint8_t IM_tune_stage = 0;
void IM_param_tune1_current_handler(void)
{
  4102f4:	b570      	push	{r4, r5, r6, lr}
	if (intermediate_time > 0)
  4102f6:	4c5b      	ldr	r4, [pc, #364]	; (410464 <IM_param_tune1_current_handler+0x170>)
  4102f8:	edd4 7a00 	vldr	s15, [r4]
  4102fc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  410300:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410304:	dc31      	bgt.n	41036a <IM_param_tune1_current_handler+0x76>
	{
		intermediate_time -= TSAMPLE;
		inverter_out_single_axis(0);
		return;
	}
	else if (time_lapse < IM_TUNE_PERIOD)
  410306:	4d58      	ldr	r5, [pc, #352]	; (410468 <IM_param_tune1_current_handler+0x174>)
  410308:	4b58      	ldr	r3, [pc, #352]	; (41046c <IM_param_tune1_current_handler+0x178>)
  41030a:	edd5 7a00 	vldr	s15, [r5]
  41030e:	ed93 7a00 	vldr	s14, [r3]
  410312:	eef4 7ac7 	vcmpe.f32	s15, s14
  410316:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41031a:	d410      	bmi.n	41033e <IM_param_tune1_current_handler+0x4a>
		else if(IM_tune_stage == 2) IM_stage3_tune();
		else if(IM_tune_stage == 3) IM_stage4_tune();
	} 
	else
	{
		if(IM_tune_stage == 0)
  41031c:	4954      	ldr	r1, [pc, #336]	; (410470 <IM_param_tune1_current_handler+0x17c>)
  41031e:	780a      	ldrb	r2, [r1, #0]
  410320:	2a00      	cmp	r2, #0
  410322:	d045      	beq.n	4103b0 <IM_param_tune1_current_handler+0xbc>
			IM_TUNE_PERIOD = IM_TUNE2_PERIOD;
			estimate_rs();
			IM_init_tune_param();
			intermediate_time = IM_TUNE1_INTERMEDIATE;
		}
		else if(IM_tune_stage == 1)
  410324:	2a01      	cmp	r2, #1
  410326:	f000 8084 	beq.w	410432 <IM_param_tune1_current_handler+0x13e>
			estimate_ls();
			IM_TUNE_PERIOD = IM_TUNE3_PERIOD;
			IM_init_tune_param();
			intermediate_time = IM_TUNE1_INTERMEDIATE;
		}
		else if(IM_tune_stage == 2)
  41032a:	2a02      	cmp	r2, #2
  41032c:	d05e      	beq.n	4103ec <IM_param_tune1_current_handler+0xf8>
			estimate_rr();
			IM_init_tune_param();
			intermediate_time = IM_TUNE1_INTERMEDIATE;
			im_lm_stage = 0;
		}
		else if(IM_tune_stage == 3)
  41032e:	2a03      	cmp	r2, #3
  410330:	d12b      	bne.n	41038a <IM_param_tune1_current_handler+0x96>
		{
			IM_tune_stage++;
			IM_TUNE_PERIOD = IM_TUNE1_PERIOD;
  410332:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
			IM_tune_stage++;
  410336:	2004      	movs	r0, #4
			IM_TUNE_PERIOD = IM_TUNE1_PERIOD;
  410338:	601a      	str	r2, [r3, #0]
			IM_tune_stage++;
  41033a:	7008      	strb	r0, [r1, #0]
  41033c:	bd70      	pop	{r4, r5, r6, pc}
		if(IM_tune_stage == 0) IM_stage1_tune();
  41033e:	4b4c      	ldr	r3, [pc, #304]	; (410470 <IM_param_tune1_current_handler+0x17c>)
  410340:	781b      	ldrb	r3, [r3, #0]
  410342:	b383      	cbz	r3, 4103a6 <IM_param_tune1_current_handler+0xb2>
		else if(IM_tune_stage == 1) IM_stage2_tune();
  410344:	2b01      	cmp	r3, #1
  410346:	d04c      	beq.n	4103e2 <IM_param_tune1_current_handler+0xee>
		else if(IM_tune_stage == 2) IM_stage3_tune();
  410348:	2b02      	cmp	r3, #2
  41034a:	d06d      	beq.n	410428 <IM_param_tune1_current_handler+0x134>
		else if(IM_tune_stage == 3) IM_stage4_tune();
  41034c:	2b03      	cmp	r3, #3
  41034e:	f000 8084 	beq.w	41045a <IM_param_tune1_current_handler+0x166>
			pop_ups_add("Tune Successful", 1500);
		}
		
		return;
	}
	time_lapse += TSAMPLE;
  410352:	4b48      	ldr	r3, [pc, #288]	; (410474 <IM_param_tune1_current_handler+0x180>)
  410354:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  410358:	edd3 6a00 	vldr	s13, [r3]
  41035c:	ee86 7a26 	vdiv.f32	s14, s12, s13
  410360:	ee77 7a27 	vadd.f32	s15, s14, s15
  410364:	edc5 7a00 	vstr	s15, [r5]
  410368:	bd70      	pop	{r4, r5, r6, pc}
		intermediate_time -= TSAMPLE;
  41036a:	4b42      	ldr	r3, [pc, #264]	; (410474 <IM_param_tune1_current_handler+0x180>)
  41036c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
		inverter_out_single_axis(0);
  410370:	2000      	movs	r0, #0
		intermediate_time -= TSAMPLE;
  410372:	edd3 6a00 	vldr	s13, [r3]
		inverter_out_single_axis(0);
  410376:	4b40      	ldr	r3, [pc, #256]	; (410478 <IM_param_tune1_current_handler+0x184>)
		intermediate_time -= TSAMPLE;
  410378:	ee86 7a26 	vdiv.f32	s14, s12, s13
  41037c:	ee77 7ac7 	vsub.f32	s15, s15, s14
  410380:	edc4 7a00 	vstr	s15, [r4]
}
  410384:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		inverter_out_single_axis(0);
  410388:	4718      	bx	r3
			vfd_estop();
  41038a:	4b3c      	ldr	r3, [pc, #240]	; (41047c <IM_param_tune1_current_handler+0x188>)
  41038c:	4798      	blx	r3
			inverter_set_dead_comp(0);
  41038e:	2000      	movs	r0, #0
  410390:	4b3b      	ldr	r3, [pc, #236]	; (410480 <IM_param_tune1_current_handler+0x18c>)
  410392:	4798      	blx	r3
			save_estimated_motor_parameters();
  410394:	4b3b      	ldr	r3, [pc, #236]	; (410484 <IM_param_tune1_current_handler+0x190>)
  410396:	4798      	blx	r3
			pop_ups_add("Tune Successful", 1500);
  410398:	f240 51dc 	movw	r1, #1500	; 0x5dc
  41039c:	483a      	ldr	r0, [pc, #232]	; (410488 <IM_param_tune1_current_handler+0x194>)
  41039e:	4b3b      	ldr	r3, [pc, #236]	; (41048c <IM_param_tune1_current_handler+0x198>)
}
  4103a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			pop_ups_add("Tune Successful", 1500);
  4103a4:	4718      	bx	r3
		if(IM_tune_stage == 0) IM_stage1_tune();
  4103a6:	4b3a      	ldr	r3, [pc, #232]	; (410490 <IM_param_tune1_current_handler+0x19c>)
  4103a8:	4798      	blx	r3
  4103aa:	edd5 7a00 	vldr	s15, [r5]
  4103ae:	e7d0      	b.n	410352 <IM_param_tune1_current_handler+0x5e>
	rs_h = (h1 - param_a[1]) / param_a[0];
  4103b0:	4a38      	ldr	r2, [pc, #224]	; (410494 <IM_param_tune1_current_handler+0x1a0>)
			IM_TUNE_PERIOD = IM_TUNE2_PERIOD;
  4103b2:	f04f 4681 	mov.w	r6, #1082130432	; 0x40800000
	rs_h = (h1 - param_a[1]) / param_a[0];
  4103b6:	eddf 7a38 	vldr	s15, [pc, #224]	; 410498 <IM_param_tune1_current_handler+0x1a4>
			IM_tune_stage++;
  4103ba:	2501      	movs	r5, #1
	rs_h = (h1 - param_a[1]) / param_a[0];
  4103bc:	ed92 7a01 	vldr	s14, [r2, #4]
  4103c0:	edd2 6a00 	vldr	s13, [r2]
  4103c4:	ee77 7ac7 	vsub.f32	s15, s15, s14
  4103c8:	4834      	ldr	r0, [pc, #208]	; (41049c <IM_param_tune1_current_handler+0x1a8>)
			IM_init_tune_param();
  4103ca:	4a35      	ldr	r2, [pc, #212]	; (4104a0 <IM_param_tune1_current_handler+0x1ac>)
			IM_TUNE_PERIOD = IM_TUNE2_PERIOD;
  4103cc:	601e      	str	r6, [r3, #0]
	rs_h = (h1 - param_a[1]) / param_a[0];
  4103ce:	ee87 7aa6 	vdiv.f32	s14, s15, s13
			IM_tune_stage++;
  4103d2:	700d      	strb	r5, [r1, #0]
	rs_h = (h1 - param_a[1]) / param_a[0];
  4103d4:	ed80 7a00 	vstr	s14, [r0]
			IM_init_tune_param();
  4103d8:	4790      	blx	r2
			intermediate_time = IM_TUNE1_INTERMEDIATE;
  4103da:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
  4103de:	6023      	str	r3, [r4, #0]
  4103e0:	bd70      	pop	{r4, r5, r6, pc}
		else if(IM_tune_stage == 1) IM_stage2_tune();
  4103e2:	4b30      	ldr	r3, [pc, #192]	; (4104a4 <IM_param_tune1_current_handler+0x1b0>)
  4103e4:	4798      	blx	r3
  4103e6:	edd5 7a00 	vldr	s15, [r5]
  4103ea:	e7b2      	b.n	410352 <IM_param_tune1_current_handler+0x5e>
	rr_h = param_a[0];
  4103ec:	4a29      	ldr	r2, [pc, #164]	; (410494 <IM_param_tune1_current_handler+0x1a0>)
			IM_tune_stage++;
  4103ee:	2003      	movs	r0, #3
	lm_h = (rr_h) / (h0 - param_a[1]) ;
  4103f0:	eddf 7a2d 	vldr	s15, [pc, #180]	; 4104a8 <IM_param_tune1_current_handler+0x1b4>
  4103f4:	ed92 7a01 	vldr	s14, [r2, #4]
	rr_h = param_a[0];
  4103f8:	6815      	ldr	r5, [r2, #0]
  4103fa:	4a2c      	ldr	r2, [pc, #176]	; (4104ac <IM_param_tune1_current_handler+0x1b8>)
	lm_h = (rr_h) / (h0 - param_a[1]) ;
  4103fc:	ee77 7ac7 	vsub.f32	s15, s15, s14
			IM_TUNE_PERIOD = IM_TUNE4_PERIOD;
  410400:	4e2b      	ldr	r6, [pc, #172]	; (4104b0 <IM_param_tune1_current_handler+0x1bc>)
	rr_h = param_a[0];
  410402:	6015      	str	r5, [r2, #0]
	lm_h = (rr_h) / (h0 - param_a[1]) ;
  410404:	edd2 6a00 	vldr	s13, [r2]
  410408:	4a2a      	ldr	r2, [pc, #168]	; (4104b4 <IM_param_tune1_current_handler+0x1c0>)
  41040a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
			IM_TUNE_PERIOD = IM_TUNE4_PERIOD;
  41040e:	601e      	str	r6, [r3, #0]
			IM_init_tune_param();
  410410:	4b23      	ldr	r3, [pc, #140]	; (4104a0 <IM_param_tune1_current_handler+0x1ac>)
			IM_tune_stage++;
  410412:	7008      	strb	r0, [r1, #0]
	lm_h = (rr_h) / (h0 - param_a[1]) ;
  410414:	ed82 7a00 	vstr	s14, [r2]
			IM_init_tune_param();
  410418:	4798      	blx	r3
			intermediate_time = IM_TUNE1_INTERMEDIATE;
  41041a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
			im_lm_stage = 0;
  41041e:	4b26      	ldr	r3, [pc, #152]	; (4104b8 <IM_param_tune1_current_handler+0x1c4>)
  410420:	2200      	movs	r2, #0
			intermediate_time = IM_TUNE1_INTERMEDIATE;
  410422:	6021      	str	r1, [r4, #0]
			im_lm_stage = 0;
  410424:	701a      	strb	r2, [r3, #0]
  410426:	bd70      	pop	{r4, r5, r6, pc}
		else if(IM_tune_stage == 2) IM_stage3_tune();
  410428:	4b24      	ldr	r3, [pc, #144]	; (4104bc <IM_param_tune1_current_handler+0x1c8>)
  41042a:	4798      	blx	r3
  41042c:	edd5 7a00 	vldr	s15, [r5]
  410430:	e78f      	b.n	410352 <IM_param_tune1_current_handler+0x5e>
	ls_h = 1 / param_a[0];
  410432:	4a18      	ldr	r2, [pc, #96]	; (410494 <IM_param_tune1_current_handler+0x1a0>)
  410434:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  410438:	4821      	ldr	r0, [pc, #132]	; (4104c0 <IM_param_tune1_current_handler+0x1cc>)
			IM_tune_stage++;
  41043a:	2502      	movs	r5, #2
	ls_h = 1 / param_a[0];
  41043c:	ed92 7a00 	vldr	s14, [r2]
			IM_TUNE_PERIOD = IM_TUNE3_PERIOD;
  410440:	4e20      	ldr	r6, [pc, #128]	; (4104c4 <IM_param_tune1_current_handler+0x1d0>)
	ls_h = 1 / param_a[0];
  410442:	eec6 7a87 	vdiv.f32	s15, s13, s14
			IM_init_tune_param();
  410446:	4a16      	ldr	r2, [pc, #88]	; (4104a0 <IM_param_tune1_current_handler+0x1ac>)
			IM_TUNE_PERIOD = IM_TUNE3_PERIOD;
  410448:	601e      	str	r6, [r3, #0]
			IM_tune_stage++;
  41044a:	700d      	strb	r5, [r1, #0]
	ls_h = 1 / param_a[0];
  41044c:	edc0 7a00 	vstr	s15, [r0]
			IM_init_tune_param();
  410450:	4790      	blx	r2
			intermediate_time = IM_TUNE1_INTERMEDIATE;
  410452:	f04f 537c 	mov.w	r3, #1056964608	; 0x3f000000
  410456:	6023      	str	r3, [r4, #0]
  410458:	bd70      	pop	{r4, r5, r6, pc}
		else if(IM_tune_stage == 3) IM_stage4_tune();
  41045a:	4b1b      	ldr	r3, [pc, #108]	; (4104c8 <IM_param_tune1_current_handler+0x1d4>)
  41045c:	4798      	blx	r3
  41045e:	edd5 7a00 	vldr	s15, [r5]
  410462:	e776      	b.n	410352 <IM_param_tune1_current_handler+0x5e>
  410464:	204009d0 	.word	0x204009d0
  410468:	204009d4 	.word	0x204009d4
  41046c:	2040645c 	.word	0x2040645c
  410470:	204009c4 	.word	0x204009c4
  410474:	204003c8 	.word	0x204003c8
  410478:	00414e3d 	.word	0x00414e3d
  41047c:	00417215 	.word	0x00417215
  410480:	004153dd 	.word	0x004153dd
  410484:	0040fc59 	.word	0x0040fc59
  410488:	0041ca60 	.word	0x0041ca60
  41048c:	0040c065 	.word	0x0040c065
  410490:	0040fdd5 	.word	0x0040fdd5
  410494:	20406480 	.word	0x20406480
  410498:	42b40000 	.word	0x42b40000
  41049c:	20406420 	.word	0x20406420
  4104a0:	00410209 	.word	0x00410209
  4104a4:	0040fe51 	.word	0x0040fe51
  4104a8:	42200000 	.word	0x42200000
  4104ac:	20406428 	.word	0x20406428
  4104b0:	41b80000 	.word	0x41b80000
  4104b4:	20406498 	.word	0x20406498
  4104b8:	204009c5 	.word	0x204009c5
  4104bc:	0040ff41 	.word	0x0040ff41
  4104c0:	20406474 	.word	0x20406474
  4104c4:	40c00000 	.word	0x40c00000
  4104c8:	004100c9 	.word	0x004100c9
  4104cc:	00000000 	.word	0x00000000

004104d0 <IM_param_tune1_init>:

void IM_param_tune1_init(void)
{
	IM_tune_stage = 0;
	rated_c = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current) * sqrt2;
  4104d0:	4a15      	ldr	r2, [pc, #84]	; (410528 <IM_param_tune1_init+0x58>)
	IM_tune_stage = 0;
  4104d2:	4b16      	ldr	r3, [pc, #88]	; (41052c <IM_param_tune1_init+0x5c>)
{
  4104d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	rated_c = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current) * sqrt2;
  4104d8:	6950      	ldr	r0, [r2, #20]
	IM_tune_stage = 0;
  4104da:	2400      	movs	r4, #0
	rated_c = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current) * sqrt2;
  4104dc:	4d14      	ldr	r5, [pc, #80]	; (410530 <IM_param_tune1_init+0x60>)
  4104de:	ee07 0a90 	vmov	s15, r0
	IM_tune_stage = 0;
  4104e2:	701c      	strb	r4, [r3, #0]
	rated_c = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current) * sqrt2;
  4104e4:	4b13      	ldr	r3, [pc, #76]	; (410534 <IM_param_tune1_init+0x64>)
  4104e6:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
  4104ea:	4f13      	ldr	r7, [pc, #76]	; (410538 <IM_param_tune1_init+0x68>)
  4104ec:	ee17 0a90 	vmov	r0, s15
  4104f0:	4798      	blx	r3
  4104f2:	a30b      	add	r3, pc, #44	; (adr r3, 410520 <IM_param_tune1_init+0x50>)
  4104f4:	e9d3 2300 	ldrd	r2, r3, [r3]
  4104f8:	47a8      	blx	r5
  4104fa:	4b10      	ldr	r3, [pc, #64]	; (41053c <IM_param_tune1_init+0x6c>)
  4104fc:	4798      	blx	r3
	IM_TUNE_PERIOD = IM_TUNE1_PERIOD;
	im_tune1_comm = menue_drive_motor_tune;
  4104fe:	4b10      	ldr	r3, [pc, #64]	; (410540 <IM_param_tune1_init+0x70>)
	IM_TUNE_PERIOD = IM_TUNE1_PERIOD;
  410500:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	im_tune1_comm = menue_drive_motor_tune;
  410504:	4d0f      	ldr	r5, [pc, #60]	; (410544 <IM_param_tune1_init+0x74>)
  410506:	781e      	ldrb	r6, [r3, #0]
	IM_TUNE_PERIOD = IM_TUNE1_PERIOD;
  410508:	4a0f      	ldr	r2, [pc, #60]	; (410548 <IM_param_tune1_init+0x78>)
	rated_c = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current) * sqrt2;
  41050a:	6038      	str	r0, [r7, #0]
	inverter_set_dead_comp(0);
  41050c:	4620      	mov	r0, r4
  41050e:	4b0f      	ldr	r3, [pc, #60]	; (41054c <IM_param_tune1_init+0x7c>)
	im_tune1_comm = menue_drive_motor_tune;
  410510:	702e      	strb	r6, [r5, #0]
	IM_TUNE_PERIOD = IM_TUNE1_PERIOD;
  410512:	6011      	str	r1, [r2, #0]
	inverter_set_dead_comp(0);
  410514:	4798      	blx	r3
	IM_init_tune_param();
  410516:	4b0e      	ldr	r3, [pc, #56]	; (410550 <IM_param_tune1_init+0x80>)

}
  410518:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	IM_init_tune_param();
  41051c:	4718      	bx	r3
  41051e:	bf00      	nop
  410520:	667f3bcd 	.word	0x667f3bcd
  410524:	3ff6a09e 	.word	0x3ff6a09e
  410528:	20404ff0 	.word	0x20404ff0
  41052c:	204009c4 	.word	0x204009c4
  410530:	004187f1 	.word	0x004187f1
  410534:	00418749 	.word	0x00418749
  410538:	20400370 	.word	0x20400370
  41053c:	00418da1 	.word	0x00418da1
  410540:	204008e9 	.word	0x204008e9
  410544:	204009cc 	.word	0x204009cc
  410548:	2040645c 	.word	0x2040645c
  41054c:	004153dd 	.word	0x004153dd
  410550:	00410209 	.word	0x00410209

00410554 <IM_param_tune1_getMdata>:

float IM_param_tune1_getMdata(void)
{
	return lm_h;
  410554:	4b01      	ldr	r3, [pc, #4]	; (41055c <IM_param_tune1_getMdata+0x8>)
  410556:	6818      	ldr	r0, [r3, #0]
  410558:	4770      	bx	lr
  41055a:	bf00      	nop
  41055c:	20406498 	.word	0x20406498

00410560 <pm_param_tune1_init>:
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
}

uint8_t pm_tune_comm = 0, start_pm_tune = 1;
void pm_param_tune1_init(void)
{
  410560:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	reg_pi_init(menue_drive_data_applied.m_ACRD_p, menue_drive_data_applied.m_ACRD_i, &pi_d);
  410564:	4c1c      	ldr	r4, [pc, #112]	; (4105d8 <pm_param_tune1_init+0x78>)
	
	motor_test_current = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current / sqrt(8));
	pm_tune_comm = menue_drive_motor_tune;
	pm_param_tune_stage = 0;
  410566:	2500      	movs	r5, #0
	reg_pi_init(menue_drive_data_applied.m_ACRD_p, menue_drive_data_applied.m_ACRD_i, &pi_d);
  410568:	4a1c      	ldr	r2, [pc, #112]	; (4105dc <pm_param_tune1_init+0x7c>)
  41056a:	6f61      	ldr	r1, [r4, #116]	; 0x74
  41056c:	6f20      	ldr	r0, [r4, #112]	; 0x70
  41056e:	4b1c      	ldr	r3, [pc, #112]	; (4105e0 <pm_param_tune1_init+0x80>)
  410570:	4798      	blx	r3
	motor_test_current = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current / sqrt(8));
  410572:	6960      	ldr	r0, [r4, #20]
  410574:	4b1b      	ldr	r3, [pc, #108]	; (4105e4 <pm_param_tune1_init+0x84>)
  410576:	4798      	blx	r3
  410578:	4f1b      	ldr	r7, [pc, #108]	; (4105e8 <pm_param_tune1_init+0x88>)
  41057a:	4e1c      	ldr	r6, [pc, #112]	; (4105ec <pm_param_tune1_init+0x8c>)
  41057c:	a314      	add	r3, pc, #80	; (adr r3, 4105d0 <pm_param_tune1_init+0x70>)
  41057e:	e9d3 2300 	ldrd	r2, r3, [r3]
  410582:	47b8      	blx	r7
  410584:	4b1a      	ldr	r3, [pc, #104]	; (4105f0 <pm_param_tune1_init+0x90>)
  410586:	4798      	blx	r3
	pm_tune_comm = menue_drive_motor_tune;
  410588:	4b1a      	ldr	r3, [pc, #104]	; (4105f4 <pm_param_tune1_init+0x94>)
  41058a:	491b      	ldr	r1, [pc, #108]	; (4105f8 <pm_param_tune1_init+0x98>)
  41058c:	f893 e000 	ldrb.w	lr, [r3]
	stg_timeout_counter = 0;
	vms = 0;
  410590:	2300      	movs	r3, #0
	pm_param_tune_stage = 0;
  410592:	4a1a      	ldr	r2, [pc, #104]	; (4105fc <pm_param_tune1_init+0x9c>)
	motor_test_current = fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current / sqrt(8));
  410594:	6030      	str	r0, [r6, #0]
	pm_tune_comm = menue_drive_motor_tune;
  410596:	f881 e000 	strb.w	lr, [r1]
	stg_timeout_counter = 0;
  41059a:	4f19      	ldr	r7, [pc, #100]	; (410600 <pm_param_tune1_init+0xa0>)
	vms = 0;
  41059c:	4e19      	ldr	r6, [pc, #100]	; (410604 <pm_param_tune1_init+0xa4>)
	ims = 0;
  41059e:	491a      	ldr	r1, [pc, #104]	; (410608 <pm_param_tune1_init+0xa8>)
	pm_param_tune_stage = 0;
  4105a0:	7015      	strb	r5, [r2, #0]
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (menue_drive_data_applied.m_pole_pos_offset);
  4105a2:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
  4105a6:	4a19      	ldr	r2, [pc, #100]	; (41060c <pm_param_tune1_init+0xac>)
	vms = 0;
  4105a8:	6033      	str	r3, [r6, #0]
	stg_timeout_counter = 0;
  4105aa:	603d      	str	r5, [r7, #0]
	ims = 0;
  4105ac:	600b      	str	r3, [r1, #0]
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (menue_drive_data_applied.m_pole_pos_offset);
  4105ae:	4790      	blx	r2
  4105b0:	edd4 7a2d 	vldr	s15, [r4, #180]	; 0xb4
	start_pm_tune = 0;
	axt_set_theta(flux_angle);
  4105b4:	ee07 0a10 	vmov	s14, r0
	start_pm_tune = 0;
  4105b8:	4a15      	ldr	r2, [pc, #84]	; (410610 <pm_param_tune1_init+0xb0>)
	axt_set_theta(flux_angle);
  4105ba:	ee77 7a27 	vadd.f32	s15, s14, s15
  4105be:	4b15      	ldr	r3, [pc, #84]	; (410614 <pm_param_tune1_init+0xb4>)
	start_pm_tune = 0;
  4105c0:	7015      	strb	r5, [r2, #0]
	axt_set_theta(flux_angle);
  4105c2:	ee17 0a90 	vmov	r0, s15
}
  4105c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	axt_set_theta(flux_angle);
  4105ca:	4718      	bx	r3
  4105cc:	f3af 8000 	nop.w
  4105d0:	667f3bcc 	.word	0x667f3bcc
  4105d4:	3ee6a09e 	.word	0x3ee6a09e
  4105d8:	20404ff0 	.word	0x20404ff0
  4105dc:	204064b4 	.word	0x204064b4
  4105e0:	0040a8fd 	.word	0x0040a8fd
  4105e4:	00418725 	.word	0x00418725
  4105e8:	004187f1 	.word	0x004187f1
  4105ec:	204064e0 	.word	0x204064e0
  4105f0:	00418da1 	.word	0x00418da1
  4105f4:	204008e9 	.word	0x204008e9
  4105f8:	204009da 	.word	0x204009da
  4105fc:	204009d9 	.word	0x204009d9
  410600:	204009dc 	.word	0x204009dc
  410604:	204064e4 	.word	0x204064e4
  410608:	204064cc 	.word	0x204064cc
  41060c:	004132bd 	.word	0x004132bd
  410610:	20400374 	.word	0x20400374
  410614:	0040e1f9 	.word	0x0040e1f9

00410618 <PM_update_measured_data_vector>:
float pa[2][2]; //covariance matricies
float phi_a[2]; //measured data vectors
float g_a[2]; //gains vecotrs

void PM_update_measured_data_vector(float v, float i)
{
  410618:	b410      	push	{r4}
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  41061a:	4a15      	ldr	r2, [pc, #84]	; (410670 <PM_update_measured_data_vector+0x58>)
{
  41061c:	ee06 1a90 	vmov	s13, r1
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  410620:	4c14      	ldr	r4, [pc, #80]	; (410674 <PM_update_measured_data_vector+0x5c>)
{
  410622:	ee05 0a90 	vmov	s11, r0
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  410626:	edd2 7a00 	vldr	s15, [r2]
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  41062a:	ed94 7a00 	vldr	s14, [r4]
  41062e:	4b12      	ldr	r3, [pc, #72]	; (410678 <PM_update_measured_data_vector+0x60>)
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  410630:	ee76 7aa7 	vadd.f32	s15, s13, s15
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  410634:	ee35 7a87 	vadd.f32	s14, s11, s14
  410638:	4910      	ldr	r1, [pc, #64]	; (41067c <PM_update_measured_data_vector+0x64>)
  41063a:	ed93 5a00 	vldr	s10, [r3]
  41063e:	4b10      	ldr	r3, [pc, #64]	; (410680 <PM_update_measured_data_vector+0x68>)
  410640:	ee27 7a05 	vmul.f32	s14, s14, s10
  410644:	ed91 6a00 	vldr	s12, [r1]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  410648:	ee67 7a85 	vmul.f32	s15, s15, s10
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  41064c:	edd3 4a00 	vldr	s9, [r3]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  410650:	ed93 5a01 	vldr	s10, [r3, #4]
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  410654:	eea4 7a86 	vfma.f32	s14, s9, s12
	
	prev_i = i;
  410658:	edc2 6a00 	vstr	s13, [r2]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  41065c:	eee6 7a05 	vfma.f32	s15, s12, s10
	prev_v = v;
  410660:	6020      	str	r0, [r4, #0]
	phi_a[0] = (c0 * phi_a[0]) + (c1 * v) + (c2 * prev_v);
  410662:	ed83 7a00 	vstr	s14, [r3]
	phi_a[1] = (c0 * phi_a[1]) + (c1 * i) + (c2 * prev_i);
  410666:	edc3 7a01 	vstr	s15, [r3, #4]
}
  41066a:	f85d 4b04 	ldr.w	r4, [sp], #4
  41066e:	4770      	bx	lr
  410670:	20406468 	.word	0x20406468
  410674:	20406460 	.word	0x20406460
  410678:	2040647c 	.word	0x2040647c
  41067c:	20406478 	.word	0x20406478
  410680:	20406488 	.word	0x20406488

00410684 <PM_update_gains_vector>:
void PM_update_gains_vector(void)
{
	float tmp[2], tmp1;
	
	//update gain1
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  410684:	4b13      	ldr	r3, [pc, #76]	; (4106d4 <PM_update_gains_vector+0x50>)
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
	
	tmp1 = ((phi_a[0] * tmp[0]) + (phi_a[1] * tmp[1]));
	tmp1 += (1.0f);
  410686:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  41068a:	4a13      	ldr	r2, [pc, #76]	; (4106d8 <PM_update_gains_vector+0x54>)
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  41068c:	ed93 7a03 	vldr	s14, [r3, #12]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  410690:	edd2 7a01 	vldr	s15, [r2, #4]
  410694:	ed92 6a00 	vldr	s12, [r2]
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  410698:	ee27 7a87 	vmul.f32	s14, s15, s14
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  41069c:	edd3 6a01 	vldr	s13, [r3, #4]
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  4106a0:	edd3 4a02 	vldr	s9, [r3, #8]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  4106a4:	ee67 6aa6 	vmul.f32	s13, s15, s13
  4106a8:	ed93 5a00 	vldr	s10, [r3]
	tmp[1] = (phi_a[0] * pa[1][0]) + (phi_a[1] * pa[1][1]);
  4106ac:	eea6 7a24 	vfma.f32	s14, s12, s9
	
	g_a[0] = tmp[0] / tmp1;
  4106b0:	4b0a      	ldr	r3, [pc, #40]	; (4106dc <PM_update_gains_vector+0x58>)
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[0][1]);
  4106b2:	eee6 6a05 	vfma.f32	s13, s12, s10
	tmp1 = ((phi_a[0] * tmp[0]) + (phi_a[1] * tmp[1]));
  4106b6:	ee67 7a87 	vmul.f32	s15, s15, s14
  4106ba:	eee6 7a26 	vfma.f32	s15, s12, s13
	tmp1 += (1.0f);
  4106be:	ee77 7aa5 	vadd.f32	s15, s15, s11
	g_a[0] = tmp[0] / tmp1;
  4106c2:	ee86 6aa7 	vdiv.f32	s12, s13, s15
	g_a[1] = tmp[1] / tmp1;
  4106c6:	eec7 6a27 	vdiv.f32	s13, s14, s15
	g_a[0] = tmp[0] / tmp1;
  4106ca:	ed83 6a00 	vstr	s12, [r3]
	g_a[1] = tmp[1] / tmp1;
  4106ce:	edc3 6a01 	vstr	s13, [r3, #4]
  4106d2:	4770      	bx	lr
  4106d4:	2040649c 	.word	0x2040649c
  4106d8:	20406488 	.word	0x20406488
  4106dc:	20406490 	.word	0x20406490

004106e0 <PM_update_covariance_matrix>:
void PM_update_covariance_matrix(void)
{
	float tmp[2];
	
	//update cov1
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  4106e0:	4b17      	ldr	r3, [pc, #92]	; (410740 <PM_update_covariance_matrix+0x60>)
  4106e2:	4a18      	ldr	r2, [pc, #96]	; (410744 <PM_update_covariance_matrix+0x64>)
  4106e4:	edd3 5a02 	vldr	s11, [r3, #8]
  4106e8:	edd2 7a01 	vldr	s15, [r2, #4]
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  4106ec:	edd3 6a03 	vldr	s13, [r3, #12]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  4106f0:	ee27 7aa5 	vmul.f32	s14, s15, s11
  4106f4:	edd2 4a00 	vldr	s9, [r2]
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  4106f8:	ee67 7aa6 	vmul.f32	s15, s15, s13
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  4106fc:	ed93 5a00 	vldr	s10, [r3]
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  410700:	ed93 6a01 	vldr	s12, [r3, #4]
	tmp[0] = (phi_a[0] * pa[0][0]) + (phi_a[1] * pa[1][0]);
  410704:	eea4 7a85 	vfma.f32	s14, s9, s10
	
	pa[0][0] -= tmp[0] * g_a[0];
  410708:	4a0f      	ldr	r2, [pc, #60]	; (410748 <PM_update_covariance_matrix+0x68>)
	tmp[1] = (phi_a[0] * pa[0][1]) + (phi_a[1] * pa[1][1]);
  41070a:	eee4 7a86 	vfma.f32	s15, s9, s12
	pa[0][0] -= tmp[0] * g_a[0];
  41070e:	ed92 4a00 	vldr	s8, [r2]
	pa[0][1] -= tmp[1] * g_a[0];
	pa[1][0] -= tmp[0] * g_a[1];
  410712:	edd2 4a01 	vldr	s9, [r2, #4]
	pa[0][0] -= tmp[0] * g_a[0];
  410716:	eeb1 7a47 	vneg.f32	s14, s14
	pa[0][1] -= tmp[1] * g_a[0];
  41071a:	eef1 7a67 	vneg.f32	s15, s15
	pa[0][0] -= tmp[0] * g_a[0];
  41071e:	eea7 5a04 	vfma.f32	s10, s14, s8
	pa[1][0] -= tmp[0] * g_a[1];
  410722:	eee7 5a24 	vfma.f32	s11, s14, s9
	pa[0][1] -= tmp[1] * g_a[0];
  410726:	eea7 6a84 	vfma.f32	s12, s15, s8
	pa[1][1] -= tmp[1] * g_a[1];
  41072a:	eee7 6aa4 	vfma.f32	s13, s15, s9
	pa[0][0] -= tmp[0] * g_a[0];
  41072e:	ed83 5a00 	vstr	s10, [r3]
	pa[1][0] -= tmp[0] * g_a[1];
  410732:	edc3 5a02 	vstr	s11, [r3, #8]
	pa[0][1] -= tmp[1] * g_a[0];
  410736:	ed83 6a01 	vstr	s12, [r3, #4]
	pa[1][1] -= tmp[1] * g_a[1];
  41073a:	edc3 6a03 	vstr	s13, [r3, #12]
  41073e:	4770      	bx	lr
  410740:	2040649c 	.word	0x2040649c
  410744:	20406488 	.word	0x20406488
  410748:	20406490 	.word	0x20406490
  41074c:	00000000 	.word	0x00000000

00410750 <PM_save_estimated_motor_parameters>:
uint8_t pm_tune2_comm = 0;
void PM_save_estimated_motor_parameters(void)
{
	menue_drive_data_setup.m_motor_stator_resistance = rs_h;
	menue_drive_data_setup.m_motor_LD = ld_h * 1000;
	menue_drive_data_setup.m_motor_LQ = lq_h * 1000;
  410750:	4b3b      	ldr	r3, [pc, #236]	; (410840 <PM_save_estimated_motor_parameters+0xf0>)
	menue_drive_data_setup.m_motor_LD = ld_h * 1000;
  410752:	4a3c      	ldr	r2, [pc, #240]	; (410844 <PM_save_estimated_motor_parameters+0xf4>)
{
  410754:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  410758:	ed2d 8b04 	vpush	{d8-d9}
	menue_drive_data_setup.m_motor_LQ = lq_h * 1000;
  41075c:	ed93 8a00 	vldr	s16, [r3]
	if (pm_tune2_comm > 1) pm_tune2_calc_PI();
  410760:	4b39      	ldr	r3, [pc, #228]	; (410848 <PM_save_estimated_motor_parameters+0xf8>)
	menue_drive_data_setup.m_motor_LD = ld_h * 1000;
  410762:	edd2 8a00 	vldr	s17, [r2]
  410766:	ed9f 9a39 	vldr	s18, [pc, #228]	; 41084c <PM_save_estimated_motor_parameters+0xfc>
	menue_drive_data_setup.m_motor_stator_resistance = rs_h;
  41076a:	4a39      	ldr	r2, [pc, #228]	; (410850 <PM_save_estimated_motor_parameters+0x100>)
	if (pm_tune2_comm > 1) pm_tune2_calc_PI();
  41076c:	f893 8000 	ldrb.w	r8, [r3]
	menue_drive_data_setup.m_motor_LD = ld_h * 1000;
  410770:	ee68 8a89 	vmul.f32	s17, s17, s18
	menue_drive_data_setup.m_motor_LQ = lq_h * 1000;
  410774:	ee28 8a09 	vmul.f32	s16, s16, s18
	menue_drive_data_setup.m_motor_stator_resistance = rs_h;
  410778:	4c36      	ldr	r4, [pc, #216]	; (410854 <PM_save_estimated_motor_parameters+0x104>)
  41077a:	6810      	ldr	r0, [r2, #0]
	if (pm_tune2_comm > 1) pm_tune2_calc_PI();
  41077c:	f1b8 0f01 	cmp.w	r8, #1
	menue_drive_data_setup.m_motor_LD = ld_h * 1000;
  410780:	edc4 8a0a 	vstr	s17, [r4, #40]	; 0x28
	menue_drive_data_setup.m_motor_LQ = lq_h * 1000;
  410784:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
	menue_drive_data_setup.m_motor_stator_resistance = rs_h;
  410788:	61e0      	str	r0, [r4, #28]
	if (pm_tune2_comm > 1) pm_tune2_calc_PI();
  41078a:	d949      	bls.n	410820 <PM_save_estimated_motor_parameters+0xd0>
	menue_drive_data_setup.m_ACRD_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_stator_resistance * 10000;
  41078c:	4d32      	ldr	r5, [pc, #200]	; (410858 <PM_save_estimated_motor_parameters+0x108>)
  41078e:	47a8      	blx	r5
  410790:	4f32      	ldr	r7, [pc, #200]	; (41085c <PM_save_estimated_motor_parameters+0x10c>)
  410792:	4e33      	ldr	r6, [pc, #204]	; (410860 <PM_save_estimated_motor_parameters+0x110>)
  410794:	a324      	add	r3, pc, #144	; (adr r3, 410828 <PM_save_estimated_motor_parameters+0xd8>)
  410796:	e9d3 2300 	ldrd	r2, r3, [r3]
  41079a:	47b8      	blx	r7
  41079c:	47b0      	blx	r6
  41079e:	4681      	mov	r9, r0
	menue_drive_data_setup.m_ACRD_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_LD * 1000;
  4107a0:	ee18 0a90 	vmov	r0, s17
	menue_drive_data_setup.m_ACRD_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_stator_resistance * 10000;
  4107a4:	f8c4 9074 	str.w	r9, [r4, #116]	; 0x74
	menue_drive_data_setup.m_ACRD_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_LD * 1000;
  4107a8:	47a8      	blx	r5
  4107aa:	a321      	add	r3, pc, #132	; (adr r3, 410830 <PM_save_estimated_motor_parameters+0xe0>)
  4107ac:	e9d3 2300 	ldrd	r2, r3, [r3]
  4107b0:	47b8      	blx	r7
  4107b2:	47b0      	blx	r6
	menue_drive_data_setup.m_ACRQ_i = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_stator_resistance * 10000;
  4107b4:	f8c4 907c 	str.w	r9, [r4, #124]	; 0x7c
	menue_drive_data_setup.m_ACRD_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_LD * 1000;
  4107b8:	6720      	str	r0, [r4, #112]	; 0x70
	menue_drive_data_setup.m_ACRQ_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_LQ * 1000;
  4107ba:	ee18 0a10 	vmov	r0, s16
  4107be:	47a8      	blx	r5
  4107c0:	a31b      	add	r3, pc, #108	; (adr r3, 410830 <PM_save_estimated_motor_parameters+0xe0>)
  4107c2:	e9d3 2300 	ldrd	r2, r3, [r3]
  4107c6:	47b8      	blx	r7
  4107c8:	47b0      	blx	r6
	if (pm_tune2_comm > 2) pm_tune2_calc_ke();
  4107ca:	f1b8 0f02 	cmp.w	r8, #2
	menue_drive_data_setup.m_ACRQ_p = TUNE_OMEGA * TUNE_CONTROLLER_BANDWIDTH * menue_drive_data_setup.m_motor_LQ * 1000;
  4107ce:	67a0      	str	r0, [r4, #120]	; 0x78
	if (pm_tune2_comm > 2) pm_tune2_calc_ke();
  4107d0:	d026      	beq.n	410820 <PM_save_estimated_motor_parameters+0xd0>
	float ke = menue_drive_data_applied.m_motor_rated_power * 1000;
  4107d2:	f8df a094 	ldr.w	sl, [pc, #148]	; 410868 <PM_save_estimated_motor_parameters+0x118>
  4107d6:	edda 7a01 	vldr	s15, [sl, #4]
	ke /= sqrt(6) * PI * fixedpt_tofloat(fixedpt_mul(menue_drive_data_applied.m_motor_rated_freq, menue_drive_data_applied.m_motor_rated_current));
  4107da:	ee67 7a89 	vmul.f32	s15, s15, s18
  4107de:	ee17 0a90 	vmov	r0, s15
  4107e2:	47a8      	blx	r5
  4107e4:	f8da 2008 	ldr.w	r2, [sl, #8]
  4107e8:	f8da 3014 	ldr.w	r3, [sl, #20]
  4107ec:	4680      	mov	r8, r0
  4107ee:	4689      	mov	r9, r1
  4107f0:	fb82 2303 	smull	r2, r3, r2, r3
  4107f4:	0bd0      	lsrs	r0, r2, #15
  4107f6:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
  4107fa:	ee07 0a90 	vmov	s15, r0
  4107fe:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
  410802:	ee17 0a90 	vmov	r0, s15
  410806:	47a8      	blx	r5
  410808:	4d16      	ldr	r5, [pc, #88]	; (410864 <PM_save_estimated_motor_parameters+0x114>)
  41080a:	a30b      	add	r3, pc, #44	; (adr r3, 410838 <PM_save_estimated_motor_parameters+0xe8>)
  41080c:	e9d3 2300 	ldrd	r2, r3, [r3]
  410810:	47b8      	blx	r7
  410812:	4602      	mov	r2, r0
  410814:	460b      	mov	r3, r1
  410816:	4640      	mov	r0, r8
  410818:	4649      	mov	r1, r9
  41081a:	47a8      	blx	r5
  41081c:	47b0      	blx	r6
  41081e:	63a0      	str	r0, [r4, #56]	; 0x38
}
  410820:	ecbd 8b04 	vpop	{d8-d9}
  410824:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  410828:	90000000 	.word	0x90000000
  41082c:	404197c9 	.word	0x404197c9
  410830:	4ccccccc 	.word	0x4ccccccc
  410834:	400c260f 	.word	0x400c260f
  410838:	831fc574 	.word	0x831fc574
  41083c:	401ec7fc 	.word	0x401ec7fc
  410840:	204064fc 	.word	0x204064fc
  410844:	204064f8 	.word	0x204064f8
  410848:	204009e5 	.word	0x204009e5
  41084c:	447a0000 	.word	0x447a0000
  410850:	20406420 	.word	0x20406420
  410854:	204050e8 	.word	0x204050e8
  410858:	00418749 	.word	0x00418749
  41085c:	004187f1 	.word	0x004187f1
  410860:	00418da1 	.word	0x00418da1
  410864:	00418a45 	.word	0x00418a45
  410868:	20404ff0 	.word	0x20404ff0
  41086c:	00000000 	.word	0x00000000

00410870 <PM_stage1_tune>:



#define RS_FILTER (2)
void PM_stage1_tune(void)
{
  410870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	float com_ia, ia;
	ia = axt_get_ialpha();
  410874:	4b2e      	ldr	r3, [pc, #184]	; (410930 <PM_stage1_tune+0xc0>)
	com_ia /= FIXEDPT_ONE;
	com_ia *= 2 * 1.4;//1.5;
	
	
	//rs_h += ((va/ia) - rs_h) * (TSAMPLE / RS_FILTER);
	PM_update_measured_data_vector(va, ia);
  410876:	4c2f      	ldr	r4, [pc, #188]	; (410934 <PM_stage1_tune+0xc4>)
	com_ia *= 2 * 1.4;//1.5;
  410878:	4d2f      	ldr	r5, [pc, #188]	; (410938 <PM_stage1_tune+0xc8>)
{
  41087a:	ed2d 8b02 	vpush	{d8}
	ia = axt_get_ialpha();
  41087e:	4798      	blx	r3
	com_ia = menue_drive_data_applied.m_motor_rated_current;
  410880:	4a2e      	ldr	r2, [pc, #184]	; (41093c <PM_stage1_tune+0xcc>)
	ia = axt_get_ialpha();
  410882:	ee08 0a10 	vmov	s16, r0
	com_ia *= 2 * 1.4;//1.5;
  410886:	4b2e      	ldr	r3, [pc, #184]	; (410940 <PM_stage1_tune+0xd0>)
	com_ia = menue_drive_data_applied.m_motor_rated_current;
  410888:	6950      	ldr	r0, [r2, #20]
	com_ia *= 2 * 1.4;//1.5;
  41088a:	ee07 0a90 	vmov	s15, r0
  41088e:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
  410892:	ee17 0a90 	vmov	r0, s15
  410896:	4798      	blx	r3
  410898:	a323      	add	r3, pc, #140	; (adr r3, 410928 <PM_stage1_tune+0xb8>)
  41089a:	e9d3 2300 	ldrd	r2, r3, [r3]
  41089e:	47a8      	blx	r5
	PM_update_measured_data_vector(va, ia);
  4108a0:	4b28      	ldr	r3, [pc, #160]	; (410944 <PM_stage1_tune+0xd4>)
	com_ia *= 2 * 1.4;//1.5;
  4108a2:	4606      	mov	r6, r0
  4108a4:	460f      	mov	r7, r1
	PM_update_measured_data_vector(va, ia);
  4108a6:	6820      	ldr	r0, [r4, #0]
  4108a8:	ee18 1a10 	vmov	r1, s16
  4108ac:	4798      	blx	r3
	PM_update_gains_vector();
  4108ae:	4b26      	ldr	r3, [pc, #152]	; (410948 <PM_stage1_tune+0xd8>)
  4108b0:	4798      	blx	r3
	PM_update_covariance_matrix();
  4108b2:	4b26      	ldr	r3, [pc, #152]	; (41094c <PM_stage1_tune+0xdc>)
  4108b4:	4798      	blx	r3
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4108b6:	4b26      	ldr	r3, [pc, #152]	; (410950 <PM_stage1_tune+0xe0>)
  4108b8:	4a26      	ldr	r2, [pc, #152]	; (410954 <PM_stage1_tune+0xe4>)
	com_ia *= 2 * 1.4;//1.5;
  4108ba:	4639      	mov	r1, r7
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4108bc:	ed93 7a01 	vldr	s14, [r3, #4]
	com_ia *= 2 * 1.4;//1.5;
  4108c0:	4630      	mov	r0, r6
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4108c2:	edd2 7a01 	vldr	s15, [r2, #4]
  4108c6:	edd3 6a00 	vldr	s13, [r3]
  4108ca:	ee67 7a27 	vmul.f32	s15, s14, s15
	oerr = output - oerr;
  4108ce:	ed92 6a00 	vldr	s12, [r2]
	param_a[0] += g_a[0] * oerr;
  4108d2:	4a21      	ldr	r2, [pc, #132]	; (410958 <PM_stage1_tune+0xe8>)
	com_ia *= 2 * 1.4;//1.5;
  4108d4:	4d21      	ldr	r5, [pc, #132]	; (41095c <PM_stage1_tune+0xec>)
	oerr = output - oerr;
  4108d6:	eee6 7a26 	vfma.f32	s15, s12, s13
	param_a[0] += g_a[0] * oerr;
  4108da:	edd2 5a00 	vldr	s11, [r2]
	param_a[1] += g_a[1] * oerr;
  4108de:	ed92 6a01 	vldr	s12, [r2, #4]
	oerr = output - oerr;
  4108e2:	ee78 7a67 	vsub.f32	s15, s16, s15
	param_a[0] += g_a[0] * oerr;
  4108e6:	eee7 6aa5 	vfma.f32	s13, s15, s11
	param_a[1] += g_a[1] * oerr;
  4108ea:	eea7 7a86 	vfma.f32	s14, s15, s12
	param_a[0] += g_a[0] * oerr;
  4108ee:	edc3 6a00 	vstr	s13, [r3]
	param_a[1] += g_a[1] * oerr;
  4108f2:	ed83 7a01 	vstr	s14, [r3, #4]
	com_ia *= 2 * 1.4;//1.5;
  4108f6:	47a8      	blx	r5
	PM_update_parameters_vector(ia);
	
	va = (com_ia - ia) * Pgain;
  4108f8:	ee07 0a90 	vmov	s15, r0
	
	//dacc_interface_writeData(0, com_ia/*est_out*/, 10, 1);
	
	inverter_out_rect((va * FIXEDPT_ONE), 0);
  4108fc:	2100      	movs	r1, #0
  4108fe:	4b18      	ldr	r3, [pc, #96]	; (410960 <PM_stage1_tune+0xf0>)
	va = (com_ia - ia) * Pgain;
  410900:	ee37 8ac8 	vsub.f32	s16, s15, s16
  410904:	eddf 7a17 	vldr	s15, [pc, #92]	; 410964 <PM_stage1_tune+0xf4>
  410908:	ee28 8a27 	vmul.f32	s16, s16, s15
	inverter_out_rect((va * FIXEDPT_ONE), 0);
  41090c:	eef0 7a48 	vmov.f32	s15, s16
	va = (com_ia - ia) * Pgain;
  410910:	ed84 8a00 	vstr	s16, [r4]
}
  410914:	ecbd 8b02 	vpop	{d8}
	inverter_out_rect((va * FIXEDPT_ONE), 0);
  410918:	eefe 7ae8 	vcvt.s32.f32	s15, s15, #15
}
  41091c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	inverter_out_rect((va * FIXEDPT_ONE), 0);
  410920:	ee17 0a90 	vmov	r0, s15
  410924:	4718      	bx	r3
  410926:	bf00      	nop
  410928:	66666666 	.word	0x66666666
  41092c:	40066666 	.word	0x40066666
  410930:	0040e2e9 	.word	0x0040e2e9
  410934:	20406454 	.word	0x20406454
  410938:	004187f1 	.word	0x004187f1
  41093c:	20404ff0 	.word	0x20404ff0
  410940:	00418749 	.word	0x00418749
  410944:	00410619 	.word	0x00410619
  410948:	00410685 	.word	0x00410685
  41094c:	004106e1 	.word	0x004106e1
  410950:	20406480 	.word	0x20406480
  410954:	20406488 	.word	0x20406488
  410958:	20406490 	.word	0x20406490
  41095c:	00418da1 	.word	0x00418da1
  410960:	00415191 	.word	0x00415191
  410964:	42200000 	.word	0x42200000

00410968 <PM_stage2_tune>:

#define PM_ANGLE_OFFSET menue_drive_data_applied.m_pole_pos_offset

void PM_stage2_tune(void)
{
  410968:	b570      	push	{r4, r5, r6, lr}
	float com_id, id;
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  41096a:	4c3d      	ldr	r4, [pc, #244]	; (410a60 <PM_stage2_tune+0xf8>)
  41096c:	4b3d      	ldr	r3, [pc, #244]	; (410a64 <PM_stage2_tune+0xfc>)
	
	com_id *= menue_drive_data_applied.m_motor_rated_current;
	com_id /= FIXEDPT_ONE;
	com_id /= 2;

	PM_update_measured_data_vector(va, id);
  41096e:	4d3e      	ldr	r5, [pc, #248]	; (410a68 <PM_stage2_tune+0x100>)
	
	va = (com_id - id) * Pgain;
	
	//dacc_interface_writeData(0, com_ia/*est_out*/, 20, 1);
	float valpha, vbeta;
	axt_ipark_exe( va, 0, &valpha, &vbeta );
  410970:	4e3e      	ldr	r6, [pc, #248]	; (410a6c <PM_stage2_tune+0x104>)
{
  410972:	ed2d 8b02 	vpush	{d8}
  410976:	b082      	sub	sp, #8
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  410978:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
  41097c:	4798      	blx	r3
  41097e:	edd4 7a2d 	vldr	s15, [r4, #180]	; 0xb4
	axt_set_theta(flux_angle);
  410982:	ee07 0a10 	vmov	s14, r0
  410986:	4b3a      	ldr	r3, [pc, #232]	; (410a70 <PM_stage2_tune+0x108>)
  410988:	ee77 7a27 	vadd.f32	s15, s14, s15
  41098c:	ee17 0a90 	vmov	r0, s15
  410990:	4798      	blx	r3
	axt_park_exe();
  410992:	4b38      	ldr	r3, [pc, #224]	; (410a74 <PM_stage2_tune+0x10c>)
  410994:	4798      	blx	r3
	id = axt_get_id();
  410996:	4b38      	ldr	r3, [pc, #224]	; (410a78 <PM_stage2_tune+0x110>)
  410998:	4798      	blx	r3
	com_id = com_id + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  41099a:	4b38      	ldr	r3, [pc, #224]	; (410a7c <PM_stage2_tune+0x114>)
  41099c:	eddf 7a38 	vldr	s15, [pc, #224]	; 410a80 <PM_stage2_tune+0x118>
	id = axt_get_id();
  4109a0:	ee08 0a10 	vmov	s16, r0
	com_id = com_id + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  4109a4:	ed93 7a00 	vldr	s14, [r3]
  4109a8:	4b36      	ldr	r3, [pc, #216]	; (410a84 <PM_stage2_tune+0x11c>)
  4109aa:	ee67 7a27 	vmul.f32	s15, s14, s15
  4109ae:	ee17 0a90 	vmov	r0, s15
  4109b2:	4798      	blx	r3
	com_id *= menue_drive_data_applied.m_motor_rated_current;
  4109b4:	edd4 3a05 	vldr	s7, [r4, #20]
	com_id = com_id + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  4109b8:	ee03 0a10 	vmov	s6, r0
	PM_update_measured_data_vector(va, id);
  4109bc:	ee18 1a10 	vmov	r1, s16
  4109c0:	6828      	ldr	r0, [r5, #0]
  4109c2:	eefa 3ac8 	vcvt.f32.s32	s7, s7, #16
  4109c6:	4b30      	ldr	r3, [pc, #192]	; (410a88 <PM_stage2_tune+0x120>)
  4109c8:	4798      	blx	r3
	PM_update_gains_vector();
  4109ca:	4b30      	ldr	r3, [pc, #192]	; (410a8c <PM_stage2_tune+0x124>)
  4109cc:	4798      	blx	r3
	PM_update_covariance_matrix();
  4109ce:	4b30      	ldr	r3, [pc, #192]	; (410a90 <PM_stage2_tune+0x128>)
  4109d0:	4798      	blx	r3
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4109d2:	4c30      	ldr	r4, [pc, #192]	; (410a94 <PM_stage2_tune+0x12c>)
  4109d4:	4930      	ldr	r1, [pc, #192]	; (410a98 <PM_stage2_tune+0x130>)
	com_id = com_id + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  4109d6:	eeb7 6a08 	vmov.f32	s12, #120	; 0x3fc00000  1.5
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4109da:	ed94 7a01 	vldr	s14, [r4, #4]
	axt_ipark_exe( va, 0, &valpha, &vbeta );
  4109de:	ab01      	add	r3, sp, #4
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4109e0:	edd1 7a01 	vldr	s15, [r1, #4]
	axt_ipark_exe( va, 0, &valpha, &vbeta );
  4109e4:	466a      	mov	r2, sp
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4109e6:	edd4 6a00 	vldr	s13, [r4]
	com_id = com_id + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  4109ea:	ee33 3a06 	vadd.f32	s6, s6, s12
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  4109ee:	ee67 7a27 	vmul.f32	s15, s14, s15
	oerr = output - oerr;
  4109f2:	edd1 5a00 	vldr	s11, [r1]
	va = (com_id - id) * Pgain;
  4109f6:	eeb0 6a48 	vmov.f32	s12, s16
	param_a[0] += g_a[0] * oerr;
  4109fa:	4928      	ldr	r1, [pc, #160]	; (410a9c <PM_stage2_tune+0x134>)
	va = (com_id - id) * Pgain;
  4109fc:	eddf 4a28 	vldr	s9, [pc, #160]	; 410aa0 <PM_stage2_tune+0x138>
	oerr = output - oerr;
  410a00:	eee5 7aa6 	vfma.f32	s15, s11, s13
	param_a[0] += g_a[0] * oerr;
  410a04:	ed91 5a00 	vldr	s10, [r1]
	va = (com_id - id) * Pgain;
  410a08:	ee93 6a23 	vfnms.f32	s12, s6, s7
	param_a[1] += g_a[1] * oerr;
  410a0c:	edd1 5a01 	vldr	s11, [r1, #4]
	axt_ipark_exe( va, 0, &valpha, &vbeta );
  410a10:	2100      	movs	r1, #0
	oerr = output - oerr;
  410a12:	ee38 8a67 	vsub.f32	s16, s16, s15
	va = (com_id - id) * Pgain;
  410a16:	ee26 6a24 	vmul.f32	s12, s12, s9
	param_a[0] += g_a[0] * oerr;
  410a1a:	eee8 6a05 	vfma.f32	s13, s16, s10
	param_a[1] += g_a[1] * oerr;
  410a1e:	eea8 7a25 	vfma.f32	s14, s16, s11
	axt_ipark_exe( va, 0, &valpha, &vbeta );
  410a22:	ee16 0a10 	vmov	r0, s12
	va = (com_id - id) * Pgain;
  410a26:	ed85 6a00 	vstr	s12, [r5]
	param_a[0] += g_a[0] * oerr;
  410a2a:	edc4 6a00 	vstr	s13, [r4]
	param_a[1] += g_a[1] * oerr;
  410a2e:	ed84 7a01 	vstr	s14, [r4, #4]
	axt_ipark_exe( va, 0, &valpha, &vbeta );
  410a32:	47b0      	blx	r6
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  410a34:	ed9d 7a01 	vldr	s14, [sp, #4]
  410a38:	eddd 7a00 	vldr	s15, [sp]
  410a3c:	eef0 6a47 	vmov.f32	s13, s14
  410a40:	4b18      	ldr	r3, [pc, #96]	; (410aa4 <PM_stage2_tune+0x13c>)
  410a42:	eeb0 7a67 	vmov.f32	s14, s15
  410a46:	eefe 6ae8 	vcvt.s32.f32	s13, s13, #15
  410a4a:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
  410a4e:	ee16 1a90 	vmov	r1, s13
  410a52:	ee17 0a10 	vmov	r0, s14
  410a56:	4798      	blx	r3
}
  410a58:	b002      	add	sp, #8
  410a5a:	ecbd 8b02 	vpop	{d8}
  410a5e:	bd70      	pop	{r4, r5, r6, pc}
  410a60:	20404ff0 	.word	0x20404ff0
  410a64:	004132bd 	.word	0x004132bd
  410a68:	20406454 	.word	0x20406454
  410a6c:	0040e301 	.word	0x0040e301
  410a70:	0040e1f9 	.word	0x0040e1f9
  410a74:	0040e23d 	.word	0x0040e23d
  410a78:	0040e2d1 	.word	0x0040e2d1
  410a7c:	204009e0 	.word	0x204009e0
  410a80:	449d1463 	.word	0x449d1463
  410a84:	00418141 	.word	0x00418141
  410a88:	00410619 	.word	0x00410619
  410a8c:	00410685 	.word	0x00410685
  410a90:	004106e1 	.word	0x004106e1
  410a94:	20406480 	.word	0x20406480
  410a98:	20406488 	.word	0x20406488
  410a9c:	20406490 	.word	0x20406490
  410aa0:	42200000 	.word	0x42200000
  410aa4:	00415191 	.word	0x00415191

00410aa8 <PM_stage3_tune>:

void PM_stage3_tune(void)
{
  410aa8:	b570      	push	{r4, r5, r6, lr}
	float com_iq, iq;
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  410aaa:	4c3d      	ldr	r4, [pc, #244]	; (410ba0 <PM_stage3_tune+0xf8>)
  410aac:	4b3d      	ldr	r3, [pc, #244]	; (410ba4 <PM_stage3_tune+0xfc>)
	
	com_iq *= menue_drive_data_applied.m_motor_rated_current;
	com_iq /= FIXEDPT_ONE;
	com_iq /= 2;

	PM_update_measured_data_vector(va, iq);
  410aae:	4d3e      	ldr	r5, [pc, #248]	; (410ba8 <PM_stage3_tune+0x100>)
	
	va = (com_iq - iq) * Pgain;
	
	//dacc_interface_writeData(0, com_ia/*est_out*/, 20, 1);
	float valpha, vbeta;
	axt_ipark_exe( 0, va, &valpha, &vbeta );
  410ab0:	4e3e      	ldr	r6, [pc, #248]	; (410bac <PM_stage3_tune+0x104>)
{
  410ab2:	ed2d 8b02 	vpush	{d8}
  410ab6:	b082      	sub	sp, #8
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  410ab8:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
  410abc:	4798      	blx	r3
  410abe:	edd4 7a2d 	vldr	s15, [r4, #180]	; 0xb4
	axt_set_theta(flux_angle);
  410ac2:	ee07 0a10 	vmov	s14, r0
  410ac6:	4b3a      	ldr	r3, [pc, #232]	; (410bb0 <PM_stage3_tune+0x108>)
  410ac8:	ee77 7a27 	vadd.f32	s15, s14, s15
  410acc:	ee17 0a90 	vmov	r0, s15
  410ad0:	4798      	blx	r3
	axt_park_exe();
  410ad2:	4b38      	ldr	r3, [pc, #224]	; (410bb4 <PM_stage3_tune+0x10c>)
  410ad4:	4798      	blx	r3
	iq = axt_get_iq();
  410ad6:	4b38      	ldr	r3, [pc, #224]	; (410bb8 <PM_stage3_tune+0x110>)
  410ad8:	4798      	blx	r3
	com_iq = com_iq + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  410ada:	4b38      	ldr	r3, [pc, #224]	; (410bbc <PM_stage3_tune+0x114>)
  410adc:	eddf 7a38 	vldr	s15, [pc, #224]	; 410bc0 <PM_stage3_tune+0x118>
	iq = axt_get_iq();
  410ae0:	ee08 0a10 	vmov	s16, r0
	com_iq = com_iq + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  410ae4:	ed93 7a00 	vldr	s14, [r3]
  410ae8:	4b36      	ldr	r3, [pc, #216]	; (410bc4 <PM_stage3_tune+0x11c>)
  410aea:	ee67 7a27 	vmul.f32	s15, s14, s15
  410aee:	ee17 0a90 	vmov	r0, s15
  410af2:	4798      	blx	r3
	com_iq *= menue_drive_data_applied.m_motor_rated_current;
  410af4:	edd4 3a05 	vldr	s7, [r4, #20]
	com_iq = com_iq + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  410af8:	ee03 0a10 	vmov	s6, r0
	PM_update_measured_data_vector(va, iq);
  410afc:	ee18 1a10 	vmov	r1, s16
  410b00:	6828      	ldr	r0, [r5, #0]
  410b02:	eefa 3ac8 	vcvt.f32.s32	s7, s7, #16
  410b06:	4b30      	ldr	r3, [pc, #192]	; (410bc8 <PM_stage3_tune+0x120>)
  410b08:	4798      	blx	r3
	PM_update_gains_vector();
  410b0a:	4b30      	ldr	r3, [pc, #192]	; (410bcc <PM_stage3_tune+0x124>)
  410b0c:	4798      	blx	r3
	PM_update_covariance_matrix();
  410b0e:	4b30      	ldr	r3, [pc, #192]	; (410bd0 <PM_stage3_tune+0x128>)
  410b10:	4798      	blx	r3
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  410b12:	4c30      	ldr	r4, [pc, #192]	; (410bd4 <PM_stage3_tune+0x12c>)
  410b14:	4930      	ldr	r1, [pc, #192]	; (410bd8 <PM_stage3_tune+0x130>)
	com_iq = com_iq + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  410b16:	eeb7 6a08 	vmov.f32	s12, #120	; 0x3fc00000  1.5
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  410b1a:	ed94 7a01 	vldr	s14, [r4, #4]
	axt_ipark_exe( 0, va, &valpha, &vbeta );
  410b1e:	ab01      	add	r3, sp, #4
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  410b20:	edd1 7a01 	vldr	s15, [r1, #4]
	axt_ipark_exe( 0, va, &valpha, &vbeta );
  410b24:	466a      	mov	r2, sp
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  410b26:	edd4 6a00 	vldr	s13, [r4]
	com_iq = com_iq + 1 * arm_sin_f32(SIG2_FREQ * PM_time_lapse);
  410b2a:	ee33 3a06 	vadd.f32	s6, s6, s12
	oerr = ((phi_a[0] * param_a[0] + phi_a[1] * param_a[1]));
  410b2e:	ee67 7a27 	vmul.f32	s15, s14, s15
	oerr = output - oerr;
  410b32:	edd1 5a00 	vldr	s11, [r1]
	va = (com_iq - iq) * Pgain;
  410b36:	eeb0 6a48 	vmov.f32	s12, s16
	param_a[0] += g_a[0] * oerr;
  410b3a:	4928      	ldr	r1, [pc, #160]	; (410bdc <PM_stage3_tune+0x134>)
	va = (com_iq - iq) * Pgain;
  410b3c:	eddf 4a28 	vldr	s9, [pc, #160]	; 410be0 <PM_stage3_tune+0x138>
	axt_ipark_exe( 0, va, &valpha, &vbeta );
  410b40:	2000      	movs	r0, #0
	oerr = output - oerr;
  410b42:	eee5 7aa6 	vfma.f32	s15, s11, s13
	param_a[0] += g_a[0] * oerr;
  410b46:	ed91 5a00 	vldr	s10, [r1]
	va = (com_iq - iq) * Pgain;
  410b4a:	ee93 6a23 	vfnms.f32	s12, s6, s7
	param_a[1] += g_a[1] * oerr;
  410b4e:	edd1 5a01 	vldr	s11, [r1, #4]
	oerr = output - oerr;
  410b52:	ee38 8a67 	vsub.f32	s16, s16, s15
	va = (com_iq - iq) * Pgain;
  410b56:	ee26 6a24 	vmul.f32	s12, s12, s9
	param_a[0] += g_a[0] * oerr;
  410b5a:	eee8 6a05 	vfma.f32	s13, s16, s10
	param_a[1] += g_a[1] * oerr;
  410b5e:	eea8 7a25 	vfma.f32	s14, s16, s11
	axt_ipark_exe( 0, va, &valpha, &vbeta );
  410b62:	ee16 1a10 	vmov	r1, s12
	va = (com_iq - iq) * Pgain;
  410b66:	ed85 6a00 	vstr	s12, [r5]
	param_a[0] += g_a[0] * oerr;
  410b6a:	edc4 6a00 	vstr	s13, [r4]
	param_a[1] += g_a[1] * oerr;
  410b6e:	ed84 7a01 	vstr	s14, [r4, #4]
	axt_ipark_exe( 0, va, &valpha, &vbeta );
  410b72:	47b0      	blx	r6
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  410b74:	ed9d 7a01 	vldr	s14, [sp, #4]
  410b78:	eddd 7a00 	vldr	s15, [sp]
  410b7c:	eef0 6a47 	vmov.f32	s13, s14
  410b80:	4b18      	ldr	r3, [pc, #96]	; (410be4 <PM_stage3_tune+0x13c>)
  410b82:	eeb0 7a67 	vmov.f32	s14, s15
  410b86:	eefe 6ae8 	vcvt.s32.f32	s13, s13, #15
  410b8a:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
  410b8e:	ee16 1a90 	vmov	r1, s13
  410b92:	ee17 0a10 	vmov	r0, s14
  410b96:	4798      	blx	r3
}
  410b98:	b002      	add	sp, #8
  410b9a:	ecbd 8b02 	vpop	{d8}
  410b9e:	bd70      	pop	{r4, r5, r6, pc}
  410ba0:	20404ff0 	.word	0x20404ff0
  410ba4:	004132bd 	.word	0x004132bd
  410ba8:	20406454 	.word	0x20406454
  410bac:	0040e301 	.word	0x0040e301
  410bb0:	0040e1f9 	.word	0x0040e1f9
  410bb4:	0040e23d 	.word	0x0040e23d
  410bb8:	0040e2dd 	.word	0x0040e2dd
  410bbc:	204009e0 	.word	0x204009e0
  410bc0:	449d1463 	.word	0x449d1463
  410bc4:	00418141 	.word	0x00418141
  410bc8:	00410619 	.word	0x00410619
  410bcc:	00410685 	.word	0x00410685
  410bd0:	004106e1 	.word	0x004106e1
  410bd4:	20406480 	.word	0x20406480
  410bd8:	20406488 	.word	0x20406488
  410bdc:	20406490 	.word	0x20406490
  410be0:	42200000 	.word	0x42200000
  410be4:	00415191 	.word	0x00415191

00410be8 <PM_init_tune_param>:
	prev_v = 0;
	prev_i = 0;
	va = 0;
	
	//init constants
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410be8:	4b19      	ldr	r3, [pc, #100]	; (410c50 <PM_init_tune_param+0x68>)
  410bea:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
  410bee:	eddf 6a19 	vldr	s13, [pc, #100]	; 410c54 <PM_init_tune_param+0x6c>
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410bf2:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
	prev_v = 0;
  410bf6:	4a18      	ldr	r2, [pc, #96]	; (410c58 <PM_init_tune_param+0x70>)
	prev_i = 0;
  410bf8:	4818      	ldr	r0, [pc, #96]	; (410c5c <PM_init_tune_param+0x74>)
	va = 0;
  410bfa:	4919      	ldr	r1, [pc, #100]	; (410c60 <PM_init_tune_param+0x78>)
{
  410bfc:	b470      	push	{r4, r5, r6}
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410bfe:	edd3 7a00 	vldr	s15, [r3]
	PM_time_lapse = 0;
  410c02:	2300      	movs	r3, #0
  410c04:	4c17      	ldr	r4, [pc, #92]	; (410c64 <PM_init_tune_param+0x7c>)
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410c06:	ee86 6aa7 	vdiv.f32	s12, s13, s15
	prev_v = 0;
  410c0a:	6013      	str	r3, [r2, #0]
	PM_time_lapse = 0;
  410c0c:	6023      	str	r3, [r4, #0]
	// init parameter vectors a to 0
	param_a[0] = 0;
	param_a[1] = 0;
	
	// init covariance matrix a to seg2 * I
	pa[0][0] = seg_sqr;
  410c0e:	4a16      	ldr	r2, [pc, #88]	; (410c68 <PM_init_tune_param+0x80>)
	param_a[0] = 0;
  410c10:	4c16      	ldr	r4, [pc, #88]	; (410c6c <PM_init_tune_param+0x84>)
	va = 0;
  410c12:	600b      	str	r3, [r1, #0]
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410c14:	4d16      	ldr	r5, [pc, #88]	; (410c70 <PM_init_tune_param+0x88>)
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410c16:	4e17      	ldr	r6, [pc, #92]	; (410c74 <PM_init_tune_param+0x8c>)
	prev_i = 0;
  410c18:	6003      	str	r3, [r0, #0]
	pa[0][1] = 0;
	pa[1][0] = 0;
	pa[1][1] = seg_sqr;
	
	phi_a[0] = 0;
  410c1a:	4917      	ldr	r1, [pc, #92]	; (410c78 <PM_init_tune_param+0x90>)
	pa[0][0] = seg_sqr;
  410c1c:	4817      	ldr	r0, [pc, #92]	; (410c7c <PM_init_tune_param+0x94>)
	param_a[0] = 0;
  410c1e:	6023      	str	r3, [r4, #0]
	param_a[1] = 0;
  410c20:	6063      	str	r3, [r4, #4]
	pa[0][1] = 0;
  410c22:	6053      	str	r3, [r2, #4]
	pa[1][0] = 0;
  410c24:	6093      	str	r3, [r2, #8]
	pa[0][0] = seg_sqr;
  410c26:	6010      	str	r0, [r2, #0]
	pa[1][1] = seg_sqr;
  410c28:	60d0      	str	r0, [r2, #12]
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410c2a:	ee76 6a07 	vadd.f32	s13, s12, s14
	phi_a[0] = 0;
  410c2e:	600b      	str	r3, [r1, #0]
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410c30:	ee37 7a46 	vsub.f32	s14, s14, s12
	phi_a[1] = 0;
  410c34:	604b      	str	r3, [r1, #4]
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410c36:	ee67 7aa6 	vmul.f32	s15, s15, s13
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410c3a:	ee87 6a26 	vdiv.f32	s12, s14, s13
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410c3e:	ee85 7aa7 	vdiv.f32	s14, s11, s15
	cc0 = ((2 - h1*TSAMPLE) / (2 + h1*TSAMPLE));
  410c42:	ed86 6a00 	vstr	s12, [r6]
	cc1 = ((TSAMPLE) / (2 + h1*TSAMPLE));
  410c46:	ed85 7a00 	vstr	s14, [r5]
}
  410c4a:	bc70      	pop	{r4, r5, r6}
  410c4c:	4770      	bx	lr
  410c4e:	bf00      	nop
  410c50:	204003c8 	.word	0x204003c8
  410c54:	42b40000 	.word	0x42b40000
  410c58:	20406460 	.word	0x20406460
  410c5c:	20406468 	.word	0x20406468
  410c60:	20406454 	.word	0x20406454
  410c64:	204009e0 	.word	0x204009e0
  410c68:	2040649c 	.word	0x2040649c
  410c6c:	20406480 	.word	0x20406480
  410c70:	2040647c 	.word	0x2040647c
  410c74:	20406478 	.word	0x20406478
  410c78:	20406488 	.word	0x20406488
  410c7c:	4b095440 	.word	0x4b095440

00410c80 <PM_param_tune2_current_handler>:
float PM_stage_period;
#define PM_TUNE_PERIOD (PM_stage_period)

uint8_t PM_tune_stage = 0;
void PM_param_tune2_current_handler(void)
{
  410c80:	b570      	push	{r4, r5, r6, lr}
	if (PM_time_lapse < PM_TUNE_PERIOD)
  410c82:	4b3e      	ldr	r3, [pc, #248]	; (410d7c <PM_param_tune2_current_handler+0xfc>)
  410c84:	4c3e      	ldr	r4, [pc, #248]	; (410d80 <PM_param_tune2_current_handler+0x100>)
  410c86:	ed93 7a00 	vldr	s14, [r3]
  410c8a:	edd4 7a00 	vldr	s15, [r4]
  410c8e:	eef4 7ac7 	vcmpe.f32	s15, s14
  410c92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410c96:	d513      	bpl.n	410cc0 <PM_param_tune2_current_handler+0x40>
	{
		if(PM_tune_stage == 0) PM_stage1_tune();
  410c98:	4b3a      	ldr	r3, [pc, #232]	; (410d84 <PM_param_tune2_current_handler+0x104>)
  410c9a:	781b      	ldrb	r3, [r3, #0]
  410c9c:	2b00      	cmp	r3, #0
  410c9e:	d033      	beq.n	410d08 <PM_param_tune2_current_handler+0x88>
		else if(PM_tune_stage == 1) PM_stage2_tune();
  410ca0:	2b01      	cmp	r3, #1
  410ca2:	d04f      	beq.n	410d44 <PM_param_tune2_current_handler+0xc4>
		else if(PM_tune_stage == 2) PM_stage3_tune();
  410ca4:	2b02      	cmp	r3, #2
  410ca6:	d052      	beq.n	410d4e <PM_param_tune2_current_handler+0xce>
			pop_ups_add("Tune Successful", 1500);
		}
		
		return;
	}
	PM_time_lapse += TSAMPLE;
  410ca8:	4b37      	ldr	r3, [pc, #220]	; (410d88 <PM_param_tune2_current_handler+0x108>)
  410caa:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  410cae:	edd3 6a00 	vldr	s13, [r3]
  410cb2:	ee86 7a26 	vdiv.f32	s14, s12, s13
  410cb6:	ee77 7a27 	vadd.f32	s15, s14, s15
  410cba:	edc4 7a00 	vstr	s15, [r4]
  410cbe:	bd70      	pop	{r4, r5, r6, pc}
		if(PM_tune_stage == 0)
  410cc0:	4a30      	ldr	r2, [pc, #192]	; (410d84 <PM_param_tune2_current_handler+0x104>)
  410cc2:	7814      	ldrb	r4, [r2, #0]
  410cc4:	b32c      	cbz	r4, 410d12 <PM_param_tune2_current_handler+0x92>
		else if(PM_tune_stage == 1)
  410cc6:	2c01      	cmp	r4, #1
  410cc8:	d046      	beq.n	410d58 <PM_param_tune2_current_handler+0xd8>
		else if(PM_tune_stage == 2)
  410cca:	2c02      	cmp	r4, #2
  410ccc:	d00d      	beq.n	410cea <PM_param_tune2_current_handler+0x6a>
			vfd_estop();
  410cce:	4b2f      	ldr	r3, [pc, #188]	; (410d8c <PM_param_tune2_current_handler+0x10c>)
  410cd0:	4798      	blx	r3
			inverter_set_dead_comp(0);
  410cd2:	2000      	movs	r0, #0
  410cd4:	4b2e      	ldr	r3, [pc, #184]	; (410d90 <PM_param_tune2_current_handler+0x110>)
  410cd6:	4798      	blx	r3
			PM_save_estimated_motor_parameters();
  410cd8:	4b2e      	ldr	r3, [pc, #184]	; (410d94 <PM_param_tune2_current_handler+0x114>)
  410cda:	4798      	blx	r3
			pop_ups_add("Tune Successful", 1500);
  410cdc:	f240 51dc 	movw	r1, #1500	; 0x5dc
  410ce0:	482d      	ldr	r0, [pc, #180]	; (410d98 <PM_param_tune2_current_handler+0x118>)
  410ce2:	4b2e      	ldr	r3, [pc, #184]	; (410d9c <PM_param_tune2_current_handler+0x11c>)
}
  410ce4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			pop_ups_add("Tune Successful", 1500);
  410ce8:	4718      	bx	r3
	lq_h = 1 / param_a[0];
  410cea:	4c2d      	ldr	r4, [pc, #180]	; (410da0 <PM_param_tune2_current_handler+0x120>)
			PM_TUNE_PERIOD = PM_TUNE1_PERIOD;
  410cec:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	lq_h = 1 / param_a[0];
  410cf0:	492c      	ldr	r1, [pc, #176]	; (410da4 <PM_param_tune2_current_handler+0x124>)
			PM_tune_stage++;
  410cf2:	2003      	movs	r0, #3
	lq_h = 1 / param_a[0];
  410cf4:	edd4 6a00 	vldr	s13, [r4]
			PM_TUNE_PERIOD = PM_TUNE1_PERIOD;
  410cf8:	edc3 7a00 	vstr	s15, [r3]
	lq_h = 1 / param_a[0];
  410cfc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
			PM_tune_stage++;
  410d00:	7010      	strb	r0, [r2, #0]
	lq_h = 1 / param_a[0];
  410d02:	ed81 7a00 	vstr	s14, [r1]
  410d06:	bd70      	pop	{r4, r5, r6, pc}
		if(PM_tune_stage == 0) PM_stage1_tune();
  410d08:	4b27      	ldr	r3, [pc, #156]	; (410da8 <PM_param_tune2_current_handler+0x128>)
  410d0a:	4798      	blx	r3
  410d0c:	edd4 7a00 	vldr	s15, [r4]
  410d10:	e7ca      	b.n	410ca8 <PM_param_tune2_current_handler+0x28>
	rs_h = (h1 - param_a[1]) / param_a[0];
  410d12:	4923      	ldr	r1, [pc, #140]	; (410da0 <PM_param_tune2_current_handler+0x120>)
			PM_tune_stage++;
  410d14:	2501      	movs	r5, #1
	rs_h = (h1 - param_a[1]) / param_a[0];
  410d16:	eddf 7a25 	vldr	s15, [pc, #148]	; 410dac <PM_param_tune2_current_handler+0x12c>
  410d1a:	ed91 7a01 	vldr	s14, [r1, #4]
  410d1e:	edd1 6a00 	vldr	s13, [r1]
  410d22:	ee77 7ac7 	vsub.f32	s15, s15, s14
  410d26:	4822      	ldr	r0, [pc, #136]	; (410db0 <PM_param_tune2_current_handler+0x130>)
			PM_TUNE_PERIOD = PM_TUNE2_PERIOD;
  410d28:	4e22      	ldr	r6, [pc, #136]	; (410db4 <PM_param_tune2_current_handler+0x134>)
			PM_init_tune_param();
  410d2a:	4923      	ldr	r1, [pc, #140]	; (410db8 <PM_param_tune2_current_handler+0x138>)
	rs_h = (h1 - param_a[1]) / param_a[0];
  410d2c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
			PM_TUNE_PERIOD = PM_TUNE2_PERIOD;
  410d30:	601e      	str	r6, [r3, #0]
			PM_tune_stage++;
  410d32:	7015      	strb	r5, [r2, #0]
	rs_h = (h1 - param_a[1]) / param_a[0];
  410d34:	ed80 7a00 	vstr	s14, [r0]
			PM_init_tune_param();
  410d38:	4788      	blx	r1
			inverter_set_dead_comp(0);
  410d3a:	4620      	mov	r0, r4
  410d3c:	4b14      	ldr	r3, [pc, #80]	; (410d90 <PM_param_tune2_current_handler+0x110>)
}
  410d3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			inverter_set_dead_comp(0);
  410d42:	4718      	bx	r3
		else if(PM_tune_stage == 1) PM_stage2_tune();
  410d44:	4b1d      	ldr	r3, [pc, #116]	; (410dbc <PM_param_tune2_current_handler+0x13c>)
  410d46:	4798      	blx	r3
  410d48:	edd4 7a00 	vldr	s15, [r4]
  410d4c:	e7ac      	b.n	410ca8 <PM_param_tune2_current_handler+0x28>
		else if(PM_tune_stage == 2) PM_stage3_tune();
  410d4e:	4b1c      	ldr	r3, [pc, #112]	; (410dc0 <PM_param_tune2_current_handler+0x140>)
  410d50:	4798      	blx	r3
  410d52:	edd4 7a00 	vldr	s15, [r4]
  410d56:	e7a7      	b.n	410ca8 <PM_param_tune2_current_handler+0x28>
	ld_h = 1 / param_a[0];
  410d58:	4911      	ldr	r1, [pc, #68]	; (410da0 <PM_param_tune2_current_handler+0x120>)
  410d5a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
			PM_TUNE_PERIOD = PM_TUNE3_PERIOD;
  410d5e:	4d15      	ldr	r5, [pc, #84]	; (410db4 <PM_param_tune2_current_handler+0x134>)
			PM_tune_stage++;
  410d60:	2402      	movs	r4, #2
	ld_h = 1 / param_a[0];
  410d62:	ed91 7a00 	vldr	s14, [r1]
  410d66:	4817      	ldr	r0, [pc, #92]	; (410dc4 <PM_param_tune2_current_handler+0x144>)
  410d68:	eec6 7a87 	vdiv.f32	s15, s13, s14
			PM_TUNE_PERIOD = PM_TUNE3_PERIOD;
  410d6c:	601d      	str	r5, [r3, #0]
			PM_tune_stage++;
  410d6e:	7014      	strb	r4, [r2, #0]
			PM_init_tune_param();
  410d70:	4911      	ldr	r1, [pc, #68]	; (410db8 <PM_param_tune2_current_handler+0x138>)
	ld_h = 1 / param_a[0];
  410d72:	edc0 7a00 	vstr	s15, [r0]
}
  410d76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			PM_init_tune_param();
  410d7a:	4708      	bx	r1
  410d7c:	20406500 	.word	0x20406500
  410d80:	204009e0 	.word	0x204009e0
  410d84:	204009e4 	.word	0x204009e4
  410d88:	204003c8 	.word	0x204003c8
  410d8c:	00417215 	.word	0x00417215
  410d90:	004153dd 	.word	0x004153dd
  410d94:	00410751 	.word	0x00410751
  410d98:	0041ca60 	.word	0x0041ca60
  410d9c:	0040c065 	.word	0x0040c065
  410da0:	20406480 	.word	0x20406480
  410da4:	204064fc 	.word	0x204064fc
  410da8:	00410871 	.word	0x00410871
  410dac:	42b40000 	.word	0x42b40000
  410db0:	20406420 	.word	0x20406420
  410db4:	40a00000 	.word	0x40a00000
  410db8:	00410be9 	.word	0x00410be9
  410dbc:	00410969 	.word	0x00410969
  410dc0:	00410aa9 	.word	0x00410aa9
  410dc4:	204064f8 	.word	0x204064f8

00410dc8 <PM_param_tune2_init>:

void PM_param_tune2_init(void)
{
	PM_tune_stage = 0;
	PM_TUNE_PERIOD = PM_TUNE1_PERIOD;
	pm_tune2_comm = menue_drive_motor_tune;
  410dc8:	4a09      	ldr	r2, [pc, #36]	; (410df0 <PM_param_tune2_init+0x28>)
	PM_tune_stage = 0;
  410dca:	2300      	movs	r3, #0
	PM_TUNE_PERIOD = PM_TUNE1_PERIOD;
  410dcc:	4909      	ldr	r1, [pc, #36]	; (410df4 <PM_param_tune2_init+0x2c>)
	inverter_set_dead_comp(0);
  410dce:	4618      	mov	r0, r3
{
  410dd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	PM_TUNE_PERIOD = PM_TUNE1_PERIOD;
  410dd4:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
	pm_tune2_comm = menue_drive_motor_tune;
  410dd8:	7817      	ldrb	r7, [r2, #0]
  410dda:	4e07      	ldr	r6, [pc, #28]	; (410df8 <PM_param_tune2_init+0x30>)
	PM_tune_stage = 0;
  410ddc:	4d07      	ldr	r5, [pc, #28]	; (410dfc <PM_param_tune2_init+0x34>)
	inverter_set_dead_comp(0);
  410dde:	4a08      	ldr	r2, [pc, #32]	; (410e00 <PM_param_tune2_init+0x38>)
	PM_tune_stage = 0;
  410de0:	702b      	strb	r3, [r5, #0]
	pm_tune2_comm = menue_drive_motor_tune;
  410de2:	7037      	strb	r7, [r6, #0]
	PM_TUNE_PERIOD = PM_TUNE1_PERIOD;
  410de4:	600c      	str	r4, [r1, #0]
	inverter_set_dead_comp(0);
  410de6:	4790      	blx	r2
	PM_init_tune_param();
  410de8:	4b06      	ldr	r3, [pc, #24]	; (410e04 <PM_param_tune2_init+0x3c>)

  410dea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	PM_init_tune_param();
  410dee:	4718      	bx	r3
  410df0:	204008e9 	.word	0x204008e9
  410df4:	20406500 	.word	0x20406500
  410df8:	204009e5 	.word	0x204009e5
  410dfc:	204009e4 	.word	0x204009e4
  410e00:	004153dd 	.word	0x004153dd
  410e04:	00410be9 	.word	0x00410be9

00410e08 <gen_test_vectors>:
#define FILTER_WIGHT (0.1F)

float vector_f_time, id_f = 0;
float test_vectors[12];
void gen_test_vectors(float first_angle, float sec_angle)
{
  410e08:	ee04 0a90 	vmov	s9, r0
	int i;
	float ang_offset = sec_angle - first_angle;
  410e0c:	ee07 1a90 	vmov	s15, r1
	while(ang_offset >= 360) ang_offset -= (360);
  410e10:	eddf 6a36 	vldr	s13, [pc, #216]	; 410eec <gen_test_vectors+0xe4>
	float ang_offset = sec_angle - first_angle;
  410e14:	ee37 7ae4 	vsub.f32	s14, s15, s9
	while(ang_offset >= 360) ang_offset -= (360);
  410e18:	eeb4 7ae6 	vcmpe.f32	s14, s13
  410e1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410e20:	db5a      	blt.n	410ed8 <gen_test_vectors+0xd0>
  410e22:	ed9f 6a33 	vldr	s12, [pc, #204]	; 410ef0 <gen_test_vectors+0xe8>
  410e26:	eeb4 7ac6 	vcmpe.f32	s14, s12
  410e2a:	ee77 7a66 	vsub.f32	s15, s14, s13
  410e2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410e32:	eeb0 7a67 	vmov.f32	s14, s15
  410e36:	daf6      	bge.n	410e26 <gen_test_vectors+0x1e>
	while(ang_offset < 0) ang_offset += (360);
  410e38:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  410e3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410e40:	d551      	bpl.n	410ee6 <gen_test_vectors+0xde>
  410e42:	ed9f 6a2a 	vldr	s12, [pc, #168]	; 410eec <gen_test_vectors+0xe4>
  410e46:	eddf 6a2b 	vldr	s13, [pc, #172]	; 410ef4 <gen_test_vectors+0xec>
  410e4a:	eef4 7ae6 	vcmpe.f32	s15, s13
  410e4e:	ee37 7a86 	vadd.f32	s14, s15, s12
  410e52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410e56:	eef0 7a47 	vmov.f32	s15, s14
  410e5a:	d4f6      	bmi.n	410e4a <gen_test_vectors+0x42>
	ang_offset /= 11;
  410e5c:	ed9f 5a26 	vldr	s10, [pc, #152]	; 410ef8 <gen_test_vectors+0xf0>
	
	for (i=0; i<12; i++)
  410e60:	2200      	movs	r2, #0
  410e62:	4b26      	ldr	r3, [pc, #152]	; (410efc <gen_test_vectors+0xf4>)
	ang_offset /= 11;
  410e64:	ee27 5a05 	vmul.f32	s10, s14, s10
	{
		test_vectors[i] = first_angle + i * ang_offset;
		while(test_vectors[i] >= 360) test_vectors[i] -= (360);
  410e68:	eddf 6a20 	vldr	s13, [pc, #128]	; 410eec <gen_test_vectors+0xe4>
  410e6c:	eddf 5a20 	vldr	s11, [pc, #128]	; 410ef0 <gen_test_vectors+0xe8>
		while(test_vectors[i] < 0) test_vectors[i] += (360);
  410e70:	ed9f 6a20 	vldr	s12, [pc, #128]	; 410ef4 <gen_test_vectors+0xec>
		test_vectors[i] = first_angle + i * ang_offset;
  410e74:	ee07 2a90 	vmov	s15, r2
  410e78:	eeb0 7a64 	vmov.f32	s14, s9
  410e7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  410e80:	eea5 7a27 	vfma.f32	s14, s10, s15
		while(test_vectors[i] >= 360) test_vectors[i] -= (360);
  410e84:	eeb4 7ae6 	vcmpe.f32	s14, s13
		test_vectors[i] = first_angle + i * ang_offset;
  410e88:	ed83 7a00 	vstr	s14, [r3]
		while(test_vectors[i] >= 360) test_vectors[i] -= (360);
  410e8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410e90:	db1f      	blt.n	410ed2 <gen_test_vectors+0xca>
  410e92:	eeb4 7ae5 	vcmpe.f32	s14, s11
  410e96:	ee77 7a66 	vsub.f32	s15, s14, s13
  410e9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410e9e:	eeb0 7a67 	vmov.f32	s14, s15
  410ea2:	daf6      	bge.n	410e92 <gen_test_vectors+0x8a>
  410ea4:	edc3 7a00 	vstr	s15, [r3]
		while(test_vectors[i] < 0) test_vectors[i] += (360);
  410ea8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  410eac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410eb0:	d50a      	bpl.n	410ec8 <gen_test_vectors+0xc0>
  410eb2:	eef4 7ac6 	vcmpe.f32	s15, s12
  410eb6:	ee37 7aa6 	vadd.f32	s14, s15, s13
  410eba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410ebe:	eef0 7a47 	vmov.f32	s15, s14
  410ec2:	d4f6      	bmi.n	410eb2 <gen_test_vectors+0xaa>
  410ec4:	ed83 7a00 	vstr	s14, [r3]
	for (i=0; i<12; i++)
  410ec8:	3201      	adds	r2, #1
  410eca:	3304      	adds	r3, #4
  410ecc:	2a0c      	cmp	r2, #12
  410ece:	d1d1      	bne.n	410e74 <gen_test_vectors+0x6c>
  410ed0:	4770      	bx	lr
		while(test_vectors[i] >= 360) test_vectors[i] -= (360);
  410ed2:	eef0 7a47 	vmov.f32	s15, s14
  410ed6:	e7e7      	b.n	410ea8 <gen_test_vectors+0xa0>
	float ang_offset = sec_angle - first_angle;
  410ed8:	eef0 7a47 	vmov.f32	s15, s14
	while(ang_offset < 0) ang_offset += (360);
  410edc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  410ee0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410ee4:	d4ad      	bmi.n	410e42 <gen_test_vectors+0x3a>
  410ee6:	eeb0 7a67 	vmov.f32	s14, s15
  410eea:	e7b7      	b.n	410e5c <gen_test_vectors+0x54>
  410eec:	43b40000 	.word	0x43b40000
  410ef0:	44340000 	.word	0x44340000
  410ef4:	c3b40000 	.word	0xc3b40000
  410ef8:	3dba2e8c 	.word	0x3dba2e8c
  410efc:	20406508 	.word	0x20406508

00410f00 <tune_vector_out>:

uint16_t vector_index = 0,  chosen_vector_index = 0;
uint32_t tune_vector_time_counter; 
float vector_min_time = 0xFFFFFFFF;
uint32_t tune_vector_out(float flux_angle)
{
  410f00:	ee07 0a10 	vmov	s14, r0
 	float id;
 	float tmp, com_vd;
 	
 	while(flux_angle > 360) flux_angle -= (360);
  410f04:	eddf 6a55 	vldr	s13, [pc, #340]	; 41105c <tune_vector_out+0x15c>
  410f08:	eeb4 7ae6 	vcmpe.f32	s14, s13
{
  410f0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 	while(flux_angle > 360) flux_angle -= (360);
  410f0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
  410f12:	ed2d 8b02 	vpush	{d8}
  410f16:	b083      	sub	sp, #12
 	while(flux_angle > 360) flux_angle -= (360);
  410f18:	f340 809c 	ble.w	411054 <tune_vector_out+0x154>
  410f1c:	ed9f 6a50 	vldr	s12, [pc, #320]	; 411060 <tune_vector_out+0x160>
  410f20:	eeb4 7ac6 	vcmpe.f32	s14, s12
  410f24:	ee77 7a66 	vsub.f32	s15, s14, s13
  410f28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410f2c:	eeb0 7a67 	vmov.f32	s14, s15
  410f30:	dcf6      	bgt.n	410f20 <tune_vector_out+0x20>
 	while(flux_angle < 0) flux_angle += (360);
  410f32:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  410f36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410f3a:	f140 8088 	bpl.w	41104e <tune_vector_out+0x14e>
  410f3e:	ed9f 6a47 	vldr	s12, [pc, #284]	; 41105c <tune_vector_out+0x15c>
  410f42:	eddf 6a48 	vldr	s13, [pc, #288]	; 411064 <tune_vector_out+0x164>
  410f46:	eef4 7ae6 	vcmpe.f32	s15, s13
  410f4a:	ee37 7a86 	vadd.f32	s14, s15, s12
  410f4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410f52:	eef0 7a47 	vmov.f32	s15, s14
  410f56:	d4f6      	bmi.n	410f46 <tune_vector_out+0x46>
 	axt_set_theta(flux_angle);
  410f58:	ee17 0a10 	vmov	r0, s14
  410f5c:	4b42      	ldr	r3, [pc, #264]	; (411068 <tune_vector_out+0x168>)
  410f5e:	4798      	blx	r3
 	axt_park_exe();
  410f60:	4b42      	ldr	r3, [pc, #264]	; (41106c <tune_vector_out+0x16c>)
  410f62:	4798      	blx	r3
 	
 	id = axt_get_id();
  410f64:	4b42      	ldr	r3, [pc, #264]	; (411070 <tune_vector_out+0x170>)
  410f66:	4798      	blx	r3

	com_vd = TEST_VOLTAGE;
 	float valpha, vbeta;
	
	//return 1;
	if (id_f >= TEST_CURRENT)
  410f68:	4a42      	ldr	r2, [pc, #264]	; (411074 <tune_vector_out+0x174>)
	id_f = (id_f * (1-FILTER_WIGHT) + id * FILTER_WIGHT);
  410f6a:	ee07 0a90 	vmov	s15, r0
  410f6e:	ed9f 7a42 	vldr	s14, [pc, #264]	; 411078 <tune_vector_out+0x178>
	if (id_f >= TEST_CURRENT)
  410f72:	f892 40b0 	ldrb.w	r4, [r2, #176]	; 0xb0
  410f76:	6953      	ldr	r3, [r2, #20]
	id_f = (id_f * (1-FILTER_WIGHT) + id * FILTER_WIGHT);
  410f78:	ee27 7a87 	vmul.f32	s14, s15, s14
	if (id_f >= TEST_CURRENT)
  410f7c:	4a3f      	ldr	r2, [pc, #252]	; (41107c <tune_vector_out+0x17c>)
  410f7e:	fb03 f304 	mul.w	r3, r3, r4
	id_f = (id_f * (1-FILTER_WIGHT) + id * FILTER_WIGHT);
  410f82:	493f      	ldr	r1, [pc, #252]	; (411080 <tune_vector_out+0x180>)
  410f84:	eddf 7a3f 	vldr	s15, [pc, #252]	; 411084 <tune_vector_out+0x184>
	if (id_f >= TEST_CURRENT)
  410f88:	fb82 0203 	smull	r0, r2, r2, r3
  410f8c:	17db      	asrs	r3, r3, #31
	id_f = (id_f * (1-FILTER_WIGHT) + id * FILTER_WIGHT);
  410f8e:	edd1 6a00 	vldr	s13, [r1]
	if (id_f >= TEST_CURRENT)
  410f92:	ebc3 1362 	rsb	r3, r3, r2, asr #5
	id_f = (id_f * (1-FILTER_WIGHT) + id * FILTER_WIGHT);
  410f96:	eea6 7aa7 	vfma.f32	s14, s13, s15
	if (id_f >= TEST_CURRENT)
  410f9a:	ee07 3a90 	vmov	s15, r3
  410f9e:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
  410fa2:	eeb4 7ae7 	vcmpe.f32	s14, s15
	id_f = (id_f * (1-FILTER_WIGHT) + id * FILTER_WIGHT);
  410fa6:	ed81 7a00 	vstr	s14, [r1]
	if (id_f >= TEST_CURRENT)
  410faa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410fae:	da45      	bge.n	41103c <tune_vector_out+0x13c>
	{
		inverter_out_rect(0, 0);
		return 1;
	}
 	axt_ipark_exe(com_vd, 0, &valpha, &vbeta );
  410fb0:	ab01      	add	r3, sp, #4
  410fb2:	466a      	mov	r2, sp
  410fb4:	2100      	movs	r1, #0
  410fb6:	4834      	ldr	r0, [pc, #208]	; (411088 <tune_vector_out+0x188>)
  410fb8:	4c34      	ldr	r4, [pc, #208]	; (41108c <tune_vector_out+0x18c>)
  410fba:	47a0      	blx	r4
 	inverter_out_rect(fixedpt_rconst(valpha), fixedpt_rconst(vbeta));
  410fbc:	ed9d 8a00 	vldr	s16, [sp]
  410fc0:	eddf 7a33 	vldr	s15, [pc, #204]	; 411090 <tune_vector_out+0x190>
  410fc4:	4e33      	ldr	r6, [pc, #204]	; (411094 <tune_vector_out+0x194>)
  410fc6:	ee68 7a27 	vmul.f32	s15, s16, s15
  410fca:	4d33      	ldr	r5, [pc, #204]	; (411098 <tune_vector_out+0x198>)
  410fcc:	4c33      	ldr	r4, [pc, #204]	; (41109c <tune_vector_out+0x19c>)
  410fce:	ee17 0a90 	vmov	r0, s15
  410fd2:	47b0      	blx	r6
  410fd4:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  410fd8:	2200      	movs	r2, #0
  410fda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  410fde:	bfb4      	ite	lt
  410fe0:	4b2f      	ldrlt	r3, [pc, #188]	; (4110a0 <tune_vector_out+0x1a0>)
  410fe2:	4b30      	ldrge	r3, [pc, #192]	; (4110a4 <tune_vector_out+0x1a4>)
  410fe4:	47a8      	blx	r5
  410fe6:	47a0      	blx	r4
  410fe8:	ed9d 8a01 	vldr	s16, [sp, #4]
  410fec:	eddf 7a28 	vldr	s15, [pc, #160]	; 411090 <tune_vector_out+0x190>
  410ff0:	4607      	mov	r7, r0
  410ff2:	ee68 7a27 	vmul.f32	s15, s16, s15
  410ff6:	ee17 0a90 	vmov	r0, s15
  410ffa:	47b0      	blx	r6
  410ffc:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  411000:	2200      	movs	r2, #0
  411002:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  411006:	bfb4      	ite	lt
  411008:	4b25      	ldrlt	r3, [pc, #148]	; (4110a0 <tune_vector_out+0x1a0>)
  41100a:	4b26      	ldrge	r3, [pc, #152]	; (4110a4 <tune_vector_out+0x1a4>)
  41100c:	47a8      	blx	r5
  41100e:	47a0      	blx	r4
  411010:	4b25      	ldr	r3, [pc, #148]	; (4110a8 <tune_vector_out+0x1a8>)
  411012:	4601      	mov	r1, r0
  411014:	4638      	mov	r0, r7
  411016:	4798      	blx	r3
	tune_vector_time_counter++;
  411018:	4a24      	ldr	r2, [pc, #144]	; (4110ac <tune_vector_out+0x1ac>)
	if (tune_vector_time_counter > SEC_COUNT) tune1_err_set;
  41101a:	f242 7110 	movw	r1, #10000	; 0x2710
	tune_vector_time_counter++;
  41101e:	6813      	ldr	r3, [r2, #0]
  411020:	3301      	adds	r3, #1
	if (tune_vector_time_counter > SEC_COUNT) tune1_err_set;
  411022:	428b      	cmp	r3, r1
	tune_vector_time_counter++;
  411024:	6013      	str	r3, [r2, #0]
	if (tune_vector_time_counter > SEC_COUNT) tune1_err_set;
  411026:	d804      	bhi.n	411032 <tune_vector_out+0x132>
  411028:	2000      	movs	r0, #0
	return 0;
}
  41102a:	b003      	add	sp, #12
  41102c:	ecbd 8b02 	vpop	{d8}
  411030:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (tune_vector_time_counter > SEC_COUNT) tune1_err_set;
  411032:	4a1f      	ldr	r2, [pc, #124]	; (4110b0 <tune_vector_out+0x1b0>)
  411034:	4b1f      	ldr	r3, [pc, #124]	; (4110b4 <tune_vector_out+0x1b4>)
  411036:	7810      	ldrb	r0, [r2, #0]
  411038:	4798      	blx	r3
  41103a:	e7f5      	b.n	411028 <tune_vector_out+0x128>
		inverter_out_rect(0, 0);
  41103c:	2100      	movs	r1, #0
  41103e:	4b1a      	ldr	r3, [pc, #104]	; (4110a8 <tune_vector_out+0x1a8>)
  411040:	4608      	mov	r0, r1
  411042:	4798      	blx	r3
		return 1;
  411044:	2001      	movs	r0, #1
}
  411046:	b003      	add	sp, #12
  411048:	ecbd 8b02 	vpop	{d8}
  41104c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 	while(flux_angle < 0) flux_angle += (360);
  41104e:	eeb0 7a67 	vmov.f32	s14, s15
  411052:	e781      	b.n	410f58 <tune_vector_out+0x58>
 	while(flux_angle > 360) flux_angle -= (360);
  411054:	ee07 0a90 	vmov	s15, r0
  411058:	e76b      	b.n	410f32 <tune_vector_out+0x32>
  41105a:	bf00      	nop
  41105c:	43b40000 	.word	0x43b40000
  411060:	44340000 	.word	0x44340000
  411064:	c3b40000 	.word	0xc3b40000
  411068:	0040e1f9 	.word	0x0040e1f9
  41106c:	0040e23d 	.word	0x0040e23d
  411070:	0040e2d1 	.word	0x0040e2d1
  411074:	20404ff0 	.word	0x20404ff0
  411078:	3dcccccd 	.word	0x3dcccccd
  41107c:	51eb851f 	.word	0x51eb851f
  411080:	204009ec 	.word	0x204009ec
  411084:	3f666666 	.word	0x3f666666
  411088:	43480000 	.word	0x43480000
  41108c:	0040e301 	.word	0x0040e301
  411090:	47000000 	.word	0x47000000
  411094:	00418749 	.word	0x00418749
  411098:	0041848d 	.word	0x0041848d
  41109c:	00418d51 	.word	0x00418d51
  4110a0:	bfe00000 	.word	0xbfe00000
  4110a4:	3fe00000 	.word	0x3fe00000
  4110a8:	00415191 	.word	0x00415191
  4110ac:	20406538 	.word	0x20406538
  4110b0:	20406ca6 	.word	0x20406ca6
  4110b4:	0041282d 	.word	0x0041282d

004110b8 <test12vectors>:


uint32_t test12vectors_delay = 0;
uint8_t test_vector_f_timer = 0;
uint32_t test12vectors(void)
{
  4110b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	float tmp = 0;
	if (test12vectors_delay > 0)
  4110ba:	4c2c      	ldr	r4, [pc, #176]	; (41116c <test12vectors+0xb4>)
  4110bc:	6823      	ldr	r3, [r4, #0]
  4110be:	2b00      	cmp	r3, #0
  4110c0:	d148      	bne.n	411154 <test12vectors+0x9c>
	{
		//start testing for a vector
		inverter_clear_override();
	}
	
	if(vector_index > 11) 
  4110c2:	4d2b      	ldr	r5, [pc, #172]	; (411170 <test12vectors+0xb8>)
		inverter_clear_override();
  4110c4:	4b2b      	ldr	r3, [pc, #172]	; (411174 <test12vectors+0xbc>)
  4110c6:	4798      	blx	r3
	if(vector_index > 11) 
  4110c8:	882b      	ldrh	r3, [r5, #0]
  4110ca:	2b0b      	cmp	r3, #11
  4110cc:	d832      	bhi.n	411134 <test12vectors+0x7c>
	{
		// all 12 vectors are tested
		inverter_set_override();
		return 1;
	}
	if (tune_vector_out(test_vectors[vector_index]))
  4110ce:	4a2a      	ldr	r2, [pc, #168]	; (411178 <test12vectors+0xc0>)
  4110d0:	492a      	ldr	r1, [pc, #168]	; (41117c <test12vectors+0xc4>)
  4110d2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  4110d6:	6818      	ldr	r0, [r3, #0]
  4110d8:	4788      	blx	r1
  4110da:	2800      	cmp	r0, #0
  4110dc:	d039      	beq.n	411152 <test12vectors+0x9a>
	{
		//The vector has been tested
		tmp = tune_vector_time_counter;
  4110de:	4928      	ldr	r1, [pc, #160]	; (411180 <test12vectors+0xc8>)
		tmp = tmp / (VECTOR_F_POWER + 1);
		vector_f_time += tmp;
  4110e0:	eef5 6a00 	vmov.f32	s13, #80	; 0x3e800000  0.250
  4110e4:	4b27      	ldr	r3, [pc, #156]	; (411184 <test12vectors+0xcc>)
		tmp = tune_vector_time_counter;
  4110e6:	ed91 7a00 	vldr	s14, [r1]
		vector_f_time += tmp;
  4110ea:	edd3 7a00 	vldr	s15, [r3]
		tmp = tune_vector_time_counter;
  4110ee:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		dummy_test = vector_f_time;
		if (test_vector_f_timer >= VECTOR_F_POWER)
  4110f2:	4825      	ldr	r0, [pc, #148]	; (411188 <test12vectors+0xd0>)
		dummy_test = vector_f_time;
  4110f4:	4e25      	ldr	r6, [pc, #148]	; (41118c <test12vectors+0xd4>)
		if (test_vector_f_timer >= VECTOR_F_POWER)
  4110f6:	7802      	ldrb	r2, [r0, #0]
		vector_f_time += tmp;
  4110f8:	eee7 7a26 	vfma.f32	s15, s14, s13
		if (test_vector_f_timer >= VECTOR_F_POWER)
  4110fc:	2a02      	cmp	r2, #2
		dummy_test = vector_f_time;
  4110fe:	eebc 7ae7 	vcvt.u32.f32	s14, s15
		vector_f_time += tmp;
  411102:	edc3 7a00 	vstr	s15, [r3]
		dummy_test = vector_f_time;
  411106:	ed86 7a00 	vstr	s14, [r6]
		if (test_vector_f_timer >= VECTOR_F_POWER)
  41110a:	d917      	bls.n	41113c <test12vectors+0x84>
		{
			if (vector_f_time <= vector_min_time)
  41110c:	4e20      	ldr	r6, [pc, #128]	; (411190 <test12vectors+0xd8>)
			{
				//found a closer vector to rotor angel
				vector_min_time = vector_f_time;
				chosen_vector_index = vector_index;
  41110e:	882a      	ldrh	r2, [r5, #0]
			if (vector_f_time <= vector_min_time)
  411110:	ed96 7a00 	vldr	s14, [r6]
  411114:	eef4 7ac7 	vcmpe.f32	s15, s14
  411118:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41111c:	d803      	bhi.n	411126 <test12vectors+0x6e>
				chosen_vector_index = vector_index;
  41111e:	4f1d      	ldr	r7, [pc, #116]	; (411194 <test12vectors+0xdc>)
				vector_min_time = vector_f_time;
  411120:	edc6 7a00 	vstr	s15, [r6]
				chosen_vector_index = vector_index;
  411124:	803a      	strh	r2, [r7, #0]
			}
			vector_index++;
  411126:	3201      	adds	r2, #1
			test_vector_f_timer = 0; //reset the vector avarage testing  time
  411128:	2700      	movs	r7, #0
			vector_f_time = 0; //reset filtered time
  41112a:	2600      	movs	r6, #0
			vector_index++;
  41112c:	802a      	strh	r2, [r5, #0]
			test_vector_f_timer = 0; //reset the vector avarage testing  time
  41112e:	7007      	strb	r7, [r0, #0]
			vector_f_time = 0; //reset filtered time
  411130:	601e      	str	r6, [r3, #0]
  411132:	e005      	b.n	411140 <test12vectors+0x88>
		inverter_set_override();
  411134:	4b18      	ldr	r3, [pc, #96]	; (411198 <test12vectors+0xe0>)
  411136:	4798      	blx	r3
		return 1;
  411138:	2001      	movs	r0, #1
  41113a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		} 
		else
		{
			//repeat testing the same vecotor
			test_vector_f_timer++;
  41113c:	3201      	adds	r2, #1
  41113e:	7002      	strb	r2, [r0, #0]
		}
		
		test12vectors_delay = TEST_VECTOR_DELAY_VAL;
		tune_vector_time_counter = 0; //reset the vector testing  time
  411140:	2300      	movs	r3, #0
		test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  411142:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
		id_f = 0;
  411146:	4a15      	ldr	r2, [pc, #84]	; (41119c <test12vectors+0xe4>)
  411148:	2500      	movs	r5, #0
  41114a:	4618      	mov	r0, r3
		tune_vector_time_counter = 0; //reset the vector testing  time
  41114c:	600b      	str	r3, [r1, #0]
		test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  41114e:	6026      	str	r6, [r4, #0]
		id_f = 0;
  411150:	6015      	str	r5, [r2, #0]
	}
	return 0;
}
  411152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		test12vectors_delay--;
  411154:	3b01      	subs	r3, #1
		inverter_set_override();
  411156:	4a10      	ldr	r2, [pc, #64]	; (411198 <test12vectors+0xe0>)
		test12vectors_delay--;
  411158:	6023      	str	r3, [r4, #0]
		inverter_set_override();
  41115a:	4790      	blx	r2
		tune_vector_time_counter = 0;
  41115c:	4c08      	ldr	r4, [pc, #32]	; (411180 <test12vectors+0xc8>)
  41115e:	2300      	movs	r3, #0
		id_f = 0;
  411160:	4a0e      	ldr	r2, [pc, #56]	; (41119c <test12vectors+0xe4>)
  411162:	2100      	movs	r1, #0
		return 0;
  411164:	4618      	mov	r0, r3
		tune_vector_time_counter = 0;
  411166:	6023      	str	r3, [r4, #0]
		id_f = 0;
  411168:	6011      	str	r1, [r2, #0]
		return 0;
  41116a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41116c:	204009f4 	.word	0x204009f4
  411170:	204009fa 	.word	0x204009fa
  411174:	004152b1 	.word	0x004152b1
  411178:	20406508 	.word	0x20406508
  41117c:	00410f01 	.word	0x00410f01
  411180:	20406538 	.word	0x20406538
  411184:	2040653c 	.word	0x2040653c
  411188:	204009f8 	.word	0x204009f8
  41118c:	204009e8 	.word	0x204009e8
  411190:	20400378 	.word	0x20400378
  411194:	204009e6 	.word	0x204009e6
  411198:	00415235 	.word	0x00415235
  41119c:	204009ec 	.word	0x204009ec

004111a0 <SPMtune_init>:

uint8_t spm_stage_counter = 0;
float tune_enc_angel;
void SPMtune_init(void)
{
  4111a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	spm_stage_counter = 0;
	tune_enc_angel = encoder_getangle_elec_abs(MOTOR_POLEPAIR);
  4111a2:	4b0e      	ldr	r3, [pc, #56]	; (4111dc <SPMtune_init+0x3c>)
	spm_stage_counter = 0;
  4111a4:	2500      	movs	r5, #0
  4111a6:	4a0e      	ldr	r2, [pc, #56]	; (4111e0 <SPMtune_init+0x40>)
	
	gen_test_vectors(0, 330);
  4111a8:	2400      	movs	r4, #0
	tune_enc_angel = encoder_getangle_elec_abs(MOTOR_POLEPAIR);
  4111aa:	f893 003c 	ldrb.w	r0, [r3, #60]	; 0x3c
  4111ae:	4b0d      	ldr	r3, [pc, #52]	; (4111e4 <SPMtune_init+0x44>)
	spm_stage_counter = 0;
  4111b0:	7015      	strb	r5, [r2, #0]
	tune_enc_angel = encoder_getangle_elec_abs(MOTOR_POLEPAIR);
  4111b2:	4798      	blx	r3
  4111b4:	4b0c      	ldr	r3, [pc, #48]	; (4111e8 <SPMtune_init+0x48>)
	gen_test_vectors(0, 330);
  4111b6:	490d      	ldr	r1, [pc, #52]	; (4111ec <SPMtune_init+0x4c>)
	tune_enc_angel = encoder_getangle_elec_abs(MOTOR_POLEPAIR);
  4111b8:	6018      	str	r0, [r3, #0]
	gen_test_vectors(0, 330);
  4111ba:	4620      	mov	r0, r4
  4111bc:	4b0c      	ldr	r3, [pc, #48]	; (4111f0 <SPMtune_init+0x50>)
  4111be:	4798      	blx	r3
	vector_index = 0;
  4111c0:	4f0c      	ldr	r7, [pc, #48]	; (4111f4 <SPMtune_init+0x54>)
	test12vectors_delay = TEST_VECTOR_DELAY_VAL;
	vector_min_time = 0xFFFFFFFF;
	vector_f_time = 0;
  4111c2:	4e0d      	ldr	r6, [pc, #52]	; (4111f8 <SPMtune_init+0x58>)
	test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  4111c4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  4111c8:	490c      	ldr	r1, [pc, #48]	; (4111fc <SPMtune_init+0x5c>)
	vector_min_time = 0xFFFFFFFF;
  4111ca:	f04f 429f 	mov.w	r2, #1333788672	; 0x4f800000
  4111ce:	4b0c      	ldr	r3, [pc, #48]	; (411200 <SPMtune_init+0x60>)
	vector_index = 0;
  4111d0:	803d      	strh	r5, [r7, #0]
	vector_f_time = 0;
  4111d2:	6034      	str	r4, [r6, #0]
	test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  4111d4:	6008      	str	r0, [r1, #0]
	vector_min_time = 0xFFFFFFFF;
  4111d6:	601a      	str	r2, [r3, #0]
  4111d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4111da:	bf00      	nop
  4111dc:	20404ff0 	.word	0x20404ff0
  4111e0:	204009f0 	.word	0x204009f0
  4111e4:	004132bd 	.word	0x004132bd
  4111e8:	20406504 	.word	0x20406504
  4111ec:	43a50000 	.word	0x43a50000
  4111f0:	00410e09 	.word	0x00410e09
  4111f4:	204009fa 	.word	0x204009fa
  4111f8:	2040653c 	.word	0x2040653c
  4111fc:	204009f4 	.word	0x204009f4
  411200:	20400378 	.word	0x20400378

00411204 <SPMstatic_tune_current_handler>:
}

void SPMstatic_tune_current_handler(void)
{
  411204:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t v1, v2;
	if (spm_stage_counter == 0)
  411208:	4c3e      	ldr	r4, [pc, #248]	; (411304 <SPMstatic_tune_current_handler+0x100>)
  41120a:	7823      	ldrb	r3, [r4, #0]
  41120c:	b12b      	cbz	r3, 41121a <SPMstatic_tune_current_handler+0x16>
			test12vectors_delay = TEST_VECTOR_DELAY_VAL;
			vector_min_time = 0xFFFFFFFF;
			vector_f_time = 0;
		}
	}
	else if (spm_stage_counter == 1)
  41120e:	2b01      	cmp	r3, #1
  411210:	d003      	beq.n	41121a <SPMstatic_tune_current_handler+0x16>
			test12vectors_delay = TEST_VECTOR_DELAY_VAL;
			vector_min_time = 0xFFFFFFFF;
			vector_f_time = 0;
		}
	}
	else if (spm_stage_counter == 2)
  411212:	2b02      	cmp	r3, #2
  411214:	d02d      	beq.n	411272 <SPMstatic_tune_current_handler+0x6e>
  411216:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (test12vectors())
  41121a:	4b3b      	ldr	r3, [pc, #236]	; (411308 <SPMstatic_tune_current_handler+0x104>)
  41121c:	4798      	blx	r3
  41121e:	2800      	cmp	r0, #0
  411220:	d0f9      	beq.n	411216 <SPMstatic_tune_current_handler+0x12>
			v2 = chosen_vector_index + 1;
  411222:	4a3a      	ldr	r2, [pc, #232]	; (41130c <SPMstatic_tune_current_handler+0x108>)
			spm_stage_counter++;
  411224:	7823      	ldrb	r3, [r4, #0]
			v2 = chosen_vector_index + 1;
  411226:	8811      	ldrh	r1, [r2, #0]
			spm_stage_counter++;
  411228:	3301      	adds	r3, #1
			v2 = chosen_vector_index + 1;
  41122a:	b2ca      	uxtb	r2, r1
			spm_stage_counter++;
  41122c:	7023      	strb	r3, [r4, #0]
			v2 = chosen_vector_index + 1;
  41122e:	1c53      	adds	r3, r2, #1
  411230:	b2db      	uxtb	r3, r3
			if(v2 > 11) v2 = 0; // overflow val is 11
  411232:	2b0c      	cmp	r3, #12
  411234:	bf28      	it	cs
  411236:	2300      	movcs	r3, #0
			if(chosen_vector_index == 0) v1 = 11;
  411238:	2900      	cmp	r1, #0
  41123a:	d05b      	beq.n	4112f4 <SPMstatic_tune_current_handler+0xf0>
			else v1 = chosen_vector_index - 1;
  41123c:	3a01      	subs	r2, #1
  41123e:	b2d2      	uxtb	r2, r2
			gen_test_vectors(test_vectors[v1], test_vectors[v2]);
  411240:	4933      	ldr	r1, [pc, #204]	; (411310 <SPMstatic_tune_current_handler+0x10c>)
			vector_index = 0;
  411242:	2700      	movs	r7, #0
			gen_test_vectors(test_vectors[v1], test_vectors[v2]);
  411244:	4c33      	ldr	r4, [pc, #204]	; (411314 <SPMstatic_tune_current_handler+0x110>)
			test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  411246:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
			gen_test_vectors(test_vectors[v1], test_vectors[v2]);
  41124a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
			vector_index = 0;
  41124e:	4e32      	ldr	r6, [pc, #200]	; (411318 <SPMstatic_tune_current_handler+0x114>)
			gen_test_vectors(test_vectors[v1], test_vectors[v2]);
  411250:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  411254:	6810      	ldr	r0, [r2, #0]
  411256:	6819      	ldr	r1, [r3, #0]
  411258:	47a0      	blx	r4
			test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  41125a:	4c30      	ldr	r4, [pc, #192]	; (41131c <SPMstatic_tune_current_handler+0x118>)
			vector_min_time = 0xFFFFFFFF;
  41125c:	4930      	ldr	r1, [pc, #192]	; (411320 <SPMstatic_tune_current_handler+0x11c>)
  41125e:	f04f 409f 	mov.w	r0, #1333788672	; 0x4f800000
			vector_f_time = 0;
  411262:	4b30      	ldr	r3, [pc, #192]	; (411324 <SPMstatic_tune_current_handler+0x120>)
  411264:	2200      	movs	r2, #0
			vector_index = 0;
  411266:	8037      	strh	r7, [r6, #0]
			test12vectors_delay = TEST_VECTOR_DELAY_VAL;
  411268:	6025      	str	r5, [r4, #0]
			vector_min_time = 0xFFFFFFFF;
  41126a:	6008      	str	r0, [r1, #0]
			vector_f_time = 0;
  41126c:	601a      	str	r2, [r3, #0]
  41126e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
		if (test12vectors())
  411272:	4b25      	ldr	r3, [pc, #148]	; (411308 <SPMstatic_tune_current_handler+0x104>)
  411274:	4798      	blx	r3
  411276:	2800      	cmp	r0, #0
  411278:	d0cd      	beq.n	411216 <SPMstatic_tune_current_handler+0x12>
		{
			spm_stage_counter++;
			
			float ret_angle = test_vectors[chosen_vector_index] - tune_enc_angel;
  41127a:	4b24      	ldr	r3, [pc, #144]	; (41130c <SPMstatic_tune_current_handler+0x108>)
  41127c:	4a24      	ldr	r2, [pc, #144]	; (411310 <SPMstatic_tune_current_handler+0x10c>)
  41127e:	881b      	ldrh	r3, [r3, #0]
  411280:	4929      	ldr	r1, [pc, #164]	; (411328 <SPMstatic_tune_current_handler+0x124>)
  411282:	eb02 0283 	add.w	r2, r2, r3, lsl #2
			while(ret_angle > 360) ret_angle -= (360);
  411286:	eddf 6a29 	vldr	s13, [pc, #164]	; 41132c <SPMstatic_tune_current_handler+0x128>
			float ret_angle = test_vectors[chosen_vector_index] - tune_enc_angel;
  41128a:	edd1 7a00 	vldr	s15, [r1]
  41128e:	ed92 7a00 	vldr	s14, [r2]
			spm_stage_counter++;
  411292:	7823      	ldrb	r3, [r4, #0]
			float ret_angle = test_vectors[chosen_vector_index] - tune_enc_angel;
  411294:	ee37 7a67 	vsub.f32	s14, s14, s15
			spm_stage_counter++;
  411298:	3301      	adds	r3, #1
			while(ret_angle > 360) ret_angle -= (360);
  41129a:	eeb4 7ae6 	vcmpe.f32	s14, s13
			spm_stage_counter++;
  41129e:	7023      	strb	r3, [r4, #0]
			while(ret_angle > 360) ret_angle -= (360);
  4112a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4112a4:	dd28      	ble.n	4112f8 <SPMstatic_tune_current_handler+0xf4>
  4112a6:	ed9f 6a22 	vldr	s12, [pc, #136]	; 411330 <SPMstatic_tune_current_handler+0x12c>
  4112aa:	eeb4 7ac6 	vcmpe.f32	s14, s12
  4112ae:	ee77 7a66 	vsub.f32	s15, s14, s13
  4112b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4112b6:	eeb0 7a67 	vmov.f32	s14, s15
  4112ba:	dcf6      	bgt.n	4112aa <SPMstatic_tune_current_handler+0xa6>
			while(ret_angle < 0) ret_angle += (360);
  4112bc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4112c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4112c4:	d51b      	bpl.n	4112fe <SPMstatic_tune_current_handler+0xfa>
  4112c6:	ed9f 6a19 	vldr	s12, [pc, #100]	; 41132c <SPMstatic_tune_current_handler+0x128>
  4112ca:	eddf 6a1a 	vldr	s13, [pc, #104]	; 411334 <SPMstatic_tune_current_handler+0x130>
  4112ce:	eef4 7ae6 	vcmpe.f32	s15, s13
  4112d2:	ee37 7a86 	vadd.f32	s14, s15, s12
  4112d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4112da:	eef0 7a47 	vmov.f32	s15, s14
  4112de:	d4f6      	bmi.n	4112ce <SPMstatic_tune_current_handler+0xca>
			menue_drive_data_setup.m_pole_pos_offset = ret_angle;
  4112e0:	4a15      	ldr	r2, [pc, #84]	; (411338 <SPMstatic_tune_current_handler+0x134>)
			pop_ups_add("ENC_Tune Successful", 1500);
  4112e2:	f240 51dc 	movw	r1, #1500	; 0x5dc
  4112e6:	4815      	ldr	r0, [pc, #84]	; (41133c <SPMstatic_tune_current_handler+0x138>)
			menue_drive_data_setup.m_pole_pos_offset = ret_angle;
  4112e8:	ed82 7a2d 	vstr	s14, [r2, #180]	; 0xb4
			pop_ups_add("ENC_Tune Successful", 1500);
  4112ec:	4b14      	ldr	r3, [pc, #80]	; (411340 <SPMstatic_tune_current_handler+0x13c>)
	else
	{
		return;
	}
	
}
  4112ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			pop_ups_add("ENC_Tune Successful", 1500);
  4112f2:	4718      	bx	r3
  4112f4:	220b      	movs	r2, #11
  4112f6:	e7a3      	b.n	411240 <SPMstatic_tune_current_handler+0x3c>
			float ret_angle = test_vectors[chosen_vector_index] - tune_enc_angel;
  4112f8:	eef0 7a47 	vmov.f32	s15, s14
  4112fc:	e7de      	b.n	4112bc <SPMstatic_tune_current_handler+0xb8>
			while(ret_angle < 0) ret_angle += (360);
  4112fe:	eeb0 7a67 	vmov.f32	s14, s15
  411302:	e7ed      	b.n	4112e0 <SPMstatic_tune_current_handler+0xdc>
  411304:	204009f0 	.word	0x204009f0
  411308:	004110b9 	.word	0x004110b9
  41130c:	204009e6 	.word	0x204009e6
  411310:	20406508 	.word	0x20406508
  411314:	00410e09 	.word	0x00410e09
  411318:	204009fa 	.word	0x204009fa
  41131c:	204009f4 	.word	0x204009f4
  411320:	20400378 	.word	0x20400378
  411324:	2040653c 	.word	0x2040653c
  411328:	20406504 	.word	0x20406504
  41132c:	43b40000 	.word	0x43b40000
  411330:	44340000 	.word	0x44340000
  411334:	c3b40000 	.word	0xc3b40000
  411338:	204050e8 	.word	0x204050e8
  41133c:	0041ca5c 	.word	0x0041ca5c
  411340:	0040c065 	.word	0x0040c065

00411344 <vectorIM_set_filter_timeconst>:
float filter_bemf_weight = 0, new_bemf_weight = 1;
void vectorIM_set_filter_timeconst(void)
{
	float temp;

	if (BEMF_FILTER_TIME == 0)
  411344:	4b18      	ldr	r3, [pc, #96]	; (4113a8 <vectorIM_set_filter_timeconst+0x64>)
  411346:	ed9f 7a19 	vldr	s14, [pc, #100]	; 4113ac <vectorIM_set_filter_timeconst+0x68>
  41134a:	edd3 7a2e 	vldr	s15, [r3, #184]	; 0xb8
  41134e:	2300      	movs	r3, #0
  411350:	ee67 7a87 	vmul.f32	s15, s15, s14
  411354:	eef5 7a40 	vcmp.f32	s15, #0.0
  411358:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41135c:	d01c      	beq.n	411398 <vectorIM_set_filter_timeconst+0x54>
	{
		new_bemf_weight = 1;
		filter_bemf_weight = 0;
	}
	else if(BEMF_FILTER_TIME > 0)
  41135e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  411362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  411366:	dd16      	ble.n	411396 <vectorIM_set_filter_timeconst+0x52>
	{
		
		temp = BEMF_FILTER_TIME;
		temp /= TSAMPLE;
  411368:	4a11      	ldr	r2, [pc, #68]	; (4113b0 <vectorIM_set_filter_timeconst+0x6c>)
		temp += 1;
  41136a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		
		temp = TSAMPLE;
		temp /= BEMF_FILTER_TIME;
		temp += 1;
		temp = 1 / temp;
		filter_bemf_weight = temp;
  41136e:	4b11      	ldr	r3, [pc, #68]	; (4113b4 <vectorIM_set_filter_timeconst+0x70>)
		temp /= TSAMPLE;
  411370:	edd2 6a00 	vldr	s13, [r2]
		new_bemf_weight = temp;
  411374:	4a10      	ldr	r2, [pc, #64]	; (4113b8 <vectorIM_set_filter_timeconst+0x74>)
		temp /= TSAMPLE;
  411376:	ee67 7aa6 	vmul.f32	s15, s15, s13
		temp /= BEMF_FILTER_TIME;
  41137a:	eec7 6a27 	vdiv.f32	s13, s14, s15
		temp += 1;
  41137e:	ee77 7a87 	vadd.f32	s15, s15, s14
		temp = 1 / temp;
  411382:	ee87 6a27 	vdiv.f32	s12, s14, s15
		temp += 1;
  411386:	ee76 7a87 	vadd.f32	s15, s13, s14
		temp = 1 / temp;
  41138a:	eec7 6a27 	vdiv.f32	s13, s14, s15
		new_bemf_weight = temp;
  41138e:	ed82 6a00 	vstr	s12, [r2]
		filter_bemf_weight = temp;
  411392:	edc3 6a00 	vstr	s13, [r3]
  411396:	4770      	bx	lr
		new_bemf_weight = 1;
  411398:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
  41139c:	4906      	ldr	r1, [pc, #24]	; (4113b8 <vectorIM_set_filter_timeconst+0x74>)
		filter_bemf_weight = 0;
  41139e:	4a05      	ldr	r2, [pc, #20]	; (4113b4 <vectorIM_set_filter_timeconst+0x70>)
		new_bemf_weight = 1;
  4113a0:	6008      	str	r0, [r1, #0]
		filter_bemf_weight = 0;
  4113a2:	6013      	str	r3, [r2, #0]
  4113a4:	4770      	bx	lr
  4113a6:	bf00      	nop
  4113a8:	20404ff0 	.word	0x20404ff0
  4113ac:	3a83126f 	.word	0x3a83126f
  4113b0:	204003c8 	.word	0x204003c8
  4113b4:	20400a08 	.word	0x20400a08
  4113b8:	2040037c 	.word	0x2040037c

004113bc <vectorIM_get_estimated_shaft_speed_rad>:
	return electrical_speed_rad / (6.283 * MOTOR_POLEPAIR);
}

float vectorIM_get_estimated_shaft_speed_rad(void)
{
	return (electrical_speed_rad / MOTOR_POLEPAIR);
  4113bc:	4a07      	ldr	r2, [pc, #28]	; (4113dc <vectorIM_get_estimated_shaft_speed_rad+0x20>)
  4113be:	4b08      	ldr	r3, [pc, #32]	; (4113e0 <vectorIM_get_estimated_shaft_speed_rad+0x24>)
  4113c0:	f892 203c 	ldrb.w	r2, [r2, #60]	; 0x3c
  4113c4:	ed93 7a00 	vldr	s14, [r3]
  4113c8:	ee07 2a90 	vmov	s15, r2
  4113cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
}
  4113d0:	eec7 6a27 	vdiv.f32	s13, s14, s15
  4113d4:	ee16 0a90 	vmov	r0, s13
  4113d8:	4770      	bx	lr
  4113da:	bf00      	nop
  4113dc:	20404ff0 	.word	0x20404ff0
  4113e0:	20400a00 	.word	0x20400a00

004113e4 <vectorIM_estimate_sync_speed>:

#define IM_SPEED_FILTER (0.1f)
float prev_ia = 0, prev_ib = 0;
float ed_mem  = 0, eq_mem = 0;
void vectorIM_estimate_sync_speed(float va, float vb)
{
  4113e4:	b570      	push	{r4, r5, r6, lr}
	float ed, eq, ws;
	float ia, ib;
	float ea, eb;
	if (vfd_states_allowedtomove() == 0)
  4113e6:	4b45      	ldr	r3, [pc, #276]	; (4114fc <vectorIM_estimate_sync_speed+0x118>)
{
  4113e8:	ed2d 8b04 	vpush	{d8-d9}
  4113ec:	b082      	sub	sp, #8
  4113ee:	ee08 0a10 	vmov	s16, r0
  4113f2:	ee08 1a90 	vmov	s17, r1
	if (vfd_states_allowedtomove() == 0)
  4113f6:	4798      	blx	r3
  4113f8:	b930      	cbnz	r0, 411408 <vectorIM_estimate_sync_speed+0x24>
	{
		electrical_speed_rad = 0;
  4113fa:	4b41      	ldr	r3, [pc, #260]	; (411500 <vectorIM_estimate_sync_speed+0x11c>)
  4113fc:	2200      	movs	r2, #0
  4113fe:	601a      	str	r2, [r3, #0]
//	electrical_speed_rad += (ws - electrical_speed_rad) * (TSAMPLE / IM_SPEED_FILTER);
	electrical_speed_rad = ws - vectorIM_slip_speed;
	
 	prev_ia = ia;
 	prev_ib = ib;
}
  411400:	b002      	add	sp, #8
  411402:	ecbd 8b04 	vpop	{d8-d9}
  411406:	bd70      	pop	{r4, r5, r6, pc}
	ia = axt_get_ialpha();
  411408:	4b3e      	ldr	r3, [pc, #248]	; (411504 <vectorIM_estimate_sync_speed+0x120>)
  41140a:	4798      	blx	r3
	ib = axt_get_ibeta();
  41140c:	4b3e      	ldr	r3, [pc, #248]	; (411508 <vectorIM_estimate_sync_speed+0x124>)
	ia = axt_get_ialpha();
  41140e:	ee09 0a90 	vmov	s19, r0
	ib = axt_get_ibeta();
  411412:	4798      	blx	r3
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  411414:	493d      	ldr	r1, [pc, #244]	; (41150c <vectorIM_estimate_sync_speed+0x128>)
	ib = axt_get_ibeta();
  411416:	ee09 0a10 	vmov	s18, r0
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  41141a:	483d      	ldr	r0, [pc, #244]	; (411510 <vectorIM_estimate_sync_speed+0x12c>)
	axt_get_park_transform(ea, eb, &ed, &eq);
  41141c:	ab01      	add	r3, sp, #4
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  41141e:	ed91 7a07 	vldr	s14, [r1, #28]
	axt_get_park_transform(ea, eb, &ed, &eq);
  411422:	466a      	mov	r2, sp
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  411424:	edd0 6a00 	vldr	s13, [r0]
  411428:	edd1 7a09 	vldr	s15, [r1, #36]	; 0x24
  41142c:	eea9 8ac7 	vfms.f32	s16, s19, s14
	eb = vb - ib * (I_IM_RS) - ((ib - prev_ib) * (I_IM_LSEG/TSAMPLE));
  411430:	4c38      	ldr	r4, [pc, #224]	; (411514 <vectorIM_estimate_sync_speed+0x130>)
  411432:	eee9 8a47 	vfms.f32	s17, s18, s14
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  411436:	4d38      	ldr	r5, [pc, #224]	; (411518 <vectorIM_estimate_sync_speed+0x134>)
  411438:	ee67 7aa6 	vmul.f32	s15, s15, s13
  41143c:	ed9f 6a37 	vldr	s12, [pc, #220]	; 41151c <vectorIM_estimate_sync_speed+0x138>
	eb = vb - ib * (I_IM_RS) - ((ib - prev_ib) * (I_IM_LSEG/TSAMPLE));
  411440:	edd4 6a00 	vldr	s13, [r4]
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  411444:	ed95 7a00 	vldr	s14, [r5]
  411448:	ee67 7a86 	vmul.f32	s15, s15, s12
	eb = vb - ib * (I_IM_RS) - ((ib - prev_ib) * (I_IM_LSEG/TSAMPLE));
  41144c:	ee76 6ac9 	vsub.f32	s13, s13, s18
	axt_get_park_transform(ea, eb, &ed, &eq);
  411450:	4e33      	ldr	r6, [pc, #204]	; (411520 <vectorIM_estimate_sync_speed+0x13c>)
	ea = va - ia * I_IM_RS - ((ia - prev_ia) * (I_IM_LSEG/TSAMPLE));
  411452:	ee37 7a69 	vsub.f32	s14, s14, s19
	axt_get_park_transform(ea, eb, &ed, &eq);
  411456:	eee6 8aa7 	vfma.f32	s17, s13, s15
  41145a:	eea7 8a27 	vfma.f32	s16, s14, s15
  41145e:	ee18 1a90 	vmov	r1, s17
  411462:	ee18 0a10 	vmov	r0, s16
  411466:	47b0      	blx	r6
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  411468:	4b2e      	ldr	r3, [pc, #184]	; (411524 <vectorIM_estimate_sync_speed+0x140>)
	eq_mem = (eq_mem * filter_bemf_weight) + (eq * new_bemf_weight);
  41146a:	eddd 7a01 	vldr	s15, [sp, #4]
	eq = eq_mem - sgn(eq_mem)*(ed_mem);
  41146e:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  411472:	ed93 7a00 	vldr	s14, [r3]
	eq = eq_mem - sgn(eq_mem)*(ed_mem);
  411476:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  41147a:	4b2b      	ldr	r3, [pc, #172]	; (411528 <vectorIM_estimate_sync_speed+0x144>)
	eq_mem = (eq_mem * filter_bemf_weight) + (eq * new_bemf_weight);
  41147c:	4a2b      	ldr	r2, [pc, #172]	; (41152c <vectorIM_estimate_sync_speed+0x148>)
  41147e:	ee67 7a27 	vmul.f32	s15, s14, s15
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  411482:	ed93 6a00 	vldr	s12, [r3]
	eq_mem = (eq_mem * filter_bemf_weight) + (eq * new_bemf_weight);
  411486:	ed92 5a00 	vldr	s10, [r2]
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  41148a:	eddd 5a00 	vldr	s11, [sp]
	eq_mem = (eq_mem * filter_bemf_weight) + (eq * new_bemf_weight);
  41148e:	eee6 7a05 	vfma.f32	s15, s12, s10
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  411492:	4b27      	ldr	r3, [pc, #156]	; (411530 <vectorIM_estimate_sync_speed+0x14c>)
	if (fixedpt_abs(vector_IM_flux) <= FLUX_MIN)
  411494:	4927      	ldr	r1, [pc, #156]	; (411534 <vectorIM_estimate_sync_speed+0x150>)
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  411496:	ee27 7a25 	vmul.f32	s14, s14, s11
  41149a:	ed93 5a00 	vldr	s10, [r3]
	if (fixedpt_abs(vector_IM_flux) <= FLUX_MIN)
  41149e:	edd1 5a00 	vldr	s11, [r1]
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  4114a2:	eea5 7a06 	vfma.f32	s14, s10, s12
	if (fixedpt_abs(vector_IM_flux) <= FLUX_MIN)
  4114a6:	ed9f 6a24 	vldr	s12, [pc, #144]	; 411538 <vectorIM_estimate_sync_speed+0x154>
  4114aa:	eeb0 5ae5 	vabs.f32	s10, s11
	eq = eq_mem - sgn(eq_mem)*(ed_mem);
  4114ae:	eef5 7ac0 	vcmpe.f32	s15, #0.0
	eq_mem = (eq_mem * filter_bemf_weight) + (eq * new_bemf_weight);
  4114b2:	edc2 7a00 	vstr	s15, [r2]
	eq = eq_mem - sgn(eq_mem)*(ed_mem);
  4114b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if (fixedpt_abs(vector_IM_flux) <= FLUX_MIN)
  4114ba:	eeb4 5ac6 	vcmpe.f32	s10, s12
	ed_mem = (ed_mem * filter_bemf_weight) + (ed * new_bemf_weight);
  4114be:	ed83 7a00 	vstr	s14, [r3]
	eq = eq_mem - sgn(eq_mem)*(ed_mem);
  4114c2:	bf58      	it	pl
  4114c4:	eef0 6a64 	vmovpl.f32	s13, s9
	if (fixedpt_abs(vector_IM_flux) <= FLUX_MIN)
  4114c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4114cc:	d913      	bls.n	4114f6 <vectorIM_estimate_sync_speed+0x112>
	eq = eq_mem - sgn(eq_mem)*(ed_mem);
  4114ce:	eee7 7a66 	vfms.f32	s15, s14, s13
		ws = eq / vector_IM_flux;
  4114d2:	ee87 7aa5 	vdiv.f32	s14, s15, s11
	electrical_speed_rad = ws - vectorIM_slip_speed;
  4114d6:	4a19      	ldr	r2, [pc, #100]	; (41153c <vectorIM_estimate_sync_speed+0x158>)
  4114d8:	4b09      	ldr	r3, [pc, #36]	; (411500 <vectorIM_estimate_sync_speed+0x11c>)
  4114da:	edd2 7a00 	vldr	s15, [r2]
 	prev_ia = ia;
  4114de:	edc5 9a00 	vstr	s19, [r5]
	electrical_speed_rad = ws - vectorIM_slip_speed;
  4114e2:	ee77 7a67 	vsub.f32	s15, s14, s15
 	prev_ib = ib;
  4114e6:	ed84 9a00 	vstr	s18, [r4]
	electrical_speed_rad = ws - vectorIM_slip_speed;
  4114ea:	edc3 7a00 	vstr	s15, [r3]
}
  4114ee:	b002      	add	sp, #8
  4114f0:	ecbd 8b04 	vpop	{d8-d9}
  4114f4:	bd70      	pop	{r4, r5, r6, pc}
		ws = 0;
  4114f6:	ed9f 7a12 	vldr	s14, [pc, #72]	; 411540 <vectorIM_estimate_sync_speed+0x15c>
  4114fa:	e7ec      	b.n	4114d6 <vectorIM_estimate_sync_speed+0xf2>
  4114fc:	00416305 	.word	0x00416305
  411500:	20400a00 	.word	0x20400a00
  411504:	0040e2e9 	.word	0x0040e2e9
  411508:	0040e2f5 	.word	0x0040e2f5
  41150c:	20404ff0 	.word	0x20404ff0
  411510:	204003c8 	.word	0x204003c8
  411514:	20400a14 	.word	0x20400a14
  411518:	20400a10 	.word	0x20400a10
  41151c:	3a83126f 	.word	0x3a83126f
  411520:	0040e28d 	.word	0x0040e28d
  411524:	2040037c 	.word	0x2040037c
  411528:	20400a08 	.word	0x20400a08
  41152c:	20400a04 	.word	0x20400a04
  411530:	204009fc 	.word	0x204009fc
  411534:	20400384 	.word	0x20400384
  411538:	38d1b717 	.word	0x38d1b717
  41153c:	20400a1c 	.word	0x20400a1c
  411540:	00000000 	.word	0x00000000

00411544 <vectorIM_calc_speeds>:

void vectorIM_calc_speeds()
{
  411544:	b508      	push	{r3, lr}
	
	if (MOTOR_IM_CVC)
  411546:	4b10      	ldr	r3, [pc, #64]	; (411588 <vectorIM_calc_speeds+0x44>)
  411548:	f893 20c5 	ldrb.w	r2, [r3, #197]	; 0xc5
  41154c:	2a01      	cmp	r2, #1
  41154e:	d00b      	beq.n	411568 <vectorIM_calc_speeds+0x24>
  411550:	4b0e      	ldr	r3, [pc, #56]	; (41158c <vectorIM_calc_speeds+0x48>)
  411552:	ed93 7a00 	vldr	s14, [r3]
	{
		//Open loop vector IM
		//e_shaft_speed = e_flux_speed - vectorIM_slip_speed;
		//electrical_speed_rad = e_shaft_speed;
	}
	flux_speed = electrical_speed_rad + vectorIM_slip_speed;
  411556:	4a0e      	ldr	r2, [pc, #56]	; (411590 <vectorIM_calc_speeds+0x4c>)
  411558:	4b0e      	ldr	r3, [pc, #56]	; (411594 <vectorIM_calc_speeds+0x50>)
  41155a:	edd2 7a00 	vldr	s15, [r2]
  41155e:	ee77 7a87 	vadd.f32	s15, s15, s14
  411562:	edc3 7a00 	vstr	s15, [r3]
  411566:	bd08      	pop	{r3, pc}
	if (MOTOR_IM_CVC)
  411568:	781a      	ldrb	r2, [r3, #0]
  41156a:	2a00      	cmp	r2, #0
  41156c:	d1f0      	bne.n	411550 <vectorIM_calc_speeds+0xc>
	float tmp = (enc_get_omega_rad_hat(MOTOR_POLEPAIR));
  41156e:	f893 003c 	ldrb.w	r0, [r3, #60]	; 0x3c
  411572:	4b09      	ldr	r3, [pc, #36]	; (411598 <vectorIM_calc_speeds+0x54>)
  411574:	4798      	blx	r3
	tmp /= FIXEDPT_ONE;
  411576:	ee07 0a10 	vmov	s14, r0
		electrical_speed_rad = vectorIM_get_measured_shaft_speed();
  41157a:	4b04      	ldr	r3, [pc, #16]	; (41158c <vectorIM_calc_speeds+0x48>)
	tmp /= FIXEDPT_ONE;
  41157c:	eeba 7ae8 	vcvt.f32.s32	s14, s14, #15
		electrical_speed_rad = vectorIM_get_measured_shaft_speed();
  411580:	ed83 7a00 	vstr	s14, [r3]
  411584:	e7e7      	b.n	411556 <vectorIM_calc_speeds+0x12>
  411586:	bf00      	nop
  411588:	20404ff0 	.word	0x20404ff0
  41158c:	20400a00 	.word	0x20400a00
  411590:	20400a1c 	.word	0x20400a1c
  411594:	20400a0c 	.word	0x20400a0c
  411598:	00413da1 	.word	0x00413da1

0041159c <vectorIM_activate_reg_reset>:

uint32_t reg_reset_flag = 1;

void vectorIM_activate_reg_reset(void)
{
	reg_reset_flag = 1;
  41159c:	4b01      	ldr	r3, [pc, #4]	; (4115a4 <vectorIM_activate_reg_reset+0x8>)
  41159e:	2201      	movs	r2, #1
  4115a0:	601a      	str	r2, [r3, #0]
  4115a2:	4770      	bx	lr
  4115a4:	20400380 	.word	0x20400380

004115a8 <vectorIM_perform>:
}

void vectorIM_perform(float desired_tourque, float desired_flux_ratio)
{
  4115a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	float id , iq, flux, vff_d, vff_q, vff_qEMF;
	float tmp, com_vd, com_vq;
	float dc_voltage = iverter_get_dc_v();
  4115ac:	4bba      	ldr	r3, [pc, #744]	; (411898 <vectorIM_perform+0x2f0>)
{
  4115ae:	468a      	mov	sl, r1
	tmp = speed * TSAMPLE;
  4115b0:	4dba      	ldr	r5, [pc, #744]	; (41189c <vectorIM_perform+0x2f4>)
	float q_sat_limit;
	dc_voltage /= FIXEDPT_ONE;
	
	vectorIM_calc_speeds();
	
	float flux_angle = vectorIM_get_angle(flux_speed);
  4115b2:	4ebb      	ldr	r6, [pc, #748]	; (4118a0 <vectorIM_perform+0x2f8>)
	float flux_max  =  (ID * I_IM_LM);
  4115b4:	4cbb      	ldr	r4, [pc, #748]	; (4118a4 <vectorIM_perform+0x2fc>)
{
  4115b6:	ed2d 8b0e 	vpush	{d8-d14}
  4115ba:	b087      	sub	sp, #28
	tmp = speed * TSAMPLE;
  4115bc:	eef7 aa00 	vmov.f32	s21, #112	; 0x3f800000  1.0
{
  4115c0:	ee0a 0a10 	vmov	s20, r0
	float dc_voltage = iverter_get_dc_v();
  4115c4:	4798      	blx	r3
	vectorIM_calc_speeds();
  4115c6:	4bb8      	ldr	r3, [pc, #736]	; (4118a8 <vectorIM_perform+0x300>)
	float dc_voltage = iverter_get_dc_v();
  4115c8:	9002      	str	r0, [sp, #8]
	vectorIM_calc_speeds();
  4115ca:	4798      	blx	r3
	tmp = speed * TSAMPLE;
  4115cc:	edd5 7a00 	vldr	s15, [r5]
	vectorIM_angle += tmp;
  4115d0:	ed9f 6ab6 	vldr	s12, [pc, #728]	; 4118ac <vectorIM_perform+0x304>
	tmp = speed * TSAMPLE;
  4115d4:	eeca 5aa7 	vdiv.f32	s11, s21, s15
	vectorIM_angle += tmp;
  4115d8:	edd6 6a00 	vldr	s13, [r6]
  4115dc:	4bb4      	ldr	r3, [pc, #720]	; (4118b0 <vectorIM_perform+0x308>)
	vectorIM_angle /= 360;
  4115de:	eddf 7ab5 	vldr	s15, [pc, #724]	; 4118b4 <vectorIM_perform+0x30c>
	vectorIM_angle += tmp;
  4115e2:	ed93 7a00 	vldr	s14, [r3]

	
	axt_set_theta(flux_angle);
  4115e6:	4ab4      	ldr	r2, [pc, #720]	; (4118b8 <vectorIM_perform+0x310>)
	vectorIM_angle += tmp;
  4115e8:	ee66 6a86 	vmul.f32	s13, s13, s12
	vectorIM_angle *= 360;
  4115ec:	ed9f 6ab3 	vldr	s12, [pc, #716]	; 4118bc <vectorIM_perform+0x314>
	vectorIM_angle += tmp;
  4115f0:	eea5 7aa6 	vfma.f32	s14, s11, s13
	vectorIM_angle /= 360;
  4115f4:	ee27 7a27 	vmul.f32	s14, s14, s15
	vectorIM_angle -= (int32_t)vectorIM_angle;
  4115f8:	eefd 7ac7 	vcvt.s32.f32	s15, s14
  4115fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  411600:	ee77 7a67 	vsub.f32	s15, s14, s15
	vectorIM_angle *= 360;
  411604:	ee67 7a86 	vmul.f32	s15, s15, s12
	axt_set_theta(flux_angle);
  411608:	ee17 0a90 	vmov	r0, s15
	vectorIM_angle *= 360;
  41160c:	edc3 7a00 	vstr	s15, [r3]
	axt_set_theta(flux_angle);
  411610:	4790      	blx	r2
	axt_park_exe();	
  411612:	4bab      	ldr	r3, [pc, #684]	; (4118c0 <vectorIM_perform+0x318>)
  411614:	4798      	blx	r3
	
	id = axt_get_id();
  411616:	4bab      	ldr	r3, [pc, #684]	; (4118c4 <vectorIM_perform+0x31c>)
  411618:	4798      	blx	r3
	iq = axt_get_iq();
  41161a:	4bab      	ldr	r3, [pc, #684]	; (4118c8 <vectorIM_perform+0x320>)
	id = axt_get_id();
  41161c:	ee08 0a90 	vmov	s17, r0
	iq = axt_get_iq();
  411620:	4798      	blx	r3
  411622:	ed9f 7aaa 	vldr	s14, [pc, #680]	; 4118cc <vectorIM_perform+0x324>
  411626:	ee0b 0a10 	vmov	s22, r0
  41162a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
	float t_ratio   =  (TSAMPLE / I_IM_TC);
  41162e:	edd4 6a08 	vldr	s13, [r4, #32]
  411632:	ee67 7a87 	vmul.f32	s15, s15, s14
	vector_IM_flux   += ((flux_max - vector_IM_flux) * t_ratio);
  411636:	4ba6      	ldr	r3, [pc, #664]	; (4118d0 <vectorIM_perform+0x328>)
	float t_ratio   =  (TSAMPLE / I_IM_TC);
  411638:	ed95 6a00 	vldr	s12, [r5]
	vector_IM_flux   += ((flux_max - vector_IM_flux) * t_ratio);
  41163c:	ed93 8a00 	vldr	s16, [r3]
	float t_ratio   =  (TSAMPLE / I_IM_TC);
  411640:	ee87 7aa6 	vdiv.f32	s14, s15, s13
	
	//speed_regulator_setKt(T_CONST);
	vff_d = (-flux_speed * I_IM_LSEG * iq);
	//vff_d=0;

	vff_qEMF = (flux * electrical_speed_rad);
  411644:	4aa3      	ldr	r2, [pc, #652]	; (4118d4 <vectorIM_perform+0x32c>)
	cid = id;
  411646:	49a4      	ldr	r1, [pc, #656]	; (4118d8 <vectorIM_perform+0x330>)
	vff_qEMF = (flux * electrical_speed_rad);
  411648:	edd2 9a00 	vldr	s19, [r2]
	ciq = iq;
  41164c:	4aa3      	ldr	r2, [pc, #652]	; (4118dc <vectorIM_perform+0x334>)
	cid = id;
  41164e:	edc1 8a00 	vstr	s17, [r1]
	vector_IM_flux   += ((flux_max - vector_IM_flux) * t_ratio);
  411652:	eef0 6a48 	vmov.f32	s13, s16
	vff_d = (-flux_speed * I_IM_LSEG * iq);
  411656:	ed96 9a00 	vldr	s18, [r6]
  41165a:	edd4 ba09 	vldr	s23, [r4, #36]	; 0x24
	ciq = iq;
  41165e:	6010      	str	r0, [r2, #0]
	vector_IM_flux   += ((flux_max - vector_IM_flux) * t_ratio);
  411660:	eed8 6aa7 	vfnms.f32	s13, s17, s15
	float t_ratio   =  (TSAMPLE / I_IM_TC);
  411664:	ee67 7a06 	vmul.f32	s15, s14, s12
  411668:	ee8a 7aa7 	vdiv.f32	s14, s21, s15
	vector_IM_flux   += ((flux_max - vector_IM_flux) * t_ratio);
  41166c:	eea7 8a26 	vfma.f32	s16, s14, s13
	vff_qEMF = (flux * electrical_speed_rad);
  411670:	ee68 9a29 	vmul.f32	s19, s16, s19
	vector_IM_flux   += ((flux_max - vector_IM_flux) * t_ratio);
  411674:	ed83 8a00 	vstr	s16, [r3]
	
	//determine motoring or regenerating action
	if (vff_qEMF > 0)
  411678:	eef5 9ac0 	vcmpe.f32	s19, #0.0
  41167c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  411680:	f340 80e7 	ble.w	411852 <vectorIM_perform+0x2aa>
	{
		if (iq < 0) vfd_set_regencount();
  411684:	eeb5 bac0 	vcmpe.f32	s22, #0.0
  411688:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41168c:	f100 80ed 	bmi.w	41186a <vectorIM_perform+0x2c2>
		else vfd_clr_regencount();
  411690:	4b93      	ldr	r3, [pc, #588]	; (4118e0 <vectorIM_perform+0x338>)
  411692:	4798      	blx	r3
  411694:	edd4 da09 	vldr	s27, [r4, #36]	; 0x24
  411698:	ed96 da00 	vldr	s26, [r6]
	
	
	//com_vd = 380 * sqrt2 * flux_speed / (6.283 * 50 );
	//com_vq = 0;
	
	if (reg_reset_flag == 1)
  41169c:	4b91      	ldr	r3, [pc, #580]	; (4118e4 <vectorIM_perform+0x33c>)
  41169e:	681b      	ldr	r3, [r3, #0]
  4116a0:	2b01      	cmp	r3, #1
  4116a2:	f000 80cd 	beq.w	411840 <vectorIM_perform+0x298>
		com_vq = 0;
	}
	else
	{
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
		com_vd = reg_pi_exe(dc_voltage * D_SAT_FACTOR, tmp, vff_d, TSAMPLE, &pi_d);
  4116a6:	eeb7 ca00 	vmov.f32	s24, #112	; 0x3f800000  1.0
  4116aa:	edd5 7a00 	vldr	s15, [r5]
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  4116ae:	4e8e      	ldr	r6, [pc, #568]	; (4118e8 <vectorIM_perform+0x340>)
  4116b0:	6b60      	ldr	r0, [r4, #52]	; 0x34
		com_vd = reg_pi_exe(dc_voltage * D_SAT_FACTOR, tmp, vff_d, TSAMPLE, &pi_d);
  4116b2:	ee8c ea27 	vdiv.f32	s28, s24, s15
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  4116b6:	f8df 8260 	ldr.w	r8, [pc, #608]	; 411918 <vectorIM_perform+0x370>
  4116ba:	47b0      	blx	r6
	dc_voltage /= FIXEDPT_ONE;
  4116bc:	eddd aa02 	vldr	s21, [sp, #8]
	vff_d = (-flux_speed * I_IM_LSEG * iq);
  4116c0:	eddf ca82 	vldr	s25, [pc, #520]	; 4118cc <vectorIM_perform+0x324>
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  4116c4:	4f89      	ldr	r7, [pc, #548]	; (4118ec <vectorIM_perform+0x344>)
		com_vd = reg_pi_exe(dc_voltage * D_SAT_FACTOR, tmp, vff_d, TSAMPLE, &pi_d);
  4116c6:	f8df 9264 	ldr.w	r9, [pc, #612]	; 41192c <vectorIM_perform+0x384>
	vff_d = (-flux_speed * I_IM_LSEG * iq);
  4116ca:	ee6b baac 	vmul.f32	s23, s23, s25
	dc_voltage /= FIXEDPT_ONE;
  4116ce:	eefa aae8 	vcvt.f32.s32	s21, s21, #15
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  4116d2:	a369      	add	r3, pc, #420	; (adr r3, 411878 <vectorIM_perform+0x2d0>)
  4116d4:	e9d3 2300 	ldrd	r2, r3, [r3]
  4116d8:	47c0      	blx	r8
	vff_d = (-flux_speed * I_IM_LSEG * iq);
  4116da:	ee29 9a6b 	vnmul.f32	s18, s18, s23
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  4116de:	e9cd 0102 	strd	r0, r1, [sp, #8]
  4116e2:	4650      	mov	r0, sl
	vff_d = (-flux_speed * I_IM_LSEG * iq);
  4116e4:	ee29 9a0b 	vmul.f32	s18, s18, s22
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  4116e8:	47b0      	blx	r6
  4116ea:	4602      	mov	r2, r0
  4116ec:	460b      	mov	r3, r1
  4116ee:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  4116f2:	47c0      	blx	r8
  4116f4:	4682      	mov	sl, r0
  4116f6:	468b      	mov	fp, r1
  4116f8:	ee18 0a90 	vmov	r0, s17
  4116fc:	47b0      	blx	r6
  4116fe:	4602      	mov	r2, r0
  411700:	460b      	mov	r3, r1
  411702:	4650      	mov	r0, sl
  411704:	4659      	mov	r1, fp
		q_sat_limit = fixedpt_abs(com_vd) / dc_voltage;
		q_sat_limit += 0.005;
		q_sat_limit = com_sin(q_sat_limit) * dc_voltage;
		
		tmp = (desired_tourque - iq); //error signal.
		com_vq = reg_pi_exe(q_sat_limit, tmp, vff_q + vff_qEMF, TSAMPLE, &pi_q );	
  411706:	ee68 8aac 	vmul.f32	s17, s17, s25
		tmp = ((desired_id * desired_flux_ratio) - id); //error signal.
  41170a:	47b8      	blx	r7
  41170c:	4b78      	ldr	r3, [pc, #480]	; (4118f0 <vectorIM_perform+0x348>)
  41170e:	4798      	blx	r3
  411710:	4682      	mov	sl, r0
		com_vd = reg_pi_exe(dc_voltage * D_SAT_FACTOR, tmp, vff_d, TSAMPLE, &pi_d);
  411712:	ee1a 0a90 	vmov	r0, s21
		com_vq = reg_pi_exe(q_sat_limit, tmp, vff_q + vff_qEMF, TSAMPLE, &pi_q );	
  411716:	ee68 8aad 	vmul.f32	s17, s17, s27
		com_vd = reg_pi_exe(dc_voltage * D_SAT_FACTOR, tmp, vff_d, TSAMPLE, &pi_d);
  41171a:	47b0      	blx	r6
  41171c:	a358      	add	r3, pc, #352	; (adr r3, 411880 <vectorIM_perform+0x2d8>)
  41171e:	e9d3 2300 	ldrd	r2, r3, [r3]
  411722:	47c0      	blx	r8
  411724:	4b72      	ldr	r3, [pc, #456]	; (4118f0 <vectorIM_perform+0x348>)
  411726:	4798      	blx	r3
  411728:	f8df e1f8 	ldr.w	lr, [pc, #504]	; 411924 <vectorIM_perform+0x37c>
  41172c:	ee19 2a10 	vmov	r2, s18
  411730:	ee1e 3a10 	vmov	r3, s28
  411734:	f8cd e000 	str.w	lr, [sp]
  411738:	4651      	mov	r1, sl
  41173a:	47c8      	blx	r9
  41173c:	ee09 0a10 	vmov	s18, r0
		com_vq = reg_pi_exe(q_sat_limit, tmp, vff_q + vff_qEMF, TSAMPLE, &pi_q );	
  411740:	eee8 9a8d 	vfma.f32	s19, s17, s26
		q_sat_limit = fixedpt_abs(com_vd) / dc_voltage;
  411744:	eef0 7ac9 	vabs.f32	s15, s18
		q_sat_limit += 0.005;
  411748:	ee87 7aaa 	vdiv.f32	s14, s15, s21
  41174c:	ee17 0a10 	vmov	r0, s14
  411750:	47b0      	blx	r6
  411752:	4e68      	ldr	r6, [pc, #416]	; (4118f4 <vectorIM_perform+0x34c>)
  411754:	a34c      	add	r3, pc, #304	; (adr r3, 411888 <vectorIM_perform+0x2e0>)
  411756:	e9d3 2300 	ldrd	r2, r3, [r3]
  41175a:	47b0      	blx	r6
  41175c:	4b64      	ldr	r3, [pc, #400]	; (4118f0 <vectorIM_perform+0x348>)
  41175e:	4798      	blx	r3
		q_sat_limit = com_sin(q_sat_limit) * dc_voltage;
  411760:	4b65      	ldr	r3, [pc, #404]	; (4118f8 <vectorIM_perform+0x350>)
  411762:	4798      	blx	r3
		com_vq = reg_pi_exe(q_sat_limit, tmp, vff_q + vff_qEMF, TSAMPLE, &pi_q );	
  411764:	ee07 0a10 	vmov	s14, r0
  411768:	edd5 7a00 	vldr	s15, [r5]
  41176c:	ee2a 7a87 	vmul.f32	s14, s21, s14
  411770:	4a62      	ldr	r2, [pc, #392]	; (4118fc <vectorIM_perform+0x354>)
  411772:	9200      	str	r2, [sp, #0]
  411774:	ee19 2a90 	vmov	r2, s19
  411778:	ee17 0a10 	vmov	r0, s14
  41177c:	ee3a 7a4b 	vsub.f32	s14, s20, s22
  411780:	ee17 1a10 	vmov	r1, s14
  411784:	ee8c 7a27 	vdiv.f32	s14, s24, s15
  411788:	ee17 3a10 	vmov	r3, s14
  41178c:	47c8      	blx	r9
  41178e:	4605      	mov	r5, r0
	}
	
	//cvd = com_vd;
	cvq = com_vq;
  411790:	4f5b      	ldr	r7, [pc, #364]	; (411900 <vectorIM_perform+0x358>)
	
	
	float valpha, vbeta;
	axt_ipark_exe(com_vd, com_vq, &valpha, &vbeta);
  411792:	4629      	mov	r1, r5
  411794:	ab05      	add	r3, sp, #20
  411796:	aa04      	add	r2, sp, #16
  411798:	ee19 0a10 	vmov	r0, s18
  41179c:	4e59      	ldr	r6, [pc, #356]	; (411904 <vectorIM_perform+0x35c>)
	cvq = com_vq;
  41179e:	603d      	str	r5, [r7, #0]
	axt_ipark_exe(com_vd, com_vq, &valpha, &vbeta);
  4117a0:	47b0      	blx	r6
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  4117a2:	ed9d 7a05 	vldr	s14, [sp, #20]
  4117a6:	eddd 7a04 	vldr	s15, [sp, #16]
  4117aa:	eef0 6a47 	vmov.f32	s13, s14
  4117ae:	4b56      	ldr	r3, [pc, #344]	; (411908 <vectorIM_perform+0x360>)
  4117b0:	eeb0 7a67 	vmov.f32	s14, s15
  4117b4:	eefe 6ae8 	vcvt.s32.f32	s13, s13, #15
  4117b8:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
  4117bc:	ee16 1a90 	vmov	r1, s13
  4117c0:	ee17 0a10 	vmov	r0, s14
  4117c4:	4798      	blx	r3
	
	
	//calc slip speed
	tmp = ( desired_tourque * I_IM_RR );
	if (fixedpt_abs(flux) <= FLUX_MIN)
  4117c6:	eef0 7ac8 	vabs.f32	s15, s16
  4117ca:	ed9f 7a50 	vldr	s14, [pc, #320]	; 41190c <vectorIM_perform+0x364>
  4117ce:	eef4 7ac7 	vcmpe.f32	s15, s14
  4117d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4117d6:	d80d      	bhi.n	4117f4 <vectorIM_perform+0x24c>
	{
		vectorIM_slip_speed = 0;
  4117d8:	4b4d      	ldr	r3, [pc, #308]	; (411910 <vectorIM_perform+0x368>)
  4117da:	2000      	movs	r0, #0
	} 
	else
	{
		vectorIM_slip_speed = (tmp / flux);
	}
	cvd = vectorIM_slip_speed / 6.283;	
  4117dc:	4a4d      	ldr	r2, [pc, #308]	; (411914 <vectorIM_perform+0x36c>)
		vectorIM_slip_speed = 0;
  4117de:	6018      	str	r0, [r3, #0]
	
	if (MOTOR_IM_OVC)
  4117e0:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
	cvd = vectorIM_slip_speed / 6.283;	
  4117e4:	6010      	str	r0, [r2, #0]
	if (MOTOR_IM_OVC)
  4117e6:	2b02      	cmp	r3, #2
  4117e8:	d01e      	beq.n	411828 <vectorIM_perform+0x280>
	//cid = (electrical_speed_rad - 0/*vectorIM_slip_speed*/) / 6.283; //electrical_speed_rad;
	//cvd /= FIXEDPT_ONE;
	//cvq = electrical_speed_rad;
	
	
}
  4117ea:	b007      	add	sp, #28
  4117ec:	ecbd 8b0e 	vpop	{d8-d14}
  4117f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	tmp = ( desired_tourque * I_IM_RR );
  4117f4:	edd4 7a08 	vldr	s15, [r4, #32]
		vectorIM_slip_speed = (tmp / flux);
  4117f8:	4a45      	ldr	r2, [pc, #276]	; (411910 <vectorIM_perform+0x368>)
	tmp = ( desired_tourque * I_IM_RR );
  4117fa:	ee2a aa27 	vmul.f32	s20, s20, s15
  4117fe:	4b3a      	ldr	r3, [pc, #232]	; (4118e8 <vectorIM_perform+0x340>)
  411800:	4d45      	ldr	r5, [pc, #276]	; (411918 <vectorIM_perform+0x370>)
		vectorIM_slip_speed = (tmp / flux);
  411802:	eeca 7a08 	vdiv.f32	s15, s20, s16
  411806:	edc2 7a00 	vstr	s15, [r2]
  41180a:	ee17 0a90 	vmov	r0, s15
  41180e:	4798      	blx	r3
  411810:	a31f      	add	r3, pc, #124	; (adr r3, 411890 <vectorIM_perform+0x2e8>)
  411812:	e9d3 2300 	ldrd	r2, r3, [r3]
  411816:	47a8      	blx	r5
  411818:	4b35      	ldr	r3, [pc, #212]	; (4118f0 <vectorIM_perform+0x348>)
  41181a:	4798      	blx	r3
	if (MOTOR_IM_OVC)
  41181c:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
	cvd = vectorIM_slip_speed / 6.283;	
  411820:	4a3c      	ldr	r2, [pc, #240]	; (411914 <vectorIM_perform+0x36c>)
	if (MOTOR_IM_OVC)
  411822:	2b02      	cmp	r3, #2
	cvd = vectorIM_slip_speed / 6.283;	
  411824:	6010      	str	r0, [r2, #0]
	if (MOTOR_IM_OVC)
  411826:	d1e0      	bne.n	4117ea <vectorIM_perform+0x242>
  411828:	7823      	ldrb	r3, [r4, #0]
  41182a:	2b00      	cmp	r3, #0
  41182c:	d1dd      	bne.n	4117ea <vectorIM_perform+0x242>
		vectorIM_estimate_sync_speed(valpha, vbeta);
  41182e:	9905      	ldr	r1, [sp, #20]
  411830:	9804      	ldr	r0, [sp, #16]
  411832:	4b3a      	ldr	r3, [pc, #232]	; (41191c <vectorIM_perform+0x374>)
  411834:	4798      	blx	r3
}
  411836:	b007      	add	sp, #28
  411838:	ecbd 8b0e 	vpop	{d8-d14}
  41183c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		reg_pi_reset_memory(&pi_d);
  411840:	4d37      	ldr	r5, [pc, #220]	; (411920 <vectorIM_perform+0x378>)
  411842:	4838      	ldr	r0, [pc, #224]	; (411924 <vectorIM_perform+0x37c>)
  411844:	47a8      	blx	r5
		reg_pi_reset_memory(&pi_q);
  411846:	482d      	ldr	r0, [pc, #180]	; (4118fc <vectorIM_perform+0x354>)
  411848:	47a8      	blx	r5
		com_vq = 0;
  41184a:	2500      	movs	r5, #0
		com_vd = 0;
  41184c:	ee09 5a10 	vmov	s18, r5
  411850:	e79e      	b.n	411790 <vectorIM_perform+0x1e8>
	else if (vff_qEMF < 0)
  411852:	d404      	bmi.n	41185e <vectorIM_perform+0x2b6>
  411854:	eeb0 da49 	vmov.f32	s26, s18
  411858:	eef0 da6b 	vmov.f32	s27, s23
  41185c:	e71e      	b.n	41169c <vectorIM_perform+0xf4>
		if (iq > 0) vfd_set_regencount();
  41185e:	eeb5 bac0 	vcmpe.f32	s22, #0.0
  411862:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  411866:	f77f af13 	ble.w	411690 <vectorIM_perform+0xe8>
		if (iq < 0) vfd_set_regencount();
  41186a:	4b2f      	ldr	r3, [pc, #188]	; (411928 <vectorIM_perform+0x380>)
  41186c:	4798      	blx	r3
  41186e:	edd4 da09 	vldr	s27, [r4, #36]	; 0x24
  411872:	ed96 da00 	vldr	s26, [r6]
  411876:	e711      	b.n	41169c <vectorIM_perform+0xf4>
  411878:	667f3bcd 	.word	0x667f3bcd
  41187c:	3ff6a09e 	.word	0x3ff6a09e
  411880:	e4e6f746 	.word	0xe4e6f746
  411884:	3fdfffff 	.word	0x3fdfffff
  411888:	47ae147b 	.word	0x47ae147b
  41188c:	3f747ae1 	.word	0x3f747ae1
  411890:	ce20d722 	.word	0xce20d722
  411894:	3fc45f57 	.word	0x3fc45f57
  411898:	0041570d 	.word	0x0041570d
  41189c:	204003c8 	.word	0x204003c8
  4118a0:	20400a0c 	.word	0x20400a0c
  4118a4:	20404ff0 	.word	0x20404ff0
  4118a8:	00411545 	.word	0x00411545
  4118ac:	42652ee0 	.word	0x42652ee0
  4118b0:	20400a18 	.word	0x20400a18
  4118b4:	3b360b61 	.word	0x3b360b61
  4118b8:	0040e1f9 	.word	0x0040e1f9
  4118bc:	43b40000 	.word	0x43b40000
  4118c0:	0040e23d 	.word	0x0040e23d
  4118c4:	0040e2d1 	.word	0x0040e2d1
  4118c8:	0040e2dd 	.word	0x0040e2dd
  4118cc:	3a83126f 	.word	0x3a83126f
  4118d0:	20400384 	.word	0x20400384
  4118d4:	20400a00 	.word	0x20400a00
  4118d8:	2040655c 	.word	0x2040655c
  4118dc:	20406554 	.word	0x20406554
  4118e0:	00416c65 	.word	0x00416c65
  4118e4:	20400380 	.word	0x20400380
  4118e8:	00418749 	.word	0x00418749
  4118ec:	00418489 	.word	0x00418489
  4118f0:	00418da1 	.word	0x00418da1
  4118f4:	0041848d 	.word	0x0041848d
  4118f8:	00409859 	.word	0x00409859
  4118fc:	20406540 	.word	0x20406540
  411900:	20406550 	.word	0x20406550
  411904:	0040e301 	.word	0x0040e301
  411908:	00415191 	.word	0x00415191
  41190c:	38d1b717 	.word	0x38d1b717
  411910:	20400a1c 	.word	0x20400a1c
  411914:	20406558 	.word	0x20406558
  411918:	004187f1 	.word	0x004187f1
  41191c:	004113e5 	.word	0x004113e5
  411920:	0040a92d 	.word	0x0040a92d
  411924:	204064b4 	.word	0x204064b4
  411928:	00416c51 	.word	0x00416c51
  41192c:	0040a935 	.word	0x0040a935

00411930 <vector_IM_init>:
 #define IKID        (menue_drive_data_applied.m_ACRD_i * menue_drive_data_applied.m_ACR_bandwidth / 10)

 #define IKPQ        (menue_drive_data_applied.m_ACRQ_p * menue_drive_data_applied.m_ACR_bandwidth / 1000)
 #define IKIQ        (menue_drive_data_applied.m_ACRQ_i * menue_drive_data_applied.m_ACR_bandwidth / 10)
void vector_IM_init(void)
{
  411930:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	reg_reset_flag = 0;
	vector_IM_flux = 0;
	vectorIM_slip_speed = 0;
	flux_speed = 0;
	vectorIM_angle = 0;
	reg_pi_init(IKPD, IKID, &pi_d);
  411934:	4c3c      	ldr	r4, [pc, #240]	; (411a28 <vector_IM_init+0xf8>)
	reg_reset_flag = 0;
  411936:	2700      	movs	r7, #0
  411938:	4e3c      	ldr	r6, [pc, #240]	; (411a2c <vector_IM_init+0xfc>)
	vector_IM_flux = 0;
  41193a:	2300      	movs	r3, #0
	reg_pi_init(IKPD, IKID, &pi_d);
  41193c:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
  411940:	edd4 6a1c 	vldr	s13, [r4, #112]	; 0x70
  411944:	ed94 7a1d 	vldr	s14, [r4, #116]	; 0x74
	vector_IM_flux = 0;
  411948:	4a39      	ldr	r2, [pc, #228]	; (411a30 <vector_IM_init+0x100>)
	reg_pi_init(IKPD, IKID, &pi_d);
  41194a:	ee27 7a87 	vmul.f32	s14, s15, s14
	vectorIM_slip_speed = 0;
  41194e:	4d39      	ldr	r5, [pc, #228]	; (411a34 <vector_IM_init+0x104>)
	reg_pi_init(IKPD, IKID, &pi_d);
  411950:	ee67 7aa6 	vmul.f32	s15, s15, s13
{
  411954:	ed2d 8b02 	vpush	{d8}
	reg_pi_init(IKPD, IKID, &pi_d);
  411958:	eddf 8a37 	vldr	s17, [pc, #220]	; 411a38 <vector_IM_init+0x108>
  41195c:	ed9f 8a37 	vldr	s16, [pc, #220]	; 411a3c <vector_IM_init+0x10c>
  411960:	ee27 7a28 	vmul.f32	s14, s14, s17
	reg_reset_flag = 0;
  411964:	6037      	str	r7, [r6, #0]
	reg_pi_init(IKPD, IKID, &pi_d);
  411966:	ee67 7a88 	vmul.f32	s15, s15, s16
	flux_speed = 0;
  41196a:	4f35      	ldr	r7, [pc, #212]	; (411a40 <vector_IM_init+0x110>)
	vectorIM_angle = 0;
  41196c:	4e35      	ldr	r6, [pc, #212]	; (411a44 <vector_IM_init+0x114>)
	vector_IM_flux = 0;
  41196e:	6013      	str	r3, [r2, #0]
	reg_pi_init(IKPD, IKID, &pi_d);
  411970:	ee17 1a10 	vmov	r1, s14
	vectorIM_slip_speed = 0;
  411974:	602b      	str	r3, [r5, #0]
	reg_pi_init(IKPD, IKID, &pi_d);
  411976:	ee17 0a90 	vmov	r0, s15
  41197a:	4a33      	ldr	r2, [pc, #204]	; (411a48 <vector_IM_init+0x118>)
  41197c:	4d33      	ldr	r5, [pc, #204]	; (411a4c <vector_IM_init+0x11c>)
	flux_speed = 0;
  41197e:	603b      	str	r3, [r7, #0]
	vectorIM_angle = 0;
  411980:	6033      	str	r3, [r6, #0]
	reg_pi_init(IKPD, IKID, &pi_d);
  411982:	47a8      	blx	r5
	reg_pi_init(IKPQ, IKIQ, &pi_q);	
  411984:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
  411988:	ed94 7a1f 	vldr	s14, [r4, #124]	; 0x7c
  41198c:	edd4 6a1e 	vldr	s13, [r4, #120]	; 0x78
  411990:	ee27 7a87 	vmul.f32	s14, s15, s14
  411994:	4a2e      	ldr	r2, [pc, #184]	; (411a50 <vector_IM_init+0x120>)
  411996:	ee67 7aa6 	vmul.f32	s15, s15, s13
  41199a:	ee27 7a28 	vmul.f32	s14, s14, s17
  41199e:	ee67 7a88 	vmul.f32	s15, s15, s16
  4119a2:	ee17 1a10 	vmov	r1, s14
  4119a6:	ee17 0a90 	vmov	r0, s15
  4119aa:	47a8      	blx	r5
	if (MOTOR_IM_CVC) speed_regulator_setKt(T_CONST);
  4119ac:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
  4119b0:	2b01      	cmp	r3, #1
  4119b2:	d005      	beq.n	4119c0 <vector_IM_init+0x90>
	vectorIM_set_filter_timeconst();
  4119b4:	4b27      	ldr	r3, [pc, #156]	; (411a54 <vector_IM_init+0x124>)
  4119b6:	ecbd 8b02 	vpop	{d8}
  4119ba:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	vectorIM_set_filter_timeconst();
  4119be:	4718      	bx	r3
	if (MOTOR_IM_CVC) speed_regulator_setKt(T_CONST);
  4119c0:	7823      	ldrb	r3, [r4, #0]
  4119c2:	2b00      	cmp	r3, #0
  4119c4:	d1f6      	bne.n	4119b4 <vector_IM_init+0x84>
  4119c6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
  4119ca:	4e23      	ldr	r6, [pc, #140]	; (411a58 <vector_IM_init+0x128>)
  4119cc:	ee67 7a88 	vmul.f32	s15, s15, s16
  4119d0:	4d22      	ldr	r5, [pc, #136]	; (411a5c <vector_IM_init+0x12c>)
  4119d2:	ee17 0a90 	vmov	r0, s15
  4119d6:	47b0      	blx	r6
  4119d8:	4680      	mov	r8, r0
  4119da:	4689      	mov	r9, r1
  4119dc:	6b60      	ldr	r0, [r4, #52]	; 0x34
  4119de:	47b0      	blx	r6
  4119e0:	a30f      	add	r3, pc, #60	; (adr r3, 411a20 <vector_IM_init+0xf0>)
  4119e2:	e9d3 2300 	ldrd	r2, r3, [r3]
  4119e6:	47a8      	blx	r5
  4119e8:	4602      	mov	r2, r0
  4119ea:	460b      	mov	r3, r1
  4119ec:	4640      	mov	r0, r8
  4119ee:	4649      	mov	r1, r9
  4119f0:	47a8      	blx	r5
  4119f2:	4606      	mov	r6, r0
  4119f4:	460f      	mov	r7, r1
  4119f6:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
  4119fa:	4b19      	ldr	r3, [pc, #100]	; (411a60 <vector_IM_init+0x130>)
  4119fc:	4798      	blx	r3
  4119fe:	4602      	mov	r2, r0
  411a00:	460b      	mov	r3, r1
  411a02:	4630      	mov	r0, r6
  411a04:	4639      	mov	r1, r7
  411a06:	47a8      	blx	r5
  411a08:	4b16      	ldr	r3, [pc, #88]	; (411a64 <vector_IM_init+0x134>)
  411a0a:	4798      	blx	r3
  411a0c:	4b16      	ldr	r3, [pc, #88]	; (411a68 <vector_IM_init+0x138>)
  411a0e:	4798      	blx	r3
	vectorIM_set_filter_timeconst();
  411a10:	4b10      	ldr	r3, [pc, #64]	; (411a54 <vector_IM_init+0x124>)
  411a12:	ecbd 8b02 	vpop	{d8}
  411a16:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	vectorIM_set_filter_timeconst();
  411a1a:	4718      	bx	r3
  411a1c:	f3af 8000 	nop.w
  411a20:	14092130 	.word	0x14092130
  411a24:	3ff3988e 	.word	0x3ff3988e
  411a28:	20404ff0 	.word	0x20404ff0
  411a2c:	20400380 	.word	0x20400380
  411a30:	20400384 	.word	0x20400384
  411a34:	20400a1c 	.word	0x20400a1c
  411a38:	3dcccccd 	.word	0x3dcccccd
  411a3c:	3a83126f 	.word	0x3a83126f
  411a40:	20400a0c 	.word	0x20400a0c
  411a44:	20400a18 	.word	0x20400a18
  411a48:	204064b4 	.word	0x204064b4
  411a4c:	0040a8fd 	.word	0x0040a8fd
  411a50:	20406540 	.word	0x20406540
  411a54:	00411345 	.word	0x00411345
  411a58:	00418749 	.word	0x00418749
  411a5c:	004187f1 	.word	0x004187f1
  411a60:	00418725 	.word	0x00418725
  411a64:	00418da1 	.word	0x00418da1
  411a68:	0040f1b1 	.word	0x0040f1b1

00411a6c <vectorPM_activate_reg_reset>:
float cvd, cvq, cid, ciq;

uint32_t regPM_reset_flag = 1;
void vectorPM_activate_reg_reset(void)
{
	regPM_reset_flag = 1;
  411a6c:	4b01      	ldr	r3, [pc, #4]	; (411a74 <vectorPM_activate_reg_reset+0x8>)
  411a6e:	2201      	movs	r2, #1
  411a70:	601a      	str	r2, [r3, #0]
  411a72:	4770      	bx	lr
  411a74:	20400388 	.word	0x20400388

00411a78 <vectorPM_perform>:

#define T_angle (65.0)
#define D_SAT_FACTOR (/*0.98 **/ cos(T_angle * PI / 180))
#define Q_SAT_FACTOR (/*0.98 **/ sin(T_angle * PI / 180))
void vectorPM_perform(float desired_tourque)
{
  411a78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  411a7c:	4c64      	ldr	r4, [pc, #400]	; (411c10 <vectorPM_perform+0x198>)
  411a7e:	4b65      	ldr	r3, [pc, #404]	; (411c14 <vectorPM_perform+0x19c>)
{
  411a80:	ed2d 8b06 	vpush	{d8-d10}
  411a84:	ee0a 0a90 	vmov	s21, r0
  411a88:	b084      	sub	sp, #16
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  411a8a:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
  411a8e:	4798      	blx	r3
  411a90:	ed94 8a2d 	vldr	s16, [r4, #180]	; 0xb4
  411a94:	ee07 0a90 	vmov	s15, r0
	float omega_ele_rad = (enc_get_omega_rad_hat(MOTOR_POLEPAIR));
  411a98:	4b5f      	ldr	r3, [pc, #380]	; (411c18 <vectorPM_perform+0x1a0>)
  411a9a:	f894 003c 	ldrb.w	r0, [r4, #60]	; 0x3c
	float flux_angle = encoder_getangle_elec_abs(MOTOR_POLEPAIR) + (PM_ANGLE_OFFSET) ;
  411a9e:	ee37 8a88 	vadd.f32	s16, s15, s16
	float omega_ele_rad = (enc_get_omega_rad_hat(MOTOR_POLEPAIR));
  411aa2:	4798      	blx	r3
  411aa4:	ee07 0a90 	vmov	s15, r0
	omega_ele_rad /= FIXEDPT_ONE;
	float id , iq, flux, vff_d, vff_q;
	float tmp, com_vd, com_vq;
	float dc_voltage = iverter_get_dc_v();
  411aa8:	4b5c      	ldr	r3, [pc, #368]	; (411c1c <vectorPM_perform+0x1a4>)
	omega_ele_rad /= FIXEDPT_ONE;
  411aaa:	eddf 9a5d 	vldr	s19, [pc, #372]	; 411c20 <vectorPM_perform+0x1a8>
	float omega_ele_rad = (enc_get_omega_rad_hat(MOTOR_POLEPAIR));
  411aae:	eeb8 9ae7 	vcvt.f32.s32	s18, s15
	float dc_voltage = iverter_get_dc_v();
  411ab2:	4798      	blx	r3
  411ab4:	ee07 0a90 	vmov	s15, r0
	float q_sat_limit;
	dc_voltage /= FIXEDPT_ONE;
	//omega_ele_rad_f += (omega_ele_rad - omega_ele_rad_f) * (TSAMPLE / SPEED_F_TIME);

	axt_set_theta(flux_angle);
  411ab8:	4b5a      	ldr	r3, [pc, #360]	; (411c24 <vectorPM_perform+0x1ac>)
  411aba:	ee18 0a10 	vmov	r0, s16
	float dc_voltage = iverter_get_dc_v();
  411abe:	eef8 8ae7 	vcvt.f32.s32	s17, s15
	axt_set_theta(flux_angle);
  411ac2:	4798      	blx	r3
	axt_park_exe();
  411ac4:	4b58      	ldr	r3, [pc, #352]	; (411c28 <vectorPM_perform+0x1b0>)
	omega_ele_rad /= FIXEDPT_ONE;
  411ac6:	ee29 9a29 	vmul.f32	s18, s18, s19
	axt_park_exe();
  411aca:	4798      	blx	r3
	
	id = axt_get_id();
  411acc:	4b57      	ldr	r3, [pc, #348]	; (411c2c <vectorPM_perform+0x1b4>)
  411ace:	4798      	blx	r3
	iq = axt_get_iq();
  411ad0:	4b57      	ldr	r3, [pc, #348]	; (411c30 <vectorPM_perform+0x1b8>)
	id = axt_get_id();
  411ad2:	4605      	mov	r5, r0
	iq = axt_get_iq();
  411ad4:	4798      	blx	r3
	
	cid = id;
	ciq = iq;//desired_tourque;
	
	vff_d = ( -omega_ele_rad * (I_PM_LQ * iq) );
	vff_q = ( omega_ele_rad * ((I_PM_LD * id ) + KE)) ;
  411ad6:	ed9f 7a57 	vldr	s14, [pc, #348]	; 411c34 <vectorPM_perform+0x1bc>
	
	//determine motoring or regenerating action
	if (omega_ele_rad > 0)
  411ada:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
	vff_q = ( omega_ele_rad * ((I_PM_LD * id ) + KE)) ;
  411ade:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
	dc_voltage /= FIXEDPT_ONE;
  411ae2:	ee68 8aa9 	vmul.f32	s17, s17, s19
	vff_q = ( omega_ele_rad * ((I_PM_LD * id ) + KE)) ;
  411ae6:	ed94 8a0e 	vldr	s16, [r4, #56]	; 0x38
	iq = axt_get_iq();
  411aea:	ee09 0a90 	vmov	s19, r0
	vff_q = ( omega_ele_rad * ((I_PM_LD * id ) + KE)) ;
  411aee:	ee67 7a87 	vmul.f32	s15, s15, s14
  411af2:	ee07 5a10 	vmov	s14, r5
	if (omega_ele_rad > 0)
  411af6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	cid = id;
  411afa:	4a4f      	ldr	r2, [pc, #316]	; (411c38 <vectorPM_perform+0x1c0>)
	ciq = iq;//desired_tourque;
  411afc:	4b4f      	ldr	r3, [pc, #316]	; (411c3c <vectorPM_perform+0x1c4>)
	vff_q = ( omega_ele_rad * ((I_PM_LD * id ) + KE)) ;
  411afe:	eea7 8a27 	vfma.f32	s16, s14, s15
	cid = id;
  411b02:	6015      	str	r5, [r2, #0]
	ciq = iq;//desired_tourque;
  411b04:	6018      	str	r0, [r3, #0]
	vff_q = ( omega_ele_rad * ((I_PM_LD * id ) + KE)) ;
  411b06:	ee28 8a09 	vmul.f32	s16, s16, s18
	if (omega_ele_rad > 0)
  411b0a:	dd69      	ble.n	411be0 <vectorPM_perform+0x168>
	{
		if (iq < 0) vfd_set_regencount();
  411b0c:	eef5 9ac0 	vcmpe.f32	s19, #0.0
  411b10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  411b14:	d46a      	bmi.n	411bec <vectorPM_perform+0x174>
		else vfd_clr_regencount();
  411b16:	4b4a      	ldr	r3, [pc, #296]	; (411c40 <vectorPM_perform+0x1c8>)
  411b18:	4798      	blx	r3
	}
 	//vff_d = 0; 
 	//vff_q = 0;
	
	tmp = (0 - id); //error signal.
	com_vd = reg_pi_exe(dc_voltage /*580 * D_SAT_FACTOR*/, tmp, 0/*vff_d*/, TSAMPLE, &pi_d);
  411b1a:	4e4a      	ldr	r6, [pc, #296]	; (411c44 <vectorPM_perform+0x1cc>)
  411b1c:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
  411b20:	4f49      	ldr	r7, [pc, #292]	; (411c48 <vectorPM_perform+0x1d0>)
  411b22:	f085 4100 	eor.w	r1, r5, #2147483648	; 0x80000000
  411b26:	edd6 7a00 	vldr	s15, [r6]
  411b2a:	2200      	movs	r2, #0
  411b2c:	4c47      	ldr	r4, [pc, #284]	; (411c4c <vectorPM_perform+0x1d4>)
  411b2e:	ee18 0a90 	vmov	r0, s17
  411b32:	ee8a 7a27 	vdiv.f32	s14, s20, s15
  411b36:	9700      	str	r7, [sp, #0]

	
	
	q_sat_limit = fixedpt_abs(com_vd) / dc_voltage;
	q_sat_limit += 0.005;
  411b38:	f8df 8140 	ldr.w	r8, [pc, #320]	; 411c7c <vectorPM_perform+0x204>
	q_sat_limit = com_sin(q_sat_limit) * dc_voltage;
	

	
	tmp = (desired_tourque - iq); //error signal.
	com_vq = reg_pi_exe(q_sat_limit/*dc_voltage*//*580 * Q_SAT_FACTOR*/, tmp, vff_q, TSAMPLE, &pi_q );
  411b3c:	4d44      	ldr	r5, [pc, #272]	; (411c50 <vectorPM_perform+0x1d8>)
	com_vd = reg_pi_exe(dc_voltage /*580 * D_SAT_FACTOR*/, tmp, 0/*vff_d*/, TSAMPLE, &pi_d);
  411b3e:	ee17 3a10 	vmov	r3, s14
  411b42:	47a0      	blx	r4
  411b44:	ee09 0a10 	vmov	s18, r0
	q_sat_limit += 0.005;
  411b48:	4b42      	ldr	r3, [pc, #264]	; (411c54 <vectorPM_perform+0x1dc>)
	q_sat_limit = fixedpt_abs(com_vd) / dc_voltage;
  411b4a:	eef0 7ac9 	vabs.f32	s15, s18
	q_sat_limit += 0.005;
  411b4e:	ee87 7aa8 	vdiv.f32	s14, s15, s17
  411b52:	ee17 0a10 	vmov	r0, s14
  411b56:	4798      	blx	r3
  411b58:	a32b      	add	r3, pc, #172	; (adr r3, 411c08 <vectorPM_perform+0x190>)
  411b5a:	e9d3 2300 	ldrd	r2, r3, [r3]
  411b5e:	47c0      	blx	r8
  411b60:	4b3d      	ldr	r3, [pc, #244]	; (411c58 <vectorPM_perform+0x1e0>)
  411b62:	4798      	blx	r3
	q_sat_limit = com_sin(q_sat_limit) * dc_voltage;
  411b64:	4b3d      	ldr	r3, [pc, #244]	; (411c5c <vectorPM_perform+0x1e4>)
  411b66:	4798      	blx	r3
	com_vq = reg_pi_exe(q_sat_limit/*dc_voltage*//*580 * Q_SAT_FACTOR*/, tmp, vff_q, TSAMPLE, &pi_q );
  411b68:	ee07 0a10 	vmov	s14, r0
  411b6c:	edd6 7a00 	vldr	s15, [r6]
  411b70:	ee18 2a10 	vmov	r2, s16
  411b74:	ee28 7a87 	vmul.f32	s14, s17, s14
  411b78:	9500      	str	r5, [sp, #0]
	
	float valpha, vbeta;
	
	axt_ipark_exe( com_vd, com_vq, &valpha, &vbeta );
  411b7a:	4e39      	ldr	r6, [pc, #228]	; (411c60 <vectorPM_perform+0x1e8>)
	com_vq = reg_pi_exe(q_sat_limit/*dc_voltage*//*580 * Q_SAT_FACTOR*/, tmp, vff_q, TSAMPLE, &pi_q );
  411b7c:	ee17 0a10 	vmov	r0, s14
  411b80:	ee8a 7a27 	vdiv.f32	s14, s20, s15
  411b84:	ee7a 7ae9 	vsub.f32	s15, s21, s19
  411b88:	ee17 1a90 	vmov	r1, s15
  411b8c:	ee17 3a10 	vmov	r3, s14
  411b90:	47a0      	blx	r4
  411b92:	4604      	mov	r4, r0
	axt_ipark_exe( com_vd, com_vq, &valpha, &vbeta );
  411b94:	ab03      	add	r3, sp, #12
  411b96:	ee19 0a10 	vmov	r0, s18
  411b9a:	4621      	mov	r1, r4
  411b9c:	aa02      	add	r2, sp, #8
  411b9e:	47b0      	blx	r6
	cvd = com_vd;
	cvq = com_vq;
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  411ba0:	ed9d 7a03 	vldr	s14, [sp, #12]
  411ba4:	eddd 7a02 	vldr	s15, [sp, #8]
  411ba8:	eef0 6a47 	vmov.f32	s13, s14
	cvq = com_vq;
  411bac:	4a2d      	ldr	r2, [pc, #180]	; (411c64 <vectorPM_perform+0x1ec>)
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  411bae:	eeb0 7a67 	vmov.f32	s14, s15
	cvd = com_vd;
  411bb2:	4e2d      	ldr	r6, [pc, #180]	; (411c68 <vectorPM_perform+0x1f0>)
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  411bb4:	4b2d      	ldr	r3, [pc, #180]	; (411c6c <vectorPM_perform+0x1f4>)
  411bb6:	eefe 6ae8 	vcvt.s32.f32	s13, s13, #15
	cvd = com_vd;
  411bba:	ed86 9a00 	vstr	s18, [r6]
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  411bbe:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
	cvq = com_vq;
  411bc2:	6014      	str	r4, [r2, #0]
	inverter_out_rect((valpha * FIXEDPT_ONE), (vbeta * FIXEDPT_ONE));
  411bc4:	ee16 1a90 	vmov	r1, s13
  411bc8:	ee17 0a10 	vmov	r0, s14
  411bcc:	4798      	blx	r3
	
	if (regPM_reset_flag == 1)
  411bce:	4b28      	ldr	r3, [pc, #160]	; (411c70 <vectorPM_perform+0x1f8>)
  411bd0:	681b      	ldr	r3, [r3, #0]
  411bd2:	2b01      	cmp	r3, #1
  411bd4:	d00d      	beq.n	411bf2 <vectorPM_perform+0x17a>
	{
		reg_pi_reset_memory(&pi_d);
		reg_pi_reset_memory(&pi_q);
	}
}
  411bd6:	b004      	add	sp, #16
  411bd8:	ecbd 8b06 	vpop	{d8-d10}
  411bdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	else if (omega_ele_rad < 0)
  411be0:	d59b      	bpl.n	411b1a <vectorPM_perform+0xa2>
		if (iq > 0) vfd_set_regencount();
  411be2:	eef5 9ac0 	vcmpe.f32	s19, #0.0
  411be6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  411bea:	dd94      	ble.n	411b16 <vectorPM_perform+0x9e>
		if (iq < 0) vfd_set_regencount();
  411bec:	4b21      	ldr	r3, [pc, #132]	; (411c74 <vectorPM_perform+0x1fc>)
  411bee:	4798      	blx	r3
  411bf0:	e793      	b.n	411b1a <vectorPM_perform+0xa2>
		reg_pi_reset_memory(&pi_d);
  411bf2:	4638      	mov	r0, r7
  411bf4:	4c20      	ldr	r4, [pc, #128]	; (411c78 <vectorPM_perform+0x200>)
  411bf6:	47a0      	blx	r4
		reg_pi_reset_memory(&pi_q);
  411bf8:	4628      	mov	r0, r5
  411bfa:	47a0      	blx	r4
}
  411bfc:	b004      	add	sp, #16
  411bfe:	ecbd 8b06 	vpop	{d8-d10}
  411c02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  411c06:	bf00      	nop
  411c08:	47ae147b 	.word	0x47ae147b
  411c0c:	3f747ae1 	.word	0x3f747ae1
  411c10:	20404ff0 	.word	0x20404ff0
  411c14:	004132bd 	.word	0x004132bd
  411c18:	00413da1 	.word	0x00413da1
  411c1c:	0041570d 	.word	0x0041570d
  411c20:	38000000 	.word	0x38000000
  411c24:	0040e1f9 	.word	0x0040e1f9
  411c28:	0040e23d 	.word	0x0040e23d
  411c2c:	0040e2d1 	.word	0x0040e2d1
  411c30:	0040e2dd 	.word	0x0040e2dd
  411c34:	3a83126f 	.word	0x3a83126f
  411c38:	2040655c 	.word	0x2040655c
  411c3c:	20406554 	.word	0x20406554
  411c40:	00416c65 	.word	0x00416c65
  411c44:	204003c8 	.word	0x204003c8
  411c48:	204064b4 	.word	0x204064b4
  411c4c:	0040a935 	.word	0x0040a935
  411c50:	20406540 	.word	0x20406540
  411c54:	00418749 	.word	0x00418749
  411c58:	00418da1 	.word	0x00418da1
  411c5c:	00409859 	.word	0x00409859
  411c60:	0040e301 	.word	0x0040e301
  411c64:	20406550 	.word	0x20406550
  411c68:	20406558 	.word	0x20406558
  411c6c:	00415191 	.word	0x00415191
  411c70:	20400388 	.word	0x20400388
  411c74:	00416c51 	.word	0x00416c51
  411c78:	0040a92d 	.word	0x0040a92d
  411c7c:	0041848d 	.word	0x0041848d

00411c80 <vector_PM_init>:

#define IKPQ_ZS     (menue_drive_data_applied.m_ACRQ_p * menue_drive_data_applied.m_ACR_bandwidth_zs / 1000)
#define IKIQ_ZS     (menue_drive_data_applied.m_ACRQ_i * menue_drive_data_applied.m_ACR_bandwidth_zs / 10)

void vector_PM_init(void)
{
  411c80:	b570      	push	{r4, r5, r6, lr}
	reg_pi_init(IKPD_ZS, IKID_ZS, &pi_d);
  411c82:	4c2d      	ldr	r4, [pc, #180]	; (411d38 <vector_PM_init+0xb8>)
  411c84:	4a2d      	ldr	r2, [pc, #180]	; (411d3c <vector_PM_init+0xbc>)
  411c86:	4d2e      	ldr	r5, [pc, #184]	; (411d40 <vector_PM_init+0xc0>)
{
  411c88:	ed2d 8b02 	vpush	{d8}
	reg_pi_init(IKPD_ZS, IKID_ZS, &pi_d);
  411c8c:	edd4 7a21 	vldr	s15, [r4, #132]	; 0x84
  411c90:	edd4 6a1c 	vldr	s13, [r4, #112]	; 0x70
  411c94:	ed94 7a1d 	vldr	s14, [r4, #116]	; 0x74
  411c98:	eddf 8a2a 	vldr	s17, [pc, #168]	; 411d44 <vector_PM_init+0xc4>
  411c9c:	ee27 7a87 	vmul.f32	s14, s15, s14
  411ca0:	ed9f 8a29 	vldr	s16, [pc, #164]	; 411d48 <vector_PM_init+0xc8>
  411ca4:	ee67 7aa6 	vmul.f32	s15, s15, s13
  411ca8:	ee27 7a28 	vmul.f32	s14, s14, s17
  411cac:	ee67 7a88 	vmul.f32	s15, s15, s16
  411cb0:	ee17 1a10 	vmov	r1, s14
  411cb4:	ee17 0a90 	vmov	r0, s15
  411cb8:	47a8      	blx	r5
	reg_pi_init(IKPQ_ZS, IKIQ_ZS, &pi_q);
  411cba:	edd4 7a21 	vldr	s15, [r4, #132]	; 0x84
  411cbe:	ed94 7a1f 	vldr	s14, [r4, #124]	; 0x7c
  411cc2:	edd4 6a1e 	vldr	s13, [r4, #120]	; 0x78
  411cc6:	ee27 7a87 	vmul.f32	s14, s15, s14
  411cca:	4a20      	ldr	r2, [pc, #128]	; (411d4c <vector_PM_init+0xcc>)
  411ccc:	ee67 7aa6 	vmul.f32	s15, s15, s13
  411cd0:	ee27 7a28 	vmul.f32	s14, s14, s17
  411cd4:	ee67 7a88 	vmul.f32	s15, s15, s16
  411cd8:	ee17 1a10 	vmov	r1, s14
  411cdc:	ee17 0a90 	vmov	r0, s15
  411ce0:	47a8      	blx	r5
	if (MOTOR_PM_CVC) speed_regulator_setKt(T_CONST);
  411ce2:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
  411ce6:	2b01      	cmp	r3, #1
  411ce8:	d002      	beq.n	411cf0 <vector_PM_init+0x70>
}
  411cea:	ecbd 8b02 	vpop	{d8}
  411cee:	bd70      	pop	{r4, r5, r6, pc}
	if (MOTOR_PM_CVC) speed_regulator_setKt(T_CONST);
  411cf0:	7823      	ldrb	r3, [r4, #0]
  411cf2:	2b01      	cmp	r3, #1
  411cf4:	d1f9      	bne.n	411cea <vector_PM_init+0x6a>
  411cf6:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
  411cfa:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
  411cfe:	ee07 3a90 	vmov	s15, r3
  411d02:	4b13      	ldr	r3, [pc, #76]	; (411d50 <vector_PM_init+0xd0>)
  411d04:	4c13      	ldr	r4, [pc, #76]	; (411d54 <vector_PM_init+0xd4>)
  411d06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  411d0a:	ee67 7a87 	vmul.f32	s15, s15, s14
  411d0e:	ee17 0a90 	vmov	r0, s15
  411d12:	4798      	blx	r3
  411d14:	a306      	add	r3, pc, #24	; (adr r3, 411d30 <vector_PM_init+0xb0>)
  411d16:	e9d3 2300 	ldrd	r2, r3, [r3]
  411d1a:	47a0      	blx	r4
  411d1c:	4b0e      	ldr	r3, [pc, #56]	; (411d58 <vector_PM_init+0xd8>)
  411d1e:	4798      	blx	r3
  411d20:	4b0e      	ldr	r3, [pc, #56]	; (411d5c <vector_PM_init+0xdc>)
}
  411d22:	ecbd 8b02 	vpop	{d8}
  411d26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	if (MOTOR_PM_CVC) speed_regulator_setKt(T_CONST);
  411d2a:	4718      	bx	r3
  411d2c:	f3af 8000 	nop.w
  411d30:	e8584cac 	.word	0xe8584cac
  411d34:	3febb67a 	.word	0x3febb67a
  411d38:	20404ff0 	.word	0x20404ff0
  411d3c:	204064b4 	.word	0x204064b4
  411d40:	0040a8fd 	.word	0x0040a8fd
  411d44:	3dcccccd 	.word	0x3dcccccd
  411d48:	3a83126f 	.word	0x3a83126f
  411d4c:	20406540 	.word	0x20406540
  411d50:	00418749 	.word	0x00418749
  411d54:	004187f1 	.word	0x004187f1
  411d58:	00418da1 	.word	0x00418da1
  411d5c:	0040f1b1 	.word	0x0040f1b1

00411d60 <vectorpm_PI_changeGains>:

void vectorpm_PI_changeGains(void)
{
  411d60:	b570      	push	{r4, r5, r6, lr}
	regPM_reset_flag = 0;
	reg_pi_change_gains(IKPD, IKID, &pi_d);
  411d62:	4c1c      	ldr	r4, [pc, #112]	; (411dd4 <vectorpm_PI_changeGains+0x74>)
	regPM_reset_flag = 0;
  411d64:	2600      	movs	r6, #0
  411d66:	4b1c      	ldr	r3, [pc, #112]	; (411dd8 <vectorpm_PI_changeGains+0x78>)
	reg_pi_change_gains(IKPD, IKID, &pi_d);
  411d68:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
  411d6c:	edd4 6a1c 	vldr	s13, [r4, #112]	; 0x70
  411d70:	ed94 7a1d 	vldr	s14, [r4, #116]	; 0x74
  411d74:	4d19      	ldr	r5, [pc, #100]	; (411ddc <vectorpm_PI_changeGains+0x7c>)
  411d76:	ee27 7a87 	vmul.f32	s14, s15, s14
  411d7a:	4a19      	ldr	r2, [pc, #100]	; (411de0 <vectorpm_PI_changeGains+0x80>)
  411d7c:	ee67 7aa6 	vmul.f32	s15, s15, s13
{
  411d80:	ed2d 8b02 	vpush	{d8}
	reg_pi_change_gains(IKPD, IKID, &pi_d);
  411d84:	eddf 8a17 	vldr	s17, [pc, #92]	; 411de4 <vectorpm_PI_changeGains+0x84>
  411d88:	ed9f 8a17 	vldr	s16, [pc, #92]	; 411de8 <vectorpm_PI_changeGains+0x88>
  411d8c:	ee27 7a28 	vmul.f32	s14, s14, s17
	regPM_reset_flag = 0;
  411d90:	601e      	str	r6, [r3, #0]
	reg_pi_change_gains(IKPD, IKID, &pi_d);
  411d92:	ee67 7a88 	vmul.f32	s15, s15, s16
  411d96:	ee17 1a10 	vmov	r1, s14
  411d9a:	ee17 0a90 	vmov	r0, s15
  411d9e:	47a8      	blx	r5
	reg_pi_change_gains(IKPQ, IKIQ, &pi_q);
  411da0:	edd4 7a20 	vldr	s15, [r4, #128]	; 0x80
  411da4:	ed94 7a1f 	vldr	s14, [r4, #124]	; 0x7c
  411da8:	462b      	mov	r3, r5
  411daa:	edd4 6a1e 	vldr	s13, [r4, #120]	; 0x78
  411dae:	ee27 7a87 	vmul.f32	s14, s15, s14
  411db2:	4a0e      	ldr	r2, [pc, #56]	; (411dec <vectorpm_PI_changeGains+0x8c>)
  411db4:	ee67 7aa6 	vmul.f32	s15, s15, s13
  411db8:	ee27 7a28 	vmul.f32	s14, s14, s17
  411dbc:	ee67 7a88 	vmul.f32	s15, s15, s16
  411dc0:	ecbd 8b02 	vpop	{d8}
	reg_pi_change_gains(IKPQ, IKIQ, &pi_q);
  411dc4:	ee17 1a10 	vmov	r1, s14
  411dc8:	ee17 0a90 	vmov	r0, s15
  411dcc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	reg_pi_change_gains(IKPQ, IKIQ, &pi_q);
  411dd0:	4718      	bx	r3
  411dd2:	bf00      	nop
  411dd4:	20404ff0 	.word	0x20404ff0
  411dd8:	20400388 	.word	0x20400388
  411ddc:	0040a8bd 	.word	0x0040a8bd
  411de0:	204064b4 	.word	0x204064b4
  411de4:	3dcccccd 	.word	0x3dcccccd
  411de8:	3a83126f 	.word	0x3a83126f
  411dec:	20406540 	.word	0x20406540

00411df0 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  411df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  411df2:	4604      	mov	r4, r0
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  411df4:	4b0f      	ldr	r3, [pc, #60]	; (411e34 <pio_handler_process+0x44>)
{
  411df6:	460f      	mov	r7, r1
	status = pio_get_interrupt_status(p_pio);
  411df8:	4798      	blx	r3
  411dfa:	4606      	mov	r6, r0
	status &= pio_get_interrupt_mask(p_pio);
  411dfc:	4b0e      	ldr	r3, [pc, #56]	; (411e38 <pio_handler_process+0x48>)
  411dfe:	4620      	mov	r0, r4
  411e00:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  411e02:	4006      	ands	r6, r0
  411e04:	d015      	beq.n	411e32 <pio_handler_process+0x42>
  411e06:	4c0d      	ldr	r4, [pc, #52]	; (411e3c <pio_handler_process+0x4c>)
  411e08:	2500      	movs	r5, #0
  411e0a:	e004      	b.n	411e16 <pio_handler_process+0x26>
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  411e0c:	2d07      	cmp	r5, #7
  411e0e:	f104 0410 	add.w	r4, r4, #16
  411e12:	d00e      	beq.n	411e32 <pio_handler_process+0x42>
  411e14:	b16e      	cbz	r6, 411e32 <pio_handler_process+0x42>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  411e16:	6823      	ldr	r3, [r4, #0]
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
  411e18:	3501      	adds	r5, #1
			if (gs_interrupt_sources[i].id == ul_id) {
  411e1a:	42bb      	cmp	r3, r7
  411e1c:	d1f6      	bne.n	411e0c <pio_handler_process+0x1c>
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  411e1e:	6861      	ldr	r1, [r4, #4]
  411e20:	4231      	tst	r1, r6
  411e22:	d0f3      	beq.n	411e0c <pio_handler_process+0x1c>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  411e24:	68e3      	ldr	r3, [r4, #12]
  411e26:	4638      	mov	r0, r7
  411e28:	4798      	blx	r3
					status &= ~(gs_interrupt_sources[i].mask);
  411e2a:	6863      	ldr	r3, [r4, #4]
  411e2c:	ea26 0603 	bic.w	r6, r6, r3
  411e30:	e7ec      	b.n	411e0c <pio_handler_process+0x1c>
  411e32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  411e34:	00417549 	.word	0x00417549
  411e38:	0041754d 	.word	0x0041754d
  411e3c:	20400a20 	.word	0x20400a20

00411e40 <PIOA_Handler>:
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
	pio_handler_process(PIOA, ID_PIOA);
  411e40:	210a      	movs	r1, #10
  411e42:	4801      	ldr	r0, [pc, #4]	; (411e48 <PIOA_Handler+0x8>)
  411e44:	4b01      	ldr	r3, [pc, #4]	; (411e4c <PIOA_Handler+0xc>)
  411e46:	4718      	bx	r3
  411e48:	400e0e00 	.word	0x400e0e00
  411e4c:	00411df1 	.word	0x00411df1

00411e50 <PIOB_Handler>:
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
    pio_handler_process(PIOB, ID_PIOB);
  411e50:	210b      	movs	r1, #11
  411e52:	4801      	ldr	r0, [pc, #4]	; (411e58 <PIOB_Handler+0x8>)
  411e54:	4b01      	ldr	r3, [pc, #4]	; (411e5c <PIOB_Handler+0xc>)
  411e56:	4718      	bx	r3
  411e58:	400e1000 	.word	0x400e1000
  411e5c:	00411df1 	.word	0x00411df1

00411e60 <PIOC_Handler>:
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
	pio_handler_process(PIOC, ID_PIOC);
  411e60:	210c      	movs	r1, #12
  411e62:	4801      	ldr	r0, [pc, #4]	; (411e68 <PIOC_Handler+0x8>)
  411e64:	4b01      	ldr	r3, [pc, #4]	; (411e6c <PIOC_Handler+0xc>)
  411e66:	4718      	bx	r3
  411e68:	400e1200 	.word	0x400e1200
  411e6c:	00411df1 	.word	0x00411df1

00411e70 <PIOD_Handler>:
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
	pio_handler_process(PIOD, ID_PIOD);
  411e70:	2110      	movs	r1, #16
  411e72:	4801      	ldr	r0, [pc, #4]	; (411e78 <PIOD_Handler+0x8>)
  411e74:	4b01      	ldr	r3, [pc, #4]	; (411e7c <PIOD_Handler+0xc>)
  411e76:	4718      	bx	r3
  411e78:	400e1400 	.word	0x400e1400
  411e7c:	00411df1 	.word	0x00411df1

00411e80 <PIOE_Handler>:
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
	pio_handler_process(PIOE, ID_PIOE);
  411e80:	2111      	movs	r1, #17
  411e82:	4801      	ldr	r0, [pc, #4]	; (411e88 <PIOE_Handler+0x8>)
  411e84:	4b01      	ldr	r3, [pc, #4]	; (411e8c <PIOE_Handler+0xc>)
  411e86:	4718      	bx	r3
  411e88:	400e1600 	.word	0x400e1600
  411e8c:	00411df1 	.word	0x00411df1

00411e90 <pwm_clocks_generate>:
 *
 * \retval Return the value to be set in the PWM Clock Register (PWM Mode Register for
 * SAM3N/SAM4N/SAM4C/SAM4CP/SAM4CM) or PWM_INVALID_ARGUMENT if the configuration cannot be met.
 */
static uint32_t pwm_clocks_generate(uint32_t ul_frequency, uint32_t ul_mck)
{
  411e90:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  411e92:	4e11      	ldr	r6, [pc, #68]	; (411ed8 <pwm_clocks_generate+0x48>)
{
  411e94:	b08d      	sub	sp, #52	; 0x34
  411e96:	4686      	mov	lr, r0
  411e98:	460f      	mov	r7, r1
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  411e9a:	ad01      	add	r5, sp, #4
  411e9c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  411e9e:	462c      	mov	r4, r5
  411ea0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  411ea2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  411ea4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  411ea6:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
			{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 };
	uint32_t ul_pre = 0;
  411eaa:	2300      	movs	r3, #0
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  411eac:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	uint32_t ul_div;

	/* Find prescaler and divisor values */
	do {
		ul_div = (ul_mck / ul_divisors[ul_pre]) / ul_frequency;
  411eb0:	f854 0b04 	ldr.w	r0, [r4], #4
  411eb4:	fbb7 f0f0 	udiv	r0, r7, r0
  411eb8:	fbb0 f0fe 	udiv	r0, r0, lr
		if (ul_div <= PWM_CLOCK_DIV_MAX) {
  411ebc:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  411ec0:	d906      	bls.n	411ed0 <pwm_clocks_generate+0x40>
			break;
		}
		ul_pre++;
  411ec2:	3301      	adds	r3, #1
	} while (ul_pre < PWM_CLOCK_PRE_MAX);
  411ec4:	2b0b      	cmp	r3, #11
  411ec6:	d1f3      	bne.n	411eb0 <pwm_clocks_generate+0x20>

	/* Return result */
	if (ul_pre < PWM_CLOCK_PRE_MAX) {
		return ul_div | (ul_pre << 8);
	} else {
		return PWM_INVALID_ARGUMENT;
  411ec8:	f64f 70ff 	movw	r0, #65535	; 0xffff
	}
}
  411ecc:	b00d      	add	sp, #52	; 0x34
  411ece:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ul_div | (ul_pre << 8);
  411ed0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
  411ed4:	b00d      	add	sp, #52	; 0x34
  411ed6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  411ed8:	0041ca70 	.word	0x0041ca70

00411edc <pwm_init>:
 * \param clock_config PWM clock configuration.
 *
 * \retval 0 if initialization succeeds, otherwise fails.
 */
uint32_t pwm_init(Pwm *p_pwm, pwm_clock_t *clock_config)
{
  411edc:	b570      	push	{r4, r5, r6, lr}
	uint32_t clock = 0;
	uint32_t result;

	/* Clock A */
	if (clock_config->ul_clka != 0) {
  411ede:	680c      	ldr	r4, [r1, #0]
{
  411ee0:	460d      	mov	r5, r1
  411ee2:	4606      	mov	r6, r0
	if (clock_config->ul_clka != 0) {
  411ee4:	b144      	cbz	r4, 411ef8 <pwm_init+0x1c>
		result = pwm_clocks_generate(clock_config->ul_clka, clock_config->ul_mck);
  411ee6:	4620      	mov	r0, r4
  411ee8:	4b0c      	ldr	r3, [pc, #48]	; (411f1c <pwm_init+0x40>)
  411eea:	6889      	ldr	r1, [r1, #8]
  411eec:	4798      	blx	r3
		if (result == PWM_INVALID_ARGUMENT) {
  411eee:	f64f 73ff 	movw	r3, #65535	; 0xffff
		result = pwm_clocks_generate(clock_config->ul_clka, clock_config->ul_mck);
  411ef2:	4604      	mov	r4, r0
		if (result == PWM_INVALID_ARGUMENT) {
  411ef4:	4298      	cmp	r0, r3
  411ef6:	d00c      	beq.n	411f12 <pwm_init+0x36>

		clock = result;
	}

	/* Clock B */
	if (clock_config->ul_clkb != 0) {
  411ef8:	6868      	ldr	r0, [r5, #4]
  411efa:	b140      	cbz	r0, 411f0e <pwm_init+0x32>
		result = pwm_clocks_generate(clock_config->ul_clkb, clock_config->ul_mck);
  411efc:	4b07      	ldr	r3, [pc, #28]	; (411f1c <pwm_init+0x40>)
  411efe:	68a9      	ldr	r1, [r5, #8]
  411f00:	4798      	blx	r3

		if (result == PWM_INVALID_ARGUMENT) {
  411f02:	f64f 73ff 	movw	r3, #65535	; 0xffff
  411f06:	4298      	cmp	r0, r3
  411f08:	d005      	beq.n	411f16 <pwm_init+0x3a>
			return result;
		}

		clock |= (result << 16);
  411f0a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
	}
#if (SAM3N || SAM4N || SAM4C || SAM4CP || SAM4CM)
	p_pwm->PWM_MR = clock;
#else
	p_pwm->PWM_CLK = clock;
  411f0e:	6034      	str	r4, [r6, #0]
#endif
	return 0;
  411f10:	2400      	movs	r4, #0
}
  411f12:	4620      	mov	r0, r4
  411f14:	bd70      	pop	{r4, r5, r6, pc}
  411f16:	4604      	mov	r4, r0
  411f18:	e7fb      	b.n	411f12 <pwm_init+0x36>
  411f1a:	bf00      	nop
  411f1c:	00411e91 	.word	0x00411e91

00411f20 <pwm_channel_init>:
 * \param p_channel Configurations of the specified PWM channel.
 *
 * \retval 0 if initialization succeeds, otherwise fails.
 */
uint32_t pwm_channel_init(Pwm *p_pwm, pwm_channel_t *p_channel)
{
  411f20:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t tmp_reg = 0;
	uint32_t ch_num = p_channel->channel;

	/* Channel Mode/Clock Register */
	tmp_reg = (p_channel->ul_prescaler & 0xF) |
  411f22:	684b      	ldr	r3, [r1, #4]
			(p_channel->polarity << 9) |
#if (SAM3U || SAM3S || SAM3XA || SAM4S || SAM4E || SAMV70 || SAMV71 || SAME70 || SAMS70)
			(p_channel->counter_event) |
  411f24:	8a8d      	ldrh	r5, [r1, #20]
	tmp_reg = (p_channel->ul_prescaler & 0xF) |
  411f26:	f003 030f 	and.w	r3, r3, #15
			(p_channel->b_deadtime_generator << 16) |
			(p_channel->b_pwmh_output_inverted << 17) |
			(p_channel->b_pwml_output_inverted << 18) |
#endif
			(p_channel->alignment);
  411f2a:	890a      	ldrh	r2, [r1, #8]
			(p_channel->polarity << 9) |
  411f2c:	7a8c      	ldrb	r4, [r1, #10]
	tmp_reg = (p_channel->ul_prescaler & 0xF) |
  411f2e:	432b      	orrs	r3, r5
			(p_channel->b_deadtime_generator << 16) |
  411f30:	7d8f      	ldrb	r7, [r1, #22]
			(p_channel->b_pwmh_output_inverted << 17) |
  411f32:	7dce      	ldrb	r6, [r1, #23]
	tmp_reg = (p_channel->ul_prescaler & 0xF) |
  411f34:	431a      	orrs	r2, r3
			(p_channel->b_pwml_output_inverted << 18) |
  411f36:	7e0d      	ldrb	r5, [r1, #24]
	uint32_t ch_num = p_channel->channel;
  411f38:	680b      	ldr	r3, [r1, #0]
	tmp_reg = (p_channel->ul_prescaler & 0xF) |
  411f3a:	ea42 2244 	orr.w	r2, r2, r4, lsl #9
  411f3e:	eb00 1443 	add.w	r4, r0, r3, lsl #5
  411f42:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
  411f46:	ea42 4246 	orr.w	r2, r2, r6, lsl #17
  411f4a:	ea42 4285 	orr.w	r2, r2, r5, lsl #18
	p_pwm->PWM_CH_NUM[ch_num].PWM_CMR = tmp_reg;
  411f4e:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200

	/* Channel Duty Cycle Register */
	p_pwm->PWM_CH_NUM[ch_num].PWM_CDTY = p_channel->ul_duty;
  411f52:	68ca      	ldr	r2, [r1, #12]
  411f54:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204

	/* Channel Period Register */
	p_pwm->PWM_CH_NUM[ch_num].PWM_CPRD = p_channel->ul_period;
  411f58:	690a      	ldr	r2, [r1, #16]
  411f5a:	f8c4 220c 	str.w	r2, [r4, #524]	; 0x20c
	
#if (SAM3U || SAM3S || SAM3XA || SAM4S || SAM4E || SAMV70 || SAMV71 || SAME70 || SAMS70)
	/* Channel Dead Time Register */
	if (p_channel->b_deadtime_generator) {
  411f5e:	7d8a      	ldrb	r2, [r1, #22]
  411f60:	b11a      	cbz	r2, 411f6a <pwm_channel_init+0x4a>
		p_pwm->PWM_CH_NUM[ch_num].PWM_DT =
				PWM_DT_DTL(p_channel->
				us_deadtime_pwml) | PWM_DT_DTH(p_channel->
  411f62:	f8d1 201a 	ldr.w	r2, [r1, #26]
		p_pwm->PWM_CH_NUM[ch_num].PWM_DT =
  411f66:	f8c4 2218 	str.w	r2, [r4, #536]	; 0x218
				us_deadtime_pwmh);
	}

	/* Output Selection Register */
	tmp_reg  = p_pwm->PWM_OS & (~((PWM_OS_OSH0 | PWM_OS_OSL0) << ch_num));
  411f6a:	f04f 1e01 	mov.w	lr, #65537	; 0x10001
	tmp_reg |= ((p_channel->output_selection.b_override_pwmh) << ch_num) |
			(((p_channel->output_selection.b_override_pwml) << ch_num)
  411f6e:	7fcf      	ldrb	r7, [r1, #31]
	tmp_reg |= ((p_channel->output_selection.b_override_pwmh) << ch_num) |
  411f70:	7f8c      	ldrb	r4, [r1, #30]
			(((p_channel->output_selection.override_level_pwml) << ch_num)
					<< 16);
	p_pwm->PWM_OOV = tmp_reg;

	/* Sync Channels Mode Register */
	uint32_t channel = (1 << ch_num);
  411f72:	2601      	movs	r6, #1
	tmp_reg  = p_pwm->PWM_OS & (~((PWM_OS_OSH0 | PWM_OS_OSL0) << ch_num));
  411f74:	fa0e fe03 	lsl.w	lr, lr, r3
  411f78:	6c85      	ldr	r5, [r0, #72]	; 0x48
			(((p_channel->output_selection.b_override_pwml) << ch_num)
  411f7a:	409f      	lsls	r7, r3
	tmp_reg |= ((p_channel->output_selection.b_override_pwmh) << ch_num) |
  411f7c:	409c      	lsls	r4, r3
	tmp_reg  = p_pwm->PWM_OS & (~((PWM_OS_OSH0 | PWM_OS_OSL0) << ch_num));
  411f7e:	ea6f 020e 	mvn.w	r2, lr
	uint32_t channel = (1 << ch_num);
  411f82:	409e      	lsls	r6, r3
	tmp_reg |= ((p_channel->output_selection.b_override_pwmh) << ch_num) |
  411f84:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
	tmp_reg  = p_pwm->PWM_OS & (~((PWM_OS_OSH0 | PWM_OS_OSL0) << ch_num));
  411f88:	4015      	ands	r5, r2
	tmp_reg |= ((p_channel->output_selection.b_override_pwmh) << ch_num) |
  411f8a:	432c      	orrs	r4, r5
	p_pwm->PWM_OS = tmp_reg;
  411f8c:	6484      	str	r4, [r0, #72]	; 0x48
			(((p_channel->output_selection.override_level_pwml) << ch_num)
  411f8e:	f891 7021 	ldrb.w	r7, [r1, #33]	; 0x21
	tmp_reg |= ((p_channel->output_selection.override_level_pwmh) << ch_num) |
  411f92:	f891 4020 	ldrb.w	r4, [r1, #32]
	tmp_reg  = p_pwm->PWM_OOV & (~((PWM_OOV_OOVH0 | PWM_OOV_OOVL0) << ch_num));
  411f96:	6c45      	ldr	r5, [r0, #68]	; 0x44
			(((p_channel->output_selection.override_level_pwml) << ch_num)
  411f98:	409f      	lsls	r7, r3
	tmp_reg |= ((p_channel->output_selection.override_level_pwmh) << ch_num) |
  411f9a:	409c      	lsls	r4, r3
	tmp_reg  = p_pwm->PWM_OOV & (~((PWM_OOV_OOVH0 | PWM_OOV_OOVL0) << ch_num));
  411f9c:	4015      	ands	r5, r2
	tmp_reg |= ((p_channel->output_selection.override_level_pwmh) << ch_num) |
  411f9e:	ea44 4207 	orr.w	r2, r4, r7, lsl #16
  411fa2:	432a      	orrs	r2, r5
	p_pwm->PWM_OOV = tmp_reg;
  411fa4:	6442      	str	r2, [r0, #68]	; 0x44
	if (p_channel->b_sync_ch) {
  411fa6:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
  411faa:	2a00      	cmp	r2, #0
  411fac:	d04e      	beq.n	41204c <pwm_channel_init+0x12c>
		p_pwm->PWM_SCM |= channel;
  411fae:	6a02      	ldr	r2, [r0, #32]
  411fb0:	4332      	orrs	r2, r6
  411fb2:	6202      	str	r2, [r0, #32]
		p_pwm->PWM_SCM &= ~((uint32_t) channel);
	}

	/* Fault Protection Value Register */
#if (SAM4E || SAMV70 || SAMV71 || SAME70 || SAMS70)
	if (p_channel->ul_fault_output_pwmh == PWM_HIGHZ) {
  411fb4:	f891 2024 	ldrb.w	r2, [r1, #36]	; 0x24
  411fb8:	2a02      	cmp	r2, #2
  411fba:	d04f      	beq.n	41205c <pwm_channel_init+0x13c>
		p_pwm->PWM_FPV2 |= (0x01 << ch_num);
	} else {
		p_pwm->PWM_FPV2 &= ~(0x01 << ch_num);
  411fbc:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
  411fc0:	43f2      	mvns	r2, r6
  411fc2:	4014      	ands	r4, r2
  411fc4:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
		if (p_channel->ul_fault_output_pwmh == PWM_HIGH) {
  411fc8:	f891 4024 	ldrb.w	r4, [r1, #36]	; 0x24
  411fcc:	2c01      	cmp	r4, #1
  411fce:	d059      	beq.n	412084 <pwm_channel_init+0x164>
			p_pwm->PWM_FPV1 |= (0x01 << ch_num);
		} else {
			p_pwm->PWM_FPV1 &= (~(0x01 << ch_num));
  411fd0:	6e84      	ldr	r4, [r0, #104]	; 0x68
  411fd2:	4022      	ands	r2, r4
  411fd4:	6682      	str	r2, [r0, #104]	; 0x68
		}
	}
	if (p_channel->ul_fault_output_pwml == PWM_HIGHZ) {
  411fd6:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
  411fda:	2a02      	cmp	r2, #2
  411fdc:	d047      	beq.n	41206e <pwm_channel_init+0x14e>
		p_pwm->PWM_FPV2 |= ((0x01 << ch_num) << 16);
	} else {
		p_pwm->PWM_FPV2 &= ~((0x01 << ch_num) << 16);
  411fde:	0432      	lsls	r2, r6, #16
  411fe0:	f8d0 50c0 	ldr.w	r5, [r0, #192]	; 0xc0
  411fe4:	43d4      	mvns	r4, r2
  411fe6:	4025      	ands	r5, r4
  411fe8:	f8c0 50c0 	str.w	r5, [r0, #192]	; 0xc0
		if (p_channel->ul_fault_output_pwml == PWM_HIGH) {
  411fec:	f891 5025 	ldrb.w	r5, [r1, #37]	; 0x25
  411ff0:	2d01      	cmp	r5, #1
  411ff2:	d043      	beq.n	41207c <pwm_channel_init+0x15c>
			p_pwm->PWM_FPV1 |= ((0x01 << ch_num) << 16);
		} else {
			p_pwm->PWM_FPV1 &= (~((0x01 << ch_num) << 16));
  411ff4:	6e82      	ldr	r2, [r0, #104]	; 0x68
  411ff6:	4014      	ands	r4, r2
  411ff8:	6684      	str	r4, [r0, #104]	; 0x68
		p_pwm->PWM_FPE2 = fault_enable_reg;
	}
#endif

#if (SAM3U || SAM3S || SAM4S || SAM4E || SAMV70 || SAMV71 || SAME70 || SAMS70)
	ch_num *= 8;
  411ffa:	00db      	lsls	r3, r3, #3
	fault_enable_reg = p_pwm->PWM_FPE;
	fault_enable_reg &= ~(0xFF << ch_num);
  411ffc:	25ff      	movs	r5, #255	; 0xff
	fault_enable_reg = p_pwm->PWM_FPE;
  411ffe:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
	fault_enable_reg |= ((p_channel->fault_id) << ch_num);
  412000:	f891 2023 	ldrb.w	r2, [r1, #35]	; 0x23
	fault_enable_reg &= ~(0xFF << ch_num);
  412004:	409d      	lsls	r5, r3
	fault_enable_reg |= ((p_channel->fault_id) << ch_num);
  412006:	409a      	lsls	r2, r3
	fault_enable_reg &= ~(0xFF << ch_num);
  412008:	ea24 0405 	bic.w	r4, r4, r5
	fault_enable_reg |= ((p_channel->fault_id) << ch_num);
  41200c:	4322      	orrs	r2, r4
	p_pwm->PWM_FPE = fault_enable_reg;
  41200e:	66c2      	str	r2, [r0, #108]	; 0x6c
	}
	p_pwm->PWM_CH_NUM_0X400[ch_num].PWM_CAE =
			PWM_CAE_ADEDGV(p_channel->ul_additional_edge) |
			p_channel->additional_edge_mode;
#elif (SAMV70 || SAMV71 || SAME70 || SAMS70)
	if (!ch_num) {
  412010:	b953      	cbnz	r3, 412028 <pwm_channel_init+0x108>
		if (p_channel->spread_spectrum_mode ==
  412012:	f891 202c 	ldrb.w	r2, [r1, #44]	; 0x2c
  412016:	2a01      	cmp	r2, #1
		PWM_SPREAD_SPECTRUM_MODE_RANDOM) {
			p_pwm->PWM_SSPR = PWM_SSPR_SPRD(p_channel->ul_spread) |
  412018:	6a8a      	ldr	r2, [r1, #40]	; 0x28
  41201a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  41201e:	bf08      	it	eq
  412020:	f042 7280 	orreq.w	r2, r2, #16777216	; 0x1000000
			PWM_SSPR_SPRDM;
			} else {
			p_pwm->PWM_SSPR = PWM_SSPR_SPRD(p_channel->ul_spread);
  412024:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
  412028:	eb00 1343 	add.w	r3, r0, r3, lsl #5
	p_pwm->PWM_CH_NUM[ch_num].PWM_CMR &= (~PWM_CMR_PPM);
	p_pwm->PWM_CH_NUM[ch_num].PWM_CMR |= (p_channel->ul_ppm_mode & PWM_CMR_PPM);
#endif

	return 0;
}
  41202c:	2000      	movs	r0, #0
	p_pwm->PWM_CH_NUM[ch_num].PWM_CMR &= (~PWM_CMR_PPM);
  41202e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
  412032:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
  412036:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
	p_pwm->PWM_CH_NUM[ch_num].PWM_CMR |= (p_channel->ul_ppm_mode & PWM_CMR_PPM);
  41203a:	6b8a      	ldr	r2, [r1, #56]	; 0x38
  41203c:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
  412040:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
  412044:	430a      	orrs	r2, r1
  412046:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
  41204a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		p_pwm->PWM_SCM &= ~((uint32_t) channel);
  41204c:	6a02      	ldr	r2, [r0, #32]
  41204e:	ea22 0206 	bic.w	r2, r2, r6
  412052:	6202      	str	r2, [r0, #32]
	if (p_channel->ul_fault_output_pwmh == PWM_HIGHZ) {
  412054:	f891 2024 	ldrb.w	r2, [r1, #36]	; 0x24
  412058:	2a02      	cmp	r2, #2
  41205a:	d1af      	bne.n	411fbc <pwm_channel_init+0x9c>
		p_pwm->PWM_FPV2 |= (0x01 << ch_num);
  41205c:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
  412060:	4332      	orrs	r2, r6
  412062:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
	if (p_channel->ul_fault_output_pwml == PWM_HIGHZ) {
  412066:	f891 2025 	ldrb.w	r2, [r1, #37]	; 0x25
  41206a:	2a02      	cmp	r2, #2
  41206c:	d1b7      	bne.n	411fde <pwm_channel_init+0xbe>
		p_pwm->PWM_FPV2 |= ((0x01 << ch_num) << 16);
  41206e:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
  412072:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  412076:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
  41207a:	e7be      	b.n	411ffa <pwm_channel_init+0xda>
			p_pwm->PWM_FPV1 |= ((0x01 << ch_num) << 16);
  41207c:	6e84      	ldr	r4, [r0, #104]	; 0x68
  41207e:	4322      	orrs	r2, r4
  412080:	6682      	str	r2, [r0, #104]	; 0x68
  412082:	e7ba      	b.n	411ffa <pwm_channel_init+0xda>
			p_pwm->PWM_FPV1 |= (0x01 << ch_num);
  412084:	6e82      	ldr	r2, [r0, #104]	; 0x68
  412086:	4332      	orrs	r2, r6
  412088:	6682      	str	r2, [r0, #104]	; 0x68
  41208a:	e7a4      	b.n	411fd6 <pwm_channel_init+0xb6>

0041208c <pwm_channel_update_duty>:
		uint32_t ul_duty)
{
	uint32_t ch_num = p_channel->channel;

		/** Check parameter */
	if (p_channel->ul_period < ul_duty) {
  41208c:	690b      	ldr	r3, [r1, #16]
  41208e:	4293      	cmp	r3, r2
  412090:	d203      	bcs.n	41209a <pwm_channel_update_duty+0xe>
		return PWM_INVALID_ARGUMENT;
  412092:	f64f 73ff 	movw	r3, #65535	; 0xffff
		p_pwm->PWM_CH_NUM[ch_num].PWM_CDTYUPD = ul_duty;
#endif
	}

	return 0;
}
  412096:	4618      	mov	r0, r3
  412098:	4770      	bx	lr
{
  41209a:	b410      	push	{r4}
	uint32_t ch_num = p_channel->channel;
  41209c:	680c      	ldr	r4, [r1, #0]
	return 0;
  41209e:	2300      	movs	r3, #0
		p_channel->ul_duty = ul_duty;
  4120a0:	60ca      	str	r2, [r1, #12]
		p_pwm->PWM_CH_NUM[ch_num].PWM_CDTYUPD = ul_duty;
  4120a2:	eb00 1044 	add.w	r0, r0, r4, lsl #5
  4120a6:	f8c0 2208 	str.w	r2, [r0, #520]	; 0x208
}
  4120aa:	4618      	mov	r0, r3
  4120ac:	f85d 4b04 	ldr.w	r4, [sp], #4
  4120b0:	4770      	bx	lr
  4120b2:	bf00      	nop

004120b4 <pwm_channel_enable>:
 * \param p_pwm Pointer to a PWM instance.
 * \param ul_channel PWM channel number to enable.
 */
void pwm_channel_enable(Pwm *p_pwm, uint32_t ul_channel)
{
	p_pwm->PWM_ENA = (1 << ul_channel);
  4120b4:	2301      	movs	r3, #1
  4120b6:	fa03 f101 	lsl.w	r1, r3, r1
  4120ba:	6041      	str	r1, [r0, #4]
  4120bc:	4770      	bx	lr
  4120be:	bf00      	nop

004120c0 <pwm_channel_disable>:
 * \param p_pwm Pointer to a PWM instance.
 * \param ul_channel PWM channel number to disable.
 */
void pwm_channel_disable(Pwm *p_pwm, uint32_t ul_channel)
{
	p_pwm->PWM_DIS = (1 << ul_channel);
  4120c0:	2301      	movs	r3, #1
  4120c2:	fa03 f101 	lsl.w	r1, r3, r1
  4120c6:	6081      	str	r1, [r0, #8]
  4120c8:	4770      	bx	lr
  4120ca:	bf00      	nop

004120cc <pwm_channel_get_interrupt_status>:
uint32_t pwm_channel_get_interrupt_status(Pwm *p_pwm)
{
#if (SAM3N || SAM4N || SAM4C || SAM4CP || SAM4CM)
	return p_pwm->PWM_ISR;
#else
	return p_pwm->PWM_ISR1;
  4120cc:	69c0      	ldr	r0, [r0, #28]
#endif
}
  4120ce:	4770      	bx	lr

004120d0 <pwm_channel_update_output>:
 * \param p_output New PWM channel output selection.
 * \param b_sync Boolean of changing of output selection. Set true to change the output synchronously (at the beginning of the next PWM period). Set false to change the output asynchronously (at the end of the execution of the function).
 */
void pwm_channel_update_output(Pwm *p_pwm, pwm_channel_t *p_channel,
		pwm_output_t *p_output, bool b_sync)
{
  4120d0:	b5f0      	push	{r4, r5, r6, r7, lr}
	p_channel->output_selection.override_level_pwmh = (pwm_level_t) pwmh;
	p_channel->output_selection.override_level_pwml = (pwm_level_t) pwml;

	/* Change override output level */
	uint32_t override_value = p_pwm->PWM_OOV;
	override_value &= ~((PWM_OOV_OOVH0 | PWM_OOV_OOVL0) << ch_num);
  4120d2:	f04f 1701 	mov.w	r7, #65537	; 0x10001
	bool override_pwml = p_output->b_override_pwml;
  4120d6:	7855      	ldrb	r5, [r2, #1]
	uint32_t pwmh = p_output->override_level_pwmh;
  4120d8:	f892 c002 	ldrb.w	ip, [r2, #2]
	uint32_t pwml = p_output->override_level_pwml;
  4120dc:	f892 e003 	ldrb.w	lr, [r2, #3]
	bool override_pwmh = p_output->b_override_pwmh;
  4120e0:	7814      	ldrb	r4, [r2, #0]
	uint32_t ch_num = p_channel->channel;
  4120e2:	680a      	ldr	r2, [r1, #0]
	override_value |= (((pwml << 16) | pwmh) << ch_num);
  4120e4:	ea4c 460e 	orr.w	r6, ip, lr, lsl #16
	p_channel->output_selection.b_override_pwmh = override_pwmh;
  4120e8:	778c      	strb	r4, [r1, #30]
	p_channel->output_selection.b_override_pwml = override_pwml;
  4120ea:	77cd      	strb	r5, [r1, #31]
	override_value &= ~((PWM_OOV_OOVH0 | PWM_OOV_OOVL0) << ch_num);
  4120ec:	4097      	lsls	r7, r2
	p_channel->output_selection.override_level_pwmh = (pwm_level_t) pwmh;
  4120ee:	f881 c020 	strb.w	ip, [r1, #32]
	override_value |= (((pwml << 16) | pwmh) << ch_num);
  4120f2:	4096      	lsls	r6, r2
	p_channel->output_selection.override_level_pwml = (pwm_level_t) pwml;
  4120f4:	f881 e021 	strb.w	lr, [r1, #33]	; 0x21
	uint32_t override_value = p_pwm->PWM_OOV;
  4120f8:	6c41      	ldr	r1, [r0, #68]	; 0x44
	override_value &= ~((PWM_OOV_OOVH0 | PWM_OOV_OOVL0) << ch_num);
  4120fa:	ea21 0107 	bic.w	r1, r1, r7
	override_value |= (((pwml << 16) | pwmh) << ch_num);
  4120fe:	4331      	orrs	r1, r6
	p_pwm->PWM_OOV = override_value;
  412100:	6441      	str	r1, [r0, #68]	; 0x44

	/* Apply new output selection */
	if (b_sync) {
		p_pwm->PWM_OSSUPD = ((override_pwml << ch_num) << 16) |
			(override_pwmh << ch_num);
		p_pwm->PWM_OSCUPD = ((!override_pwml << ch_num) << 16) |
  412102:	f085 0101 	eor.w	r1, r5, #1
	if (b_sync) {
  412106:	b96b      	cbnz	r3, 412124 <pwm_channel_update_output+0x54>
			(!override_pwmh << ch_num);
	} else {
		p_pwm->PWM_OSS = ((override_pwml << ch_num) << 16) |
			(override_pwmh << ch_num);
		p_pwm->PWM_OSC = ((!override_pwml << ch_num) << 16) |
			(!override_pwmh << ch_num);
  412108:	f084 0301 	eor.w	r3, r4, #1
		p_pwm->PWM_OSS = ((override_pwml << ch_num) << 16) |
  41210c:	4095      	lsls	r5, r2
			(override_pwmh << ch_num);
  41210e:	4094      	lsls	r4, r2
		p_pwm->PWM_OSC = ((!override_pwml << ch_num) << 16) |
  412110:	4091      	lsls	r1, r2
			(!override_pwmh << ch_num);
  412112:	fa03 f202 	lsl.w	r2, r3, r2
		p_pwm->PWM_OSS = ((override_pwml << ch_num) << 16) |
  412116:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
		p_pwm->PWM_OSC = ((!override_pwml << ch_num) << 16) |
  41211a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
		p_pwm->PWM_OSS = ((override_pwml << ch_num) << 16) |
  41211e:	64c4      	str	r4, [r0, #76]	; 0x4c
		p_pwm->PWM_OSC = ((!override_pwml << ch_num) << 16) |
  412120:	6502      	str	r2, [r0, #80]	; 0x50
  412122:	bdf0      	pop	{r4, r5, r6, r7, pc}
			(!override_pwmh << ch_num);
  412124:	f084 0301 	eor.w	r3, r4, #1
		p_pwm->PWM_OSSUPD = ((override_pwml << ch_num) << 16) |
  412128:	4095      	lsls	r5, r2
			(override_pwmh << ch_num);
  41212a:	4094      	lsls	r4, r2
		p_pwm->PWM_OSCUPD = ((!override_pwml << ch_num) << 16) |
  41212c:	4091      	lsls	r1, r2
			(!override_pwmh << ch_num);
  41212e:	fa03 f202 	lsl.w	r2, r3, r2
		p_pwm->PWM_OSSUPD = ((override_pwml << ch_num) << 16) |
  412132:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
		p_pwm->PWM_OSCUPD = ((!override_pwml << ch_num) << 16) |
  412136:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
		p_pwm->PWM_OSSUPD = ((override_pwml << ch_num) << 16) |
  41213a:	6544      	str	r4, [r0, #84]	; 0x54
		p_pwm->PWM_OSCUPD = ((!override_pwml << ch_num) << 16) |
  41213c:	6582      	str	r2, [r0, #88]	; 0x58
  41213e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00412140 <pwm_fault_init>:
 * \param p_fault Configurations of a fault input.
 *
 * \retval 0 if configuration succeeds, otherwise fails.
 */
uint32_t pwm_fault_init(Pwm *p_pwm, pwm_fault_t *p_fault)
{
  412140:	b410      	push	{r4}
	uint32_t fault_id = p_fault->fault_id;
	uint32_t fault_reg = p_pwm->PWM_FMR;

	/** Polarity of fault input */
	if (p_fault->polarity == PWM_HIGH) {
  412142:	784c      	ldrb	r4, [r1, #1]
	uint32_t fault_id = p_fault->fault_id;
  412144:	780a      	ldrb	r2, [r1, #0]
	if (p_fault->polarity == PWM_HIGH) {
  412146:	2c01      	cmp	r4, #1
	uint32_t fault_reg = p_pwm->PWM_FMR;
  412148:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
		fault_reg |= fault_id;
	} else {
		fault_reg &= ~fault_id;
	}
	/** Boolean of clearing fault flag */
	if (p_fault->b_clear) {
  41214a:	788c      	ldrb	r4, [r1, #2]
		fault_reg |= fault_id;
  41214c:	bf0c      	ite	eq
  41214e:	4313      	orreq	r3, r2
		fault_reg &= ~fault_id;
  412150:	4393      	bicne	r3, r2
	if (p_fault->b_clear) {
  412152:	b154      	cbz	r4, 41216a <pwm_fault_init+0x2a>
		fault_reg |= (fault_id << 8);
	} else {
		fault_reg &= ~(fault_id << 8);
	}
	/** Boolean of fault filtering */
	if (p_fault->b_filtered) {
  412154:	78c9      	ldrb	r1, [r1, #3]
		fault_reg |= (fault_id << 8);
  412156:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (p_fault->b_filtered) {
  41215a:	b959      	cbnz	r1, 412174 <pwm_fault_init+0x34>
		fault_reg |= (fault_id << 16);
	} else {
		fault_reg &= ~(fault_id << 16);
  41215c:	ea23 4302 	bic.w	r3, r3, r2, lsl #16
	}

	p_pwm->PWM_FMR = fault_reg;
  412160:	65c3      	str	r3, [r0, #92]	; 0x5c

	return 0;
}
  412162:	2000      	movs	r0, #0
  412164:	f85d 4b04 	ldr.w	r4, [sp], #4
  412168:	4770      	bx	lr
	if (p_fault->b_filtered) {
  41216a:	78c9      	ldrb	r1, [r1, #3]
		fault_reg &= ~(fault_id << 8);
  41216c:	ea23 2302 	bic.w	r3, r3, r2, lsl #8
	if (p_fault->b_filtered) {
  412170:	2900      	cmp	r1, #0
  412172:	d0f3      	beq.n	41215c <pwm_fault_init+0x1c>
		fault_reg |= (fault_id << 16);
  412174:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	p_pwm->PWM_FMR = fault_reg;
  412178:	65c3      	str	r3, [r0, #92]	; 0x5c
}
  41217a:	2000      	movs	r0, #0
  41217c:	f85d 4b04 	ldr.w	r4, [sp], #4
  412180:	4770      	bx	lr
  412182:	bf00      	nop

00412184 <pwm_fault_get_status>:
 *
 * \return Bitmask of IDs of all active faulty.
 */
uint32_t pwm_fault_get_status(Pwm *p_pwm)
{
	return ((p_pwm->PWM_FSR >> 8) & 0xFF);
  412184:	6e00      	ldr	r0, [r0, #96]	; 0x60
}
  412186:	f3c0 2007 	ubfx	r0, r0, #8, #8
  41218a:	4770      	bx	lr

0041218c <pwm_fault_clear_status>:
 * \param p_pwm Pointer to a PWM instance.
 * \param id Faulty ID.
 */
void pwm_fault_clear_status(Pwm *p_pwm, pwm_fault_id_t id)
{
	p_pwm->PWM_FCR = id;
  41218c:	6641      	str	r1, [r0, #100]	; 0x64
  41218e:	4770      	bx	lr

00412190 <pwm_cmp_init>:
 *
 * \retval 0 if initialization succeeds, otherwise fails.
 */
uint32_t pwm_cmp_init(Pwm *p_pwm, pwm_cmp_t *p_cmp)
{
	uint32_t unit = p_cmp->unit;
  412190:	680a      	ldr	r2, [r1, #0]

	p_pwm->PWM_CMP[unit].PWM_CMPV = PWM_CMPV_CV(p_cmp->ul_value) |
  412192:	688b      	ldr	r3, [r1, #8]
{
  412194:	b4f0      	push	{r4, r5, r6, r7}
	p_pwm->PWM_CMP[unit].PWM_CMPV = PWM_CMPV_CV(p_cmp->ul_value) |
  412196:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
			(p_cmp->b_is_decrementing << 24);
  41219a:	7b0d      	ldrb	r5, [r1, #12]
	p_pwm->PWM_CMP[unit].PWM_CMPV = PWM_CMPV_CV(p_cmp->ul_value) |
  41219c:	f102 0413 	add.w	r4, r2, #19

	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121a0:	0116      	lsls	r6, r2, #4
	p_pwm->PWM_CMP[unit].PWM_CMPV = PWM_CMPV_CV(p_cmp->ul_value) |
  4121a2:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
  4121a6:	0124      	lsls	r4, r4, #4
	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121a8:	1987      	adds	r7, r0, r6
	p_pwm->PWM_CMP[unit].PWM_CMPV = PWM_CMPV_CV(p_cmp->ul_value) |
  4121aa:	5103      	str	r3, [r0, r4]
	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121ac:	690b      	ldr	r3, [r1, #16]
			PWM_CMPM_CPR(p_cmp->ul_period) |
  4121ae:	694d      	ldr	r5, [r1, #20]
			PWM_CMPM_CUPR(p_cmp->ul_update_period);
  4121b0:	698c      	ldr	r4, [r1, #24]
	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121b2:	011b      	lsls	r3, r3, #4
			PWM_CMPM_CPR(p_cmp->ul_period) |
  4121b4:	022d      	lsls	r5, r5, #8
	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121b6:	b2db      	uxtb	r3, r3
			PWM_CMPM_CPR(p_cmp->ul_period) |
  4121b8:	f405 6570 	and.w	r5, r5, #3840	; 0xf00
			PWM_CMPM_CUPR(p_cmp->ul_update_period);
  4121bc:	0424      	lsls	r4, r4, #16
	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121be:	432b      	orrs	r3, r5
			PWM_CMPM_CUPR(p_cmp->ul_update_period);
  4121c0:	f404 2470 	and.w	r4, r4, #983040	; 0xf0000
			PWM_CMPM_CPR(p_cmp->ul_period) |
  4121c4:	4323      	orrs	r3, r4

	/** Boolean of generating a match pulse */
	if (p_cmp->b_pulse_on_line_0) {
		p_pwm->PWM_ELMR[0] |= (1 << unit);
  4121c6:	2401      	movs	r4, #1
	p_pwm->PWM_CMP[unit].PWM_CMPM = PWM_CMPM_CTR(p_cmp->ul_trigger) |
  4121c8:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
	if (p_cmp->b_pulse_on_line_0) {
  4121cc:	7f0b      	ldrb	r3, [r1, #28]
  4121ce:	b1bb      	cbz	r3, 412200 <pwm_cmp_init+0x70>
		p_pwm->PWM_ELMR[0] |= (1 << unit);
  4121d0:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  4121d2:	fa04 f202 	lsl.w	r2, r4, r2
  4121d6:	4313      	orrs	r3, r2
  4121d8:	67c3      	str	r3, [r0, #124]	; 0x7c
	} else {
		p_pwm->PWM_ELMR[0] &= ~((uint32_t) (1 << unit));
	}
	/** Boolean of generating a match pulse */
	if (p_cmp->b_pulse_on_line_1) {
  4121da:	7f4b      	ldrb	r3, [r1, #29]
  4121dc:	b1cb      	cbz	r3, 412212 <pwm_cmp_init+0x82>
		p_pwm->PWM_ELMR[1] |= (1 << unit);
  4121de:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
  4121e2:	431a      	orrs	r2, r3
  4121e4:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		p_pwm->PWM_ELMR[1] &= ~((uint32_t) (1 << unit));
	}

	/** Boolean of comparison enable */
	if (p_cmp->b_enable) {
		p_pwm->PWM_CMP[unit].PWM_CMPM |= PWM_CMPM_CEN;
  4121e8:	4430      	add	r0, r6
	if (p_cmp->b_enable) {
  4121ea:	790b      	ldrb	r3, [r1, #4]
  4121ec:	b9db      	cbnz	r3, 412226 <pwm_cmp_init+0x96>
	} else {
		p_pwm->PWM_CMP[unit].PWM_CMPM &= ~PWM_CMPM_CEN;
  4121ee:	f8d0 3138 	ldr.w	r3, [r0, #312]	; 0x138
  4121f2:	f023 0301 	bic.w	r3, r3, #1
  4121f6:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
	}

	return 0;
}
  4121fa:	2000      	movs	r0, #0
  4121fc:	bcf0      	pop	{r4, r5, r6, r7}
  4121fe:	4770      	bx	lr
		p_pwm->PWM_ELMR[0] &= ~((uint32_t) (1 << unit));
  412200:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  412202:	fa04 f202 	lsl.w	r2, r4, r2
  412206:	ea23 0302 	bic.w	r3, r3, r2
  41220a:	67c3      	str	r3, [r0, #124]	; 0x7c
	if (p_cmp->b_pulse_on_line_1) {
  41220c:	7f4b      	ldrb	r3, [r1, #29]
  41220e:	2b00      	cmp	r3, #0
  412210:	d1e5      	bne.n	4121de <pwm_cmp_init+0x4e>
		p_pwm->PWM_ELMR[1] &= ~((uint32_t) (1 << unit));
  412212:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
  412216:	ea23 0202 	bic.w	r2, r3, r2
  41221a:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		p_pwm->PWM_CMP[unit].PWM_CMPM |= PWM_CMPM_CEN;
  41221e:	4430      	add	r0, r6
	if (p_cmp->b_enable) {
  412220:	790b      	ldrb	r3, [r1, #4]
  412222:	2b00      	cmp	r3, #0
  412224:	d0e3      	beq.n	4121ee <pwm_cmp_init+0x5e>
		p_pwm->PWM_CMP[unit].PWM_CMPM |= PWM_CMPM_CEN;
  412226:	f8d0 3138 	ldr.w	r3, [r0, #312]	; 0x138
  41222a:	f043 0301 	orr.w	r3, r3, #1
  41222e:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
}
  412232:	2000      	movs	r0, #0
  412234:	bcf0      	pop	{r4, r5, r6, r7}
  412236:	4770      	bx	lr

00412238 <pwm_sync_init>:
 *
 * \retval 0 if initialization succeeds, otherwise fails.
 */
uint32_t pwm_sync_init(Pwm *p_pwm, pwm_sync_update_mode_t mode,
		uint32_t ul_update_period)
{
  412238:	b410      	push	{r4}
  41223a:	4604      	mov	r4, r0
	sync_mode &= ~PWM_SCM_UPDM_Msk;
	sync_mode |= mode;

	p_pwm->PWM_SCM = sync_mode;

	p_pwm->PWM_SCUP = PWM_SCUP_UPR(ul_update_period);
  41223c:	f002 020f 	and.w	r2, r2, #15

	return 0;
}
  412240:	2000      	movs	r0, #0
	uint32_t sync_mode = p_pwm->PWM_SCM;
  412242:	6a23      	ldr	r3, [r4, #32]
	sync_mode &= ~PWM_SCM_UPDM_Msk;
  412244:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
	sync_mode |= mode;
  412248:	4319      	orrs	r1, r3
	p_pwm->PWM_SCM = sync_mode;
  41224a:	6221      	str	r1, [r4, #32]
	p_pwm->PWM_SCUP = PWM_SCUP_UPR(ul_update_period);
  41224c:	62e2      	str	r2, [r4, #44]	; 0x2c
}
  41224e:	f85d 4b04 	ldr.w	r4, [sp], #4
  412252:	4770      	bx	lr

00412254 <pwm_sync_unlock_update>:
 *
 * \param p_pwm Pointer to a PWM instance.
 */
void pwm_sync_unlock_update(Pwm *p_pwm)
{
	p_pwm->PWM_SCUC = PWM_SCUC_UPDULOCK;
  412254:	2301      	movs	r3, #1
  412256:	6283      	str	r3, [r0, #40]	; 0x28
  412258:	4770      	bx	lr
  41225a:	bf00      	nop

0041225c <pwm_enable_protect>:
 */
void pwm_enable_protect(Pwm *p_pwm, uint32_t ul_group, bool b_sw)
{
	uint32_t wp = 0;

	if (b_sw) {
  41225c:	b92a      	cbnz	r2, 41226a <pwm_enable_protect+0xe>
		wp = PWM_WPCR_WPKEY_PASSWD | (ul_group << 2) |
				PWM_WPCR_WPCMD_ENABLE_SW_PROT;
	} else {
		wp = PWM_WPCR_WPKEY_PASSWD | (ul_group << 2) |
  41225e:	4b06      	ldr	r3, [pc, #24]	; (412278 <pwm_enable_protect+0x1c>)
  412260:	ea43 0181 	orr.w	r1, r3, r1, lsl #2
				PWM_WPCR_WPCMD_ENABLE_HW_PROT;
	}

	p_pwm->PWM_WPCR = wp;
  412264:	f8c0 10e4 	str.w	r1, [r0, #228]	; 0xe4
  412268:	4770      	bx	lr
		wp = PWM_WPCR_WPKEY_PASSWD | (ul_group << 2) |
  41226a:	4b04      	ldr	r3, [pc, #16]	; (41227c <pwm_enable_protect+0x20>)
  41226c:	ea43 0181 	orr.w	r1, r3, r1, lsl #2
	p_pwm->PWM_WPCR = wp;
  412270:	f8c0 10e4 	str.w	r1, [r0, #228]	; 0xe4
  412274:	4770      	bx	lr
  412276:	bf00      	nop
  412278:	50574d02 	.word	0x50574d02
  41227c:	50574d01 	.word	0x50574d01

00412280 <twihs_set_speed>:
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;
	uint32_t cldiv, chdiv;

	/* High-Speed can be only used in slave mode, 400k is the max speed allowed for master */
	if (ul_speed > I2C_FAST_MODE_SPEED) {
  412280:	4b2c      	ldr	r3, [pc, #176]	; (412334 <twihs_set_speed+0xb4>)
  412282:	4299      	cmp	r1, r3
{
  412284:	b430      	push	{r4, r5}
	if (ul_speed > I2C_FAST_MODE_SPEED) {
  412286:	d84d      	bhi.n	412324 <twihs_set_speed+0xa4>
		return FAIL;
	}

	/* Low level time not less than 1.3us of I2C Fast Mode. */
	if (ul_speed > LOW_LEVEL_TIME_LIMIT) {
  412288:	f5a3 537a 	sub.w	r3, r3, #16000	; 0x3e80
  41228c:	4299      	cmp	r1, r3
  41228e:	d92e      	bls.n	4122ee <twihs_set_speed+0x6e>
		/* Low level of time fixed for 1.3us. */
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  412290:	4b29      	ldr	r3, [pc, #164]	; (412338 <twihs_set_speed+0xb8>)
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  412292:	4c2a      	ldr	r4, [pc, #168]	; (41233c <twihs_set_speed+0xbc>)
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  412294:	440b      	add	r3, r1
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  412296:	fba4 1402 	umull	r1, r4, r4, r2
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  41229a:	009b      	lsls	r3, r3, #2
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  41229c:	0ba4      	lsrs	r4, r4, #14
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  41229e:	fbb2 f2f3 	udiv	r2, r2, r3
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  4122a2:	3c03      	subs	r4, #3
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  4122a4:	3a03      	subs	r2, #3
		
		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((cldiv > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  4122a6:	2cff      	cmp	r4, #255	; 0xff
  4122a8:	d940      	bls.n	41232c <twihs_set_speed+0xac>
  4122aa:	2100      	movs	r1, #0
  4122ac:	e000      	b.n	4122b0 <twihs_set_speed+0x30>
  4122ae:	b13b      	cbz	r3, 4122c0 <twihs_set_speed+0x40>
			/* Increase clock divider */
			ckdiv++;
  4122b0:	3101      	adds	r1, #1
			/* Divide cldiv value */
			cldiv /= TWIHS_CLK_DIVIDER;
  4122b2:	0864      	lsrs	r4, r4, #1
		while ((cldiv > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  4122b4:	2906      	cmp	r1, #6
  4122b6:	bf8c      	ite	hi
  4122b8:	2300      	movhi	r3, #0
  4122ba:	2301      	movls	r3, #1
  4122bc:	2cff      	cmp	r4, #255	; 0xff
  4122be:	d8f6      	bhi.n	4122ae <twihs_set_speed+0x2e>
		}
		/* chdiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((chdiv > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  4122c0:	2aff      	cmp	r2, #255	; 0xff
  4122c2:	d907      	bls.n	4122d4 <twihs_set_speed+0x54>
  4122c4:	b913      	cbnz	r3, 4122cc <twihs_set_speed+0x4c>
  4122c6:	e005      	b.n	4122d4 <twihs_set_speed+0x54>
  4122c8:	2906      	cmp	r1, #6
  4122ca:	d803      	bhi.n	4122d4 <twihs_set_speed+0x54>
			/* Increase clock divider */
			ckdiv++;
			/* Divide cldiv value */
			chdiv /= TWIHS_CLK_DIVIDER;
  4122cc:	0852      	lsrs	r2, r2, #1
			ckdiv++;
  4122ce:	3101      	adds	r1, #1
		while ((chdiv > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  4122d0:	2aff      	cmp	r2, #255	; 0xff
  4122d2:	d8f9      	bhi.n	4122c8 <twihs_set_speed+0x48>
		}

		/* set clock waveform generator register */
		p_twihs->TWIHS_CWGR =
				TWIHS_CWGR_CLDIV(cldiv) | TWIHS_CWGR_CHDIV(chdiv) |
  4122d4:	0213      	lsls	r3, r2, #8
		p_twihs->TWIHS_CWGR =
  4122d6:	2500      	movs	r5, #0
				TWIHS_CWGR_CKDIV(ckdiv);
  4122d8:	0409      	lsls	r1, r1, #16
				TWIHS_CWGR_CLDIV(cldiv) | TWIHS_CWGR_CHDIV(chdiv) |
  4122da:	b29b      	uxth	r3, r3
				TWIHS_CWGR_CKDIV(ckdiv);
  4122dc:	f401 21e0 	and.w	r1, r1, #458752	; 0x70000
				TWIHS_CWGR_CLDIV(cldiv) | TWIHS_CWGR_CHDIV(chdiv) |
  4122e0:	b2e4      	uxtb	r4, r4
  4122e2:	430b      	orrs	r3, r1
  4122e4:	4323      	orrs	r3, r4
		p_twihs->TWIHS_CWGR =
  4122e6:	6103      	str	r3, [r0, #16]
				TWIHS_CWGR_CLDIV(c_lh_div) | TWIHS_CWGR_CHDIV(c_lh_div) |
				TWIHS_CWGR_CKDIV(ckdiv);
	}

	return PASS;
}
  4122e8:	4628      	mov	r0, r5
  4122ea:	bc30      	pop	{r4, r5}
  4122ec:	4770      	bx	lr
		c_lh_div = ul_mck / (ul_speed * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  4122ee:	0049      	lsls	r1, r1, #1
		while ((c_lh_div > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  4122f0:	2300      	movs	r3, #0
		c_lh_div = ul_mck / (ul_speed * TWIHS_CLK_DIVIDER) - TWIHS_CLK_CALC_ARGU;
  4122f2:	fbb2 f2f1 	udiv	r2, r2, r1
  4122f6:	3a03      	subs	r2, #3
		while ((c_lh_div > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  4122f8:	2aff      	cmp	r2, #255	; 0xff
  4122fa:	d802      	bhi.n	412302 <twihs_set_speed+0x82>
  4122fc:	e008      	b.n	412310 <twihs_set_speed+0x90>
  4122fe:	2b06      	cmp	r3, #6
  412300:	d803      	bhi.n	41230a <twihs_set_speed+0x8a>
			c_lh_div /= TWIHS_CLK_DIVIDER;
  412302:	0852      	lsrs	r2, r2, #1
			ckdiv++;
  412304:	3301      	adds	r3, #1
		while ((c_lh_div > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  412306:	2aff      	cmp	r2, #255	; 0xff
  412308:	d8f9      	bhi.n	4122fe <twihs_set_speed+0x7e>
  41230a:	041b      	lsls	r3, r3, #16
  41230c:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWIHS_CWGR_CLDIV(c_lh_div) | TWIHS_CWGR_CHDIV(c_lh_div) |
  412310:	0211      	lsls	r1, r2, #8
	return PASS;
  412312:	2500      	movs	r5, #0
				TWIHS_CWGR_CLDIV(c_lh_div) | TWIHS_CWGR_CHDIV(c_lh_div) |
  412314:	b2d2      	uxtb	r2, r2
  412316:	b289      	uxth	r1, r1
  412318:	431a      	orrs	r2, r3
  41231a:	430a      	orrs	r2, r1
		p_twihs->TWIHS_CWGR =
  41231c:	6102      	str	r2, [r0, #16]
}
  41231e:	4628      	mov	r0, r5
  412320:	bc30      	pop	{r4, r5}
  412322:	4770      	bx	lr
		return FAIL;
  412324:	2501      	movs	r5, #1
}
  412326:	4628      	mov	r0, r5
  412328:	bc30      	pop	{r4, r5}
  41232a:	4770      	bx	lr
		while ((cldiv > TWIHS_CLK_DIV_MAX) && (ckdiv < TWIHS_CLK_DIV_MIN)) {
  41232c:	2301      	movs	r3, #1
	uint32_t ckdiv = 0;
  41232e:	2100      	movs	r1, #0
  412330:	e7c6      	b.n	4122c0 <twihs_set_speed+0x40>
  412332:	bf00      	nop
  412334:	00061a80 	.word	0x00061a80
  412338:	3ffd1200 	.word	0x3ffd1200
  41233c:	057619f1 	.word	0x057619f1

00412340 <twihs_master_init>:
{
  412340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	p_twihs->TWIHS_CR = TWIHS_CR_MSEN;
  412342:	2204      	movs	r2, #4
	p_twihs->TWIHS_IDR = ~0UL;
  412344:	f04f 37ff 	mov.w	r7, #4294967295
 * \param p_twihs Pointer to a TWIHS instance.
 */
void twihs_reset(Twihs *p_twihs)
{
	/* Set SWRST bit to reset TWIHS peripheral */
	p_twihs->TWIHS_CR = TWIHS_CR_SWRST;
  412348:	2480      	movs	r4, #128	; 0x80
	p_twihs->TWIHS_CR = TWIHS_CR_MSDIS;
  41234a:	2608      	movs	r6, #8
	p_twihs->TWIHS_CR = TWIHS_CR_SVDIS;
  41234c:	2520      	movs	r5, #32
	p_twihs->TWIHS_IDR = ~0UL;
  41234e:	6287      	str	r7, [r0, #40]	; 0x28
	p_twihs->TWIHS_SR;
  412350:	6a07      	ldr	r7, [r0, #32]
	p_twihs->TWIHS_CR = TWIHS_CR_SWRST;
  412352:	6004      	str	r4, [r0, #0]
	if (twihs_set_speed(p_twihs, p_opt->speed, p_opt->master_clk) == FAIL) {
  412354:	4c06      	ldr	r4, [pc, #24]	; (412370 <twihs_master_init+0x30>)
	p_twihs->TWIHS_RHR;
  412356:	6b07      	ldr	r7, [r0, #48]	; 0x30
	p_twihs->TWIHS_CR = TWIHS_CR_MSDIS;
  412358:	6006      	str	r6, [r0, #0]
	p_twihs->TWIHS_CR = TWIHS_CR_SVDIS;
  41235a:	6005      	str	r5, [r0, #0]
	p_twihs->TWIHS_CR = TWIHS_CR_MSEN;
  41235c:	6002      	str	r2, [r0, #0]
	if (twihs_set_speed(p_twihs, p_opt->speed, p_opt->master_clk) == FAIL) {
  41235e:	680a      	ldr	r2, [r1, #0]
  412360:	6849      	ldr	r1, [r1, #4]
  412362:	47a0      	blx	r4
}
  412364:	f1a0 0001 	sub.w	r0, r0, #1
  412368:	fab0 f080 	clz	r0, r0
  41236c:	0940      	lsrs	r0, r0, #5
  41236e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  412370:	00412281 	.word	0x00412281

00412374 <twihs_master_read>:
	uint32_t status, cnt = p_packet->length;
  412374:	68ca      	ldr	r2, [r1, #12]
	if (cnt == 0) {
  412376:	2a00      	cmp	r2, #0
  412378:	d049      	beq.n	41240e <twihs_master_read+0x9a>
{
  41237a:	b470      	push	{r4, r5, r6}
	p_twihs->TWIHS_MMR = 0;
  41237c:	2600      	movs	r6, #0
	uint8_t *buffer = p_packet->buffer;
  41237e:	688c      	ldr	r4, [r1, #8]
	p_twihs->TWIHS_MMR = 0;
  412380:	6046      	str	r6, [r0, #4]
			((p_packet->addr_length << TWIHS_MMR_IADRSZ_Pos) &
  412382:	684b      	ldr	r3, [r1, #4]
	p_twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(p_packet->chip) |
  412384:	7c0d      	ldrb	r5, [r1, #16]
			((p_packet->addr_length << TWIHS_MMR_IADRSZ_Pos) &
  412386:	021b      	lsls	r3, r3, #8
	p_twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(p_packet->chip) |
  412388:	042d      	lsls	r5, r5, #16
			((p_packet->addr_length << TWIHS_MMR_IADRSZ_Pos) &
  41238a:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twihs->TWIHS_MMR = TWIHS_MMR_MREAD | TWIHS_MMR_DADR(p_packet->chip) |
  41238e:	f405 05fe 	and.w	r5, r5, #8323072	; 0x7f0000
  412392:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  412396:	432b      	orrs	r3, r5
  412398:	6043      	str	r3, [r0, #4]
	p_twihs->TWIHS_IADR = 0;
  41239a:	60c6      	str	r6, [r0, #12]
	p_twihs->TWIHS_IADR = twihs_mk_addr(p_packet->addr, p_packet->addr_length);
  41239c:	684b      	ldr	r3, [r1, #4]
	if (len == 0)
  41239e:	b9bb      	cbnz	r3, 4123d0 <twihs_master_read+0x5c>
		return 0;
  4123a0:	461d      	mov	r5, r3
	p_twihs->TWIHS_CR = TWIHS_CR_START;
  4123a2:	2301      	movs	r3, #1
	p_twihs->TWIHS_IADR = twihs_mk_addr(p_packet->addr, p_packet->addr_length);
  4123a4:	60c5      	str	r5, [r0, #12]
			p_twihs->TWIHS_CR = TWIHS_CR_STOP;
  4123a6:	2502      	movs	r5, #2
	p_twihs->TWIHS_CR = TWIHS_CR_START;
  4123a8:	6003      	str	r3, [r0, #0]
		status = p_twihs->TWIHS_SR;
  4123aa:	6a03      	ldr	r3, [r0, #32]
		if (status & TWIHS_SR_NACK) {
  4123ac:	05d9      	lsls	r1, r3, #23
  4123ae:	d40c      	bmi.n	4123ca <twihs_master_read+0x56>
  4123b0:	f247 5130 	movw	r1, #30000	; 0x7530
		if (cnt == 1) {
  4123b4:	2a01      	cmp	r2, #1
  4123b6:	d01e      	beq.n	4123f6 <twihs_master_read+0x82>
		if (!(status & TWIHS_SR_RXRDY)) {
  4123b8:	079e      	lsls	r6, r3, #30
  4123ba:	d515      	bpl.n	4123e8 <twihs_master_read+0x74>
		*buffer++ = p_twihs->TWIHS_RHR;
  4123bc:	6b03      	ldr	r3, [r0, #48]	; 0x30
		cnt--;
  4123be:	3a01      	subs	r2, #1
		*buffer++ = p_twihs->TWIHS_RHR;
  4123c0:	f804 3b01 	strb.w	r3, [r4], #1
		status = p_twihs->TWIHS_SR;
  4123c4:	6a03      	ldr	r3, [r0, #32]
		if (status & TWIHS_SR_NACK) {
  4123c6:	05d9      	lsls	r1, r3, #23
  4123c8:	d5f2      	bpl.n	4123b0 <twihs_master_read+0x3c>
			return TWIHS_RECEIVE_NACK;
  4123ca:	2005      	movs	r0, #5
}
  4123cc:	bc70      	pop	{r4, r5, r6}
  4123ce:	4770      	bx	lr
	if (len > 1) {
  4123d0:	2b01      	cmp	r3, #1
	val = addr[0];
  4123d2:	780d      	ldrb	r5, [r1, #0]
	if (len > 1) {
  4123d4:	dde5      	ble.n	4123a2 <twihs_master_read+0x2e>
		val |= addr[1];
  4123d6:	784e      	ldrb	r6, [r1, #1]
	if (len > 2) {
  4123d8:	2b02      	cmp	r3, #2
		val |= addr[1];
  4123da:	ea46 2505 	orr.w	r5, r6, r5, lsl #8
	if (len > 2) {
  4123de:	d0e0      	beq.n	4123a2 <twihs_master_read+0x2e>
		val |= addr[2];
  4123e0:	788b      	ldrb	r3, [r1, #2]
  4123e2:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  4123e6:	e7dc      	b.n	4123a2 <twihs_master_read+0x2e>
		status = p_twihs->TWIHS_SR;
  4123e8:	6a03      	ldr	r3, [r0, #32]
		if (status & TWIHS_SR_NACK) {
  4123ea:	05de      	lsls	r6, r3, #23
  4123ec:	d4ed      	bmi.n	4123ca <twihs_master_read+0x56>
		if (!timeout--) {
  4123ee:	3901      	subs	r1, #1
  4123f0:	d1e0      	bne.n	4123b4 <twihs_master_read+0x40>
			return TWIHS_ERROR_TIMEOUT;
  4123f2:	2009      	movs	r0, #9
  4123f4:	e7ea      	b.n	4123cc <twihs_master_read+0x58>
		if (!(status & TWIHS_SR_RXRDY)) {
  4123f6:	079b      	lsls	r3, r3, #30
			p_twihs->TWIHS_CR = TWIHS_CR_STOP;
  4123f8:	6005      	str	r5, [r0, #0]
		if (!(status & TWIHS_SR_RXRDY)) {
  4123fa:	d5f5      	bpl.n	4123e8 <twihs_master_read+0x74>
		*buffer++ = p_twihs->TWIHS_RHR;
  4123fc:	6b03      	ldr	r3, [r0, #48]	; 0x30
  4123fe:	7023      	strb	r3, [r4, #0]
	while (!(p_twihs->TWIHS_SR & TWIHS_SR_TXCOMP)) {
  412400:	6a03      	ldr	r3, [r0, #32]
  412402:	07db      	lsls	r3, r3, #31
  412404:	d5fc      	bpl.n	412400 <twihs_master_read+0x8c>
	p_twihs->TWIHS_SR;
  412406:	6a03      	ldr	r3, [r0, #32]
	return TWIHS_SUCCESS;
  412408:	2000      	movs	r0, #0
}
  41240a:	bc70      	pop	{r4, r5, r6}
  41240c:	4770      	bx	lr
		return TWIHS_INVALID_ARGUMENT;
  41240e:	2001      	movs	r0, #1
  412410:	4770      	bx	lr
  412412:	bf00      	nop

00412414 <twihs_master_write>:
{
  412414:	4603      	mov	r3, r0
	uint32_t status, cnt = p_packet->length;
  412416:	68c8      	ldr	r0, [r1, #12]
	if (cnt == 0) {
  412418:	2800      	cmp	r0, #0
  41241a:	d034      	beq.n	412486 <twihs_master_write+0x72>
{
  41241c:	b470      	push	{r4, r5, r6}
	p_twihs->TWIHS_MMR = 0;
  41241e:	2600      	movs	r6, #0
	uint8_t *buffer = p_packet->buffer;
  412420:	688c      	ldr	r4, [r1, #8]
	p_twihs->TWIHS_MMR = 0;
  412422:	605e      	str	r6, [r3, #4]
	p_twihs->TWIHS_MMR = TWIHS_MMR_DADR(p_packet->chip) |
  412424:	7c0a      	ldrb	r2, [r1, #16]
			((p_packet->addr_length << TWIHS_MMR_IADRSZ_Pos) &
  412426:	684d      	ldr	r5, [r1, #4]
	p_twihs->TWIHS_MMR = TWIHS_MMR_DADR(p_packet->chip) |
  412428:	0412      	lsls	r2, r2, #16
			((p_packet->addr_length << TWIHS_MMR_IADRSZ_Pos) &
  41242a:	022d      	lsls	r5, r5, #8
	p_twihs->TWIHS_MMR = TWIHS_MMR_DADR(p_packet->chip) |
  41242c:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
			((p_packet->addr_length << TWIHS_MMR_IADRSZ_Pos) &
  412430:	f405 7540 	and.w	r5, r5, #768	; 0x300
	p_twihs->TWIHS_MMR = TWIHS_MMR_DADR(p_packet->chip) |
  412434:	432a      	orrs	r2, r5
  412436:	605a      	str	r2, [r3, #4]
	p_twihs->TWIHS_IADR = 0;
  412438:	60de      	str	r6, [r3, #12]
	p_twihs->TWIHS_IADR = twihs_mk_addr(p_packet->addr, p_packet->addr_length);
  41243a:	684a      	ldr	r2, [r1, #4]
	if (len == 0)
  41243c:	b98a      	cbnz	r2, 412462 <twihs_master_write+0x4e>
		return 0;
  41243e:	4615      	mov	r5, r2
	p_twihs->TWIHS_IADR = twihs_mk_addr(p_packet->addr, p_packet->addr_length);
  412440:	60dd      	str	r5, [r3, #12]
		status = p_twihs->TWIHS_SR;
  412442:	6a1a      	ldr	r2, [r3, #32]
		if (status & TWIHS_SR_NACK) {
  412444:	05d6      	lsls	r6, r2, #23
  412446:	d409      	bmi.n	41245c <twihs_master_write+0x48>
		if (!(status & TWIHS_SR_TXRDY)) {
  412448:	0755      	lsls	r5, r2, #29
  41244a:	d5fa      	bpl.n	412442 <twihs_master_write+0x2e>
		p_twihs->TWIHS_THR = *buffer++;
  41244c:	f814 2b01 	ldrb.w	r2, [r4], #1
	while (cnt > 0) {
  412450:	3801      	subs	r0, #1
		p_twihs->TWIHS_THR = *buffer++;
  412452:	635a      	str	r2, [r3, #52]	; 0x34
	while (cnt > 0) {
  412454:	d013      	beq.n	41247e <twihs_master_write+0x6a>
		status = p_twihs->TWIHS_SR;
  412456:	6a1a      	ldr	r2, [r3, #32]
		if (status & TWIHS_SR_NACK) {
  412458:	05d6      	lsls	r6, r2, #23
  41245a:	d5f5      	bpl.n	412448 <twihs_master_write+0x34>
			return TWIHS_RECEIVE_NACK;
  41245c:	2005      	movs	r0, #5
}
  41245e:	bc70      	pop	{r4, r5, r6}
  412460:	4770      	bx	lr
	if (len > 1) {
  412462:	2a01      	cmp	r2, #1
	val = addr[0];
  412464:	780d      	ldrb	r5, [r1, #0]
	if (len > 1) {
  412466:	ddeb      	ble.n	412440 <twihs_master_write+0x2c>
		val |= addr[1];
  412468:	784e      	ldrb	r6, [r1, #1]
	if (len > 2) {
  41246a:	2a02      	cmp	r2, #2
		val |= addr[1];
  41246c:	ea46 2505 	orr.w	r5, r6, r5, lsl #8
	if (len > 2) {
  412470:	d0e6      	beq.n	412440 <twihs_master_write+0x2c>
		val |= addr[2];
  412472:	788a      	ldrb	r2, [r1, #2]
  412474:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
  412478:	e7e2      	b.n	412440 <twihs_master_write+0x2c>
		if (status & TWIHS_SR_TXRDY) {
  41247a:	0751      	lsls	r1, r2, #29
  41247c:	d405      	bmi.n	41248a <twihs_master_write+0x76>
		status = p_twihs->TWIHS_SR;
  41247e:	6a1a      	ldr	r2, [r3, #32]
		if (status & TWIHS_SR_NACK) {
  412480:	05d4      	lsls	r4, r2, #23
  412482:	d4eb      	bmi.n	41245c <twihs_master_write+0x48>
  412484:	e7f9      	b.n	41247a <twihs_master_write+0x66>
		return TWIHS_INVALID_ARGUMENT;
  412486:	2001      	movs	r0, #1
  412488:	4770      	bx	lr
	p_twihs->TWIHS_CR = TWIHS_CR_STOP;
  41248a:	2202      	movs	r2, #2
  41248c:	601a      	str	r2, [r3, #0]
	while (!(p_twihs->TWIHS_SR & TWIHS_SR_TXCOMP)) {
  41248e:	6a1a      	ldr	r2, [r3, #32]
  412490:	07d2      	lsls	r2, r2, #31
  412492:	d5fc      	bpl.n	41248e <twihs_master_write+0x7a>
}
  412494:	bc70      	pop	{r4, r5, r6}
  412496:	4770      	bx	lr

00412498 <usart_set_async_baudrate>:
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  412498:	010b      	lsls	r3, r1, #4
  41249a:	4293      	cmp	r3, r2
{
  41249c:	b410      	push	{r4}
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  41249e:	d814      	bhi.n	4124ca <usart_set_async_baudrate+0x32>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4124a0:	0859      	lsrs	r1, r3, #1
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4124a2:	f64f 74fe 	movw	r4, #65534	; 0xfffe
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4124a6:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  4124aa:	fbb2 f2f3 	udiv	r2, r2, r3
	cd = cd_fp >> 3;
  4124ae:	08d3      	lsrs	r3, r2, #3
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4124b0:	1e59      	subs	r1, r3, #1
  4124b2:	42a1      	cmp	r1, r4
  4124b4:	d815      	bhi.n	4124e2 <usart_set_async_baudrate+0x4a>
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  4124b6:	0412      	lsls	r2, r2, #16

	return 0;
  4124b8:	2100      	movs	r1, #0
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  4124ba:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
  4124be:	431a      	orrs	r2, r3
  4124c0:	6202      	str	r2, [r0, #32]
}
  4124c2:	4608      	mov	r0, r1
  4124c4:	f85d 4b04 	ldr.w	r4, [sp], #4
  4124c8:	4770      	bx	lr
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4124ca:	00c9      	lsls	r1, r1, #3
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4124cc:	f64f 74fe 	movw	r4, #65534	; 0xfffe
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4124d0:	084b      	lsrs	r3, r1, #1
  4124d2:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  4124d6:	fbb2 f2f1 	udiv	r2, r2, r1
	cd = cd_fp >> 3;
  4124da:	08d3      	lsrs	r3, r2, #3
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4124dc:	1e59      	subs	r1, r3, #1
  4124de:	42a1      	cmp	r1, r4
  4124e0:	d904      	bls.n	4124ec <usart_set_async_baudrate+0x54>
		return 1;
  4124e2:	2101      	movs	r1, #1
}
  4124e4:	f85d 4b04 	ldr.w	r4, [sp], #4
  4124e8:	4608      	mov	r0, r1
  4124ea:	4770      	bx	lr
		p_usart->US_MR |= US_MR_OVER;
  4124ec:	6841      	ldr	r1, [r0, #4]
  4124ee:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
  4124f2:	6041      	str	r1, [r0, #4]
  4124f4:	e7df      	b.n	4124b6 <usart_set_async_baudrate+0x1e>
  4124f6:	bf00      	nop

004124f8 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  4124f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	p_usart->US_MR = 0;
  4124fa:	2400      	movs	r4, #0
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  4124fc:	4d14      	ldr	r5, [pc, #80]	; (412550 <usart_init_rs232+0x58>)
	p_usart->US_CR = US_CR_RSTSTA;
  4124fe:	f44f 7680 	mov.w	r6, #256	; 0x100
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  412502:	f04f 0e88 	mov.w	lr, #136	; 0x88
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  412506:	2724      	movs	r7, #36	; 0x24
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  412508:	f8c0 50e4 	str.w	r5, [r0, #228]	; 0xe4
	p_usart->US_MR = 0;
  41250c:	6044      	str	r4, [r0, #4]
	p_usart->US_CR = US_CR_RTSDIS;
  41250e:	f44f 2500 	mov.w	r5, #524288	; 0x80000
	p_usart->US_RTOR = 0;
  412512:	6244      	str	r4, [r0, #36]	; 0x24
	p_usart->US_TTGR = 0;
  412514:	6284      	str	r4, [r0, #40]	; 0x28
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  412516:	f8c0 e000 	str.w	lr, [r0]
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  41251a:	6007      	str	r7, [r0, #0]
	p_usart->US_CR = US_CR_RSTSTA;
  41251c:	6006      	str	r6, [r0, #0]
	ul_reg_val = 0;
  41251e:	4e0d      	ldr	r6, [pc, #52]	; (412554 <usart_init_rs232+0x5c>)
	p_usart->US_CR = US_CR_RTSDIS;
  412520:	6005      	str	r5, [r0, #0]
	ul_reg_val = 0;
  412522:	6034      	str	r4, [r6, #0]
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  412524:	b189      	cbz	r1, 41254a <usart_init_rs232+0x52>
  412526:	460d      	mov	r5, r1
  412528:	4b0b      	ldr	r3, [pc, #44]	; (412558 <usart_init_rs232+0x60>)
  41252a:	6809      	ldr	r1, [r1, #0]
  41252c:	4604      	mov	r4, r0
  41252e:	4798      	blx	r3
  412530:	b958      	cbnz	r0, 41254a <usart_init_rs232+0x52>
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  412532:	686a      	ldr	r2, [r5, #4]
  412534:	68ab      	ldr	r3, [r5, #8]
  412536:	692f      	ldr	r7, [r5, #16]
  412538:	4313      	orrs	r3, r2
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  41253a:	68e9      	ldr	r1, [r5, #12]
	p_usart->US_MR |= ul_reg_val;
  41253c:	6862      	ldr	r2, [r4, #4]
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  41253e:	433b      	orrs	r3, r7
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  412540:	430b      	orrs	r3, r1
	p_usart->US_MR |= ul_reg_val;
  412542:	431a      	orrs	r2, r3
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  412544:	6033      	str	r3, [r6, #0]
	p_usart->US_MR |= ul_reg_val;
  412546:	6062      	str	r2, [r4, #4]
}
  412548:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 1;
  41254a:	2001      	movs	r0, #1
  41254c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41254e:	bf00      	nop
  412550:	55534100 	.word	0x55534100
  412554:	20400a90 	.word	0x20400a90
  412558:	00412499 	.word	0x00412499

0041255c <usart_init_rs485>:
{
  41255c:	b510      	push	{r4, lr}
	if (usart_init_rs232(p_usart, p_usart_opt, ul_mck)) {
  41255e:	4b06      	ldr	r3, [pc, #24]	; (412578 <usart_init_rs485+0x1c>)
{
  412560:	4604      	mov	r4, r0
	if (usart_init_rs232(p_usart, p_usart_opt, ul_mck)) {
  412562:	4798      	blx	r3
  412564:	b930      	cbnz	r0, 412574 <usart_init_rs485+0x18>
	p_usart->US_MR = (p_usart->US_MR & ~US_MR_USART_MODE_Msk) |
  412566:	6863      	ldr	r3, [r4, #4]
  412568:	f023 030f 	bic.w	r3, r3, #15
  41256c:	f043 0301 	orr.w	r3, r3, #1
  412570:	6063      	str	r3, [r4, #4]
	return 0;
  412572:	bd10      	pop	{r4, pc}
		return 1;
  412574:	2001      	movs	r0, #1
}
  412576:	bd10      	pop	{r4, pc}
  412578:	004124f9 	.word	0x004124f9

0041257c <usart_init_spi_master>:
{
  41257c:	b5f0      	push	{r4, r5, r6, r7, lr}
  41257e:	4603      	mov	r3, r0
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  412580:	4c26      	ldr	r4, [pc, #152]	; (41261c <usart_init_spi_master+0xa0>)
	p_usart->US_MR = 0;
  412582:	2000      	movs	r0, #0
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  412584:	f04f 0e88 	mov.w	lr, #136	; 0x88
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  412588:	f8c3 40e4 	str.w	r4, [r3, #228]	; 0xe4
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  41258c:	2724      	movs	r7, #36	; 0x24
	p_usart->US_CR = US_CR_RSTSTA;
  41258e:	f44f 7680 	mov.w	r6, #256	; 0x100
	p_usart->US_CR = US_CR_RTSDIS;
  412592:	f44f 2500 	mov.w	r5, #524288	; 0x80000
	ul_reg_val = 0;
  412596:	4c22      	ldr	r4, [pc, #136]	; (412620 <usart_init_spi_master+0xa4>)
	p_usart->US_MR = 0;
  412598:	6058      	str	r0, [r3, #4]
	ul_reg_val = 0;
  41259a:	6020      	str	r0, [r4, #0]
	p_usart->US_RTOR = 0;
  41259c:	6258      	str	r0, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
  41259e:	6298      	str	r0, [r3, #40]	; 0x28
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  4125a0:	f8c3 e000 	str.w	lr, [r3]
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  4125a4:	601f      	str	r7, [r3, #0]
	p_usart->US_CR = US_CR_RSTSTA;
  4125a6:	601e      	str	r6, [r3, #0]
	p_usart->US_CR = US_CR_RTSDIS;
  4125a8:	601d      	str	r5, [r3, #0]
	if (!p_usart_opt || (p_usart_opt->spi_mode > SPI_MODE_3) ||
  4125aa:	b161      	cbz	r1, 4125c6 <usart_init_spi_master+0x4a>
  4125ac:	6888      	ldr	r0, [r1, #8]
  4125ae:	2803      	cmp	r0, #3
  4125b0:	d809      	bhi.n	4125c6 <usart_init_spi_master+0x4a>
			usart_set_spi_master_baudrate(p_usart, p_usart_opt->baudrate,
  4125b2:	6808      	ldr	r0, [r1, #0]
	if (cd < MIN_CD_VALUE_SPI || cd > MAX_CD_VALUE) {
  4125b4:	f64f 75fb 	movw	r5, #65531	; 0xfffb
	cd = (ul_mck + baudrate / 2) / baudrate;
  4125b8:	eb02 0250 	add.w	r2, r2, r0, lsr #1
  4125bc:	fbb2 f2f0 	udiv	r2, r2, r0
	if (cd < MIN_CD_VALUE_SPI || cd > MAX_CD_VALUE) {
  4125c0:	1f10      	subs	r0, r2, #4
  4125c2:	42a8      	cmp	r0, r5
  4125c4:	d901      	bls.n	4125ca <usart_init_spi_master+0x4e>
		return 1;
  4125c6:	2001      	movs	r0, #1
}
  4125c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	p_usart->US_BRGR = cd << US_BRGR_CD_Pos;
  4125ca:	621a      	str	r2, [r3, #32]
	ul_reg_val |= US_MR_USART_MODE_SPI_MASTER | US_MR_CLKO |
  4125cc:	6848      	ldr	r0, [r1, #4]
  4125ce:	68cd      	ldr	r5, [r1, #12]
  4125d0:	4a14      	ldr	r2, [pc, #80]	; (412624 <usart_init_spi_master+0xa8>)
  4125d2:	4328      	orrs	r0, r5
	switch (p_usart_opt->spi_mode) {
  4125d4:	6889      	ldr	r1, [r1, #8]
	ul_reg_val |= US_MR_USART_MODE_SPI_MASTER | US_MR_CLKO |
  4125d6:	4302      	orrs	r2, r0
  4125d8:	6022      	str	r2, [r4, #0]
	switch (p_usart_opt->spi_mode) {
  4125da:	2903      	cmp	r1, #3
  4125dc:	d808      	bhi.n	4125f0 <usart_init_spi_master+0x74>
  4125de:	e8df f001 	tbb	[pc, r1]
  4125e2:	0216      	.short	0x0216
  4125e4:	0c12      	.short	0x0c12
		ul_reg_val &= ~US_MR_CPOL;
  4125e6:	4910      	ldr	r1, [pc, #64]	; (412628 <usart_init_spi_master+0xac>)
  4125e8:	4a0e      	ldr	r2, [pc, #56]	; (412624 <usart_init_spi_master+0xa8>)
  4125ea:	4001      	ands	r1, r0
  4125ec:	430a      	orrs	r2, r1
  4125ee:	6022      	str	r2, [r4, #0]
	p_usart->US_MR |= ul_reg_val;
  4125f0:	6859      	ldr	r1, [r3, #4]
	return 0;
  4125f2:	2000      	movs	r0, #0
	p_usart->US_MR |= ul_reg_val;
  4125f4:	430a      	orrs	r2, r1
  4125f6:	605a      	str	r2, [r3, #4]
	return 0;
  4125f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ul_reg_val |= US_MR_CPOL;
  4125fa:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  4125fe:	4a0b      	ldr	r2, [pc, #44]	; (41262c <usart_init_spi_master+0xb0>)
  412600:	4302      	orrs	r2, r0
  412602:	6022      	str	r2, [r4, #0]
		break;
  412604:	e7f4      	b.n	4125f0 <usart_init_spi_master+0x74>
		ul_reg_val |= US_MR_CPOL;
  412606:	4a0a      	ldr	r2, [pc, #40]	; (412630 <usart_init_spi_master+0xb4>)
  412608:	4302      	orrs	r2, r0
  41260a:	6022      	str	r2, [r4, #0]
		break;
  41260c:	e7f0      	b.n	4125f0 <usart_init_spi_master+0x74>
		ul_reg_val &= ~US_MR_CPOL;
  41260e:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
  412612:	4a08      	ldr	r2, [pc, #32]	; (412634 <usart_init_spi_master+0xb8>)
  412614:	4302      	orrs	r2, r0
  412616:	6022      	str	r2, [r4, #0]
		break;
  412618:	e7ea      	b.n	4125f0 <usart_init_spi_master+0x74>
  41261a:	bf00      	nop
  41261c:	55534100 	.word	0x55534100
  412620:	20400a94 	.word	0x20400a94
  412624:	0004000e 	.word	0x0004000e
  412628:	fffefeff 	.word	0xfffefeff
  41262c:	0005000e 	.word	0x0005000e
  412630:	0005010e 	.word	0x0005010e
  412634:	0004010e 	.word	0x0004010e

00412638 <usart_lin_disable_pdc_mode>:
	p_usart->US_LINMR &= ~US_LINMR_PDCM;
  412638:	6d43      	ldr	r3, [r0, #84]	; 0x54
  41263a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  41263e:	6543      	str	r3, [r0, #84]	; 0x54
  412640:	4770      	bx	lr
  412642:	bf00      	nop

00412644 <usart_enable_tx>:
	p_usart->US_CR = US_CR_TXEN;
  412644:	2340      	movs	r3, #64	; 0x40
  412646:	6003      	str	r3, [r0, #0]
  412648:	4770      	bx	lr
  41264a:	bf00      	nop

0041264c <usart_enable_rx>:
	p_usart->US_CR = US_CR_RXEN;
  41264c:	2310      	movs	r3, #16
  41264e:	6003      	str	r3, [r0, #0]
  412650:	4770      	bx	lr
  412652:	bf00      	nop

00412654 <usart_set_rx_timeout>:
	p_usart->US_RTOR = timeout;
  412654:	6241      	str	r1, [r0, #36]	; 0x24
  412656:	4770      	bx	lr

00412658 <usart_enable_interrupt>:
	p_usart->US_IER = ul_sources;
  412658:	6081      	str	r1, [r0, #8]
  41265a:	4770      	bx	lr

0041265c <usart_disable_interrupt>:
	p_usart->US_IDR = ul_sources;
  41265c:	60c1      	str	r1, [r0, #12]
  41265e:	4770      	bx	lr

00412660 <usart_start_rx_timeout>:
	p_usart->US_CR = US_CR_STTTO;
  412660:	f44f 6300 	mov.w	r3, #2048	; 0x800
  412664:	6003      	str	r3, [r0, #0]
  412666:	4770      	bx	lr

00412668 <usart_drive_RTS_pin_low>:
  412668:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  41266c:	6003      	str	r3, [r0, #0]
  41266e:	4770      	bx	lr

00412670 <usart_spi_force_chip_select>:
	p_usart->US_CR = US_CR_FCS;
  412670:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  412674:	6003      	str	r3, [r0, #0]
  412676:	4770      	bx	lr

00412678 <usart_is_tx_ready>:
	return (p_usart->US_CSR & US_CSR_TXRDY) > 0;
  412678:	6940      	ldr	r0, [r0, #20]
}
  41267a:	f3c0 0040 	ubfx	r0, r0, #1, #1
  41267e:	4770      	bx	lr

00412680 <usart_is_tx_empty>:
	return (p_usart->US_CSR & US_CSR_TXEMPTY) > 0;
  412680:	6940      	ldr	r0, [r0, #20]
}
  412682:	f3c0 2040 	ubfx	r0, r0, #9, #1
  412686:	4770      	bx	lr

00412688 <tc_init>:

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  412688:	0189      	lsls	r1, r1, #6
{
  41268a:	b430      	push	{r4, r5}
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  41268c:	1843      	adds	r3, r0, r1

	/*  Disable TC clock. */
	tc_channel->TC_CCR = TC_CCR_CLKDIS;
  41268e:	2502      	movs	r5, #2

	/*  Disable interrupts. */
	tc_channel->TC_IDR = 0xFFFFFFFF;
  412690:	f04f 34ff 	mov.w	r4, #4294967295
	tc_channel->TC_CCR = TC_CCR_CLKDIS;
  412694:	5045      	str	r5, [r0, r1]
	tc_channel->TC_IDR = 0xFFFFFFFF;
  412696:	629c      	str	r4, [r3, #40]	; 0x28

	/*  Clear status register. */
	tc_channel->TC_SR;
  412698:	6a19      	ldr	r1, [r3, #32]

	/*  Set mode. */
	tc_channel->TC_CMR = ul_mode;
  41269a:	605a      	str	r2, [r3, #4]
}
  41269c:	bc30      	pop	{r4, r5}
  41269e:	4770      	bx	lr

004126a0 <tc_set_block_mode>:
		uint32_t ul_blockmode)
{
	/* Validate inputs. */
	Assert(p_tc);
	
	p_tc->TC_BMR = ul_blockmode;
  4126a0:	f8c0 10c4 	str.w	r1, [r0, #196]	; 0xc4
  4126a4:	4770      	bx	lr
  4126a6:	bf00      	nop

004126a8 <tc_start>:
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
  4126a8:	0189      	lsls	r1, r1, #6
  4126aa:	2305      	movs	r3, #5
  4126ac:	5043      	str	r3, [r0, r1]
  4126ae:	4770      	bx	lr

004126b0 <tc_read_cv>:
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	return p_tc->TC_CHANNEL[ul_channel].TC_CV;
  4126b0:	eb00 1181 	add.w	r1, r0, r1, lsl #6
  4126b4:	6908      	ldr	r0, [r1, #16]
}
  4126b6:	4770      	bx	lr

004126b8 <tc_write_rc>:
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_RC = ul_value;
  4126b8:	eb00 1181 	add.w	r1, r0, r1, lsl #6
  4126bc:	61ca      	str	r2, [r1, #28]
  4126be:	4770      	bx	lr

004126c0 <tc_enable_interrupt>:

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4126c0:	eb00 1181 	add.w	r1, r0, r1, lsl #6
	tc_channel->TC_IER = ul_sources;
  4126c4:	624a      	str	r2, [r1, #36]	; 0x24
  4126c6:	4770      	bx	lr

004126c8 <tc_get_status>:
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
			
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4126c8:	eb00 1181 	add.w	r1, r0, r1, lsl #6
	return tc_channel->TC_SR;
  4126cc:	6a08      	ldr	r0, [r1, #32]
}
  4126ce:	4770      	bx	lr

004126d0 <sph_faults_handler>:
sph_fault_t sph_faults[SPH_FAULT_COUNT];

uint32_t sph_faults_display_time_counter = 0;
uint32_t sph_faults_stop_i = 0, sph_faults_pos = 0, sph_faults_stop_i_to = 0, sph_faults_pos_to = 0; 
void sph_faults_handler(void)
{
  4126d0:	4a35      	ldr	r2, [pc, #212]	; (4127a8 <sph_faults_handler+0xd8>)
  4126d2:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 4127b8 <sph_faults_handler+0xe8>
  4126d6:	4b35      	ldr	r3, [pc, #212]	; (4127ac <sph_faults_handler+0xdc>)
  4126d8:	f8dc 0000 	ldr.w	r0, [ip]
  4126dc:	f503 7161 	add.w	r1, r3, #900	; 0x384
  4126e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4126e4:	2400      	movs	r4, #0
  4126e6:	b083      	sub	sp, #12
  4126e8:	4f31      	ldr	r7, [pc, #196]	; (4127b0 <sph_faults_handler+0xe0>)
  4126ea:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 4127bc <sph_faults_handler+0xec>
  4126ee:	46a2      	mov	sl, r4
  4126f0:	6812      	ldr	r2, [r2, #0]
  4126f2:	4625      	mov	r5, r4
  4126f4:	9401      	str	r4, [sp, #4]
  4126f6:	4693      	mov	fp, r2
  4126f8:	f8d7 9000 	ldr.w	r9, [r7]
  4126fc:	f8de 8000 	ldr.w	r8, [lr]
  412700:	e006      	b.n	412710 <sph_faults_handler+0x40>
			fault_counter = sph_faults[i].fault_counter;
			fault_counter &= ~0x80000000; //clear the fault set bit
			if (fault_counter > 0)
			{
				//there is time to pass for the fault
				fault_counter--; //decrement the fault counter
  412702:	3a01      	subs	r2, #1
				fault_counter |= 0x80000000; //reset the fault set bit
  412704:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
				sph_faults[i].fault_counter = fault_counter;
  412708:	605a      	str	r2, [r3, #4]
  41270a:	3314      	adds	r3, #20
	for (i=0; i<SPH_FAULT_COUNT; i++)
  41270c:	428b      	cmp	r3, r1
  41270e:	d014      	beq.n	41273a <sph_faults_handler+0x6a>
		if ((sph_faults[i].fault_timeout > 0) && (sph_faults[i].fault_timeout != 0xFFFFFFFF))
  412710:	689a      	ldr	r2, [r3, #8]
  412712:	3a01      	subs	r2, #1
  412714:	3203      	adds	r2, #3
  412716:	d8f8      	bhi.n	41270a <sph_faults_handler+0x3a>
			fault_counter = sph_faults[i].fault_counter;
  412718:	685e      	ldr	r6, [r3, #4]
			if (fault_counter > 0)
  41271a:	f036 4200 	bics.w	r2, r6, #2147483648	; 0x80000000
  41271e:	d1f0      	bne.n	412702 <sph_faults_handler+0x32>
			}
			else if (sph_faults[i].fault_counter == 0x80000000)
  412720:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
  412724:	d1f1      	bne.n	41270a <sph_faults_handler+0x3a>
			{
				//clear the fault
				sph_faults[i].fault_counter = 0;
				if (sph_faults[i].fault_type == STOP_IMMEDIATE)
  412726:	781e      	ldrb	r6, [r3, #0]
				sph_faults[i].fault_counter = 0;
  412728:	605a      	str	r2, [r3, #4]
				if (sph_faults[i].fault_type == STOP_IMMEDIATE)
  41272a:	b9e6      	cbnz	r6, 412766 <sph_faults_handler+0x96>
				{
					//no timeout fault
					if(sph_faults_stop_i>0) sph_faults_stop_i--;
  41272c:	2800      	cmp	r0, #0
  41272e:	d0ec      	beq.n	41270a <sph_faults_handler+0x3a>
  412730:	3314      	adds	r3, #20
  412732:	3801      	subs	r0, #1
  412734:	2501      	movs	r5, #1
	for (i=0; i<SPH_FAULT_COUNT; i++)
  412736:	428b      	cmp	r3, r1
  412738:	d1ea      	bne.n	412710 <sph_faults_handler+0x40>
  41273a:	bb8d      	cbnz	r5, 4127a0 <sph_faults_handler+0xd0>
  41273c:	f1ba 0f00 	cmp.w	sl, #0
  412740:	d001      	beq.n	412746 <sph_faults_handler+0x76>
  412742:	f8ce 8000 	str.w	r8, [lr]
  412746:	9b01      	ldr	r3, [sp, #4]
  412748:	b10b      	cbz	r3, 41274e <sph_faults_handler+0x7e>
  41274a:	f8c7 9000 	str.w	r9, [r7]
  41274e:	b114      	cbz	r4, 412756 <sph_faults_handler+0x86>
  412750:	4b15      	ldr	r3, [pc, #84]	; (4127a8 <sph_faults_handler+0xd8>)
  412752:	f8c3 b000 	str.w	fp, [r3]
					if(sph_faults_pos_to>0) sph_faults_pos_to--;
				}
			}
		}	
	}
	if(sph_faults_display_time_counter) sph_faults_display_time_counter--;
  412756:	4a17      	ldr	r2, [pc, #92]	; (4127b4 <sph_faults_handler+0xe4>)
  412758:	6813      	ldr	r3, [r2, #0]
  41275a:	b10b      	cbz	r3, 412760 <sph_faults_handler+0x90>
  41275c:	3b01      	subs	r3, #1
  41275e:	6013      	str	r3, [r2, #0]
}
  412760:	b003      	add	sp, #12
  412762:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				else if (sph_faults[i].fault_type == POS_FAULT)
  412766:	2e02      	cmp	r6, #2
  412768:	d00b      	beq.n	412782 <sph_faults_handler+0xb2>
				else if (sph_faults[i].fault_type == T_STOP_IMMEDIATE)
  41276a:	2e01      	cmp	r6, #1
  41276c:	d011      	beq.n	412792 <sph_faults_handler+0xc2>
				else if (sph_faults[i].fault_type == T_POS_FAULT)
  41276e:	2e03      	cmp	r6, #3
  412770:	d1cb      	bne.n	41270a <sph_faults_handler+0x3a>
					if(sph_faults_pos_to>0) sph_faults_pos_to--;
  412772:	465a      	mov	r2, fp
  412774:	2a00      	cmp	r2, #0
  412776:	d0c8      	beq.n	41270a <sph_faults_handler+0x3a>
  412778:	f10b 32ff 	add.w	r2, fp, #4294967295
  41277c:	2401      	movs	r4, #1
  41277e:	4693      	mov	fp, r2
  412780:	e7c3      	b.n	41270a <sph_faults_handler+0x3a>
					if(sph_faults_pos>0) sph_faults_pos--;
  412782:	f1b8 0f00 	cmp.w	r8, #0
  412786:	d0c0      	beq.n	41270a <sph_faults_handler+0x3a>
  412788:	f108 38ff 	add.w	r8, r8, #4294967295
  41278c:	f04f 0a01 	mov.w	sl, #1
  412790:	e7bb      	b.n	41270a <sph_faults_handler+0x3a>
					if(sph_faults_stop_i_to>0) sph_faults_stop_i_to--;
  412792:	f1b9 0f00 	cmp.w	r9, #0
  412796:	d0b8      	beq.n	41270a <sph_faults_handler+0x3a>
  412798:	f109 39ff 	add.w	r9, r9, #4294967295
  41279c:	9601      	str	r6, [sp, #4]
  41279e:	e7b4      	b.n	41270a <sph_faults_handler+0x3a>
  4127a0:	f8cc 0000 	str.w	r0, [ip]
  4127a4:	e7ca      	b.n	41273c <sph_faults_handler+0x6c>
  4127a6:	bf00      	nop
  4127a8:	20400aa4 	.word	0x20400aa4
  4127ac:	20406560 	.word	0x20406560
  4127b0:	20400aac 	.word	0x20400aac
  4127b4:	20400a9c 	.word	0x20400a9c
  4127b8:	20400aa8 	.word	0x20400aa8
  4127bc:	20400aa0 	.word	0x20400aa0

004127c0 <sph_faults_add_fault>:

uint32_t sph_faults_add_fault(fault_type_t fault_type, uint32_t fault_timeout, uint8_t fault_prefix, uint8_t fault_code, const char *e_string)
{
  4127c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  4127c2:	4f13      	ldr	r7, [pc, #76]	; (412810 <sph_faults_add_fault+0x50>)
  4127c4:	4686      	mov	lr, r0
	uint32_t i;
	for (i=0; i<SPH_FAULT_COUNT; i++)
  4127c6:	2000      	movs	r0, #0
  4127c8:	463c      	mov	r4, r7
  4127ca:	e002      	b.n	4127d2 <sph_faults_add_fault+0x12>
  4127cc:	3001      	adds	r0, #1
  4127ce:	282d      	cmp	r0, #45	; 0x2d
  4127d0:	d01a      	beq.n	412808 <sph_faults_add_fault+0x48>
	{
		if (sph_faults[i].fault_timeout == 0)
  4127d2:	68a5      	ldr	r5, [r4, #8]
  4127d4:	3414      	adds	r4, #20
  4127d6:	2d00      	cmp	r5, #0
  4127d8:	d1f8      	bne.n	4127cc <sph_faults_add_fault+0xc>
		{
			//there is an empty place for a fault
			sph_faults[i].fault_type = fault_type;
  4127da:	eb00 0680 	add.w	r6, r0, r0, lsl #2
  4127de:	00b6      	lsls	r6, r6, #2
  4127e0:	19bc      	adds	r4, r7, r6
  4127e2:	f807 e006 	strb.w	lr, [r7, r6]
			sph_faults[i].fault_timeout = fault_timeout;
  4127e6:	60a1      	str	r1, [r4, #8]
			sph_faults[i].e_string = e_string;
  4127e8:	9905      	ldr	r1, [sp, #20]
			sph_faults[i].fault_counter = 0;
  4127ea:	6065      	str	r5, [r4, #4]
			sph_faults[i].e_string = e_string;
  4127ec:	6121      	str	r1, [r4, #16]
			sph_faults[i].fault_prefix = fault_prefix;
  4127ee:	7322      	strb	r2, [r4, #12]
			sph_faults[i].fault_code = fault_code;
  4127f0:	7363      	strb	r3, [r4, #13]
			if (fault_type == STOP_IMMEDIATE)
  4127f2:	f1be 0f00 	cmp.w	lr, #0
  4127f6:	d003      	beq.n	412800 <sph_faults_add_fault+0x40>
			{
				//no timeout fault
				sph_faults[i].fault_timeout = 0xFFFFFFFF;	
			}
			else if (fault_type == POS_FAULT)
  4127f8:	f1be 0f02 	cmp.w	lr, #2
  4127fc:	d000      	beq.n	412800 <sph_faults_add_fault+0x40>
			}
			return i;
		}
	}
	return 0xFFFFFFFF;		
}
  4127fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
				sph_faults[i].fault_timeout = 0xFFFFFFFF;
  412800:	f04f 33ff 	mov.w	r3, #4294967295
  412804:	60a3      	str	r3, [r4, #8]
  412806:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return 0xFFFFFFFF;		
  412808:	f04f 30ff 	mov.w	r0, #4294967295
}
  41280c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41280e:	bf00      	nop
  412810:	20406560 	.word	0x20406560

00412814 <sph_faults_init>:

void sph_faults_init(void)
{
  412814:	4b04      	ldr	r3, [pc, #16]	; (412828 <sph_faults_init+0x14>)
	uint32_t i;
	for (i=0; i<SPH_FAULT_COUNT; i++)
	{
		sph_faults[i].fault_timeout = 0;	
  412816:	2100      	movs	r1, #0
  412818:	f503 7261 	add.w	r2, r3, #900	; 0x384
  41281c:	6099      	str	r1, [r3, #8]
  41281e:	3314      	adds	r3, #20
	for (i=0; i<SPH_FAULT_COUNT; i++)
  412820:	4293      	cmp	r3, r2
  412822:	d1fb      	bne.n	41281c <sph_faults_init+0x8>
	}
}
  412824:	4770      	bx	lr
  412826:	bf00      	nop
  412828:	20406560 	.word	0x20406560

0041282c <sph_faults_setfault>:

void sph_faults_setfault(uint32_t fault_index)
{
	if (fault_index < SPH_FAULT_COUNT)
  41282c:	282c      	cmp	r0, #44	; 0x2c
  41282e:	d81b      	bhi.n	412868 <sph_faults_setfault+0x3c>
{
  412830:	b570      	push	{r4, r5, r6, lr}
	{
		if(!(sph_faults[fault_index].fault_counter & 0x80000000))
  412832:	0086      	lsls	r6, r0, #2
  412834:	4d1a      	ldr	r5, [pc, #104]	; (4128a0 <sph_faults_setfault+0x74>)
  412836:	4604      	mov	r4, r0
  412838:	1833      	adds	r3, r6, r0
  41283a:	009b      	lsls	r3, r3, #2
  41283c:	18ea      	adds	r2, r5, r3
  41283e:	6852      	ldr	r2, [r2, #4]
  412840:	2a00      	cmp	r2, #0
  412842:	db09      	blt.n	412858 <sph_faults_setfault+0x2c>
		{
			//fault not set, so set it.
			if (sph_faults[fault_index].fault_type == STOP_IMMEDIATE)
  412844:	5ceb      	ldrb	r3, [r5, r3]
  412846:	b983      	cbnz	r3, 41286a <sph_faults_setfault+0x3e>
			{
				//no timeout fault
				if(sph_faults[fault_index].fault_counter == 0) sph_faults_stop_i++;	
  412848:	b91a      	cbnz	r2, 412852 <sph_faults_setfault+0x26>
  41284a:	4a16      	ldr	r2, [pc, #88]	; (4128a4 <sph_faults_setfault+0x78>)
  41284c:	6813      	ldr	r3, [r2, #0]
  41284e:	3301      	adds	r3, #1
  412850:	6013      	str	r3, [r2, #0]
			}
			else if (sph_faults[fault_index].fault_type == T_POS_FAULT)
			{
				if(sph_faults[fault_index].fault_counter == 0) sph_faults_pos_to++;
			}
			fault_history_setFault(fault_index);
  412852:	b2e0      	uxtb	r0, r4
  412854:	4b14      	ldr	r3, [pc, #80]	; (4128a8 <sph_faults_setfault+0x7c>)
  412856:	4798      	blx	r3
		}
		sph_faults[fault_index].fault_counter = sph_faults[fault_index].fault_timeout | 0x80000000;
  412858:	4434      	add	r4, r6
  41285a:	eb05 0484 	add.w	r4, r5, r4, lsl #2
  41285e:	68a3      	ldr	r3, [r4, #8]
  412860:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  412864:	6063      	str	r3, [r4, #4]
  412866:	bd70      	pop	{r4, r5, r6, pc}
  412868:	4770      	bx	lr
			else if (sph_faults[fault_index].fault_type == POS_FAULT)
  41286a:	2b02      	cmp	r3, #2
  41286c:	d00a      	beq.n	412884 <sph_faults_setfault+0x58>
			else if (sph_faults[fault_index].fault_type == T_STOP_IMMEDIATE)
  41286e:	2b01      	cmp	r3, #1
  412870:	d00f      	beq.n	412892 <sph_faults_setfault+0x66>
				if(sph_faults[fault_index].fault_counter == 0) sph_faults_pos_to++;
  412872:	2a00      	cmp	r2, #0
  412874:	d1ed      	bne.n	412852 <sph_faults_setfault+0x26>
  412876:	2b03      	cmp	r3, #3
  412878:	d1eb      	bne.n	412852 <sph_faults_setfault+0x26>
  41287a:	4a0c      	ldr	r2, [pc, #48]	; (4128ac <sph_faults_setfault+0x80>)
  41287c:	6813      	ldr	r3, [r2, #0]
  41287e:	3301      	adds	r3, #1
  412880:	6013      	str	r3, [r2, #0]
  412882:	e7e6      	b.n	412852 <sph_faults_setfault+0x26>
				if(sph_faults[fault_index].fault_counter == 0) sph_faults_pos++;
  412884:	2a00      	cmp	r2, #0
  412886:	d1e4      	bne.n	412852 <sph_faults_setfault+0x26>
  412888:	4a09      	ldr	r2, [pc, #36]	; (4128b0 <sph_faults_setfault+0x84>)
  41288a:	6813      	ldr	r3, [r2, #0]
  41288c:	3301      	adds	r3, #1
  41288e:	6013      	str	r3, [r2, #0]
  412890:	e7df      	b.n	412852 <sph_faults_setfault+0x26>
				if(sph_faults[fault_index].fault_counter == 0) sph_faults_stop_i_to++;
  412892:	2a00      	cmp	r2, #0
  412894:	d1dd      	bne.n	412852 <sph_faults_setfault+0x26>
  412896:	4a07      	ldr	r2, [pc, #28]	; (4128b4 <sph_faults_setfault+0x88>)
  412898:	6813      	ldr	r3, [r2, #0]
  41289a:	3301      	adds	r3, #1
  41289c:	6013      	str	r3, [r2, #0]
  41289e:	e7d8      	b.n	412852 <sph_faults_setfault+0x26>
  4128a0:	20406560 	.word	0x20406560
  4128a4:	20400aa8 	.word	0x20400aa8
  4128a8:	00412ad5 	.word	0x00412ad5
  4128ac:	20400aa4 	.word	0x20400aa4
  4128b0:	20400aa0 	.word	0x20400aa0
  4128b4:	20400aac 	.word	0x20400aac

004128b8 <sph_faults_is_present>:
	}
}

uint32_t sph_faults_is_present(uint32_t fault_index)
{
	if (fault_index < SPH_FAULT_COUNT)
  4128b8:	282c      	cmp	r0, #44	; 0x2c
  4128ba:	d807      	bhi.n	4128cc <sph_faults_is_present+0x14>
	{
		
		if (sph_faults[fault_index].fault_counter & 0x80000000) return 1;
  4128bc:	4b04      	ldr	r3, [pc, #16]	; (4128d0 <sph_faults_is_present+0x18>)
  4128be:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4128c2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4128c6:	6840      	ldr	r0, [r0, #4]
  4128c8:	0fc0      	lsrs	r0, r0, #31
  4128ca:	4770      	bx	lr
  4128cc:	2000      	movs	r0, #0
	}
	return 0;
}
  4128ce:	4770      	bx	lr
  4128d0:	20406560 	.word	0x20406560

004128d4 <sph_faults_sie_check>:
uint32_t sph_faults_sie_check(void)
{
	//if there is stop imediate error return 1, else 0
	if((sph_faults_stop_i) || (sph_faults_stop_i_to)) 
  4128d4:	4b05      	ldr	r3, [pc, #20]	; (4128ec <sph_faults_sie_check+0x18>)
  4128d6:	681b      	ldr	r3, [r3, #0]
  4128d8:	b92b      	cbnz	r3, 4128e6 <sph_faults_sie_check+0x12>
  4128da:	4b05      	ldr	r3, [pc, #20]	; (4128f0 <sph_faults_sie_check+0x1c>)
  4128dc:	6818      	ldr	r0, [r3, #0]
  4128de:	3000      	adds	r0, #0
  4128e0:	bf18      	it	ne
  4128e2:	2001      	movne	r0, #1
  4128e4:	4770      	bx	lr
  4128e6:	2001      	movs	r0, #1
	{
		return 1;
	}
	else return 0;
}
  4128e8:	4770      	bx	lr
  4128ea:	bf00      	nop
  4128ec:	20400aa8 	.word	0x20400aa8
  4128f0:	20400aac 	.word	0x20400aac

004128f4 <sph_faults_get_fault_to_display>:
	else return 0;
}

uint8_t sph_faults_display_index=0;
uint32_t sph_faults_get_fault_to_display(const char **str, char *fault_prefix, char *fault_code)
{
  4128f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t i;
	if (!(sph_faults[sph_faults_display_index].fault_counter & 0x80000000) || (sph_faults_display_time_counter == 0))
  4128f6:	f8df e090 	ldr.w	lr, [pc, #144]	; 412988 <sph_faults_get_fault_to_display+0x94>
  4128fa:	4f21      	ldr	r7, [pc, #132]	; (412980 <sph_faults_get_fault_to_display+0x8c>)
  4128fc:	f89e 4000 	ldrb.w	r4, [lr]
  412900:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  412904:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  412908:	685d      	ldr	r5, [r3, #4]
  41290a:	2d00      	cmp	r5, #0
  41290c:	db31      	blt.n	412972 <sph_faults_get_fault_to_display+0x7e>
  41290e:	252d      	movs	r5, #45	; 0x2d
  412910:	e001      	b.n	412916 <sph_faults_get_fault_to_display+0x22>
	{
		//there is no fault here, or display timed-out
		for(i=0; i<SPH_FAULT_COUNT; i++)
  412912:	3d01      	subs	r5, #1
  412914:	d029      	beq.n	41296a <sph_faults_get_fault_to_display+0x76>
		{
			if(++sph_faults_display_index >= SPH_FAULT_COUNT) sph_faults_display_index=0;
  412916:	3401      	adds	r4, #1
  412918:	b2e4      	uxtb	r4, r4
  41291a:	2c2c      	cmp	r4, #44	; 0x2c
  41291c:	4623      	mov	r3, r4
  41291e:	d901      	bls.n	412924 <sph_faults_get_fault_to_display+0x30>
  412920:	2400      	movs	r4, #0
  412922:	4623      	mov	r3, r4
			if (sph_faults[sph_faults_display_index].fault_counter & 0x80000000)
  412924:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  412928:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  41292c:	685e      	ldr	r6, [r3, #4]
  41292e:	2e00      	cmp	r6, #0
  412930:	daef      	bge.n	412912 <sph_faults_get_fault_to_display+0x1e>
			{
				//a fault found to display
				sph_faults_display_time_counter = SPH_FAULT_DISPLAY_TIMEOUT;
  412932:	f640 3cb8 	movw	ip, #3000	; 0xbb8
  412936:	4e13      	ldr	r6, [pc, #76]	; (412984 <sph_faults_get_fault_to_display+0x90>)
				*str = sph_faults[sph_faults_display_index].e_string;
  412938:	691b      	ldr	r3, [r3, #16]
				*fault_code = sph_faults[sph_faults_display_index].fault_code;
				*fault_prefix = sph_faults[sph_faults_display_index].fault_prefix;
				return 1;
  41293a:	2501      	movs	r5, #1
  41293c:	f88e 4000 	strb.w	r4, [lr]
				sph_faults_display_time_counter = SPH_FAULT_DISPLAY_TIMEOUT;
  412940:	f8c6 c000 	str.w	ip, [r6]
		}
	}
	else
	{
		// the fault is still there to display
		*str = sph_faults[sph_faults_display_index].e_string;
  412944:	6003      	str	r3, [r0, #0]
		*fault_code = sph_faults[sph_faults_display_index].fault_code;
		*fault_prefix = sph_faults[sph_faults_display_index].fault_prefix;		
		return 1;
	}
	return 0;	
}
  412946:	4628      	mov	r0, r5
		*fault_code = sph_faults[sph_faults_display_index].fault_code;
  412948:	f89e 3000 	ldrb.w	r3, [lr]
  41294c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  412950:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  412954:	7b5b      	ldrb	r3, [r3, #13]
  412956:	7013      	strb	r3, [r2, #0]
		*fault_prefix = sph_faults[sph_faults_display_index].fault_prefix;		
  412958:	f89e 3000 	ldrb.w	r3, [lr]
  41295c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  412960:	eb07 0783 	add.w	r7, r7, r3, lsl #2
  412964:	7b3b      	ldrb	r3, [r7, #12]
  412966:	700b      	strb	r3, [r1, #0]
}
  412968:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41296a:	f88e 4000 	strb.w	r4, [lr]
  41296e:	4628      	mov	r0, r5
  412970:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!(sph_faults[sph_faults_display_index].fault_counter & 0x80000000) || (sph_faults_display_time_counter == 0))
  412972:	4d04      	ldr	r5, [pc, #16]	; (412984 <sph_faults_get_fault_to_display+0x90>)
  412974:	682d      	ldr	r5, [r5, #0]
  412976:	2d00      	cmp	r5, #0
  412978:	d0c9      	beq.n	41290e <sph_faults_get_fault_to_display+0x1a>
		*str = sph_faults[sph_faults_display_index].e_string;
  41297a:	691b      	ldr	r3, [r3, #16]
		return 1;
  41297c:	2501      	movs	r5, #1
  41297e:	e7e1      	b.n	412944 <sph_faults_get_fault_to_display+0x50>
  412980:	20406560 	.word	0x20406560
  412984:	20400a9c 	.word	0x20400a9c
  412988:	20400a98 	.word	0x20400a98

0041298c <sph_faults_get_fault_string>:

const char *sph_faults_get_fault_string(uint8_t fault_id)
{
	if (fault_id < SPH_FAULT_COUNT)
  41298c:	282c      	cmp	r0, #44	; 0x2c
  41298e:	d806      	bhi.n	41299e <sph_faults_get_fault_string+0x12>
	{
		return sph_faults[fault_id].e_string;
  412990:	4b04      	ldr	r3, [pc, #16]	; (4129a4 <sph_faults_get_fault_string+0x18>)
  412992:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  412996:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  41299a:	6900      	ldr	r0, [r0, #16]
  41299c:	4770      	bx	lr
	} 
	else
	{
		return "";
  41299e:	4802      	ldr	r0, [pc, #8]	; (4129a8 <sph_faults_get_fault_string+0x1c>)
	}
}
  4129a0:	4770      	bx	lr
  4129a2:	bf00      	nop
  4129a4:	20406560 	.word	0x20406560
  4129a8:	0041b014 	.word	0x0041b014

004129ac <dont_record_fault>:
	if((sph_faults_stop_i) || (sph_faults_stop_i_to)) 
  4129ac:	4b08      	ldr	r3, [pc, #32]	; (4129d0 <dont_record_fault+0x24>)
  4129ae:	681b      	ldr	r3, [r3, #0]
  4129b0:	b92b      	cbnz	r3, 4129be <dont_record_fault+0x12>
  4129b2:	4b08      	ldr	r3, [pc, #32]	; (4129d4 <dont_record_fault+0x28>)
  4129b4:	681b      	ldr	r3, [r3, #0]
  4129b6:	b913      	cbnz	r3, 4129be <dont_record_fault+0x12>
	if((sph_faults_pos) || (sph_faults_pos_to))
  4129b8:	4b07      	ldr	r3, [pc, #28]	; (4129d8 <dont_record_fault+0x2c>)
  4129ba:	681b      	ldr	r3, [r3, #0]
  4129bc:	b10b      	cbz	r3, 4129c2 <dont_record_fault+0x16>
{
	// function return 0 if there's something inhibit service call
	if(sph_faults_sie_check())
	return 1;
	if(sph_faults_pose_check())
	return 1;
  4129be:	2001      	movs	r0, #1
  4129c0:	4770      	bx	lr
	if((sph_faults_pos) || (sph_faults_pos_to))
  4129c2:	4b06      	ldr	r3, [pc, #24]	; (4129dc <dont_record_fault+0x30>)
  4129c4:	6818      	ldr	r0, [r3, #0]
	
	return 0;
  4129c6:	3000      	adds	r0, #0
  4129c8:	bf18      	it	ne
  4129ca:	2001      	movne	r0, #1
  4129cc:	4770      	bx	lr
  4129ce:	bf00      	nop
  4129d0:	20400aa8 	.word	0x20400aa8
  4129d4:	20400aac 	.word	0x20400aac
  4129d8:	20400aa0 	.word	0x20400aa0
  4129dc:	20400aa4 	.word	0x20400aa4

004129e0 <fault_history_init>:

fault_history_t faults_history_list[SPH_FAULT_COUNT];
uint8_t fault_history_newDataFlag[SPH_FAULT_COUNT];
uint32_t fault_history_entry_pointer;
void fault_history_init()
{
  4129e0:	b470      	push	{r4, r5, r6}
  4129e2:	4a0b      	ldr	r2, [pc, #44]	; (412a10 <fault_history_init+0x30>)
	uint32_t i;
	fault_history_entry_pointer = 0xFF;
  4129e4:	25ff      	movs	r5, #255	; 0xff
  4129e6:	4e0b      	ldr	r6, [pc, #44]	; (412a14 <fault_history_init+0x34>)
	for (i=0; i<SPH_FAULT_COUNT; i++)
	{
		//set newDataFlag to 0;
		fault_history_newDataFlag[i] = 0;
  4129e8:	2000      	movs	r0, #0
		faults_history_list[i].next_f_ptr = 0xFF; //set pointer to null
  4129ea:	4629      	mov	r1, r5
  4129ec:	f102 042d 	add.w	r4, r2, #45	; 0x2d
  4129f0:	4b09      	ldr	r3, [pc, #36]	; (412a18 <fault_history_init+0x38>)
	fault_history_entry_pointer = 0xFF;
  4129f2:	6035      	str	r5, [r6, #0]
		fault_history_newDataFlag[i] = 0;
  4129f4:	f802 0f01 	strb.w	r0, [r2, #1]!
	for (i=0; i<SPH_FAULT_COUNT; i++)
  4129f8:	42a2      	cmp	r2, r4
		faults_history_list[i].next_f_ptr = 0xFF; //set pointer to null
  4129fa:	7019      	strb	r1, [r3, #0]
  4129fc:	f103 0314 	add.w	r3, r3, #20
		faults_history_list[i].prev_f_ptr = 0xFF; //set pointer to null
  412a00:	f803 1c13 	strb.w	r1, [r3, #-19]
		faults_history_list[i].occurance_count = 0; //set count to zero
  412a04:	f823 0c0c 	strh.w	r0, [r3, #-12]
	for (i=0; i<SPH_FAULT_COUNT; i++)
  412a08:	d1f4      	bne.n	4129f4 <fault_history_init+0x14>
	}
}
  412a0a:	bc70      	pop	{r4, r5, r6}
  412a0c:	4770      	bx	lr
  412a0e:	bf00      	nop
  412a10:	204068e3 	.word	0x204068e3
  412a14:	20406c98 	.word	0x20406c98
  412a18:	20406914 	.word	0x20406914

00412a1c <fault_history_saveAll>:
		faults_history_list[i].occurance_count = 0;
	}
}

void fault_history_saveAll()
{
  412a1c:	4b0c      	ldr	r3, [pc, #48]	; (412a50 <fault_history_saveAll+0x34>)
	uint32_t i;
	//return;
	for (i=0; i<SPH_FAULT_COUNT; i++)
	{
		//set newDataFlag to 0;
		fault_history_newDataFlag[i] = 0;
  412a1e:	2100      	movs	r1, #0
  412a20:	f103 022d 	add.w	r2, r3, #45	; 0x2d
{
  412a24:	b510      	push	{r4, lr}
		fault_history_newDataFlag[i] = 0;
  412a26:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (i=0; i<SPH_FAULT_COUNT; i++)
  412a2a:	4293      	cmp	r3, r2
  412a2c:	d1fb      	bne.n	412a26 <fault_history_saveAll+0xa>
	}
	//save fault history to EEPROM
	at24cxx_dynamic_sch_write_array(0, EEPROM_MEN_SAVE_END_ADD, sizeof(fault_history_entry_pointer), &fault_history_entry_pointer);
  412a2e:	4c09      	ldr	r4, [pc, #36]	; (412a54 <fault_history_saveAll+0x38>)
  412a30:	2204      	movs	r2, #4
  412a32:	4b09      	ldr	r3, [pc, #36]	; (412a58 <fault_history_saveAll+0x3c>)
  412a34:	f240 3175 	movw	r1, #885	; 0x375
  412a38:	2000      	movs	r0, #0
  412a3a:	47a0      	blx	r4
	at24cxx_dynamic_sch_write_array(0, EEPROM_MEN_SAVE_END_ADD + sizeof(fault_history_entry_pointer), sizeof(fault_history_t) * SPH_FAULT_COUNT, faults_history_list);
  412a3c:	46a4      	mov	ip, r4
  412a3e:	4b07      	ldr	r3, [pc, #28]	; (412a5c <fault_history_saveAll+0x40>)
  412a40:	f44f 7261 	mov.w	r2, #900	; 0x384
  412a44:	f240 3179 	movw	r1, #889	; 0x379
  412a48:	2000      	movs	r0, #0
}
  412a4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	at24cxx_dynamic_sch_write_array(0, EEPROM_MEN_SAVE_END_ADD + sizeof(fault_history_entry_pointer), sizeof(fault_history_t) * SPH_FAULT_COUNT, faults_history_list);
  412a4e:	4760      	bx	ip
  412a50:	204068e3 	.word	0x204068e3
  412a54:	0040ac1d 	.word	0x0040ac1d
  412a58:	20406c98 	.word	0x20406c98
  412a5c:	20406914 	.word	0x20406914

00412a60 <fault_history_eraseAndSaveAll>:

void fault_history_eraseAndSaveAll()
{
  412a60:	b4f0      	push	{r4, r5, r6, r7}
  412a62:	4a0c      	ldr	r2, [pc, #48]	; (412a94 <fault_history_eraseAndSaveAll+0x34>)
	fault_history_entry_pointer = 0xFF;
  412a64:	26ff      	movs	r6, #255	; 0xff
  412a66:	4f0c      	ldr	r7, [pc, #48]	; (412a98 <fault_history_eraseAndSaveAll+0x38>)
		fault_history_newDataFlag[i] = 1;
  412a68:	2501      	movs	r5, #1
		faults_history_list[i].next_f_ptr = 0xFF; //set pointer to null
  412a6a:	4631      	mov	r1, r6
  412a6c:	f102 042d 	add.w	r4, r2, #45	; 0x2d
  412a70:	4b0a      	ldr	r3, [pc, #40]	; (412a9c <fault_history_eraseAndSaveAll+0x3c>)
		faults_history_list[i].occurance_count = 0;
  412a72:	2000      	movs	r0, #0
	fault_history_entry_pointer = 0xFF;
  412a74:	603e      	str	r6, [r7, #0]
		fault_history_newDataFlag[i] = 1;
  412a76:	f802 5f01 	strb.w	r5, [r2, #1]!
	for (i=0; i<SPH_FAULT_COUNT; i++)
  412a7a:	42a2      	cmp	r2, r4
		faults_history_list[i].next_f_ptr = 0xFF; //set pointer to null
  412a7c:	7019      	strb	r1, [r3, #0]
  412a7e:	f103 0314 	add.w	r3, r3, #20
		faults_history_list[i].prev_f_ptr = 0xFF; //set pointer to null
  412a82:	f803 1c13 	strb.w	r1, [r3, #-19]
		faults_history_list[i].occurance_count = 0;
  412a86:	f823 0c0c 	strh.w	r0, [r3, #-12]
	for (i=0; i<SPH_FAULT_COUNT; i++)
  412a8a:	d1f4      	bne.n	412a76 <fault_history_eraseAndSaveAll+0x16>
	fault_history_eraseAll();
	fault_history_saveAll();
  412a8c:	4b04      	ldr	r3, [pc, #16]	; (412aa0 <fault_history_eraseAndSaveAll+0x40>)
}
  412a8e:	bcf0      	pop	{r4, r5, r6, r7}
	fault_history_saveAll();
  412a90:	4718      	bx	r3
  412a92:	bf00      	nop
  412a94:	204068e3 	.word	0x204068e3
  412a98:	20406c98 	.word	0x20406c98
  412a9c:	20406914 	.word	0x20406914
  412aa0:	00412a1d 	.word	0x00412a1d

00412aa4 <fault_history_loadAll>:

void fault_history_loadAll()
{
  412aa4:	b510      	push	{r4, lr}
	//load fault history to RAM
 	at24cxx_dynamic_sch_read_array(0, EEPROM_MEN_SAVE_END_ADD, sizeof(fault_history_entry_pointer), &fault_history_entry_pointer);
  412aa6:	4c08      	ldr	r4, [pc, #32]	; (412ac8 <fault_history_loadAll+0x24>)
  412aa8:	2204      	movs	r2, #4
  412aaa:	4b08      	ldr	r3, [pc, #32]	; (412acc <fault_history_loadAll+0x28>)
  412aac:	f240 3175 	movw	r1, #885	; 0x375
  412ab0:	2000      	movs	r0, #0
  412ab2:	47a0      	blx	r4
 	at24cxx_dynamic_sch_read_array(0, EEPROM_MEN_SAVE_END_ADD + sizeof(fault_history_entry_pointer), sizeof(fault_history_t) * SPH_FAULT_COUNT, faults_history_list);
  412ab4:	46a4      	mov	ip, r4
  412ab6:	4b06      	ldr	r3, [pc, #24]	; (412ad0 <fault_history_loadAll+0x2c>)
  412ab8:	f44f 7261 	mov.w	r2, #900	; 0x384
  412abc:	f240 3179 	movw	r1, #889	; 0x379
  412ac0:	2000      	movs	r0, #0
}
  412ac2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 	at24cxx_dynamic_sch_read_array(0, EEPROM_MEN_SAVE_END_ADD + sizeof(fault_history_entry_pointer), sizeof(fault_history_t) * SPH_FAULT_COUNT, faults_history_list);
  412ac6:	4760      	bx	ip
  412ac8:	0040ac6d 	.word	0x0040ac6d
  412acc:	20406c98 	.word	0x20406c98
  412ad0:	20406914 	.word	0x20406914

00412ad4 <fault_history_setFault>:

void fault_history_setFault(uint8_t faultId)
{
	uint32_t year, month, day, hour, minute;
	if (faultId < SPH_FAULT_COUNT)
  412ad4:	282c      	cmp	r0, #44	; 0x2c
  412ad6:	d87e      	bhi.n	412bd6 <fault_history_setFault+0x102>
	{
		//we are within the faults range
		
		if (faultId != fault_history_entry_pointer)
  412ad8:	4946      	ldr	r1, [pc, #280]	; (412bf4 <fault_history_setFault+0x120>)
{
  412ada:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		if (faultId != fault_history_entry_pointer)
  412ade:	680b      	ldr	r3, [r1, #0]
{
  412ae0:	b089      	sub	sp, #36	; 0x24
		if (faultId != fault_history_entry_pointer)
  412ae2:	4298      	cmp	r0, r3
  412ae4:	d07c      	beq.n	412be0 <fault_history_setFault+0x10c>
		{
			//faultId != entry fult pointer
			if (faults_history_list[faultId].prev_f_ptr < SPH_FAULT_COUNT)
  412ae6:	0087      	lsls	r7, r0, #2
  412ae8:	4c43      	ldr	r4, [pc, #268]	; (412bf8 <fault_history_setFault+0x124>)
  412aea:	183a      	adds	r2, r7, r0
  412aec:	0092      	lsls	r2, r2, #2
  412aee:	18a5      	adds	r5, r4, r2
  412af0:	786d      	ldrb	r5, [r5, #1]
  412af2:	2d2c      	cmp	r5, #44	; 0x2c
  412af4:	d804      	bhi.n	412b00 <fault_history_setFault+0x2c>
			{
				//this fault points to another chained fault
				//so set it's next fault pointer to this fault's next pointer
				faults_history_list[faults_history_list[faultId].prev_f_ptr].next_f_ptr = faults_history_list[faultId].next_f_ptr;
  412af6:	5ca6      	ldrb	r6, [r4, r2]
  412af8:	eb05 0285 	add.w	r2, r5, r5, lsl #2
  412afc:	f804 6022 	strb.w	r6, [r4, r2, lsl #2]
			}
		
			if (faults_history_list[faultId].next_f_ptr < SPH_FAULT_COUNT)
  412b00:	183a      	adds	r2, r7, r0
  412b02:	f814 2022 	ldrb.w	r2, [r4, r2, lsl #2]
  412b06:	2a2c      	cmp	r2, #44	; 0x2c
  412b08:	d804      	bhi.n	412b14 <fault_history_setFault+0x40>
			{
				//this fault points to another chained fault
				//so set it's prev fault pointer to this fauilt's prev pointer
				faults_history_list[faults_history_list[faultId].next_f_ptr].prev_f_ptr = faults_history_list[faultId].prev_f_ptr;
  412b0a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  412b0e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  412b12:	7055      	strb	r5, [r2, #1]
			}
			//set faultId.pointer to point to entrypointer
			faults_history_list[faultId].next_f_ptr = fault_history_entry_pointer;
  412b14:	183a      	adds	r2, r7, r0
			faults_history_list[faultId].prev_f_ptr = 0xFF;
  412b16:	26ff      	movs	r6, #255	; 0xff
			if (fault_history_entry_pointer < SPH_FAULT_COUNT)
  412b18:	2b2c      	cmp	r3, #44	; 0x2c
			faults_history_list[faultId].next_f_ptr = fault_history_entry_pointer;
  412b1a:	ea4f 0282 	mov.w	r2, r2, lsl #2
  412b1e:	eb04 0502 	add.w	r5, r4, r2
  412b22:	54a3      	strb	r3, [r4, r2]
			faults_history_list[faultId].prev_f_ptr = 0xFF;
  412b24:	706e      	strb	r6, [r5, #1]
			if (fault_history_entry_pointer < SPH_FAULT_COUNT)
  412b26:	d804      	bhi.n	412b32 <fault_history_setFault+0x5e>
			{
				//set fault_history_entry_pointer.pointer to point to faultId
				faults_history_list[fault_history_entry_pointer].prev_f_ptr = faultId;
  412b28:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  412b2c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  412b30:	7058      	strb	r0, [r3, #1]
			}
		
			//set faultId.prevPointer to point to Null
			faults_history_list[faultId].prev_f_ptr = 0xFF;
  412b32:	183b      	adds	r3, r7, r0
  412b34:	22ff      	movs	r2, #255	; 0xff
			//set entrypoint to point to faultId
			fault_history_entry_pointer = faultId;
  412b36:	6008      	str	r0, [r1, #0]
			faults_history_list[faultId].prev_f_ptr = 0xFF;
  412b38:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  412b3c:	705a      	strb	r2, [r3, #1]
		}

		
		if (faults_history_list[faultId].next_f_ptr == faultId)
  412b3e:	183b      	adds	r3, r7, r0
  412b40:	009b      	lsls	r3, r3, #2
  412b42:	5ce2      	ldrb	r2, [r4, r3]
  412b44:	4282      	cmp	r2, r0
  412b46:	d052      	beq.n	412bee <fault_history_setFault+0x11a>
		} 
		
		
		
		//increment faultId.ocurrance count
		faults_history_list[faultId].occurance_count++;
  412b48:	183e      	adds	r6, r7, r0
		
		// save last occurance time and date
		rtc_get_date(RTC, &year, &month, &day, 0);
  412b4a:	f04f 0800 	mov.w	r8, #0
  412b4e:	ab05      	add	r3, sp, #20
  412b50:	aa04      	add	r2, sp, #16
		faults_history_list[faultId].occurance_count++;
  412b52:	eb04 0686 	add.w	r6, r4, r6, lsl #2
		rtc_get_date(RTC, &year, &month, &day, 0);
  412b56:	f8cd 8000 	str.w	r8, [sp]
  412b5a:	a903      	add	r1, sp, #12
  412b5c:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 412c14 <fault_history_setFault+0x140>
		faults_history_list[faultId].occurance_count++;
  412b60:	f8b6 e008 	ldrh.w	lr, [r6, #8]
  412b64:	4605      	mov	r5, r0
		rtc_get_date(RTC, &year, &month, &day, 0);
  412b66:	4825      	ldr	r0, [pc, #148]	; (412bfc <fault_history_setFault+0x128>)
		faults_history_list[faultId].occurance_count++;
  412b68:	f10e 0e01 	add.w	lr, lr, #1
  412b6c:	f8a6 e008 	strh.w	lr, [r6, #8]
		rtc_get_date(RTC, &year, &month, &day, 0);
  412b70:	47c8      	blx	r9
		rtc_get_time(RTC, &hour, &minute, 0);
  412b72:	4643      	mov	r3, r8
  412b74:	aa07      	add	r2, sp, #28
  412b76:	a906      	add	r1, sp, #24
  412b78:	4820      	ldr	r0, [pc, #128]	; (412bfc <fault_history_setFault+0x128>)
  412b7a:	f8df 909c 	ldr.w	r9, [pc, #156]	; 412c18 <fault_history_setFault+0x144>
  412b7e:	47c8      	blx	r9
		faults_history_list[faultId].f_day = day;
		faults_history_list[faultId].f_month = month;
		faults_history_list[faultId].f_hour = hour;
  412b80:	9a06      	ldr	r2, [sp, #24]
		faults_history_list[faultId].f_minute = minute;
		if (year > 2012) year -= 2012;
  412b82:	f240 7cdc 	movw	ip, #2012	; 0x7dc
  412b86:	9b03      	ldr	r3, [sp, #12]
		faults_history_list[faultId].f_day = day;
  412b88:	9805      	ldr	r0, [sp, #20]
		faults_history_list[faultId].f_month = month;
  412b8a:	9904      	ldr	r1, [sp, #16]
		if (year > 2012) year -= 2012;
  412b8c:	4563      	cmp	r3, ip
		faults_history_list[faultId].f_hour = hour;
  412b8e:	70f2      	strb	r2, [r6, #3]
		faults_history_list[faultId].f_minute = minute;
  412b90:	f89d 201c 	ldrb.w	r2, [sp, #28]
		faults_history_list[faultId].f_day = day;
  412b94:	7130      	strb	r0, [r6, #4]
		faults_history_list[faultId].f_month = month;
  412b96:	7171      	strb	r1, [r6, #5]
		faults_history_list[faultId].f_minute = minute;
  412b98:	70b2      	strb	r2, [r6, #2]
		if (year > 2012) year -= 2012;
  412b9a:	d91d      	bls.n	412bd8 <fault_history_setFault+0x104>
  412b9c:	f2a3 73dc 	subw	r3, r3, #2012	; 0x7dc
  412ba0:	fa5f fe83 	uxtb.w	lr, r3
  412ba4:	9303      	str	r3, [sp, #12]
		else year = 0;
		faults_history_list[faultId].f_year = year;
  412ba6:	1978      	adds	r0, r7, r5
		faults_history_list[faultId].floor = get_current_floor() & 0x7F;
  412ba8:	4b15      	ldr	r3, [pc, #84]	; (412c00 <fault_history_setFault+0x12c>)
		faults_history_list[faultId].f_year = year;
  412baa:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  412bae:	f884 e006 	strb.w	lr, [r4, #6]
		faults_history_list[faultId].floor = get_current_floor() & 0x7F;
  412bb2:	4798      	blx	r3
  412bb4:	f000 007f 	and.w	r0, r0, #127	; 0x7f
		if(mstop == 0) faults_history_list[faultId].floor |= 0x80;
		faults_history_list[faultId].states = vfdstates_get_d_state();
  412bb8:	4b12      	ldr	r3, [pc, #72]	; (412c04 <fault_history_setFault+0x130>)
		faults_history_list[faultId].floor = get_current_floor() & 0x7F;
  412bba:	72e0      	strb	r0, [r4, #11]
		faults_history_list[faultId].states = vfdstates_get_d_state();
  412bbc:	4798      	blx	r3
		faults_history_list[faultId].id = cid;
  412bbe:	4a12      	ldr	r2, [pc, #72]	; (412c08 <fault_history_setFault+0x134>)
		faults_history_list[faultId].iq = ciq;
  412bc0:	4b12      	ldr	r3, [pc, #72]	; (412c0c <fault_history_setFault+0x138>)
		faults_history_list[faultId].id = cid;
  412bc2:	6811      	ldr	r1, [r2, #0]
		faults_history_list[faultId].iq = ciq;
  412bc4:	681a      	ldr	r2, [r3, #0]
		fault_history_saveAll();
  412bc6:	4b12      	ldr	r3, [pc, #72]	; (412c10 <fault_history_setFault+0x13c>)
		faults_history_list[faultId].states = vfdstates_get_d_state();
  412bc8:	72a0      	strb	r0, [r4, #10]
		faults_history_list[faultId].id = cid;
  412bca:	60e1      	str	r1, [r4, #12]
		faults_history_list[faultId].iq = ciq;
  412bcc:	6122      	str	r2, [r4, #16]
		fault_history_saveAll();
  412bce:	4798      	blx	r3
	}
}
  412bd0:	b009      	add	sp, #36	; 0x24
  412bd2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  412bd6:	4770      	bx	lr
		else year = 0;
  412bd8:	46c6      	mov	lr, r8
  412bda:	f8cd 800c 	str.w	r8, [sp, #12]
  412bde:	e7e2      	b.n	412ba6 <fault_history_setFault+0xd2>
  412be0:	0087      	lsls	r7, r0, #2
  412be2:	4c05      	ldr	r4, [pc, #20]	; (412bf8 <fault_history_setFault+0x124>)
		if (faults_history_list[faultId].next_f_ptr == faultId)
  412be4:	183b      	adds	r3, r7, r0
  412be6:	009b      	lsls	r3, r3, #2
  412be8:	5ce2      	ldrb	r2, [r4, r3]
  412bea:	4282      	cmp	r2, r0
  412bec:	d1ac      	bne.n	412b48 <fault_history_setFault+0x74>
			faults_history_list[faultId].next_f_ptr = 0xFF;
  412bee:	22ff      	movs	r2, #255	; 0xff
  412bf0:	54e2      	strb	r2, [r4, r3]
  412bf2:	e7a9      	b.n	412b48 <fault_history_setFault+0x74>
  412bf4:	20406c98 	.word	0x20406c98
  412bf8:	20406914 	.word	0x20406914
  412bfc:	400e1860 	.word	0x400e1860
  412c00:	00400e15 	.word	0x00400e15
  412c04:	004162a5 	.word	0x004162a5
  412c08:	2040655c 	.word	0x2040655c
  412c0c:	20406554 	.word	0x20406554
  412c10:	00412a1d 	.word	0x00412a1d
  412c14:	00400611 	.word	0x00400611
  412c18:	004005b9 	.word	0x004005b9

00412c1c <get_first_fault>:

uint8_t current_fault_view;
fault_history_t *get_first_fault(uint8_t *fault_ptr, uint8_t *fault_indx)
{
  412c1c:	b430      	push	{r4, r5}
	current_fault_view = 0xff;
  412c1e:	4a0b      	ldr	r2, [pc, #44]	; (412c4c <get_first_fault+0x30>)
  412c20:	25ff      	movs	r5, #255	; 0xff
	*fault_indx = 0;
  412c22:	2300      	movs	r3, #0
	if (fault_history_entry_pointer >= SPH_FAULT_COUNT)
  412c24:	4c0a      	ldr	r4, [pc, #40]	; (412c50 <get_first_fault+0x34>)
	current_fault_view = 0xff;
  412c26:	7015      	strb	r5, [r2, #0]
	*fault_indx = 0;
  412c28:	700b      	strb	r3, [r1, #0]
	if (fault_history_entry_pointer >= SPH_FAULT_COUNT)
  412c2a:	6821      	ldr	r1, [r4, #0]
  412c2c:	292c      	cmp	r1, #44	; 0x2c
  412c2e:	d80a      	bhi.n	412c46 <get_first_fault+0x2a>
	{
		return 0;
	} 
	else
	{
		*fault_ptr = fault_history_entry_pointer;
  412c30:	7001      	strb	r1, [r0, #0]
		current_fault_view = fault_history_entry_pointer;
  412c32:	6821      	ldr	r1, [r4, #0]
		return &faults_history_list[current_fault_view];
  412c34:	4807      	ldr	r0, [pc, #28]	; (412c54 <get_first_fault+0x38>)
  412c36:	b2cb      	uxtb	r3, r1
		current_fault_view = fault_history_entry_pointer;
  412c38:	7011      	strb	r1, [r2, #0]
		return &faults_history_list[current_fault_view];
  412c3a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	}
}
  412c3e:	bc30      	pop	{r4, r5}
		return &faults_history_list[current_fault_view];
  412c40:	eb00 0083 	add.w	r0, r0, r3, lsl #2
}
  412c44:	4770      	bx	lr
		return 0;
  412c46:	4618      	mov	r0, r3
}
  412c48:	bc30      	pop	{r4, r5}
  412c4a:	4770      	bx	lr
  412c4c:	20406c9c 	.word	0x20406c9c
  412c50:	20406c98 	.word	0x20406c98
  412c54:	20406914 	.word	0x20406914

00412c58 <get_next_fault>:

fault_history_t *get_next_fault(uint8_t *fault_ptr, uint8_t *fault_indx)
{
  412c58:	b430      	push	{r4, r5}
	if (current_fault_view >= SPH_FAULT_COUNT)
  412c5a:	4c12      	ldr	r4, [pc, #72]	; (412ca4 <get_next_fault+0x4c>)
  412c5c:	7822      	ldrb	r2, [r4, #0]
  412c5e:	2a2c      	cmp	r2, #44	; 0x2c
  412c60:	d81d      	bhi.n	412c9e <get_next_fault+0x46>
	{
		return 0;
	}
	else
	{
		if (faults_history_list[current_fault_view].next_f_ptr >= SPH_FAULT_COUNT)
  412c62:	4b11      	ldr	r3, [pc, #68]	; (412ca8 <get_next_fault+0x50>)
  412c64:	eb02 0582 	add.w	r5, r2, r2, lsl #2
  412c68:	f813 5025 	ldrb.w	r5, [r3, r5, lsl #2]
  412c6c:	2d2c      	cmp	r5, #44	; 0x2c
  412c6e:	d810      	bhi.n	412c92 <get_next_fault+0x3a>
		{
			// no next fault to view
			return &faults_history_list[current_fault_view];
		}
		(*fault_indx)++;
  412c70:	780a      	ldrb	r2, [r1, #0]
  412c72:	3201      	adds	r2, #1
  412c74:	700a      	strb	r2, [r1, #0]
		current_fault_view = faults_history_list[current_fault_view].next_f_ptr;
  412c76:	7822      	ldrb	r2, [r4, #0]
  412c78:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  412c7c:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
  412c80:	7022      	strb	r2, [r4, #0]
		*fault_ptr = current_fault_view;
  412c82:	7002      	strb	r2, [r0, #0]
		return &faults_history_list[current_fault_view];
  412c84:	7820      	ldrb	r0, [r4, #0]
  412c86:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	}
}
  412c8a:	bc30      	pop	{r4, r5}
		return &faults_history_list[current_fault_view];
  412c8c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
}
  412c90:	4770      	bx	lr
			return &faults_history_list[current_fault_view];
  412c92:	eb02 0282 	add.w	r2, r2, r2, lsl #2
}
  412c96:	bc30      	pop	{r4, r5}
			return &faults_history_list[current_fault_view];
  412c98:	eb03 0082 	add.w	r0, r3, r2, lsl #2
}
  412c9c:	4770      	bx	lr
		return 0;
  412c9e:	2000      	movs	r0, #0
}
  412ca0:	bc30      	pop	{r4, r5}
  412ca2:	4770      	bx	lr
  412ca4:	20406c9c 	.word	0x20406c9c
  412ca8:	20406914 	.word	0x20406914

00412cac <get_previous_fault>:

fault_history_t *get_previous_fault(uint8_t *fault_ptr, uint8_t *fault_indx)
{
  412cac:	b430      	push	{r4, r5}
	if (current_fault_view >= SPH_FAULT_COUNT)
  412cae:	4d14      	ldr	r5, [pc, #80]	; (412d00 <get_previous_fault+0x54>)
  412cb0:	782b      	ldrb	r3, [r5, #0]
  412cb2:	2b2c      	cmp	r3, #44	; 0x2c
  412cb4:	d821      	bhi.n	412cfa <get_previous_fault+0x4e>
	{
		return 0;
	}
	else
	{
		if (faults_history_list[current_fault_view].prev_f_ptr >= SPH_FAULT_COUNT)
  412cb6:	4a13      	ldr	r2, [pc, #76]	; (412d04 <get_previous_fault+0x58>)
  412cb8:	eb03 0483 	add.w	r4, r3, r3, lsl #2
  412cbc:	eb02 0484 	add.w	r4, r2, r4, lsl #2
  412cc0:	7864      	ldrb	r4, [r4, #1]
  412cc2:	2c2c      	cmp	r4, #44	; 0x2c
  412cc4:	d813      	bhi.n	412cee <get_previous_fault+0x42>
		{
			// no next fault to view
			return &faults_history_list[current_fault_view];
		}
		if(*fault_indx > 0) (*fault_indx)--;
  412cc6:	780b      	ldrb	r3, [r1, #0]
  412cc8:	b943      	cbnz	r3, 412cdc <get_previous_fault+0x30>
		current_fault_view = faults_history_list[current_fault_view].prev_f_ptr;
  412cca:	702c      	strb	r4, [r5, #0]
		*fault_ptr = current_fault_view;
  412ccc:	7004      	strb	r4, [r0, #0]
		return &faults_history_list[current_fault_view];
  412cce:	7828      	ldrb	r0, [r5, #0]
  412cd0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	}
  412cd4:	bc30      	pop	{r4, r5}
		return &faults_history_list[current_fault_view];
  412cd6:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  412cda:	4770      	bx	lr
		if(*fault_indx > 0) (*fault_indx)--;
  412cdc:	3b01      	subs	r3, #1
  412cde:	700b      	strb	r3, [r1, #0]
  412ce0:	782b      	ldrb	r3, [r5, #0]
  412ce2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  412ce6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  412cea:	785c      	ldrb	r4, [r3, #1]
  412cec:	e7ed      	b.n	412cca <get_previous_fault+0x1e>
			return &faults_history_list[current_fault_view];
  412cee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  412cf2:	bc30      	pop	{r4, r5}
			return &faults_history_list[current_fault_view];
  412cf4:	eb02 0083 	add.w	r0, r2, r3, lsl #2
  412cf8:	4770      	bx	lr
		return 0;
  412cfa:	2000      	movs	r0, #0
  412cfc:	bc30      	pop	{r4, r5}
  412cfe:	4770      	bx	lr
  412d00:	20406c9c 	.word	0x20406c9c
  412d04:	20406914 	.word	0x20406914

00412d08 <d_faults_init>:
		fault_zs_servo_idx, fault_tune1_idx, fault_oc_idx, fault_brk_idx, fault_uv_ard_idx, fault_sincos_err_idx,
		ofault_phfail_idx, sleep_f_idx, rswdrst_f_idx, wdrst_f_idx, init_fault, mCFb_f_idx, bCFb_f_idx, FxCFb_f_idx,
		fault_accoc_idx, fault_decoc_idx, fault_dis_dev_idx;

void d_faults_init(void)
{
  412d08:	b530      	push	{r4, r5, lr}
	fault_ov_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 1, "Over voltage");
  412d0a:	2301      	movs	r3, #1
{
  412d0c:	b083      	sub	sp, #12
	fault_ov_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 1, "Over voltage");
  412d0e:	4a8c      	ldr	r2, [pc, #560]	; (412f40 <d_faults_init+0x238>)
  412d10:	f241 3188 	movw	r1, #5000	; 0x1388
  412d14:	4c8b      	ldr	r4, [pc, #556]	; (412f44 <d_faults_init+0x23c>)
  412d16:	4618      	mov	r0, r3
  412d18:	9200      	str	r2, [sp, #0]
  412d1a:	461a      	mov	r2, r3
  412d1c:	47a0      	blx	r4
	fault_uv_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 2, "Under voltage");
  412d1e:	2201      	movs	r2, #1
	fault_ov_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 1, "Over voltage");
  412d20:	4b89      	ldr	r3, [pc, #548]	; (412f48 <d_faults_init+0x240>)
	fault_uv_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 2, "Under voltage");
  412d22:	498a      	ldr	r1, [pc, #552]	; (412f4c <d_faults_init+0x244>)
	fault_ov_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 1, "Over voltage");
  412d24:	7018      	strb	r0, [r3, #0]
	fault_uv_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 2, "Under voltage");
  412d26:	2302      	movs	r3, #2
  412d28:	9100      	str	r1, [sp, #0]
  412d2a:	4610      	mov	r0, r2
  412d2c:	f241 3188 	movw	r1, #5000	; 0x1388
	fault_phfail_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 8, "Phase fail");
	ofault_phfail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 9, "Motor Phase fail");
	fault_endat_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 800, 1, 10, "PG COMM");
	fault_controlNotSupportted = sph_faults_add_fault(T_STOP_IMMEDIATE, 1000, 1, 11, "Control mode not supp");
	fault_speedDev_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 12, "Speed deviation");
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 13, "ARD Under voltage");
  412d30:	4d87      	ldr	r5, [pc, #540]	; (412f50 <d_faults_init+0x248>)
	fault_uv_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 2, "Under voltage");
  412d32:	47a0      	blx	r4
	fault_oc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 3, "Over current");
  412d34:	2201      	movs	r2, #1
	fault_uv_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 2, "Under voltage");
  412d36:	4b87      	ldr	r3, [pc, #540]	; (412f54 <d_faults_init+0x24c>)
	fault_oc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 3, "Over current");
  412d38:	4987      	ldr	r1, [pc, #540]	; (412f58 <d_faults_init+0x250>)
	fault_uv_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 2, "Under voltage");
  412d3a:	7018      	strb	r0, [r3, #0]
	fault_oc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 3, "Over current");
  412d3c:	2303      	movs	r3, #3
  412d3e:	9100      	str	r1, [sp, #0]
  412d40:	4610      	mov	r0, r2
  412d42:	f241 3188 	movw	r1, #5000	; 0x1388
  412d46:	47a0      	blx	r4
	fault_ol_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 4, "Overload");
  412d48:	2201      	movs	r2, #1
	fault_oc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 3, "Over current");
  412d4a:	4b84      	ldr	r3, [pc, #528]	; (412f5c <d_faults_init+0x254>)
	fault_ol_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 4, "Overload");
  412d4c:	4984      	ldr	r1, [pc, #528]	; (412f60 <d_faults_init+0x258>)
	fault_oc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 3, "Over current");
  412d4e:	7018      	strb	r0, [r3, #0]
	fault_ol_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 4, "Overload");
  412d50:	2304      	movs	r3, #4
  412d52:	9100      	str	r1, [sp, #0]
  412d54:	4610      	mov	r0, r2
  412d56:	f241 3188 	movw	r1, #5000	; 0x1388
  412d5a:	47a0      	blx	r4
  412d5c:	4a81      	ldr	r2, [pc, #516]	; (412f64 <d_faults_init+0x25c>)
	fault_sc_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 5, "output short circuit");
  412d5e:	4982      	ldr	r1, [pc, #520]	; (412f68 <d_faults_init+0x260>)
  412d60:	2305      	movs	r3, #5
	fault_ol_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 4, "Overload");
  412d62:	7010      	strb	r0, [r2, #0]
	fault_sc_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 5, "output short circuit");
  412d64:	2201      	movs	r2, #1
  412d66:	9100      	str	r1, [sp, #0]
  412d68:	2000      	movs	r0, #0
  412d6a:	f241 3188 	movw	r1, #5000	; 0x1388
  412d6e:	47a0      	blx	r4
	fault_ot_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 6, "IGBT over temperature");
  412d70:	2201      	movs	r2, #1
	fault_sc_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 5, "output short circuit");
  412d72:	4b7e      	ldr	r3, [pc, #504]	; (412f6c <d_faults_init+0x264>)
	fault_ot_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 6, "IGBT over temperature");
  412d74:	497e      	ldr	r1, [pc, #504]	; (412f70 <d_faults_init+0x268>)
	fault_sc_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 5, "output short circuit");
  412d76:	7018      	strb	r0, [r3, #0]
	fault_ot_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 6, "IGBT over temperature");
  412d78:	2306      	movs	r3, #6
  412d7a:	9100      	str	r1, [sp, #0]
  412d7c:	4610      	mov	r0, r2
  412d7e:	f241 3188 	movw	r1, #5000	; 0x1388
  412d82:	47a0      	blx	r4
  412d84:	4a7b      	ldr	r2, [pc, #492]	; (412f74 <d_faults_init+0x26c>)
	fault_en_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 7, "Drive En error");
  412d86:	497c      	ldr	r1, [pc, #496]	; (412f78 <d_faults_init+0x270>)
  412d88:	2307      	movs	r3, #7
	fault_ot_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 6, "IGBT over temperature");
  412d8a:	7010      	strb	r0, [r2, #0]
	fault_en_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 7, "Drive En error");
  412d8c:	2201      	movs	r2, #1
  412d8e:	9100      	str	r1, [sp, #0]
  412d90:	2000      	movs	r0, #0
  412d92:	f241 3188 	movw	r1, #5000	; 0x1388
  412d96:	47a0      	blx	r4
  412d98:	4a78      	ldr	r2, [pc, #480]	; (412f7c <d_faults_init+0x274>)
	fault_phfail_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 8, "Phase fail");
  412d9a:	4979      	ldr	r1, [pc, #484]	; (412f80 <d_faults_init+0x278>)
  412d9c:	2308      	movs	r3, #8
	fault_en_idx = sph_faults_add_fault(STOP_IMMEDIATE, 5000, 1, 7, "Drive En error");
  412d9e:	7010      	strb	r0, [r2, #0]
	fault_phfail_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 8, "Phase fail");
  412da0:	2201      	movs	r2, #1
  412da2:	9100      	str	r1, [sp, #0]
  412da4:	2003      	movs	r0, #3
  412da6:	f241 3188 	movw	r1, #5000	; 0x1388
  412daa:	47a0      	blx	r4
	ofault_phfail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 9, "Motor Phase fail");
  412dac:	2201      	movs	r2, #1
	fault_phfail_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 8, "Phase fail");
  412dae:	4b75      	ldr	r3, [pc, #468]	; (412f84 <d_faults_init+0x27c>)
	ofault_phfail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 9, "Motor Phase fail");
  412db0:	4975      	ldr	r1, [pc, #468]	; (412f88 <d_faults_init+0x280>)
	fault_phfail_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 8, "Phase fail");
  412db2:	7018      	strb	r0, [r3, #0]
	ofault_phfail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 9, "Motor Phase fail");
  412db4:	2309      	movs	r3, #9
  412db6:	9100      	str	r1, [sp, #0]
  412db8:	4610      	mov	r0, r2
  412dba:	f241 3188 	movw	r1, #5000	; 0x1388
  412dbe:	47a0      	blx	r4
	fault_endat_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 800, 1, 10, "PG COMM");
  412dc0:	2201      	movs	r2, #1
	ofault_phfail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 9, "Motor Phase fail");
  412dc2:	4b72      	ldr	r3, [pc, #456]	; (412f8c <d_faults_init+0x284>)
	fault_endat_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 800, 1, 10, "PG COMM");
  412dc4:	4972      	ldr	r1, [pc, #456]	; (412f90 <d_faults_init+0x288>)
	ofault_phfail_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 9, "Motor Phase fail");
  412dc6:	7018      	strb	r0, [r3, #0]
	fault_endat_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 800, 1, 10, "PG COMM");
  412dc8:	230a      	movs	r3, #10
  412dca:	9100      	str	r1, [sp, #0]
  412dcc:	4610      	mov	r0, r2
  412dce:	f44f 7148 	mov.w	r1, #800	; 0x320
  412dd2:	47a0      	blx	r4
	fault_controlNotSupportted = sph_faults_add_fault(T_STOP_IMMEDIATE, 1000, 1, 11, "Control mode not supp");
  412dd4:	2201      	movs	r2, #1
	fault_endat_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 800, 1, 10, "PG COMM");
  412dd6:	4b6f      	ldr	r3, [pc, #444]	; (412f94 <d_faults_init+0x28c>)
	fault_controlNotSupportted = sph_faults_add_fault(T_STOP_IMMEDIATE, 1000, 1, 11, "Control mode not supp");
  412dd8:	496f      	ldr	r1, [pc, #444]	; (412f98 <d_faults_init+0x290>)
	fault_endat_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 800, 1, 10, "PG COMM");
  412dda:	7018      	strb	r0, [r3, #0]
	fault_controlNotSupportted = sph_faults_add_fault(T_STOP_IMMEDIATE, 1000, 1, 11, "Control mode not supp");
  412ddc:	230b      	movs	r3, #11
  412dde:	9100      	str	r1, [sp, #0]
  412de0:	4610      	mov	r0, r2
  412de2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  412de6:	47a0      	blx	r4
	fault_speedDev_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 12, "Speed deviation");
  412de8:	2201      	movs	r2, #1
	fault_controlNotSupportted = sph_faults_add_fault(T_STOP_IMMEDIATE, 1000, 1, 11, "Control mode not supp");
  412dea:	4b6c      	ldr	r3, [pc, #432]	; (412f9c <d_faults_init+0x294>)
	fault_speedDev_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 12, "Speed deviation");
  412dec:	496c      	ldr	r1, [pc, #432]	; (412fa0 <d_faults_init+0x298>)
	fault_controlNotSupportted = sph_faults_add_fault(T_STOP_IMMEDIATE, 1000, 1, 11, "Control mode not supp");
  412dee:	7018      	strb	r0, [r3, #0]
	fault_speedDev_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 12, "Speed deviation");
  412df0:	230c      	movs	r3, #12
  412df2:	9100      	str	r1, [sp, #0]
  412df4:	4610      	mov	r0, r2
  412df6:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412dfa:	47a0      	blx	r4
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 13, "ARD Under voltage");
  412dfc:	2201      	movs	r2, #1
	fault_speedDev_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 12, "Speed deviation");
  412dfe:	4b69      	ldr	r3, [pc, #420]	; (412fa4 <d_faults_init+0x29c>)
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 13, "ARD Under voltage");
  412e00:	4969      	ldr	r1, [pc, #420]	; (412fa8 <d_faults_init+0x2a0>)
	fault_speedDev_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 12, "Speed deviation");
  412e02:	7018      	strb	r0, [r3, #0]
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 13, "ARD Under voltage");
  412e04:	230d      	movs	r3, #13
  412e06:	9100      	str	r1, [sp, #0]
  412e08:	4610      	mov	r0, r2
  412e0a:	f242 7110 	movw	r1, #10000	; 0x2710
  412e0e:	47a0      	blx	r4
	fault_zs_servo_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 4000, 1, 14, "ZS servo out of range");
  412e10:	2201      	movs	r2, #1
  412e12:	4b66      	ldr	r3, [pc, #408]	; (412fac <d_faults_init+0x2a4>)
  412e14:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 13, "ARD Under voltage");
  412e18:	7028      	strb	r0, [r5, #0]
	fault_zs_servo_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 4000, 1, 14, "ZS servo out of range");
  412e1a:	4610      	mov	r0, r2
  412e1c:	9300      	str	r3, [sp, #0]
  412e1e:	230e      	movs	r3, #14
  412e20:	47a0      	blx	r4
	fault_tune1_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 15, "Tune1 Error");
  412e22:	2201      	movs	r2, #1
	fault_zs_servo_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 4000, 1, 14, "ZS servo out of range");
  412e24:	4b62      	ldr	r3, [pc, #392]	; (412fb0 <d_faults_init+0x2a8>)
	fault_tune1_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 15, "Tune1 Error");
  412e26:	4963      	ldr	r1, [pc, #396]	; (412fb4 <d_faults_init+0x2ac>)
	fault_zs_servo_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 4000, 1, 14, "ZS servo out of range");
  412e28:	7018      	strb	r0, [r3, #0]
	fault_tune1_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 15, "Tune1 Error");
  412e2a:	230f      	movs	r3, #15
  412e2c:	9100      	str	r1, [sp, #0]
  412e2e:	4610      	mov	r0, r2
  412e30:	f242 7110 	movw	r1, #10000	; 0x2710
  412e34:	47a0      	blx	r4
  412e36:	4a60      	ldr	r2, [pc, #384]	; (412fb8 <d_faults_init+0x2b0>)
	//fault_oc_idx = sph_faults_add_fault(STOP_IMMEDIATE, 10000, "Over Current");
	fault_brk_idx = sph_faults_add_fault(STOP_IMMEDIATE, 10000, 1, 16, "Brake short ct");
  412e38:	4960      	ldr	r1, [pc, #384]	; (412fbc <d_faults_init+0x2b4>)
  412e3a:	2310      	movs	r3, #16
	fault_tune1_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 10000, 1, 15, "Tune1 Error");
  412e3c:	7010      	strb	r0, [r2, #0]
	fault_brk_idx = sph_faults_add_fault(STOP_IMMEDIATE, 10000, 1, 16, "Brake short ct");
  412e3e:	2201      	movs	r2, #1
  412e40:	9100      	str	r1, [sp, #0]
  412e42:	2000      	movs	r0, #0
  412e44:	f242 7110 	movw	r1, #10000	; 0x2710
  412e48:	47a0      	blx	r4
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 17, "Under ARD voltage");
  412e4a:	2201      	movs	r2, #1
	fault_brk_idx = sph_faults_add_fault(STOP_IMMEDIATE, 10000, 1, 16, "Brake short ct");
  412e4c:	4b5c      	ldr	r3, [pc, #368]	; (412fc0 <d_faults_init+0x2b8>)
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 17, "Under ARD voltage");
  412e4e:	495d      	ldr	r1, [pc, #372]	; (412fc4 <d_faults_init+0x2bc>)
	fault_brk_idx = sph_faults_add_fault(STOP_IMMEDIATE, 10000, 1, 16, "Brake short ct");
  412e50:	7018      	strb	r0, [r3, #0]
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 17, "Under ARD voltage");
  412e52:	2311      	movs	r3, #17
  412e54:	9100      	str	r1, [sp, #0]
  412e56:	4610      	mov	r0, r2
  412e58:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412e5c:	47a0      	blx	r4
	fault_sincos_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 18, "SinCos sig missing");
  412e5e:	2201      	movs	r2, #1
  412e60:	4b59      	ldr	r3, [pc, #356]	; (412fc8 <d_faults_init+0x2c0>)
  412e62:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
	fault_uv_ard_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 17, "Under ARD voltage");
  412e66:	7028      	strb	r0, [r5, #0]
	fault_sincos_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 18, "SinCos sig missing");
  412e68:	4610      	mov	r0, r2
  412e6a:	9300      	str	r3, [sp, #0]
  412e6c:	2312      	movs	r3, #18
  412e6e:	47a0      	blx	r4
  412e70:	4a56      	ldr	r2, [pc, #344]	; (412fcc <d_faults_init+0x2c4>)
	sleep_f_idx = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 19, "Reset needed");
  412e72:	4957      	ldr	r1, [pc, #348]	; (412fd0 <d_faults_init+0x2c8>)
  412e74:	2313      	movs	r3, #19
	fault_sincos_err_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 18, "SinCos sig missing");
  412e76:	7010      	strb	r0, [r2, #0]
	sleep_f_idx = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 19, "Reset needed");
  412e78:	2201      	movs	r2, #1
  412e7a:	9100      	str	r1, [sp, #0]
  412e7c:	2000      	movs	r0, #0
  412e7e:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412e82:	47a0      	blx	r4
  412e84:	4a53      	ldr	r2, [pc, #332]	; (412fd4 <d_faults_init+0x2cc>)
	wdrst_f_idx  = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 20, "WDReset");
  412e86:	4954      	ldr	r1, [pc, #336]	; (412fd8 <d_faults_init+0x2d0>)
  412e88:	2314      	movs	r3, #20
	sleep_f_idx = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 19, "Reset needed");
  412e8a:	7010      	strb	r0, [r2, #0]
	wdrst_f_idx  = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 20, "WDReset");
  412e8c:	2201      	movs	r2, #1
  412e8e:	9100      	str	r1, [sp, #0]
  412e90:	2000      	movs	r0, #0
  412e92:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412e96:	47a0      	blx	r4
  412e98:	4a50      	ldr	r2, [pc, #320]	; (412fdc <d_faults_init+0x2d4>)
	rswdrst_f_idx = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 21, "RSWDReset"); 
  412e9a:	4951      	ldr	r1, [pc, #324]	; (412fe0 <d_faults_init+0x2d8>)
  412e9c:	2315      	movs	r3, #21
	wdrst_f_idx  = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 20, "WDReset");
  412e9e:	7010      	strb	r0, [r2, #0]
	rswdrst_f_idx = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 21, "RSWDReset"); 
  412ea0:	2201      	movs	r2, #1
  412ea2:	9100      	str	r1, [sp, #0]
  412ea4:	2000      	movs	r0, #0
  412ea6:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412eaa:	47a0      	blx	r4
  412eac:	4a4d      	ldr	r2, [pc, #308]	; (412fe4 <d_faults_init+0x2dc>)
	init_fault = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 22, "init fault");
  412eae:	494e      	ldr	r1, [pc, #312]	; (412fe8 <d_faults_init+0x2e0>)
  412eb0:	2316      	movs	r3, #22
	rswdrst_f_idx = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 21, "RSWDReset"); 
  412eb2:	7010      	strb	r0, [r2, #0]
	init_fault = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 22, "init fault");
  412eb4:	2201      	movs	r2, #1
  412eb6:	9100      	str	r1, [sp, #0]
  412eb8:	2000      	movs	r0, #0
  412eba:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412ebe:	47a0      	blx	r4
	mCFb_f_idx  = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 23, "MOC FB fault");
  412ec0:	2201      	movs	r2, #1
	init_fault = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 22, "init fault");
  412ec2:	4b4a      	ldr	r3, [pc, #296]	; (412fec <d_faults_init+0x2e4>)
	mCFb_f_idx  = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 23, "MOC FB fault");
  412ec4:	494a      	ldr	r1, [pc, #296]	; (412ff0 <d_faults_init+0x2e8>)
	init_fault = sph_faults_add_fault(STOP_IMMEDIATE, 8000, 1, 22, "init fault");
  412ec6:	7018      	strb	r0, [r3, #0]
	mCFb_f_idx  = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 23, "MOC FB fault");
  412ec8:	2317      	movs	r3, #23
  412eca:	9100      	str	r1, [sp, #0]
  412ecc:	4610      	mov	r0, r2
  412ece:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412ed2:	47a0      	blx	r4
	bCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 24, "Brk FB fault");
  412ed4:	2201      	movs	r2, #1
	mCFb_f_idx  = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 23, "MOC FB fault");
  412ed6:	4b47      	ldr	r3, [pc, #284]	; (412ff4 <d_faults_init+0x2ec>)
	bCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 24, "Brk FB fault");
  412ed8:	4947      	ldr	r1, [pc, #284]	; (412ff8 <d_faults_init+0x2f0>)
	mCFb_f_idx  = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 23, "MOC FB fault");
  412eda:	7018      	strb	r0, [r3, #0]
	bCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 24, "Brk FB fault");
  412edc:	2318      	movs	r3, #24
  412ede:	9100      	str	r1, [sp, #0]
  412ee0:	4610      	mov	r0, r2
  412ee2:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  412ee6:	47a0      	blx	r4
	FxCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 50000, 1, 25, "Fx FB fault");
  412ee8:	2201      	movs	r2, #1
	bCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 24, "Brk FB fault");
  412eea:	4b44      	ldr	r3, [pc, #272]	; (412ffc <d_faults_init+0x2f4>)
	FxCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 50000, 1, 25, "Fx FB fault");
  412eec:	4944      	ldr	r1, [pc, #272]	; (413000 <d_faults_init+0x2f8>)
	bCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 8000, 1, 24, "Brk FB fault");
  412eee:	7018      	strb	r0, [r3, #0]
	FxCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 50000, 1, 25, "Fx FB fault");
  412ef0:	2319      	movs	r3, #25
  412ef2:	9100      	str	r1, [sp, #0]
  412ef4:	4610      	mov	r0, r2
  412ef6:	f24c 3150 	movw	r1, #50000	; 0xc350
  412efa:	47a0      	blx	r4
	fault_accoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 26, "Acc OverCurrent");
  412efc:	2201      	movs	r2, #1
	FxCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 50000, 1, 25, "Fx FB fault");
  412efe:	4b41      	ldr	r3, [pc, #260]	; (413004 <d_faults_init+0x2fc>)
	fault_accoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 26, "Acc OverCurrent");
  412f00:	4941      	ldr	r1, [pc, #260]	; (413008 <d_faults_init+0x300>)
	FxCFb_f_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 50000, 1, 25, "Fx FB fault");
  412f02:	7018      	strb	r0, [r3, #0]
	fault_accoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 26, "Acc OverCurrent");
  412f04:	231a      	movs	r3, #26
  412f06:	9100      	str	r1, [sp, #0]
  412f08:	4610      	mov	r0, r2
  412f0a:	f241 3188 	movw	r1, #5000	; 0x1388
  412f0e:	47a0      	blx	r4
	fault_decoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 27, "Dec OverCurrent");
  412f10:	2201      	movs	r2, #1
	fault_accoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 26, "Acc OverCurrent");
  412f12:	4b3e      	ldr	r3, [pc, #248]	; (41300c <d_faults_init+0x304>)
	fault_decoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 27, "Dec OverCurrent");
  412f14:	493e      	ldr	r1, [pc, #248]	; (413010 <d_faults_init+0x308>)
	fault_accoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 26, "Acc OverCurrent");
  412f16:	7018      	strb	r0, [r3, #0]
	fault_decoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 27, "Dec OverCurrent");
  412f18:	231b      	movs	r3, #27
  412f1a:	9100      	str	r1, [sp, #0]
  412f1c:	4610      	mov	r0, r2
  412f1e:	f241 3188 	movw	r1, #5000	; 0x1388
  412f22:	47a0      	blx	r4
  412f24:	4a3b      	ldr	r2, [pc, #236]	; (413014 <d_faults_init+0x30c>)
	fault_dis_dev_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 28, "Distance dev");
  412f26:	493c      	ldr	r1, [pc, #240]	; (413018 <d_faults_init+0x310>)
  412f28:	231c      	movs	r3, #28
	fault_decoc_idx = sph_faults_add_fault(T_STOP_IMMEDIATE, 5000, 1, 27, "Dec OverCurrent");
  412f2a:	7010      	strb	r0, [r2, #0]
	fault_dis_dev_idx = sph_faults_add_fault(T_POS_FAULT, 5000, 1, 28, "Distance dev");
  412f2c:	2201      	movs	r2, #1
  412f2e:	9100      	str	r1, [sp, #0]
  412f30:	2003      	movs	r0, #3
  412f32:	f241 3188 	movw	r1, #5000	; 0x1388
  412f36:	47a0      	blx	r4
  412f38:	4b38      	ldr	r3, [pc, #224]	; (41301c <d_faults_init+0x314>)
  412f3a:	7018      	strb	r0, [r3, #0]
  412f3c:	b003      	add	sp, #12
  412f3e:	bd30      	pop	{r4, r5, pc}
  412f40:	0041ca9c 	.word	0x0041ca9c
  412f44:	004127c1 	.word	0x004127c1
  412f48:	20406cb1 	.word	0x20406cb1
  412f4c:	0041cb50 	.word	0x0041cb50
  412f50:	20406cad 	.word	0x20406cad
  412f54:	20406cb2 	.word	0x20406cb2
  412f58:	0041caac 	.word	0x0041caac
  412f5c:	20406cac 	.word	0x20406cac
  412f60:	0041aa10 	.word	0x0041aa10
  412f64:	20406ca5 	.word	0x20406ca5
  412f68:	0041cabc 	.word	0x0041cabc
  412f6c:	20406c9f 	.word	0x20406c9f
  412f70:	0041cad4 	.word	0x0041cad4
  412f74:	20406ca1 	.word	0x20406ca1
  412f78:	0041caec 	.word	0x0041caec
  412f7c:	20406cb3 	.word	0x20406cb3
  412f80:	0041cafc 	.word	0x0041cafc
  412f84:	20406cb4 	.word	0x20406cb4
  412f88:	0041cb08 	.word	0x0041cb08
  412f8c:	20406ca7 	.word	0x20406ca7
  412f90:	0041cb1c 	.word	0x0041cb1c
  412f94:	20406ca3 	.word	0x20406ca3
  412f98:	0041cb24 	.word	0x0041cb24
  412f9c:	20406caa 	.word	0x20406caa
  412fa0:	0041cb3c 	.word	0x0041cb3c
  412fa4:	20406cab 	.word	0x20406cab
  412fa8:	0041cb4c 	.word	0x0041cb4c
  412fac:	0041cb60 	.word	0x0041cb60
  412fb0:	20406ca8 	.word	0x20406ca8
  412fb4:	0041cb78 	.word	0x0041cb78
  412fb8:	20406ca6 	.word	0x20406ca6
  412fbc:	0041cb84 	.word	0x0041cb84
  412fc0:	20406caf 	.word	0x20406caf
  412fc4:	0041cb94 	.word	0x0041cb94
  412fc8:	0041cba8 	.word	0x0041cba8
  412fcc:	20406cb6 	.word	0x20406cb6
  412fd0:	0041cbbc 	.word	0x0041cbbc
  412fd4:	20406c9d 	.word	0x20406c9d
  412fd8:	0041cbcc 	.word	0x0041cbcc
  412fdc:	20406cb0 	.word	0x20406cb0
  412fe0:	0041cbd4 	.word	0x0041cbd4
  412fe4:	20406ca0 	.word	0x20406ca0
  412fe8:	0041cbe0 	.word	0x0041cbe0
  412fec:	20406ca9 	.word	0x20406ca9
  412ff0:	0041cbec 	.word	0x0041cbec
  412ff4:	20406cb7 	.word	0x20406cb7
  412ff8:	0041cbfc 	.word	0x0041cbfc
  412ffc:	20406c9e 	.word	0x20406c9e
  413000:	0041cc0c 	.word	0x0041cc0c
  413004:	20406cb5 	.word	0x20406cb5
  413008:	0041cc18 	.word	0x0041cc18
  41300c:	20406cae 	.word	0x20406cae
  413010:	0041cc28 	.word	0x0041cc28
  413014:	20406ca4 	.word	0x20406ca4
  413018:	0041cc38 	.word	0x0041cc38
  41301c:	20406ca2 	.word	0x20406ca2

00413020 <d_util_init>:
#include <d_faults.h>
#include <d_util.h>

void d_util_init(void)
{
	d_faults_init();
  413020:	4b00      	ldr	r3, [pc, #0]	; (413024 <d_util_init+0x4>)
  413022:	4718      	bx	r3
  413024:	00412d09 	.word	0x00412d09

00413028 <vf_speed_out_handler>:
#include <axistransform.h>
#include <motor_data.h>

fixedpt theta = fixedpt_rconst(0);
void vf_speed_out_handler(fixedpt speed, uint32_t breakactive)
{
  413028:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	fixedpt volts = 0, break_volts = 0, thetaincrement, freq = fixedpt_abs(speed);
	float tmp = TSAMPLE;
  41302c:	4b7e      	ldr	r3, [pc, #504]	; (413228 <vf_speed_out_handler+0x200>)
	fixedpt volts = 0, break_volts = 0, thetaincrement, freq = fixedpt_abs(speed);
  41302e:	ea80 76e0 	eor.w	r6, r0, r0, asr #31
	tmp *= FIXEDPT_ONE;
	
	if (freq > FMAX)
  413032:	4c7e      	ldr	r4, [pc, #504]	; (41322c <vf_speed_out_handler+0x204>)
{
  413034:	4605      	mov	r5, r0
	fixedpt volts = 0, break_volts = 0, thetaincrement, freq = fixedpt_abs(speed);
  413036:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
	tmp *= FIXEDPT_ONE;
  41303a:	ed9f 7a7d 	vldr	s14, [pc, #500]	; 413230 <vf_speed_out_handler+0x208>
{
  41303e:	4688      	mov	r8, r1
  413040:	ed2d 8b02 	vpush	{d8}
	tmp *= FIXEDPT_ONE;
  413044:	edd3 7a00 	vldr	s15, [r3]
{
  413048:	b083      	sub	sp, #12
	if (freq > FMAX)
  41304a:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
	tmp *= FIXEDPT_ONE;
  41304e:	ee87 8a27 	vdiv.f32	s16, s14, s15
	if (freq > FMAX)
  413052:	429e      	cmp	r6, r3
  413054:	dd04      	ble.n	413060 <vf_speed_out_handler+0x38>
	{
		if(speed < 0) speed = -FMAX;
  413056:	2800      	cmp	r0, #0
  413058:	f2c0 80a0 	blt.w	41319c <vf_speed_out_handler+0x174>
  41305c:	461e      	mov	r6, r3
  41305e:	461d      	mov	r5, r3
		else speed = FMAX;
		
		freq = FMAX;
	}
	
	if (freq <= FMIN)
  413060:	f8d4 b094 	ldr.w	fp, [r4, #148]	; 0x94
  413064:	455e      	cmp	r6, fp
  413066:	dc59      	bgt.n	41311c <vf_speed_out_handler+0xf4>
  413068:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
  41306c:	6927      	ldr	r7, [r4, #16]
  41306e:	ea83 79e3 	eor.w	r9, r3, r3, asr #31
  413072:	eba9 79e3 	sub.w	r9, r9, r3, asr #31
	
	volts = fixedpt_abs(volts);
	
	break_volts = fixedpt_div(vbase, fixedpt_rconst(100));
	break_volts = fixedpt_mul(break_volts, BREAK_VOLTAGE);
	if (breakactive) if (speed <= BREAK_FREQ)
  413076:	f1b8 0f00 	cmp.w	r8, #0
  41307a:	d01f      	beq.n	4130bc <vf_speed_out_handler+0x94>
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  41307c:	17fb      	asrs	r3, r7, #31
  41307e:	4e6d      	ldr	r6, [pc, #436]	; (413234 <vf_speed_out_handler+0x20c>)
  413080:	03f8      	lsls	r0, r7, #15
  413082:	f44f 1248 	mov.w	r2, #3276800	; 0x320000
  413086:	03d9      	lsls	r1, r3, #15
  413088:	2300      	movs	r3, #0
  41308a:	ea41 4157 	orr.w	r1, r1, r7, lsr #17
  41308e:	47b0      	blx	r6
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  413090:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
  413094:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
  413098:	ea4f 7be3 	mov.w	fp, r3, asr #31
  41309c:	fba0 6703 	umull	r6, r7, r0, r3
	{
		// apply break voltage at break speed
		if(volts < break_volts) volts = break_volts;
  4130a0:	4295      	cmp	r5, r2
  4130a2:	fb00 f00b 	mul.w	r0, r0, fp
  4130a6:	fb03 0101 	mla	r1, r3, r1, r0
  4130aa:	ea4f 33d6 	mov.w	r3, r6, lsr #15
  4130ae:	440f      	add	r7, r1
  4130b0:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  4130b4:	dc02      	bgt.n	4130bc <vf_speed_out_handler+0x94>
  4130b6:	4599      	cmp	r9, r3
  4130b8:	bfb8      	it	lt
  4130ba:	4699      	movlt	r9, r3
  4130bc:	f44f 0634 	mov.w	r6, #11796480	; 0xb40000
	
	volts = fixedpt_mul(volts, fixedpt_rconst(1.414213562)); // multiply by sqrt(2)
	
	speed = fixedpt_mul(speed, fixedpt_rconst(360));
	
	thetaincrement = tmp;
  4130c0:	eefd 7ac8 	vcvt.s32.f32	s15, s16
	thetaincrement = fixedpt_mul(speed, thetaincrement);

	theta += thetaincrement;
  4130c4:	f8df e174 	ldr.w	lr, [pc, #372]	; 41323c <vf_speed_out_handler+0x214>
  4130c8:	f24b 5405 	movw	r4, #46341	; 0xb505
  4130cc:	fb85 6706 	smull	r6, r7, r5, r6
	thetaincrement = tmp;
  4130d0:	ee17 2a90 	vmov	r2, s15
	theta += thetaincrement;
  4130d4:	f8de 0000 	ldr.w	r0, [lr]
  4130d8:	0bf3      	lsrs	r3, r6, #15
  4130da:	fb89 4504 	smull	r4, r5, r9, r4
  4130de:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
  4130e2:	0be1      	lsrs	r1, r4, #15
  4130e4:	fb82 2303 	smull	r2, r3, r2, r3
  4130e8:	ea41 4145 	orr.w	r1, r1, r5, lsl #17
  4130ec:	0bd2      	lsrs	r2, r2, #15
  4130ee:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  4130f2:	4410      	add	r0, r2

	while(theta > fixedpt_rconst(360)) theta -= fixedpt_rconst(360);
  4130f4:	f5b0 0f34 	cmp.w	r0, #11796480	; 0xb40000
	theta += thetaincrement;
  4130f8:	f8ce 0000 	str.w	r0, [lr]
	while(theta > fixedpt_rconst(360)) theta -= fixedpt_rconst(360);
  4130fc:	f340 8087 	ble.w	41320e <vf_speed_out_handler+0x1e6>
  413100:	f5a0 0034 	sub.w	r0, r0, #11796480	; 0xb40000
  413104:	f5b0 0f34 	cmp.w	r0, #11796480	; 0xb40000
  413108:	dcfa      	bgt.n	413100 <vf_speed_out_handler+0xd8>
  41310a:	f8ce 0000 	str.w	r0, [lr]
	
	//axt_set_theta(fixedpt_tofloat(theta));
	//axt_park_exe();
	float valpha, vbeta;
	//axt_ipark_exe(0, fixedpt_tofloat(volts), &valpha, &vbeta);
	inverter_out_polar(theta, volts);
  41310e:	4b4a      	ldr	r3, [pc, #296]	; (413238 <vf_speed_out_handler+0x210>)
	//inverter_out_rect(fixedpt_rconst(valpha), fixedpt_rconst(vbeta));	
}
  413110:	b003      	add	sp, #12
  413112:	ecbd 8b02 	vpop	{d8}
  413116:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	inverter_out_polar(theta, volts);
  41311a:	4718      	bx	r3
	else if (freq <= FM)
  41311c:	f8d4 a09c 	ldr.w	sl, [r4, #156]	; 0x9c
  413120:	4556      	cmp	r6, sl
  413122:	dc32      	bgt.n	41318a <vf_speed_out_handler+0x162>
		volts = fixedpt_mul(sl1, freq - FMIN) + VMIN;
  413124:	f8d4 9090 	ldr.w	r9, [r4, #144]	; 0x90
  413128:	ebaa 020b 	sub.w	r2, sl, fp
  41312c:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
  413130:	eba6 0b0b 	sub.w	fp, r6, fp
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  413134:	17d3      	asrs	r3, r2, #31
  413136:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 413234 <vf_speed_out_handler+0x20c>
  41313a:	eba1 0e09 	sub.w	lr, r1, r9
  41313e:	6927      	ldr	r7, [r4, #16]
  413140:	4670      	mov	r0, lr
  413142:	17c1      	asrs	r1, r0, #31
  413144:	ea4f 30ce 	mov.w	r0, lr, lsl #15
  413148:	03c9      	lsls	r1, r1, #15
  41314a:	ea41 415e 	orr.w	r1, r1, lr, lsr #17
  41314e:	47d0      	blx	sl
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  413150:	fb8b 0100 	smull	r0, r1, fp, r0
  413154:	f8d4 60a8 	ldr.w	r6, [r4, #168]	; 0xa8
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  413158:	f44f 1248 	mov.w	r2, #3276800	; 0x320000
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  41315c:	0bc0      	lsrs	r0, r0, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  41315e:	2300      	movs	r3, #0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  413160:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
  413164:	4481      	add	r9, r0
  413166:	fb89 0106 	smull	r0, r1, r9, r6
  41316a:	0bc6      	lsrs	r6, r0, #15
  41316c:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  413170:	ea4f 7ce6 	mov.w	ip, r6, asr #31
  413174:	03f0      	lsls	r0, r6, #15
  413176:	ea4f 31cc 	mov.w	r1, ip, lsl #15
  41317a:	ea41 4156 	orr.w	r1, r1, r6, lsr #17
  41317e:	47d0      	blx	sl
  413180:	ea80 79e0 	eor.w	r9, r0, r0, asr #31
  413184:	eba9 79e0 	sub.w	r9, r9, r0, asr #31
  413188:	e775      	b.n	413076 <vf_speed_out_handler+0x4e>
	else if (freq <= fbase)
  41318a:	68a2      	ldr	r2, [r4, #8]
		volts = fixedpt_mul(sl2, freq - FM) + fixedpt_div(fixedpt_mul(VM, TBOOST), fixedpt_rconst(100));
  41318c:	6927      	ldr	r7, [r4, #16]
	else if (freq <= fbase)
  41318e:	4296      	cmp	r6, r2
  413190:	dd07      	ble.n	4131a2 <vf_speed_out_handler+0x17a>
	else if (freq <= FMAX)
  413192:	429e      	cmp	r6, r3
  413194:	dd42      	ble.n	41321c <vf_speed_out_handler+0x1f4>
  413196:	f04f 0900 	mov.w	r9, #0
  41319a:	e76c      	b.n	413076 <vf_speed_out_handler+0x4e>
		if(speed < 0) speed = -FMAX;
  41319c:	425d      	negs	r5, r3
  41319e:	461e      	mov	r6, r3
  4131a0:	e75e      	b.n	413060 <vf_speed_out_handler+0x38>
		volts = fixedpt_mul(sl2, freq - FM) + fixedpt_div(fixedpt_mul(VM, TBOOST), fixedpt_rconst(100));
  4131a2:	f8d4 b098 	ldr.w	fp, [r4, #152]	; 0x98
  4131a6:	eba2 020a 	sub.w	r2, r2, sl
  4131aa:	f8df 9088 	ldr.w	r9, [pc, #136]	; 413234 <vf_speed_out_handler+0x20c>
  4131ae:	eba6 060a 	sub.w	r6, r6, sl
  4131b2:	eba7 0c0b 	sub.w	ip, r7, fp
  4131b6:	17d3      	asrs	r3, r2, #31
  4131b8:	4660      	mov	r0, ip
  4131ba:	17c1      	asrs	r1, r0, #31
  4131bc:	e9cd 0100 	strd	r0, r1, [sp]
  4131c0:	9901      	ldr	r1, [sp, #4]
  4131c2:	ea4f 30cc 	mov.w	r0, ip, lsl #15
  4131c6:	ea4f 3ec1 	mov.w	lr, r1, lsl #15
  4131ca:	ea4e 415c 	orr.w	r1, lr, ip, lsr #17
  4131ce:	47c8      	blx	r9
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4131d0:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  4131d4:	f44f 1248 	mov.w	r2, #3276800	; 0x320000
  4131d8:	2300      	movs	r3, #0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4131da:	fb8b ab01 	smull	sl, fp, fp, r1
  4131de:	fb86 0100 	smull	r0, r1, r6, r0
  4131e2:	ea4f 3eda 	mov.w	lr, sl, lsr #15
  4131e6:	0bc6      	lsrs	r6, r0, #15
  4131e8:	ea4e 4e4b 	orr.w	lr, lr, fp, lsl #17
  4131ec:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  4131f0:	ea4f 7bee 	mov.w	fp, lr, asr #31
  4131f4:	ea4f 30ce 	mov.w	r0, lr, lsl #15
  4131f8:	ea4f 31cb 	mov.w	r1, fp, lsl #15
  4131fc:	ea41 415e 	orr.w	r1, r1, lr, lsr #17
  413200:	47c8      	blx	r9
  413202:	4430      	add	r0, r6
  413204:	ea80 79e0 	eor.w	r9, r0, r0, asr #31
  413208:	eba9 79e0 	sub.w	r9, r9, r0, asr #31
  41320c:	e733      	b.n	413076 <vf_speed_out_handler+0x4e>
	while(theta < 0) theta += fixedpt_rconst(360);
  41320e:	2800      	cmp	r0, #0
  413210:	f6bf af7d 	bge.w	41310e <vf_speed_out_handler+0xe6>
  413214:	f510 0034 	adds.w	r0, r0, #11796480	; 0xb40000
  413218:	d4fc      	bmi.n	413214 <vf_speed_out_handler+0x1ec>
  41321a:	e776      	b.n	41310a <vf_speed_out_handler+0xe2>
  41321c:	ea87 79e7 	eor.w	r9, r7, r7, asr #31
  413220:	eba9 79e7 	sub.w	r9, r9, r7, asr #31
  413224:	e727      	b.n	413076 <vf_speed_out_handler+0x4e>
  413226:	bf00      	nop
  413228:	204003c8 	.word	0x204003c8
  41322c:	20404ff0 	.word	0x20404ff0
  413230:	47000000 	.word	0x47000000
  413234:	0041905d 	.word	0x0041905d
  413238:	004150a9 	.word	0x004150a9
  41323c:	20400ab0 	.word	0x20400ab0

00413240 <vfd_enable_isEnabled>:
	if (E0 == E1)
	{
		if(E0 == 1) return 1;
	}
	return 0;
}
  413240:	2001      	movs	r0, #1
  413242:	4770      	bx	lr

00413244 <vfd_enable_handler>:

uint32_t vfd_enable_delay_counter = 0, vfd_enable_start_delay_counter = 0;
void vfd_enable_handler(void)
{
	if (vfd_enable_start_delay_counter < 2500)
  413244:	4a0a      	ldr	r2, [pc, #40]	; (413270 <vfd_enable_handler+0x2c>)
  413246:	f640 11c3 	movw	r1, #2499	; 0x9c3
  41324a:	6813      	ldr	r3, [r2, #0]
  41324c:	428b      	cmp	r3, r1
  41324e:	d90b      	bls.n	413268 <vfd_enable_handler+0x24>
	{
		vfd_enable_start_delay_counter++;
		return;
	}
	if (!(++vfd_enable_delay_counter < 40))
  413250:	4a08      	ldr	r2, [pc, #32]	; (413274 <vfd_enable_handler+0x30>)
  413252:	6813      	ldr	r3, [r2, #0]
  413254:	3301      	adds	r3, #1
  413256:	2b27      	cmp	r3, #39	; 0x27
  413258:	d904      	bls.n	413264 <vfd_enable_handler+0x20>
	{
		vfd_enable_delay_counter = 0;
  41325a:	2300      	movs	r3, #0
		en_delay_counter = 0;
  41325c:	4906      	ldr	r1, [pc, #24]	; (413278 <vfd_enable_handler+0x34>)
		vfd_enable_delay_counter = 0;
  41325e:	6013      	str	r3, [r2, #0]
		en_delay_counter = 0;
  413260:	700b      	strb	r3, [r1, #0]
  413262:	4770      	bx	lr
	if (!(++vfd_enable_delay_counter < 40))
  413264:	6013      	str	r3, [r2, #0]
  413266:	4770      	bx	lr
		vfd_enable_start_delay_counter++;
  413268:	3301      	adds	r3, #1
  41326a:	6013      	str	r3, [r2, #0]
		return;
  41326c:	4770      	bx	lr
  41326e:	bf00      	nop
  413270:	20400abc 	.word	0x20400abc
  413274:	20400ab8 	.word	0x20400ab8
  413278:	20400ab4 	.word	0x20400ab4

0041327c <encoder_handler>:
#include <encoder_interface.h>
#include <pwm_interface.h>

void encoder_handler(void)
{
	if(menue_drive_data_applied.m_encoder_type == 2) // endat encoder
  41327c:	4b07      	ldr	r3, [pc, #28]	; (41329c <encoder_handler+0x20>)
  41327e:	f893 20ac 	ldrb.w	r2, [r3, #172]	; 0xac
  413282:	2a02      	cmp	r2, #2
  413284:	d000      	beq.n	413288 <encoder_handler+0xc>
  413286:	4770      	bx	lr
	{
		if (MOTOR_PM_CVC) endat_handler();
  413288:	f893 20c5 	ldrb.w	r2, [r3, #197]	; 0xc5
  41328c:	2a01      	cmp	r2, #1
  41328e:	d1fa      	bne.n	413286 <encoder_handler+0xa>
  413290:	781b      	ldrb	r3, [r3, #0]
  413292:	2b01      	cmp	r3, #1
  413294:	d1f7      	bne.n	413286 <encoder_handler+0xa>
  413296:	4b02      	ldr	r3, [pc, #8]	; (4132a0 <encoder_handler+0x24>)
  413298:	4718      	bx	r3
  41329a:	bf00      	nop
  41329c:	20404ff0 	.word	0x20404ff0
  4132a0:	004136d1 	.word	0x004136d1

004132a4 <encoder_init>:
	}
}

void encoder_init(void)
{
  4132a4:	b510      	push	{r4, lr}
	inc_init();
  4132a6:	4b03      	ldr	r3, [pc, #12]	; (4132b4 <encoder_init+0x10>)
  4132a8:	4798      	blx	r3
	endat_init();
  4132aa:	4b03      	ldr	r3, [pc, #12]	; (4132b8 <encoder_init+0x14>)
}
  4132ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	endat_init();
  4132b0:	4718      	bx	r3
  4132b2:	bf00      	nop
  4132b4:	0041377d 	.word	0x0041377d
  4132b8:	004133c9 	.word	0x004133c9

004132bc <encoder_getangle_elec_abs>:
		endat_getangle();
}

float encoder_getangle_elec_abs(uint32_t pole_pair)
{
	if(menue_drive_data_applied.m_encoder_type == 1)
  4132bc:	4b05      	ldr	r3, [pc, #20]	; (4132d4 <encoder_getangle_elec_abs+0x18>)
  4132be:	f893 30ac 	ldrb.w	r3, [r3, #172]	; 0xac
  4132c2:	2b01      	cmp	r3, #1
  4132c4:	d004      	beq.n	4132d0 <encoder_getangle_elec_abs+0x14>
		sincos_getangle_elec(pole_pair);
	else if(menue_drive_data_applied.m_encoder_type == 2)
  4132c6:	2b02      	cmp	r3, #2
  4132c8:	d000      	beq.n	4132cc <encoder_getangle_elec_abs+0x10>
		endat_getangle_elec(pole_pair);
}
  4132ca:	4770      	bx	lr
		endat_getangle_elec(pole_pair);
  4132cc:	4b02      	ldr	r3, [pc, #8]	; (4132d8 <encoder_getangle_elec_abs+0x1c>)
  4132ce:	4718      	bx	r3
		sincos_getangle_elec(pole_pair);
  4132d0:	4b02      	ldr	r3, [pc, #8]	; (4132dc <encoder_getangle_elec_abs+0x20>)
  4132d2:	4718      	bx	r3
  4132d4:	20404ff0 	.word	0x20404ff0
  4132d8:	0041354d 	.word	0x0041354d
  4132dc:	00414129 	.word	0x00414129

004132e0 <spi_xdmac_configure>:
 
/** XDMAC channel configuration. */
xdmac_channel_config_t xdmac_tx_cfg, xdmac_rx_cfg;

void spi_xdmac_configure(Usart *const pusart, uint32_t buff_size)
{
  4132e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
// 	XDMAC_CIE_RBIE  |
// 	XDMAC_CIE_WBIE  |
// 	XDMAC_CIE_ROIE);

	/* Initialize channel config for transmitter */
	xdmac_tx_cfg.mbr_ubc = buff_size;
  4132e4:	4e20      	ldr	r6, [pc, #128]	; (413368 <spi_xdmac_configure+0x88>)
	XDMAC_CC_DIF_AHB_IF1 |
	XDMAC_CC_SAM_INCREMENTED_AM |
	XDMAC_CC_DAM_FIXED_AM |
	XDMAC_CC_PERID(USART2_DMAC_ID_TX);

	xdmac_tx_cfg.mbr_bc =  0;
  4132e6:	2500      	movs	r5, #0
	xdmac->XDMAC_CHID[channel_num].XDMAC_CNDC = config;
  4132e8:	4c20      	ldr	r4, [pc, #128]	; (41336c <spi_xdmac_configure+0x8c>)
	xdmac_tx_cfg.mbr_da = (uint32_t)&pusart->US_THR;
  4132ea:	f100 0e1c 	add.w	lr, r0, #28
	xdmac_tx_cfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |
  4132ee:	4b20      	ldr	r3, [pc, #128]	; (413370 <spi_xdmac_configure+0x90>)
{
  4132f0:	4607      	mov	r7, r0
	xdmac_tx_cfg.mbr_sa = (uint32_t)test_line;
  4132f2:	f8df a084 	ldr.w	sl, [pc, #132]	; 413378 <spi_xdmac_configure+0x98>
{
  4132f6:	468b      	mov	fp, r1
	xdmac_tx_cfg.mbr_ubc = buff_size;
  4132f8:	6031      	str	r1, [r6, #0]
	xdmac_tx_cfg.mbr_ds =  0;
	xdmac_tx_cfg.mbr_sus = 0;
	xdmac_tx_cfg.mbr_dus = 0;

	xdmac_channel_set_descriptor_control(XDMAC, ENDAT_XDMAC_TX_CH, 0);
	xdmac_configure_transfer(XDMAC, ENDAT_XDMAC_TX_CH, &xdmac_tx_cfg);
  4132fa:	4632      	mov	r2, r6
  4132fc:	f8c4 55ec 	str.w	r5, [r4, #1516]	; 0x5ec
  413300:	4620      	mov	r0, r4
  413302:	2116      	movs	r1, #22
  413304:	f8df 9074 	ldr.w	r9, [pc, #116]	; 41337c <spi_xdmac_configure+0x9c>
	xdmac_tx_cfg.mbr_da = (uint32_t)&pusart->US_THR;
  413308:	f8c6 e008 	str.w	lr, [r6, #8]
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  41330c:	f04f 0801 	mov.w	r8, #1
	xdmac_tx_cfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |
  413310:	60f3      	str	r3, [r6, #12]
	/* Initialize channel config for receiver */
	xdmac_rx_cfg.mbr_ubc = buff_size;

	xdmac_rx_cfg.mbr_da = (uint32_t)test_line;

	xdmac_rx_cfg.mbr_sa = (uint32_t)&pusart->US_RHR;
  413312:	3718      	adds	r7, #24
	xdmac_tx_cfg.mbr_sa = (uint32_t)test_line;
  413314:	f8c6 a004 	str.w	sl, [r6, #4]
	xdmac_tx_cfg.mbr_bc =  0;
  413318:	6135      	str	r5, [r6, #16]
	xdmac_tx_cfg.mbr_ds =  0;
  41331a:	6175      	str	r5, [r6, #20]
	xdmac_tx_cfg.mbr_sus = 0;
  41331c:	61b5      	str	r5, [r6, #24]
	xdmac_tx_cfg.mbr_dus = 0;
  41331e:	61f5      	str	r5, [r6, #28]
	xdmac_configure_transfer(XDMAC, ENDAT_XDMAC_TX_CH, &xdmac_tx_cfg);
  413320:	47c8      	blx	r9
	xdmac_rx_cfg.mbr_ubc = buff_size;
  413322:	4b14      	ldr	r3, [pc, #80]	; (413374 <spi_xdmac_configure+0x94>)
	xdmac->XDMAC_GIE = ( XDMAC_GIE_IE0 << channel_num) ;
  413324:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
	xdmac_rx_cfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |
  413328:	f8df e054 	ldr.w	lr, [pc, #84]	; 413380 <spi_xdmac_configure+0xa0>
	xdmac_rx_cfg.mbr_bc =  0;
	xdmac_tx_cfg.mbr_ds =  0;
	xdmac_rx_cfg.mbr_sus = 0;
	xdmac_rx_cfg.mbr_dus = 0;

	xdmac_configure_transfer(XDMAC, ENDAT_XDMAC_RX_CH, &xdmac_rx_cfg);
  41332c:	4620      	mov	r0, r4
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  41332e:	f8c4 85d0 	str.w	r8, [r4, #1488]	; 0x5d0
  413332:	461a      	mov	r2, r3
	xdmac->XDMAC_GIE = ( XDMAC_GIE_IE0 << channel_num) ;
  413334:	60e1      	str	r1, [r4, #12]
	XDMAC->XDMAC_GE = (XDMAC_GE_EN0 << ENDAT_XDMAC_TX_CH);
  413336:	61e1      	str	r1, [r4, #28]
	xdmac_configure_transfer(XDMAC, ENDAT_XDMAC_RX_CH, &xdmac_rx_cfg);
  413338:	2117      	movs	r1, #23
	xdmac_rx_cfg.mbr_ubc = buff_size;
  41333a:	f8c3 b000 	str.w	fp, [r3]
	xdmac_rx_cfg.mbr_sa = (uint32_t)&pusart->US_RHR;
  41333e:	605f      	str	r7, [r3, #4]
	xdmac_rx_cfg.mbr_da = (uint32_t)test_line;
  413340:	f8c3 a008 	str.w	sl, [r3, #8]
	xdmac_rx_cfg.mbr_bc =  0;
  413344:	611d      	str	r5, [r3, #16]
	xdmac_rx_cfg.mbr_sus = 0;
  413346:	619d      	str	r5, [r3, #24]
	xdmac_rx_cfg.mbr_dus = 0;
  413348:	61dd      	str	r5, [r3, #28]
	xdmac_rx_cfg.mbr_cfg = XDMAC_CC_TYPE_PER_TRAN |
  41334a:	f8c3 e00c 	str.w	lr, [r3, #12]
	xdmac_tx_cfg.mbr_ds =  0;
  41334e:	6175      	str	r5, [r6, #20]
	xdmac_configure_transfer(XDMAC, ENDAT_XDMAC_RX_CH, &xdmac_rx_cfg);
  413350:	47c8      	blx	r9

	xdmac_channel_set_descriptor_control(XDMAC, ENDAT_XDMAC_RX_CH, 0);

	xdmac_channel_enable_interrupt(XDMAC, ENDAT_XDMAC_RX_CH, xdmaint);
	//xdmac_channel_enable(XDMAC, ENDAT_XDMAC_RX_CH);
	XDMAC->XDMAC_GE = (XDMAC_GE_EN0 << ENDAT_XDMAC_RX_CH);
  413352:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
	xdmac->XDMAC_CHID[channel_num].XDMAC_CNDC = config;
  413356:	f8c4 562c 	str.w	r5, [r4, #1580]	; 0x62c
	xdmac->XDMAC_CHID[channel_num].XDMAC_CIE = mask;
  41335a:	f8c4 8610 	str.w	r8, [r4, #1552]	; 0x610
  41335e:	61e3      	str	r3, [r4, #28]
	xdmac->XDMAC_GIE = ( XDMAC_GIE_IE0 << channel_num) ;
  413360:	60e3      	str	r3, [r4, #12]
  413362:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413366:	bf00      	nop
  413368:	204053b4 	.word	0x204053b4
  41336c:	40078000 	.word	0x40078000
  413370:	0b014011 	.word	0x0b014011
  413374:	20405394 	.word	0x20405394
  413378:	20406cc4 	.word	0x20406cc4
  41337c:	004006d1 	.word	0x004006d1
  413380:	0c042001 	.word	0x0c042001

00413384 <endat_write_pda_packet.part.1>:
	endat_f_trials = 0;
}



uint32_t endat_write_pda_packet(char *line, uint32_t lenght)
  413384:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	if(!(USART2->US_CSR & US_CSR_TXRDY)) return 0;
	
	usart_drive_RTS_pin_low(USART2);
  413386:	4e0c      	ldr	r6, [pc, #48]	; (4133b8 <endat_write_pda_packet.part.1+0x34>)
uint32_t endat_write_pda_packet(char *line, uint32_t lenght)
  413388:	4607      	mov	r7, r0
	usart_drive_RTS_pin_low(USART2);
  41338a:	4b0c      	ldr	r3, [pc, #48]	; (4133bc <endat_write_pda_packet.part.1+0x38>)
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  41338c:	247d      	movs	r4, #125	; 0x7d
  41338e:	4630      	mov	r0, r6
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  413390:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
  413394:	4798      	blx	r3
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  413396:	4b0a      	ldr	r3, [pc, #40]	; (4133c0 <endat_write_pda_packet.part.1+0x3c>)
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  413398:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
	
	spi_disable_xdmac();
	spi_xdmac_configure(USART2, lenght);
  41339c:	4630      	mov	r0, r6
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  41339e:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
  4133a2:	4639      	mov	r1, r7
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  4133a4:	621d      	str	r5, [r3, #32]
  4133a6:	4e07      	ldr	r6, [pc, #28]	; (4133c4 <endat_write_pda_packet.part.1+0x40>)
	xdmac->XDMAC_GID = (XDMAC_GID_ID0 << channel_num);
  4133a8:	611d      	str	r5, [r3, #16]
	xdmac->XDMAC_CHID[channel_num].XDMAC_CID = mask;
  4133aa:	f8c3 45d4 	str.w	r4, [r3, #1492]	; 0x5d4
	xdmac->XDMAC_GD =(XDMAC_GD_DI0 << channel_num);
  4133ae:	621a      	str	r2, [r3, #32]
	xdmac->XDMAC_GID = (XDMAC_GID_ID0 << channel_num);
  4133b0:	611a      	str	r2, [r3, #16]
  4133b2:	47b0      	blx	r6
	
	return 1;
}
  4133b4:	2001      	movs	r0, #1
  4133b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4133b8:	4002c000 	.word	0x4002c000
  4133bc:	00412669 	.word	0x00412669
  4133c0:	40078000 	.word	0x40078000
  4133c4:	004132e1 	.word	0x004132e1

004133c8 <endat_init>:
{
  4133c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	pio_set_output(PIOD, PIO_PD18|PIO_PD19, LOW, DISABLE, ENABLE);
  4133cc:	2201      	movs	r2, #1
{
  4133ce:	b086      	sub	sp, #24
	const usart_spi_opt_t usart2Temp_opt =
  4133d0:	4b23      	ldr	r3, [pc, #140]	; (413460 <endat_init+0x98>)

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  4133d2:	f44f 4700 	mov.w	r7, #32768	; 0x8000
	pio_set_output(PIOD, PIO_PD18|PIO_PD19, LOW, DISABLE, ENABLE);
  4133d6:	9200      	str	r2, [sp, #0]
	const usart_spi_opt_t usart2Temp_opt =
  4133d8:	ad02      	add	r5, sp, #8
	pio_set_output(PIOD, PIO_PD18|PIO_PD19, LOW, DISABLE, ENABLE);
  4133da:	4c22      	ldr	r4, [pc, #136]	; (413464 <endat_init+0x9c>)
  4133dc:	4e22      	ldr	r6, [pc, #136]	; (413468 <endat_init+0xa0>)
	pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD15);
  4133de:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 413494 <endat_init+0xcc>
	const usart_spi_opt_t usart2Temp_opt =
  4133e2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  4133e4:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	pio_set_output(PIOD, PIO_PD18|PIO_PD19, LOW, DISABLE, ENABLE);
  4133e8:	2300      	movs	r3, #0
  4133ea:	4620      	mov	r0, r4
  4133ec:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
  4133f0:	461a      	mov	r2, r3
  4133f2:	47b0      	blx	r6
	pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD15);
  4133f4:	4620      	mov	r0, r4
  4133f6:	463a      	mov	r2, r7
  4133f8:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4133fc:	47c0      	blx	r8
  4133fe:	4e1b      	ldr	r6, [pc, #108]	; (41346c <endat_init+0xa4>)
	pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD16);
  413400:	4620      	mov	r0, r4
  413402:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  413406:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  41340a:	47c0      	blx	r8
	pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD17);
  41340c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  413410:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  413414:	4620      	mov	r0, r4
	usart_drive_RTS_pin_low(USART2);
  413416:	4c16      	ldr	r4, [pc, #88]	; (413470 <endat_init+0xa8>)
	pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD17);
  413418:	47c0      	blx	r8
  41341a:	f8c6 7180 	str.w	r7, [r6, #384]	; 0x180
 	pmc_enable_periph_clk(ID_USART2);
  41341e:	200f      	movs	r0, #15
  413420:	4b14      	ldr	r3, [pc, #80]	; (413474 <endat_init+0xac>)
  413422:	4798      	blx	r3
	usart_drive_RTS_pin_low(USART2);
  413424:	4620      	mov	r0, r4
  413426:	4b14      	ldr	r3, [pc, #80]	; (413478 <endat_init+0xb0>)
  413428:	4798      	blx	r3
	usart_spi_force_chip_select(USART2);
  41342a:	4620      	mov	r0, r4
  41342c:	4b13      	ldr	r3, [pc, #76]	; (41347c <endat_init+0xb4>)
  41342e:	4798      	blx	r3
 	usart_init_spi_master(USART2, &usart2Temp_opt, MAIN_PERIF_FREQ);
  413430:	4629      	mov	r1, r5
  413432:	4a13      	ldr	r2, [pc, #76]	; (413480 <endat_init+0xb8>)
  413434:	4620      	mov	r0, r4
  413436:	4b13      	ldr	r3, [pc, #76]	; (413484 <endat_init+0xbc>)
  413438:	4798      	blx	r3
	usart_lin_disable_pdc_mode(USART2);
  41343a:	4620      	mov	r0, r4
  41343c:	4b12      	ldr	r3, [pc, #72]	; (413488 <endat_init+0xc0>)
  41343e:	4798      	blx	r3
 	usart_enable_tx(USART2);
  413440:	4620      	mov	r0, r4
  413442:	4b12      	ldr	r3, [pc, #72]	; (41348c <endat_init+0xc4>)
  413444:	4798      	blx	r3
	usart_enable_rx(USART2);	
  413446:	4620      	mov	r0, r4
  413448:	4b11      	ldr	r3, [pc, #68]	; (413490 <endat_init+0xc8>)
  41344a:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHPR[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  41344c:	2300      	movs	r3, #0
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  41344e:	f8c6 7180 	str.w	r7, [r6, #384]	; 0x180
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  413452:	f886 330f 	strb.w	r3, [r6, #783]	; 0x30f
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  413456:	6037      	str	r7, [r6, #0]
}
  413458:	b006      	add	sp, #24
  41345a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41345e:	bf00      	nop
  413460:	0041cc48 	.word	0x0041cc48
  413464:	400e1400 	.word	0x400e1400
  413468:	00417515 	.word	0x00417515
  41346c:	e000e100 	.word	0xe000e100
  413470:	4002c000 	.word	0x4002c000
  413474:	00417a25 	.word	0x00417a25
  413478:	00412669 	.word	0x00412669
  41347c:	00412671 	.word	0x00412671
  413480:	08f0d180 	.word	0x08f0d180
  413484:	0041257d 	.word	0x0041257d
  413488:	00412639 	.word	0x00412639
  41348c:	00412645 	.word	0x00412645
  413490:	0041264d 	.word	0x0041264d
  413494:	00417445 	.word	0x00417445

00413498 <inverMSG>:
	}
}
void inverMSG(char start)
{
	char i;
	for (i=start; ((i<ENDAT_BUFFER_SIZE) && (i<start + 4)); i++)
  413498:	2805      	cmp	r0, #5
  41349a:	d827      	bhi.n	4134ec <inverMSG+0x54>
  41349c:	1c41      	adds	r1, r0, #1
{
  41349e:	b5f0      	push	{r4, r5, r6, r7, lr}
  4134a0:	b2c9      	uxtb	r1, r1
  4134a2:	4d13      	ldr	r5, [pc, #76]	; (4134f0 <inverMSG+0x58>)
	for (i=start; ((i<ENDAT_BUFFER_SIZE) && (i<start + 4)); i++)
  4134a4:	1cc7      	adds	r7, r0, #3
	{
		test_line[i] = invertbyte(test_line[i]);
  4134a6:	5c2b      	ldrb	r3, [r5, r0]
	for (i=start; ((i<ENDAT_BUFFER_SIZE) && (i<start + 4)); i++)
  4134a8:	b2cc      	uxtb	r4, r1
  4134aa:	1c4e      	adds	r6, r1, #1
	inv_byte = (inv_byte & 0xF0) >> 4 | (inv_byte & 0x0F) << 4;
  4134ac:	011a      	lsls	r2, r3, #4
	for (i=start; ((i<ENDAT_BUFFER_SIZE) && (i<start + 4)); i++)
  4134ae:	2c05      	cmp	r4, #5
	inv_byte = (inv_byte & 0xF0) >> 4 | (inv_byte & 0x0F) << 4;
  4134b0:	ea42 1213 	orr.w	r2, r2, r3, lsr #4
	inv_byte = (inv_byte & 0xCC) >> 2 | (inv_byte & 0x33) << 2;
  4134b4:	b2d2      	uxtb	r2, r2
  4134b6:	ea4f 0382 	mov.w	r3, r2, lsl #2
  4134ba:	ea4f 0ea2 	mov.w	lr, r2, asr #2
  4134be:	f003 03cc 	and.w	r3, r3, #204	; 0xcc
  4134c2:	f00e 0233 	and.w	r2, lr, #51	; 0x33
	inv_byte = (inv_byte & 0xAA) >> 1 | (inv_byte & 0x55) << 1;
  4134c6:	ea43 0302 	orr.w	r3, r3, r2
  4134ca:	ea4f 0263 	mov.w	r2, r3, asr #1
  4134ce:	ea4f 0343 	mov.w	r3, r3, lsl #1
  4134d2:	f002 0255 	and.w	r2, r2, #85	; 0x55
  4134d6:	f023 0355 	bic.w	r3, r3, #85	; 0x55
  4134da:	ea43 0302 	orr.w	r3, r3, r2
		test_line[i] = invertbyte(test_line[i]);
  4134de:	542b      	strb	r3, [r5, r0]
	for (i=start; ((i<ENDAT_BUFFER_SIZE) && (i<start + 4)); i++)
  4134e0:	4608      	mov	r0, r1
  4134e2:	d802      	bhi.n	4134ea <inverMSG+0x52>
  4134e4:	428f      	cmp	r7, r1
  4134e6:	4631      	mov	r1, r6
  4134e8:	dadd      	bge.n	4134a6 <inverMSG+0xe>
  4134ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4134ec:	4770      	bx	lr
  4134ee:	bf00      	nop
  4134f0:	20406cc4 	.word	0x20406cc4

004134f4 <USART2_Handler>:
	}
	//encoder_endat_filter();	
}

void USART2_Handler(void)
{
  4134f4:	b510      	push	{r4, lr}
	
	if(usart_is_tx_empty(USART2))
  4134f6:	4c0e      	ldr	r4, [pc, #56]	; (413530 <USART2_Handler+0x3c>)
  4134f8:	4b0e      	ldr	r3, [pc, #56]	; (413534 <USART2_Handler+0x40>)
  4134fa:	4620      	mov	r0, r4
  4134fc:	4798      	blx	r3
  4134fe:	b900      	cbnz	r0, 413502 <USART2_Handler+0xe>
  413500:	bd10      	pop	{r4, pc}
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  413502:	4b0d      	ldr	r3, [pc, #52]	; (413538 <USART2_Handler+0x44>)
  413504:	f44f 2280 	mov.w	r2, #262144	; 0x40000
	{
		//first char of the Endat frame sent
		endat_txena(0); //enable recieve
		usart_disable_interrupt(USART2, US_IER_TXEMPTY);
  413508:	f44f 7100 	mov.w	r1, #512	; 0x200
  41350c:	4620      	mov	r0, r4
  41350e:	635a      	str	r2, [r3, #52]	; 0x34
  413510:	4b0a      	ldr	r3, [pc, #40]	; (41353c <USART2_Handler+0x48>)
  413512:	4798      	blx	r3
	if(!(USART2->US_CSR & US_CSR_TXRDY)) return 0;
  413514:	6963      	ldr	r3, [r4, #20]
  413516:	079b      	lsls	r3, r3, #30
  413518:	d405      	bmi.n	413526 <USART2_Handler+0x32>
		endat_write_pda_packet(test_line, ENDAT_BUFFER_SIZE);
		endat_stage = 0;
  41351a:	2300      	movs	r3, #0
  41351c:	4908      	ldr	r1, [pc, #32]	; (413540 <USART2_Handler+0x4c>)
		endat_stage_timer = 0;
  41351e:	4a09      	ldr	r2, [pc, #36]	; (413544 <USART2_Handler+0x50>)
		endat_stage = 0;
  413520:	600b      	str	r3, [r1, #0]
		endat_stage_timer = 0;
  413522:	6013      	str	r3, [r2, #0]
  413524:	bd10      	pop	{r4, pc}
  413526:	4b08      	ldr	r3, [pc, #32]	; (413548 <USART2_Handler+0x54>)
  413528:	2006      	movs	r0, #6
  41352a:	4798      	blx	r3
  41352c:	e7f5      	b.n	41351a <USART2_Handler+0x26>
  41352e:	bf00      	nop
  413530:	4002c000 	.word	0x4002c000
  413534:	00412681 	.word	0x00412681
  413538:	400e1400 	.word	0x400e1400
  41353c:	0041265d 	.word	0x0041265d
  413540:	20400ac4 	.word	0x20400ac4
  413544:	20400ac8 	.word	0x20400ac8
  413548:	00413385 	.word	0x00413385

0041354c <endat_getangle_elec>:
}

float endat_getangle_elec(uint32_t pole_pair)
{
	float ret_val;
	ret_val = ((endat_pos * pole_pair) % ENDAT_MAX_VAL) * 360;
  41354c:	4b08      	ldr	r3, [pc, #32]	; (413570 <endat_getangle_elec+0x24>)
  41354e:	f44f 72b4 	mov.w	r2, #360	; 0x168
  413552:	681b      	ldr	r3, [r3, #0]
  413554:	fb03 f000 	mul.w	r0, r3, r0
  413558:	f3c0 000c 	ubfx	r0, r0, #0, #13
  41355c:	fb02 f000 	mul.w	r0, r2, r0
	ret_val /= ENDAT_MAX_VAL;
	return ret_val;
}
  413560:	ee07 0a90 	vmov	s15, r0
  413564:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
  413568:	ee17 0a90 	vmov	r0, s15
  41356c:	4770      	bx	lr
  41356e:	bf00      	nop
  413570:	20406cc0 	.word	0x20406cc0

00413574 <makeCRCPos>:
{
	return endat_f_bits;
}

uint32_t makeCRCPos(uint16_t clocks, uint16_t AlmPos)
{
  413574:	b5f0      	push	{r4, r5, r6, r7, lr}
  413576:	b089      	sub	sp, #36	; 0x24
	uint8_t ex; //auxiliary variable
	uint32_t crc = 0;  //determined CRC code
	signed int i;
	
	for(i=0; i<5; i++) //set all flip-flops to 1
		ff[i] = 1; 
  413578:	2301      	movs	r3, #1
  41357a:	f10d 020b 	add.w	r2, sp, #11
  41357e:	f10d 041a 	add.w	r4, sp, #26
  413582:	f88d 3004 	strb.w	r3, [sp, #4]
  413586:	f88d 3005 	strb.w	r3, [sp, #5]
  41358a:	f88d 3006 	strb.w	r3, [sp, #6]
  41358e:	f88d 3007 	strb.w	r3, [sp, #7]
  413592:	f88d 3008 	strb.w	r3, [sp, #8]
	
	for (i=0; i<15; i++) // transfer pos bits into code array
	{
		code[i] = (AlmPos & 1) ? 1 : 0;
  413596:	f001 0301 	and.w	r3, r1, #1
  41359a:	0849      	lsrs	r1, r1, #1
  41359c:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (i=0; i<15; i++) // transfer pos bits into code array
  4135a0:	42a2      	cmp	r2, r4
  4135a2:	d1f8      	bne.n	413596 <makeCRCPos+0x22>
		AlmPos >>= 1;
	}
	
	for(i=0; i<clocks; i++) // calculate the CRC
  4135a4:	b390      	cbz	r0, 41360c <makeCRCPos+0x98>
  4135a6:	2401      	movs	r4, #1
  4135a8:	a903      	add	r1, sp, #12
  4135aa:	4625      	mov	r5, r4
  4135ac:	4408      	add	r0, r1
  4135ae:	46a6      	mov	lr, r4
  4135b0:	4626      	mov	r6, r4
  4135b2:	4627      	mov	r7, r4
  4135b4:	e001      	b.n	4135ba <makeCRCPos+0x46>
	{
		ex = ff[4] ^ code[i];
		ff[4] = ff[3];
		ff[3] = ff[2] ^ ex;
		ff[2] = ff[1];
		ff[1] = ff[0] ^ ex;
  4135b6:	4665      	mov	r5, ip
		ff[3] = ff[2] ^ ex;
  4135b8:	4616      	mov	r6, r2
		ex = ff[4] ^ code[i];
  4135ba:	f811 3b01 	ldrb.w	r3, [r1], #1
  4135be:	407b      	eors	r3, r7
	for(i=0; i<clocks; i++) // calculate the CRC
  4135c0:	4281      	cmp	r1, r0
  4135c2:	4637      	mov	r7, r6
		ex = ff[4] ^ code[i];
  4135c4:	b2db      	uxtb	r3, r3
		ff[3] = ff[2] ^ ex;
  4135c6:	ea83 020e 	eor.w	r2, r3, lr
		ff[1] = ff[0] ^ ex;
  4135ca:	ea83 0c04 	eor.w	ip, r3, r4
  4135ce:	46ae      	mov	lr, r5
		ex = ff[4] ^ code[i];
  4135d0:	461c      	mov	r4, r3
		ff[3] = ff[2] ^ ex;
  4135d2:	b2d2      	uxtb	r2, r2
	for(i=0; i<clocks; i++) // calculate the CRC
  4135d4:	d1ef      	bne.n	4135b6 <makeCRCPos+0x42>
  4135d6:	f88d 6008 	strb.w	r6, [sp, #8]
  4135da:	f88d 2007 	strb.w	r2, [sp, #7]
  4135de:	f88d 5006 	strb.w	r5, [sp, #6]
  4135e2:	f88d c005 	strb.w	ip, [sp, #5]
  4135e6:	f88d 3004 	strb.w	r3, [sp, #4]
  4135ea:	aa01      	add	r2, sp, #4
  4135ec:	f10d 0109 	add.w	r1, sp, #9
  4135f0:	2000      	movs	r0, #0
		ff[0] = ex;
	}
	
	for(i=0; i<5; i++)
	{
		ff[i] = ff[i] ? 0 : 1;
  4135f2:	fab3 f383 	clz	r3, r3
  4135f6:	095b      	lsrs	r3, r3, #5
  4135f8:	f802 3b01 	strb.w	r3, [r2], #1
	for(i=0; i<5; i++)
  4135fc:	4291      	cmp	r1, r2
		crc <<= 1;
		crc |= ff[i];
  4135fe:	ea43 0040 	orr.w	r0, r3, r0, lsl #1
	for(i=0; i<5; i++)
  413602:	d001      	beq.n	413608 <makeCRCPos+0x94>
  413604:	7813      	ldrb	r3, [r2, #0]
  413606:	e7f4      	b.n	4135f2 <makeCRCPos+0x7e>
	}
	
	return crc;
  413608:	b009      	add	sp, #36	; 0x24
  41360a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for(i=0; i<clocks; i++) // calculate the CRC
  41360c:	2301      	movs	r3, #1
  41360e:	e7ec      	b.n	4135ea <makeCRCPos+0x76>

00413610 <endat_frame_decode>:
{
  413610:	b570      	push	{r4, r5, r6, lr}
  413612:	4e27      	ldr	r6, [pc, #156]	; (4136b0 <endat_frame_decode+0xa0>)
  413614:	2400      	movs	r4, #0
  413616:	4633      	mov	r3, r6
		if (test_line[i])
  413618:	f813 2b01 	ldrb.w	r2, [r3], #1
  41361c:	b2e0      	uxtb	r0, r4
  41361e:	b99a      	cbnz	r2, 413648 <endat_frame_decode+0x38>
  413620:	3401      	adds	r4, #1
	for (i=0; i<ENDAT_BUFFER_SIZE; i++)
  413622:	2c06      	cmp	r4, #6
  413624:	d1f8      	bne.n	413618 <endat_frame_decode+0x8>
	test_line[i] &= 0x3F;
  413626:	79b3      	ldrb	r3, [r6, #6]
  413628:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  41362c:	71b3      	strb	r3, [r6, #6]
	if (endat_f_trials < ENDAT_MAXIMUM_COMM_TRIALS)
  41362e:	4a21      	ldr	r2, [pc, #132]	; (4136b4 <endat_frame_decode+0xa4>)
  413630:	6813      	ldr	r3, [r2, #0]
  413632:	2b09      	cmp	r3, #9
  413634:	d802      	bhi.n	41363c <endat_frame_decode+0x2c>
		++endat_f_trials;
  413636:	3301      	adds	r3, #1
  413638:	6013      	str	r3, [r2, #0]
  41363a:	bd70      	pop	{r4, r5, r6, pc}
		endat_err_set;
  41363c:	4a1e      	ldr	r2, [pc, #120]	; (4136b8 <endat_frame_decode+0xa8>)
  41363e:	4b1f      	ldr	r3, [pc, #124]	; (4136bc <endat_frame_decode+0xac>)
  413640:	7810      	ldrb	r0, [r2, #0]
}
  413642:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		endat_err_set;
  413646:	4718      	bx	r3
	if((ENDAT_BUFFER_SIZE - i) > 4 )
  413648:	f1c4 0306 	rsb	r3, r4, #6
	test_line[i] &= 0x3F;
  41364c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
	if((ENDAT_BUFFER_SIZE - i) > 4 )
  413650:	2b04      	cmp	r3, #4
	test_line[i] &= 0x3F;
  413652:	5532      	strb	r2, [r6, r4]
	if((ENDAT_BUFFER_SIZE - i) > 4 )
  413654:	ddeb      	ble.n	41362e <endat_frame_decode+0x1e>
		inverMSG(i); // invert data from MSB first to LSB first
  413656:	4b1a      	ldr	r3, [pc, #104]	; (4136c0 <endat_frame_decode+0xb0>)
  413658:	4798      	blx	r3
		temp_pos = *pos_crc_frame_p;
  41365a:	5935      	ldr	r5, [r6, r4]
		*pos_crc_frame_p = 0;
  41365c:	2300      	movs	r3, #0
  41365e:	5133      	str	r3, [r6, r4]
		if (temp_pos)
  413660:	b16d      	cbz	r5, 41367e <endat_frame_decode+0x6e>
			while((temp_pos&1) == 0) temp_pos = (temp_pos >> 1);
  413662:	07e9      	lsls	r1, r5, #31
  413664:	d501      	bpl.n	41366a <endat_frame_decode+0x5a>
  413666:	e01c      	b.n	4136a2 <endat_frame_decode+0x92>
  413668:	461d      	mov	r5, r3
  41366a:	086b      	lsrs	r3, r5, #1
  41366c:	07da      	lsls	r2, r3, #31
  41366e:	d5fb      	bpl.n	413668 <endat_frame_decode+0x58>
  413670:	08ac      	lsrs	r4, r5, #2
  413672:	f3c5 4544 	ubfx	r5, r5, #17, #5
  413676:	f3c4 040e 	ubfx	r4, r4, #0, #15
  41367a:	b2a1      	uxth	r1, r4
  41367c:	e001      	b.n	413682 <endat_frame_decode+0x72>
  41367e:	462c      	mov	r4, r5
  413680:	4629      	mov	r1, r5
		if (makeCRCPos(15, temp_pos) == temp_crc)
  413682:	200f      	movs	r0, #15
  413684:	4b0f      	ldr	r3, [pc, #60]	; (4136c4 <endat_frame_decode+0xb4>)
  413686:	4798      	blx	r3
  413688:	42a8      	cmp	r0, r5
  41368a:	d1d0      	bne.n	41362e <endat_frame_decode+0x1e>
			endat_f_bits = temp_pos & 3;
  41368c:	f004 0503 	and.w	r5, r4, #3
  413690:	480d      	ldr	r0, [pc, #52]	; (4136c8 <endat_frame_decode+0xb8>)
			temp_pos = temp_pos >> 2;
  413692:	08a4      	lsrs	r4, r4, #2
			endat_posR = temp_pos;
  413694:	490d      	ldr	r1, [pc, #52]	; (4136cc <endat_frame_decode+0xbc>)
	endat_f_trials = 0;
  413696:	4b07      	ldr	r3, [pc, #28]	; (4136b4 <endat_frame_decode+0xa4>)
  413698:	2200      	movs	r2, #0
			endat_f_bits = temp_pos & 3;
  41369a:	7005      	strb	r5, [r0, #0]
			endat_posR = temp_pos;
  41369c:	600c      	str	r4, [r1, #0]
	endat_f_trials = 0;
  41369e:	601a      	str	r2, [r3, #0]
  4136a0:	bd70      	pop	{r4, r5, r6, pc}
  4136a2:	086c      	lsrs	r4, r5, #1
  4136a4:	f3c5 4504 	ubfx	r5, r5, #16, #5
  4136a8:	f3c4 040e 	ubfx	r4, r4, #0, #15
  4136ac:	b2a1      	uxth	r1, r4
  4136ae:	e7e8      	b.n	413682 <endat_frame_decode+0x72>
  4136b0:	20406cc4 	.word	0x20406cc4
  4136b4:	20400ac0 	.word	0x20400ac0
  4136b8:	20406ca3 	.word	0x20406ca3
  4136bc:	0041282d 	.word	0x0041282d
  4136c0:	00413499 	.word	0x00413499
  4136c4:	00413575 	.word	0x00413575
  4136c8:	20406cbc 	.word	0x20406cbc
  4136cc:	20406cc0 	.word	0x20406cc0

004136d0 <endat_handler>:
	if(++endat_stage_timer > 10) 
  4136d0:	4a20      	ldr	r2, [pc, #128]	; (413754 <endat_handler+0x84>)
{
  4136d2:	b570      	push	{r4, r5, r6, lr}
	if(++endat_stage_timer > 10) 
  4136d4:	6813      	ldr	r3, [r2, #0]
  4136d6:	3301      	adds	r3, #1
  4136d8:	2b0a      	cmp	r3, #10
  4136da:	d806      	bhi.n	4136ea <endat_handler+0x1a>
 	if(usart_is_tx_empty(USART2) && usart_is_tx_ready(USART2) && (endat_stage == 0))
  4136dc:	4c1e      	ldr	r4, [pc, #120]	; (413758 <endat_handler+0x88>)
	if(++endat_stage_timer > 10) 
  4136de:	6013      	str	r3, [r2, #0]
 	if(usart_is_tx_empty(USART2) && usart_is_tx_ready(USART2) && (endat_stage == 0))
  4136e0:	4620      	mov	r0, r4
  4136e2:	4b1e      	ldr	r3, [pc, #120]	; (41375c <endat_handler+0x8c>)
  4136e4:	4798      	blx	r3
  4136e6:	b950      	cbnz	r0, 4136fe <endat_handler+0x2e>
  4136e8:	bd70      	pop	{r4, r5, r6, pc}
		endat_stage_timer = 0;
  4136ea:	2300      	movs	r3, #0
		endat_stage = 0;
  4136ec:	491c      	ldr	r1, [pc, #112]	; (413760 <endat_handler+0x90>)
 	if(usart_is_tx_empty(USART2) && usart_is_tx_ready(USART2) && (endat_stage == 0))
  4136ee:	4c1a      	ldr	r4, [pc, #104]	; (413758 <endat_handler+0x88>)
		endat_stage_timer = 0;
  4136f0:	6013      	str	r3, [r2, #0]
		endat_stage = 0;
  4136f2:	600b      	str	r3, [r1, #0]
 	if(usart_is_tx_empty(USART2) && usart_is_tx_ready(USART2) && (endat_stage == 0))
  4136f4:	4620      	mov	r0, r4
  4136f6:	4b19      	ldr	r3, [pc, #100]	; (41375c <endat_handler+0x8c>)
  4136f8:	4798      	blx	r3
  4136fa:	2800      	cmp	r0, #0
  4136fc:	d0f4      	beq.n	4136e8 <endat_handler+0x18>
  4136fe:	4620      	mov	r0, r4
  413700:	4b18      	ldr	r3, [pc, #96]	; (413764 <endat_handler+0x94>)
  413702:	4798      	blx	r3
  413704:	2800      	cmp	r0, #0
  413706:	d0ef      	beq.n	4136e8 <endat_handler+0x18>
  413708:	4e15      	ldr	r6, [pc, #84]	; (413760 <endat_handler+0x90>)
  41370a:	6835      	ldr	r5, [r6, #0]
  41370c:	2d00      	cmp	r5, #0
  41370e:	d1eb      	bne.n	4136e8 <endat_handler+0x18>
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  413710:	4b15      	ldr	r3, [pc, #84]	; (413768 <endat_handler+0x98>)
  413712:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  413716:	f44f 2180 	mov.w	r1, #262144	; 0x40000
		endat_frame_decode();
  41371a:	4a14      	ldr	r2, [pc, #80]	; (41376c <endat_handler+0x9c>)
  41371c:	6318      	str	r0, [r3, #48]	; 0x30
  41371e:	6319      	str	r1, [r3, #48]	; 0x30
  413720:	4790      	blx	r2
		*endat_buffer = 0;
  413722:	4b13      	ldr	r3, [pc, #76]	; (413770 <endat_handler+0xa0>)
		test_line[0] = invertbyte((0x7 << 2));
  413724:	2238      	movs	r2, #56	; 0x38
		endat_stage = 1;
  413726:	2001      	movs	r0, #1
		*endat_buffer = 0;
  413728:	705d      	strb	r5, [r3, #1]
  41372a:	709d      	strb	r5, [r3, #2]
  41372c:	70dd      	strb	r5, [r3, #3]
		test_line[0] = invertbyte((0x7 << 2));
  41372e:	701a      	strb	r2, [r3, #0]
		endat_stage = 1;
  413730:	6030      	str	r0, [r6, #0]
	if(!(USART2->US_CSR & US_CSR_TXRDY)) return 0;
  413732:	6962      	ldr	r2, [r4, #20]
		*endat_buffer = 0;
  413734:	711d      	strb	r5, [r3, #4]
  413736:	715d      	strb	r5, [r3, #5]
  413738:	719d      	strb	r5, [r3, #6]
  41373a:	71dd      	strb	r5, [r3, #7]
	if(!(USART2->US_CSR & US_CSR_TXRDY)) return 0;
  41373c:	0793      	lsls	r3, r2, #30
  41373e:	d406      	bmi.n	41374e <endat_handler+0x7e>
		usart_enable_interrupt(USART2, US_IER_TXEMPTY);// generate interrupt after sending the first char
  413740:	f44f 7100 	mov.w	r1, #512	; 0x200
  413744:	4804      	ldr	r0, [pc, #16]	; (413758 <endat_handler+0x88>)
  413746:	4b0b      	ldr	r3, [pc, #44]	; (413774 <endat_handler+0xa4>)
}
  413748:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		usart_enable_interrupt(USART2, US_IER_TXEMPTY);// generate interrupt after sending the first char
  41374c:	4718      	bx	r3
  41374e:	4b0a      	ldr	r3, [pc, #40]	; (413778 <endat_handler+0xa8>)
  413750:	4798      	blx	r3
  413752:	e7f5      	b.n	413740 <endat_handler+0x70>
  413754:	20400ac8 	.word	0x20400ac8
  413758:	4002c000 	.word	0x4002c000
  41375c:	00412681 	.word	0x00412681
  413760:	20400ac4 	.word	0x20400ac4
  413764:	00412679 	.word	0x00412679
  413768:	400e1400 	.word	0x400e1400
  41376c:	00413611 	.word	0x00413611
  413770:	20406cc4 	.word	0x20406cc4
  413774:	00412659 	.word	0x00412659
  413778:	00413385 	.word	0x00413385

0041377c <inc_init>:
float f_enc_omega_hat = 0, filtered_enc_omega_hat = 0;
float f_enc_acc_hat = 0, filtered_enc_acc_hat = 0;
float f_enc_theta_hat_frac = 0;

void inc_init()
{
  41377c:	b510      	push	{r4, lr}
	//set TC0 as qdec unit
	pmc_enable_periph_clk(ID_TC0);
  41377e:	4b1a      	ldr	r3, [pc, #104]	; (4137e8 <inc_init+0x6c>)
  413780:	2017      	movs	r0, #23
  413782:	4798      	blx	r3
	//set TIOA0 periph
	pio_set_peripheral(PIOA, PIO_PERIPH_B, PIO_PA0);
  413784:	4c19      	ldr	r4, [pc, #100]	; (4137ec <inc_init+0x70>)
  413786:	2201      	movs	r2, #1
  413788:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  41378c:	4818      	ldr	r0, [pc, #96]	; (4137f0 <inc_init+0x74>)
  41378e:	47a0      	blx	r4
	//set TIOB1 periph
	pio_set_peripheral(PIOA,PIO_PERIPH_B,PIO_PA16);
  413790:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  413794:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  413798:	4815      	ldr	r0, [pc, #84]	; (4137f0 <inc_init+0x74>)
  41379a:	47a0      	blx	r4
	//set TIOB0 periph
	pio_set_peripheral(PIOA,PIO_PERIPH_B,PIO_PA1);
  41379c:	2202      	movs	r2, #2
  41379e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4137a2:	4813      	ldr	r0, [pc, #76]	; (4137f0 <inc_init+0x74>)
  4137a4:	47a0      	blx	r4
	
	tc_init(TC0,0,TC_CMR_TCCLKS_XC0); //
  4137a6:	4c13      	ldr	r4, [pc, #76]	; (4137f4 <inc_init+0x78>)
  4137a8:	2205      	movs	r2, #5
  4137aa:	2100      	movs	r1, #0
  4137ac:	4812      	ldr	r0, [pc, #72]	; (4137f8 <inc_init+0x7c>)
  4137ae:	47a0      	blx	r4
	tc_init(TC0,1,TC_CMR_TCCLKS_XC0); //
  4137b0:	2101      	movs	r1, #1
  4137b2:	2205      	movs	r2, #5
  4137b4:	4810      	ldr	r0, [pc, #64]	; (4137f8 <inc_init+0x7c>)
  4137b6:	47a0      	blx	r4
	//tc_init(TC0,2,TC_CMR_TCCLKS_XC0|TC_CMR_WAVSEL_UP); //
	
	
	if (menue_drive_data_setup.m_pg_direction == 1)
  4137b8:	4b10      	ldr	r3, [pc, #64]	; (4137fc <inc_init+0x80>)
	{
		tc_set_block_mode(TC0, TC_BMR_QDEN|TC_BMR_POSEN|TC_BMR_SWAP);
	} 
	else
	{
		tc_set_block_mode(TC0, TC_BMR_QDEN|TC_BMR_POSEN/*|TC_BMR_EDGPHA*/);
  4137ba:	480f      	ldr	r0, [pc, #60]	; (4137f8 <inc_init+0x7c>)
	if (menue_drive_data_setup.m_pg_direction == 1)
  4137bc:	f893 30ad 	ldrb.w	r3, [r3, #173]	; 0xad
	}
	
	
	tc_start(TC0,0);
  4137c0:	4c0f      	ldr	r4, [pc, #60]	; (413800 <inc_init+0x84>)
	if (menue_drive_data_setup.m_pg_direction == 1)
  4137c2:	2b01      	cmp	r3, #1
		tc_set_block_mode(TC0, TC_BMR_QDEN|TC_BMR_POSEN/*|TC_BMR_EDGPHA*/);
  4137c4:	4b0f      	ldr	r3, [pc, #60]	; (413804 <inc_init+0x88>)
		tc_set_block_mode(TC0, TC_BMR_QDEN|TC_BMR_POSEN|TC_BMR_SWAP);
  4137c6:	bf0c      	ite	eq
  4137c8:	490f      	ldreq	r1, [pc, #60]	; (413808 <inc_init+0x8c>)
		tc_set_block_mode(TC0, TC_BMR_QDEN|TC_BMR_POSEN/*|TC_BMR_EDGPHA*/);
  4137ca:	f44f 7140 	movne.w	r1, #768	; 0x300
  4137ce:	4798      	blx	r3
	tc_start(TC0,0);
  4137d0:	2100      	movs	r1, #0
  4137d2:	4809      	ldr	r0, [pc, #36]	; (4137f8 <inc_init+0x7c>)
  4137d4:	47a0      	blx	r4
	tc_start(TC0,1);
  4137d6:	2101      	movs	r1, #1
  4137d8:	4807      	ldr	r0, [pc, #28]	; (4137f8 <inc_init+0x7c>)
  4137da:	47a0      	blx	r4
	tc_start(TC0,2);
  4137dc:	4623      	mov	r3, r4
  4137de:	2102      	movs	r1, #2
  4137e0:	4805      	ldr	r0, [pc, #20]	; (4137f8 <inc_init+0x7c>)
}
  4137e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	tc_start(TC0,2);
  4137e6:	4718      	bx	r3
  4137e8:	00417a25 	.word	0x00417a25
  4137ec:	00417445 	.word	0x00417445
  4137f0:	400e0e00 	.word	0x400e0e00
  4137f4:	00412689 	.word	0x00412689
  4137f8:	4000c000 	.word	0x4000c000
  4137fc:	204050e8 	.word	0x204050e8
  413800:	004126a9 	.word	0x004126a9
  413804:	004126a1 	.word	0x004126a1
  413808:	00010300 	.word	0x00010300

0041380c <sincos_store_phs_adc_val>:

uint16_t sincos_phase_adc_reading[2];
void sincos_store_phs_adc_val(uint16_t *adc_reading)
{
	sincos_phase_adc_reading[0] = adc_reading[0];
  41380c:	8802      	ldrh	r2, [r0, #0]
  41380e:	4b02      	ldr	r3, [pc, #8]	; (413818 <sincos_store_phs_adc_val+0xc>)
  413810:	801a      	strh	r2, [r3, #0]
	sincos_phase_adc_reading[1] = adc_reading[1];
  413812:	8842      	ldrh	r2, [r0, #2]
  413814:	805a      	strh	r2, [r3, #2]
  413816:	4770      	bx	lr
  413818:	20406cec 	.word	0x20406cec

0041381c <sincos_store_val>:
fixedpt enc_theta_frac = 0;
#define SINVALMAX /*3822*/3980
// hold a decmal val of less than 1 enc count
fixedpt enc_phase = 0;	
void sincos_store_val(void)
{
  41381c:	b508      	push	{r3, lr}
	uint32_t i;
	fixedpt tmp_enc_phase = 0;
	
	if( sincos_phase_adc_reading[0] > SINVALMAX) sincos_phase_adc_reading[0] = SINVALMAX;
  41381e:	4b24      	ldr	r3, [pc, #144]	; (4138b0 <sincos_store_val+0x94>)
  413820:	f640 728c 	movw	r2, #3980	; 0xf8c
  413824:	8818      	ldrh	r0, [r3, #0]
  413826:	4290      	cmp	r0, r2
  413828:	d82d      	bhi.n	413886 <sincos_store_val+0x6a>
  41382a:	f2a0 70c6 	subw	r0, r0, #1990	; 0x7c6
  41382e:	4a21      	ldr	r2, [pc, #132]	; (4138b4 <sincos_store_val+0x98>)
  413830:	03c0      	lsls	r0, r0, #15
  413832:	fb82 1200 	smull	r1, r2, r2, r0
  413836:	17c0      	asrs	r0, r0, #31
	if( sincos_phase_adc_reading[1] > SINVALMAX) sincos_phase_adc_reading[1] = SINVALMAX;
  413838:	8859      	ldrh	r1, [r3, #2]
  41383a:	ebc0 10e2 	rsb	r0, r0, r2, asr #7
  41383e:	f640 728c 	movw	r2, #3980	; 0xf8c
  413842:	4291      	cmp	r1, r2
  413844:	d827      	bhi.n	413896 <sincos_store_val+0x7a>
  413846:	f2a1 71c6 	subw	r1, r1, #1990	; 0x7c6
  41384a:	4b1a      	ldr	r3, [pc, #104]	; (4138b4 <sincos_store_val+0x98>)
  41384c:	03c9      	lsls	r1, r1, #15
  41384e:	fb83 2301 	smull	r2, r3, r3, r1
  413852:	17c9      	asrs	r1, r1, #31
  413854:	ebc1 11e3 	rsb	r1, r1, r3, asr #7
	fixedpt fsin, fcos;
	
	if (menue_drive_data_applied.m_pg_direction == 1)
  413858:	4b17      	ldr	r3, [pc, #92]	; (4138b8 <sincos_store_val+0x9c>)
  41385a:	f893 30ad 	ldrb.w	r3, [r3, #173]	; 0xad
  41385e:	2b01      	cmp	r3, #1
  413860:	d021      	beq.n	4138a6 <sincos_store_val+0x8a>
	

	fsin /= (SINVALMAX/2);
	fcos /= (SINVALMAX/2);
	
	tmp_enc_phase = arctan2(-fcos, fsin); // get sincos phase val
  413862:	4b16      	ldr	r3, [pc, #88]	; (4138bc <sincos_store_val+0xa0>)
  413864:	4240      	negs	r0, r0
  413866:	4798      	blx	r3
	fixedpt tmp_frac;
	// convert the phase val from 360 deg/1 count to 180 deg/1 count
 	if(tmp_enc_phase > fixedpt_rconst(180)) tmp_frac = tmp_enc_phase - fixedpt_rconst(180);
  413868:	f5b0 0fb4 	cmp.w	r0, #5898240	; 0x5a0000
	else tmp_frac = tmp_enc_phase;
	// convert the phase val from deg to frac of 1 enc count
 	tmp_frac /= 180;
  41386c:	4b14      	ldr	r3, [pc, #80]	; (4138c0 <sincos_store_val+0xa4>)
 	if(tmp_enc_phase > fixedpt_rconst(180)) tmp_frac = tmp_enc_phase - fixedpt_rconst(180);
  41386e:	bfc8      	it	gt
  413870:	f5a0 00b4 	subgt.w	r0, r0, #5898240	; 0x5a0000
	//store the frac part
 	enc_phase = tmp_frac;
  413874:	4913      	ldr	r1, [pc, #76]	; (4138c4 <sincos_store_val+0xa8>)
 	tmp_frac /= 180;
  413876:	fb83 e300 	smull	lr, r3, r3, r0
  41387a:	17c2      	asrs	r2, r0, #31
  41387c:	4418      	add	r0, r3
  41387e:	ebc2 10e0 	rsb	r0, r2, r0, asr #7
 	enc_phase = tmp_frac;
  413882:	6008      	str	r0, [r1, #0]
  413884:	bd08      	pop	{r3, pc}
	if( sincos_phase_adc_reading[0] > SINVALMAX) sincos_phase_adc_reading[0] = SINVALMAX;
  413886:	801a      	strh	r2, [r3, #0]
	if( sincos_phase_adc_reading[1] > SINVALMAX) sincos_phase_adc_reading[1] = SINVALMAX;
  413888:	f640 728c 	movw	r2, #3980	; 0xf8c
  41388c:	8859      	ldrh	r1, [r3, #2]
	if( sincos_phase_adc_reading[0] > SINVALMAX) sincos_phase_adc_reading[0] = SINVALMAX;
  41388e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	if( sincos_phase_adc_reading[1] > SINVALMAX) sincos_phase_adc_reading[1] = SINVALMAX;
  413892:	4291      	cmp	r1, r2
  413894:	d9d7      	bls.n	413846 <sincos_store_val+0x2a>
  413896:	805a      	strh	r2, [r3, #2]
  413898:	f44f 4100 	mov.w	r1, #32768	; 0x8000
	if (menue_drive_data_applied.m_pg_direction == 1)
  41389c:	4b06      	ldr	r3, [pc, #24]	; (4138b8 <sincos_store_val+0x9c>)
  41389e:	f893 30ad 	ldrb.w	r3, [r3, #173]	; 0xad
  4138a2:	2b01      	cmp	r3, #1
  4138a4:	d1dd      	bne.n	413862 <sincos_store_val+0x46>
  4138a6:	460b      	mov	r3, r1
  4138a8:	4601      	mov	r1, r0
  4138aa:	4618      	mov	r0, r3
  4138ac:	e7d9      	b.n	413862 <sincos_store_val+0x46>
  4138ae:	bf00      	nop
  4138b0:	20406cec 	.word	0x20406cec
  4138b4:	10776183 	.word	0x10776183
  4138b8:	20404ff0 	.word	0x20404ff0
  4138bc:	00409755 	.word	0x00409755
  4138c0:	b60b60b7 	.word	0xb60b60b7
  4138c4:	20400ad8 	.word	0x20400ad8

004138c8 <enc_get_phase>:
	//dacc_interface_writeData(0, enc_phase, FIXEDPT_ONE, 0);
	//enc_phase = 0;
}
fixedpt enc_get_phase (void)
{
	return enc_phase;
  4138c8:	4b01      	ldr	r3, [pc, #4]	; (4138d0 <enc_get_phase+0x8>)
	} 
	else
	{
		return enc_phase;
	}
}
  4138ca:	6818      	ldr	r0, [r3, #0]
  4138cc:	4770      	bx	lr
  4138ce:	bf00      	nop
  4138d0:	20400ad8 	.word	0x20400ad8

004138d4 <store_enc_count>:

void store_enc_count(void)
{
  4138d4:	b510      	push	{r4, lr}
	uint16_t en_cv = tc_read_cv(TC0,0);
  4138d6:	2100      	movs	r1, #0
  4138d8:	4b10      	ldr	r3, [pc, #64]	; (41391c <store_enc_count+0x48>)
  4138da:	4811      	ldr	r0, [pc, #68]	; (413920 <store_enc_count+0x4c>)
  4138dc:	4798      	blx	r3
	int32_t difference = en_cv - prev_enc_val;
  4138de:	4b11      	ldr	r3, [pc, #68]	; (413924 <store_enc_count+0x50>)
  4138e0:	b282      	uxth	r2, r0
	int64_t *eenc_val = (int64_t)&enc_count[0];
	prev_enc_val = en_cv;
	if(abs(difference) > 20000)
  4138e2:	f644 6120 	movw	r1, #20000	; 0x4e20
	int32_t difference = en_cv - prev_enc_val;
  4138e6:	881c      	ldrh	r4, [r3, #0]
	uint16_t en_cv = tc_read_cv(TC0,0);
  4138e8:	8018      	strh	r0, [r3, #0]
	int32_t difference = en_cv - prev_enc_val;
  4138ea:	1b12      	subs	r2, r2, r4
	if(abs(difference) > 20000)
  4138ec:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
  4138f0:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
  4138f4:	4288      	cmp	r0, r1
  4138f6:	dd09      	ble.n	41390c <store_enc_count+0x38>
	{
		// encoder overflow
		if(difference < 0) (*eenc_val) += 0x10000;
  4138f8:	2a00      	cmp	r2, #0
  4138fa:	e893 0003 	ldmia.w	r3, {r0, r1}
  4138fe:	db06      	blt.n	41390e <store_enc_count+0x3a>
		else (*eenc_val) -= 0x10000;
  413900:	f5b0 3080 	subs.w	r0, r0, #65536	; 0x10000
  413904:	f141 31ff 	adc.w	r1, r1, #4294967295
  413908:	e883 0003 	stmia.w	r3, {r0, r1}
  41390c:	bd10      	pop	{r4, pc}
		if(difference < 0) (*eenc_val) += 0x10000;
  41390e:	f510 3080 	adds.w	r0, r0, #65536	; 0x10000
  413912:	f141 0100 	adc.w	r1, r1, #0
  413916:	e883 0003 	stmia.w	r3, {r0, r1}
  41391a:	bd10      	pop	{r4, pc}
  41391c:	004126b1 	.word	0x004126b1
  413920:	4000c000 	.word	0x4000c000
  413924:	20400acc 	.word	0x20400acc

00413928 <encoder_direct_speed_measure>:
}

int64_t enc_get_theta(void)
{
	int64_t *temp = (uint64_t)&enc_count[0];
	return (*temp + enc_quad_offset);
  413928:	4940      	ldr	r1, [pc, #256]	; (413a2c <encoder_direct_speed_measure+0x104>)
  41392a:	4841      	ldr	r0, [pc, #260]	; (413a30 <encoder_direct_speed_measure+0x108>)
{
  41392c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	fixedpt enc_temp_phase = enc_phase;
  413930:	4c40      	ldr	r4, [pc, #256]	; (413a34 <encoder_direct_speed_measure+0x10c>)
		displacement += (enc_inc_val - enc_prev_pos);
  413932:	4d41      	ldr	r5, [pc, #260]	; (413a38 <encoder_direct_speed_measure+0x110>)
		tmp = enc_temp_phase - (2 * enc_prev_phase) + enc_prev_phase2;
  413934:	f8df 8134 	ldr.w	r8, [pc, #308]	; 413a6c <encoder_direct_speed_measure+0x144>
{
  413938:	ed2d 8b04 	vpush	{d8-d9}
	return (*temp + enc_quad_offset);
  41393c:	680a      	ldr	r2, [r1, #0]
{
  41393e:	b083      	sub	sp, #12
	return (*temp + enc_quad_offset);
  413940:	684b      	ldr	r3, [r1, #4]
		displacement = enc_temp_phase - enc_prev_phase;
  413942:	493e      	ldr	r1, [pc, #248]	; (413a3c <encoder_direct_speed_measure+0x114>)
	fixedpt enc_temp_phase = enc_phase;
  413944:	6827      	ldr	r7, [r4, #0]
		displacement = enc_temp_phase - enc_prev_phase;
  413946:	680c      	ldr	r4, [r1, #0]
		displacement += (enc_inc_val - enc_prev_pos);
  413948:	ed9f 9a3d 	vldr	s18, [pc, #244]	; 413a40 <encoder_direct_speed_measure+0x118>
		displacement = enc_temp_phase - enc_prev_phase;
  41394c:	eba7 0b04 	sub.w	fp, r7, r4
	return (*temp + enc_quad_offset);
  413950:	e9d0 0100 	ldrd	r0, r1, [r0]
		displacement += (enc_inc_val - enc_prev_pos);
  413954:	e9d5 5600 	ldrd	r5, r6, [r5]
	return (*temp + enc_quad_offset);
  413958:	eb12 0900 	adds.w	r9, r2, r0
		displacement = enc_temp_phase - enc_prev_phase;
  41395c:	ee07 ba90 	vmov	s15, fp
	return (*temp + enc_quad_offset);
  413960:	eb43 0a01 	adc.w	sl, r3, r1
		displacement += (enc_inc_val - enc_prev_pos);
  413964:	ebb9 0205 	subs.w	r2, r9, r5
		displacement = enc_temp_phase - enc_prev_phase;
  413968:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
		displacement += (enc_inc_val - enc_prev_pos);
  41396c:	eb6a 0306 	sbc.w	r3, sl, r6
  413970:	4610      	mov	r0, r2
  413972:	e9cd 2300 	strd	r2, r3, [sp]
  413976:	4619      	mov	r1, r3
  413978:	4b32      	ldr	r3, [pc, #200]	; (413a44 <encoder_direct_speed_measure+0x11c>)
  41397a:	4798      	blx	r3
  41397c:	ee08 0a90 	vmov	s17, r0
		tmp = enc_temp_phase - (2 * enc_prev_phase) + enc_prev_phase2;
  413980:	ebab 0104 	sub.w	r1, fp, r4
  413984:	f8d8 0000 	ldr.w	r0, [r8]
		displacement += (enc_inc_val - enc_prev_pos);
  413988:	eee8 8a09 	vfma.f32	s17, s16, s18
		displacement *= 1000; //sampling frequency
  41398c:	eddf 7a2e 	vldr	s15, [pc, #184]	; 413a48 <encoder_direct_speed_measure+0x120>
		tmp = enc_temp_phase - (2 * enc_prev_phase) + enc_prev_phase2;
  413990:	4401      	add	r1, r0
		displacement += (enc_inc_val - (2 * enc_prev_pos) + enc_prev_pos2);
  413992:	e9dd 2300 	ldrd	r2, r3, [sp]
  413996:	ebb2 0b05 	subs.w	fp, r2, r5
  41399a:	4a2c      	ldr	r2, [pc, #176]	; (413a4c <encoder_direct_speed_measure+0x124>)
		displacement *= 1000; //sampling frequency
  41399c:	ee68 8aa7 	vmul.f32	s17, s17, s15
		displacement = tmp;
  4139a0:	ee07 1a90 	vmov	s15, r1
		displacement += (enc_inc_val - (2 * enc_prev_pos) + enc_prev_pos2);
  4139a4:	eb63 0c06 	sbc.w	ip, r3, r6
		f_enc_omega_hat = displacement;
  4139a8:	4b29      	ldr	r3, [pc, #164]	; (413a50 <encoder_direct_speed_measure+0x128>)
		displacement = tmp;
  4139aa:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
		f_enc_omega_hat = displacement;
  4139ae:	edc3 8a00 	vstr	s17, [r3]
		displacement += (enc_inc_val - (2 * enc_prev_pos) + enc_prev_pos2);
  4139b2:	4b24      	ldr	r3, [pc, #144]	; (413a44 <encoder_direct_speed_measure+0x11c>)
  4139b4:	e9d2 0100 	ldrd	r0, r1, [r2]
  4139b8:	eb10 000b 	adds.w	r0, r0, fp
		enc_prev_pos2 = enc_prev_pos;
  4139bc:	46ab      	mov	fp, r5
		displacement += (enc_inc_val - (2 * enc_prev_pos) + enc_prev_pos2);
  4139be:	eb41 010c 	adc.w	r1, r1, ip
  4139c2:	4798      	blx	r3
  4139c4:	ee06 0a90 	vmov	s13, r0
	filtered_enc_acc_hat = (f_enc_acc_hat * ENC_SPEED_WEIGHT + filtered_enc_acc_hat * ENC_F_SPEED_WEIGHT);
  4139c8:	4a22      	ldr	r2, [pc, #136]	; (413a54 <encoder_direct_speed_measure+0x12c>)
		enc_prev_pos2 = enc_prev_pos;
  4139ca:	46b4      	mov	ip, r6
		displacement += (enc_inc_val - (2 * enc_prev_pos) + enc_prev_pos2);
  4139cc:	eee8 6a09 	vfma.f32	s13, s16, s18
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  4139d0:	4b21      	ldr	r3, [pc, #132]	; (413a58 <encoder_direct_speed_measure+0x130>)
  4139d2:	4922      	ldr	r1, [pc, #136]	; (413a5c <encoder_direct_speed_measure+0x134>)
		displacement *= 1000000; //sampling frequency2
  4139d4:	ed9f 6a22 	vldr	s12, [pc, #136]	; 413a60 <encoder_direct_speed_measure+0x138>
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  4139d8:	edd1 7a00 	vldr	s15, [r1]
	filtered_enc_acc_hat = (f_enc_acc_hat * ENC_SPEED_WEIGHT + filtered_enc_acc_hat * ENC_F_SPEED_WEIGHT);
  4139dc:	ed92 7a00 	vldr	s14, [r2]
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  4139e0:	4820      	ldr	r0, [pc, #128]	; (413a64 <encoder_direct_speed_measure+0x13c>)
		displacement *= 1000000; //sampling frequency2
  4139e2:	ee66 6a86 	vmul.f32	s13, s13, s12
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  4139e6:	ed93 6a00 	vldr	s12, [r3]
	filtered_enc_acc_hat = (f_enc_acc_hat * ENC_SPEED_WEIGHT + filtered_enc_acc_hat * ENC_F_SPEED_WEIGHT);
  4139ea:	ee27 7a87 	vmul.f32	s14, s15, s14
		f_enc_acc_hat = displacement;
  4139ee:	491e      	ldr	r1, [pc, #120]	; (413a68 <encoder_direct_speed_measure+0x140>)
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  4139f0:	ee67 7a86 	vmul.f32	s15, s15, s12
  4139f4:	ed90 6a00 	vldr	s12, [r0]
		f_enc_acc_hat = displacement;
  4139f8:	edc1 6a00 	vstr	s13, [r1]
	filtered_enc_acc_hat = (f_enc_acc_hat * ENC_SPEED_WEIGHT + filtered_enc_acc_hat * ENC_F_SPEED_WEIGHT);
  4139fc:	eea6 7a86 	vfma.f32	s14, s13, s12
		enc_prev_pos = enc_inc_val;
  413a00:	490d      	ldr	r1, [pc, #52]	; (413a38 <encoder_direct_speed_measure+0x110>)
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  413a02:	eee8 7a86 	vfma.f32	s15, s17, s12
		enc_prev_phase = enc_temp_phase;
  413a06:	480d      	ldr	r0, [pc, #52]	; (413a3c <encoder_direct_speed_measure+0x114>)
		enc_prev_phase2 = enc_prev_phase;
  413a08:	f8c8 4000 	str.w	r4, [r8]
		enc_prev_phase = enc_temp_phase;
  413a0c:	6007      	str	r7, [r0, #0]
		enc_prev_pos = enc_inc_val;
  413a0e:	e9c1 9a00 	strd	r9, sl, [r1]
		enc_prev_pos2 = enc_prev_pos;
  413a12:	490e      	ldr	r1, [pc, #56]	; (413a4c <encoder_direct_speed_measure+0x124>)
	filtered_enc_acc_hat = (f_enc_acc_hat * ENC_SPEED_WEIGHT + filtered_enc_acc_hat * ENC_F_SPEED_WEIGHT);
  413a14:	ed82 7a00 	vstr	s14, [r2]
	filtered_enc_omega_hat = (f_enc_omega_hat * ENC_SPEED_WEIGHT + filtered_enc_omega_hat * ENC_F_SPEED_WEIGHT);
  413a18:	edc3 7a00 	vstr	s15, [r3]
		enc_prev_pos2 = enc_prev_pos;
  413a1c:	e9c1 bc00 	strd	fp, ip, [r1]
}
  413a20:	b003      	add	sp, #12
  413a22:	ecbd 8b04 	vpop	{d8-d9}
  413a26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413a2a:	bf00      	nop
  413a2c:	20400acc 	.word	0x20400acc
  413a30:	20400af8 	.word	0x20400af8
  413a34:	20400ad8 	.word	0x20400ad8
  413a38:	20400ae8 	.word	0x20400ae8
  413a3c:	20400adc 	.word	0x20400adc
  413a40:	38000000 	.word	0x38000000
  413a44:	00418fe1 	.word	0x00418fe1
  413a48:	447a0000 	.word	0x447a0000
  413a4c:	20400af0 	.word	0x20400af0
  413a50:	20400b0c 	.word	0x20400b0c
  413a54:	20400b18 	.word	0x20400b18
  413a58:	20400b1c 	.word	0x20400b1c
  413a5c:	20400b14 	.word	0x20400b14
  413a60:	49742400 	.word	0x49742400
  413a64:	2040038c 	.word	0x2040038c
  413a68:	20400b08 	.word	0x20400b08
  413a6c:	20400ae0 	.word	0x20400ae0

00413a70 <enc_set_theta>:
{
  413a70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return (*temp + enc_quad_offset);
  413a74:	4c17      	ldr	r4, [pc, #92]	; (413ad4 <enc_set_theta+0x64>)
{
  413a76:	4606      	mov	r6, r0
	return (*temp + enc_quad_offset);
  413a78:	4d17      	ldr	r5, [pc, #92]	; (413ad8 <enc_set_theta+0x68>)
{
  413a7a:	460f      	mov	r7, r1
	return (*temp + enc_quad_offset);
  413a7c:	6822      	ldr	r2, [r4, #0]
  413a7e:	6863      	ldr	r3, [r4, #4]
	enc_prev_pos += enc_offset;
  413a80:	f8df e064 	ldr.w	lr, [pc, #100]	; 413ae8 <enc_set_theta+0x78>
	return (*temp + enc_quad_offset);
  413a84:	e9d5 0100 	ldrd	r0, r1, [r5]
  413a88:	eb12 0800 	adds.w	r8, r2, r0
	enc_quad_offset -= prev_enc_val;
  413a8c:	8822      	ldrh	r2, [r4, #0]
	return (*temp + enc_quad_offset);
  413a8e:	eb43 0901 	adc.w	r9, r3, r1
	int64_t enc_offset = pos - enc_get_theta();
  413a92:	ebb6 0808 	subs.w	r8, r6, r8
	enc_quad_offset -= prev_enc_val;
  413a96:	f04f 0300 	mov.w	r3, #0
	int64_t enc_offset = pos - enc_get_theta();
  413a9a:	eb67 0909 	sbc.w	r9, r7, r9
	distance_regulator_correct_offset(enc_offset);
  413a9e:	4640      	mov	r0, r8
	*eencval = pos - enc_quad_offset;
  413aa0:	e884 000c 	stmia.w	r4, {r2, r3}
	enc_quad_offset -= prev_enc_val;
  413aa4:	1ab2      	subs	r2, r6, r2
	distance_regulator_correct_offset(enc_offset);
  413aa6:	4649      	mov	r1, r9
	enc_quad_offset -= prev_enc_val;
  413aa8:	eb67 0303 	sbc.w	r3, r7, r3
  413aac:	e9c5 2300 	strd	r2, r3, [r5]
	enc_prev_pos += enc_offset;
  413ab0:	e9de 2300 	ldrd	r2, r3, [lr]
  413ab4:	eb18 0802 	adds.w	r8, r8, r2
  413ab8:	eb49 0903 	adc.w	r9, r9, r3
	distance_regulator_correct_offset(enc_offset);
  413abc:	4b07      	ldr	r3, [pc, #28]	; (413adc <enc_set_theta+0x6c>)
	enc_prev_pos += enc_offset;
  413abe:	e9ce 8900 	strd	r8, r9, [lr]
	distance_regulator_correct_offset(enc_offset);
  413ac2:	4798      	blx	r3
	enc_theta_hat = pos;
  413ac4:	4a06      	ldr	r2, [pc, #24]	; (413ae0 <enc_set_theta+0x70>)
	pos_regulator_reset_keeping_pos();
  413ac6:	4b07      	ldr	r3, [pc, #28]	; (413ae4 <enc_set_theta+0x74>)
	enc_theta_hat = pos;
  413ac8:	e9c2 6700 	strd	r6, r7, [r2]
}
  413acc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	pos_regulator_reset_keeping_pos();
  413ad0:	4718      	bx	r3
  413ad2:	bf00      	nop
  413ad4:	20400acc 	.word	0x20400acc
  413ad8:	20400af8 	.word	0x20400af8
  413adc:	0040f0c5 	.word	0x0040f0c5
  413ae0:	20400b00 	.word	0x20400b00
  413ae4:	0040f165 	.word	0x0040f165
  413ae8:	20400ae8 	.word	0x20400ae8

00413aec <enc_get_theta>:
	return (*temp + enc_quad_offset);
  413aec:	4905      	ldr	r1, [pc, #20]	; (413b04 <enc_get_theta+0x18>)
  413aee:	4806      	ldr	r0, [pc, #24]	; (413b08 <enc_get_theta+0x1c>)
{
  413af0:	b430      	push	{r4, r5}
	return (*temp + enc_quad_offset);
  413af2:	e9d0 4500 	ldrd	r4, r5, [r0]
  413af6:	680a      	ldr	r2, [r1, #0]
  413af8:	684b      	ldr	r3, [r1, #4]
}
  413afa:	1910      	adds	r0, r2, r4
  413afc:	eb43 0105 	adc.w	r1, r3, r5
  413b00:	bc30      	pop	{r4, r5}
  413b02:	4770      	bx	lr
  413b04:	20400acc 	.word	0x20400acc
  413b08:	20400af8 	.word	0x20400af8

00413b0c <enc_get_lin_theta>:
	return (*temp + enc_quad_offset);
  413b0c:	4b1f      	ldr	r3, [pc, #124]	; (413b8c <enc_get_lin_theta+0x80>)
  413b0e:	4a20      	ldr	r2, [pc, #128]	; (413b90 <enc_get_lin_theta+0x84>)
int64_t theta_tm1 = 0;
fixedpt phase_tm1 = 0;
int64_t theta_t;
#define sign(x) (x<0)?-1:1
int64_t enc_get_lin_theta(void)
{
  413b10:	b4f0      	push	{r4, r5, r6, r7}
	theta_t = enc_get_theta();
	
	if ( fixedpt_abs(theta_t - theta_tm1) < 2)
  413b12:	4e20      	ldr	r6, [pc, #128]	; (413b94 <enc_get_lin_theta+0x88>)
	return (*temp + enc_quad_offset);
  413b14:	6818      	ldr	r0, [r3, #0]
  413b16:	6859      	ldr	r1, [r3, #4]
	theta_t = enc_get_theta();
  413b18:	4f1f      	ldr	r7, [pc, #124]	; (413b98 <enc_get_lin_theta+0x8c>)
	return (*temp + enc_quad_offset);
  413b1a:	e9d2 2300 	ldrd	r2, r3, [r2]
	if ( fixedpt_abs(theta_t - theta_tm1) < 2)
  413b1e:	e9d6 4500 	ldrd	r4, r5, [r6]
	return (*temp + enc_quad_offset);
  413b22:	1880      	adds	r0, r0, r2
  413b24:	4159      	adcs	r1, r3
	if ( fixedpt_abs(theta_t - theta_tm1) < 2)
  413b26:	1b02      	subs	r2, r0, r4
  413b28:	eb61 0305 	sbc.w	r3, r1, r5
  413b2c:	3201      	adds	r2, #1
  413b2e:	f143 0300 	adc.w	r3, r3, #0
  413b32:	2b00      	cmp	r3, #0
	{
		if ( fixedpt_abs(enc_phase - phase_tm1) > fixedpt_rconst(0.5)) //phase transition of more than 0.5
  413b34:	4b19      	ldr	r3, [pc, #100]	; (413b9c <enc_get_lin_theta+0x90>)
	if ( fixedpt_abs(theta_t - theta_tm1) < 2)
  413b36:	bf08      	it	eq
  413b38:	2a03      	cmpeq	r2, #3
		if ( fixedpt_abs(enc_phase - phase_tm1) > fixedpt_rconst(0.5)) //phase transition of more than 0.5
  413b3a:	4a19      	ldr	r2, [pc, #100]	; (413ba0 <enc_get_lin_theta+0x94>)
	theta_t = enc_get_theta();
  413b3c:	e9c7 0100 	strd	r0, r1, [r7]
		if ( fixedpt_abs(enc_phase - phase_tm1) > fixedpt_rconst(0.5)) //phase transition of more than 0.5
  413b40:	6812      	ldr	r2, [r2, #0]
	if ( fixedpt_abs(theta_t - theta_tm1) < 2)
  413b42:	d214      	bcs.n	413b6e <enc_get_lin_theta+0x62>
		if ( fixedpt_abs(enc_phase - phase_tm1) > fixedpt_rconst(0.5)) //phase transition of more than 0.5
  413b44:	6819      	ldr	r1, [r3, #0]
  413b46:	1a51      	subs	r1, r2, r1
  413b48:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
  413b4c:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
  413b50:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
  413b54:	dd10      	ble.n	413b78 <enc_get_lin_theta+0x6c>
		{
			// enc pulse_cross_over
			theta_tm1 -= sign(enc_phase - phase_tm1);
  413b56:	2900      	cmp	r1, #0
  413b58:	db13      	blt.n	413b82 <enc_get_lin_theta+0x76>
  413b5a:	2001      	movs	r0, #1
  413b5c:	2100      	movs	r1, #0
  413b5e:	1a20      	subs	r0, r4, r0
	} 
	else
	{
		theta_tm1 = theta_t;
	}
	phase_tm1 = enc_phase;
  413b60:	601a      	str	r2, [r3, #0]
			theta_tm1 -= sign(enc_phase - phase_tm1);
  413b62:	eb65 0101 	sbc.w	r1, r5, r1
  413b66:	e9c6 0100 	strd	r0, r1, [r6]
	return theta_tm1;
}
  413b6a:	bcf0      	pop	{r4, r5, r6, r7}
  413b6c:	4770      	bx	lr
		theta_tm1 = theta_t;
  413b6e:	e9c6 0100 	strd	r0, r1, [r6]
	phase_tm1 = enc_phase;
  413b72:	601a      	str	r2, [r3, #0]
}
  413b74:	bcf0      	pop	{r4, r5, r6, r7}
  413b76:	4770      	bx	lr
  413b78:	4620      	mov	r0, r4
  413b7a:	4629      	mov	r1, r5
	phase_tm1 = enc_phase;
  413b7c:	601a      	str	r2, [r3, #0]
}
  413b7e:	bcf0      	pop	{r4, r5, r6, r7}
  413b80:	4770      	bx	lr
			theta_tm1 -= sign(enc_phase - phase_tm1);
  413b82:	f04f 30ff 	mov.w	r0, #4294967295
  413b86:	f04f 31ff 	mov.w	r1, #4294967295
  413b8a:	e7e8      	b.n	413b5e <enc_get_lin_theta+0x52>
  413b8c:	20400acc 	.word	0x20400acc
  413b90:	20400af8 	.word	0x20400af8
  413b94:	20400b28 	.word	0x20400b28
  413b98:	20406ce0 	.word	0x20406ce0
  413b9c:	20400b20 	.word	0x20400b20
  413ba0:	20400ad8 	.word	0x20400ad8
  413ba4:	00000000 	.word	0x00000000

00413ba8 <encoder_alpha_beta_filter_handler>:
{
  413ba8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	f_enc_theta_hat_frac += f_enc_omega_hat/(1000) /*sampling frequency*/;
  413bac:	4c36      	ldr	r4, [pc, #216]	; (413c88 <encoder_alpha_beta_filter_handler+0xe0>)
  413bae:	4e37      	ldr	r6, [pc, #220]	; (413c8c <encoder_alpha_beta_filter_handler+0xe4>)
  413bb0:	edd4 7a00 	vldr	s15, [r4]
  413bb4:	edd6 6a00 	vldr	s13, [r6]
  413bb8:	ed9f 7a35 	vldr	s14, [pc, #212]	; 413c90 <encoder_alpha_beta_filter_handler+0xe8>
	enc_theta_hat += i_tmp;
  413bbc:	4d35      	ldr	r5, [pc, #212]	; (413c94 <encoder_alpha_beta_filter_handler+0xec>)
	f_enc_theta_hat_frac += f_enc_omega_hat/(1000) /*sampling frequency*/;
  413bbe:	eee6 7a87 	vfma.f32	s15, s13, s14
	theta_error = enc_get_lin_theta();
  413bc2:	4935      	ldr	r1, [pc, #212]	; (413c98 <encoder_alpha_beta_filter_handler+0xf0>)
  413bc4:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 413cbc <encoder_alpha_beta_filter_handler+0x114>
	f_enc_theta_hat_frac += (ENC_ALPHA * theta_error);
  413bc8:	4f34      	ldr	r7, [pc, #208]	; (413c9c <encoder_alpha_beta_filter_handler+0xf4>)
{
  413bca:	ed2d 8b02 	vpush	{d8}
	enc_theta_hat += i_tmp;
  413bce:	e9d5 2300 	ldrd	r2, r3, [r5]
	i_tmp = f_enc_theta_hat_frac;
  413bd2:	eebd 7ae7 	vcvt.s32.f32	s14, s15
{
  413bd6:	b083      	sub	sp, #12
	f_enc_theta_hat_frac -= i_tmp;
  413bd8:	eef8 6ac7 	vcvt.f32.s32	s13, s14
	enc_theta_hat += i_tmp;
  413bdc:	ee17 0a10 	vmov	r0, s14
  413be0:	1812      	adds	r2, r2, r0
	f_enc_theta_hat_frac -= i_tmp;
  413be2:	ee77 7ae6 	vsub.f32	s15, s15, s13
	enc_theta_hat += i_tmp;
  413be6:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
	f_enc_theta_hat_frac -= i_tmp;
  413bea:	edc4 7a00 	vstr	s15, [r4]
	enc_theta_hat += i_tmp;
  413bee:	e9c5 2300 	strd	r2, r3, [r5]
	theta_error = enc_get_lin_theta();
  413bf2:	4788      	blx	r1
  413bf4:	47c0      	blx	r8
  413bf6:	9001      	str	r0, [sp, #4]
	theta_error -= enc_theta_hat;
  413bf8:	ed9d 8a01 	vldr	s16, [sp, #4]
  413bfc:	e9d5 0100 	ldrd	r0, r1, [r5]
  413c00:	47c0      	blx	r8
  413c02:	ee07 0a90 	vmov	s15, r0
	temp_v = enc_phase;
  413c06:	4b26      	ldr	r3, [pc, #152]	; (413ca0 <encoder_alpha_beta_filter_handler+0xf8>)
	theta_error -= enc_theta_hat;
  413c08:	ee78 7a67 	vsub.f32	s15, s16, s15
	theta_error += (temp_v - f_enc_theta_hat_frac);
  413c0c:	ed94 8a00 	vldr	s16, [r4]
	temp_v = enc_phase;
  413c10:	ed93 7a00 	vldr	s14, [r3]
	theta_error += (temp_v - f_enc_theta_hat_frac);
  413c14:	eddf 6a23 	vldr	s13, [pc, #140]	; 413ca4 <encoder_alpha_beta_filter_handler+0xfc>
	theta_error -= enc_theta_hat;
  413c18:	edcd 7a01 	vstr	s15, [sp, #4]
	temp_v = enc_phase;
  413c1c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	theta_error += (temp_v - f_enc_theta_hat_frac);
  413c20:	eddd 7a01 	vldr	s15, [sp, #4]
	f_enc_theta_hat_frac += (ENC_ALPHA * theta_error);
  413c24:	4d20      	ldr	r5, [pc, #128]	; (413ca8 <encoder_alpha_beta_filter_handler+0x100>)
	theta_error += (temp_v - f_enc_theta_hat_frac);
  413c26:	ee77 7ac8 	vsub.f32	s15, s15, s16
  413c2a:	eee7 7a26 	vfma.f32	s15, s14, s13
  413c2e:	edcd 7a01 	vstr	s15, [sp, #4]
	f_enc_theta_hat_frac += (ENC_ALPHA * theta_error);
  413c32:	9801      	ldr	r0, [sp, #4]
  413c34:	47b8      	blx	r7
  413c36:	a312      	add	r3, pc, #72	; (adr r3, 413c80 <encoder_alpha_beta_filter_handler+0xd8>)
  413c38:	e9d3 2300 	ldrd	r2, r3, [r3]
  413c3c:	47a8      	blx	r5
  413c3e:	4680      	mov	r8, r0
  413c40:	4689      	mov	r9, r1
  413c42:	ee18 0a10 	vmov	r0, s16
  413c46:	47b8      	blx	r7
  413c48:	4d18      	ldr	r5, [pc, #96]	; (413cac <encoder_alpha_beta_filter_handler+0x104>)
  413c4a:	4602      	mov	r2, r0
  413c4c:	460b      	mov	r3, r1
  413c4e:	4640      	mov	r0, r8
  413c50:	4649      	mov	r1, r9
  413c52:	47a8      	blx	r5
  413c54:	4b16      	ldr	r3, [pc, #88]	; (413cb0 <encoder_alpha_beta_filter_handler+0x108>)
  413c56:	4798      	blx	r3
	f_enc_omega_hat += temp_v;
  413c58:	edd6 7a00 	vldr	s15, [r6]
	temp_v = (ENC_BETA * theta_error);
  413c5c:	eddd 6a01 	vldr	s13, [sp, #4]
	f_enc_omega_hat += temp_v;
  413c60:	ed9f 7a14 	vldr	s14, [pc, #80]	; 413cb4 <encoder_alpha_beta_filter_handler+0x10c>
	filtered_enc_omega_hat = f_enc_omega_hat;
  413c64:	4b14      	ldr	r3, [pc, #80]	; (413cb8 <encoder_alpha_beta_filter_handler+0x110>)
	f_enc_omega_hat += temp_v;
  413c66:	eee6 7a87 	vfma.f32	s15, s13, s14
	f_enc_theta_hat_frac += (ENC_ALPHA * theta_error);
  413c6a:	6020      	str	r0, [r4, #0]
	f_enc_omega_hat += temp_v;
  413c6c:	edc6 7a00 	vstr	s15, [r6]
	filtered_enc_omega_hat = f_enc_omega_hat;
  413c70:	edc3 7a00 	vstr	s15, [r3]
}
  413c74:	b003      	add	sp, #12
  413c76:	ecbd 8b02 	vpop	{d8}
  413c7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  413c7e:	bf00      	nop
  413c80:	851eb852 	.word	0x851eb852
  413c84:	3ff051eb 	.word	0x3ff051eb
  413c88:	20400b10 	.word	0x20400b10
  413c8c:	20400b0c 	.word	0x20400b0c
  413c90:	3a83126f 	.word	0x3a83126f
  413c94:	20400b00 	.word	0x20400b00
  413c98:	00413b0d 	.word	0x00413b0d
  413c9c:	00418749 	.word	0x00418749
  413ca0:	20400ad8 	.word	0x20400ad8
  413ca4:	38000000 	.word	0x38000000
  413ca8:	004187f1 	.word	0x004187f1
  413cac:	0041848d 	.word	0x0041848d
  413cb0:	00418da1 	.word	0x00418da1
  413cb4:	42c00000 	.word	0x42c00000
  413cb8:	20400b1c 	.word	0x20400b1c
  413cbc:	00418fe1 	.word	0x00418fe1

00413cc0 <encoder_inc_handler>:
	store_enc_count();
  413cc0:	4b07      	ldr	r3, [pc, #28]	; (413ce0 <encoder_inc_handler+0x20>)
{
  413cc2:	b510      	push	{r4, lr}
	store_enc_count();
  413cc4:	4798      	blx	r3
	if (menue_drive_data_applied.m_encoder_type == 0) encoder_alpha_beta_filter_handler(); //incremental encoder
  413cc6:	4b07      	ldr	r3, [pc, #28]	; (413ce4 <encoder_inc_handler+0x24>)
  413cc8:	f893 30ac 	ldrb.w	r3, [r3, #172]	; 0xac
  413ccc:	b11b      	cbz	r3, 413cd6 <encoder_inc_handler+0x16>
	else encoder_direct_speed_measure(); //sin/cos encoder
  413cce:	4b06      	ldr	r3, [pc, #24]	; (413ce8 <encoder_inc_handler+0x28>)
}
  413cd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	else encoder_direct_speed_measure(); //sin/cos encoder
  413cd4:	4718      	bx	r3
	if (menue_drive_data_applied.m_encoder_type == 0) encoder_alpha_beta_filter_handler(); //incremental encoder
  413cd6:	4b05      	ldr	r3, [pc, #20]	; (413cec <encoder_inc_handler+0x2c>)
}
  413cd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if (menue_drive_data_applied.m_encoder_type == 0) encoder_alpha_beta_filter_handler(); //incremental encoder
  413cdc:	4718      	bx	r3
  413cde:	bf00      	nop
  413ce0:	004138d5 	.word	0x004138d5
  413ce4:	20404ff0 	.word	0x20404ff0
  413ce8:	00413929 	.word	0x00413929
  413cec:	00413ba9 	.word	0x00413ba9

00413cf0 <enc_get_omega_hat>:
}

fixedpt enc_get_omega_hat(void)
{
	//return enc_count_sample * FIXEDPT_ONE;
	return filtered_enc_omega_hat * FIXEDPT_ONE;
  413cf0:	4b04      	ldr	r3, [pc, #16]	; (413d04 <enc_get_omega_hat+0x14>)
  413cf2:	edd3 7a00 	vldr	s15, [r3]
}
  413cf6:	eeb0 7a67 	vmov.f32	s14, s15
  413cfa:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15
  413cfe:	ee17 0a10 	vmov	r0, s14
  413d02:	4770      	bx	lr
  413d04:	20400b1c 	.word	0x20400b1c

00413d08 <enc_get_acc_shaft_rad_hat>:
	//return (filtered_enc_omega_hat * FIXEDPT_ONE) / ENC_COUNT_REV;
}

float enc_get_acc_shaft_rad_hat(void)
{
	return (filtered_enc_acc_hat *  M_TWO_PI) / ENC_COUNT_REV ;
  413d08:	4b09      	ldr	r3, [pc, #36]	; (413d30 <enc_get_acc_shaft_rad_hat+0x28>)
  413d0a:	4a0a      	ldr	r2, [pc, #40]	; (413d34 <enc_get_acc_shaft_rad_hat+0x2c>)
  413d0c:	f8b3 30ae 	ldrh.w	r3, [r3, #174]	; 0xae
  413d10:	ed92 7a00 	vldr	s14, [r2]
  413d14:	005b      	lsls	r3, r3, #1
  413d16:	eddf 6a08 	vldr	s13, [pc, #32]	; 413d38 <enc_get_acc_shaft_rad_hat+0x30>
  413d1a:	ee07 3a90 	vmov	s15, r3
  413d1e:	ee27 7a26 	vmul.f32	s14, s14, s13
  413d22:	eef8 7ae7 	vcvt.f32.s32	s15, s15
}
  413d26:	eec7 6a27 	vdiv.f32	s13, s14, s15
  413d2a:	ee16 0a90 	vmov	r0, s13
  413d2e:	4770      	bx	lr
  413d30:	20404ff0 	.word	0x20404ff0
  413d34:	20400b18 	.word	0x20400b18
  413d38:	40c90fdb 	.word	0x40c90fdb

00413d3c <enc_get_omega_shaft_rad_hat>:

float enc_get_omega_shaft_rad_hat(void)
{
	return (filtered_enc_omega_hat *  M_TWO_PI) / ENC_COUNT_REV ;
  413d3c:	4b09      	ldr	r3, [pc, #36]	; (413d64 <enc_get_omega_shaft_rad_hat+0x28>)
  413d3e:	4a0a      	ldr	r2, [pc, #40]	; (413d68 <enc_get_omega_shaft_rad_hat+0x2c>)
  413d40:	f8b3 30ae 	ldrh.w	r3, [r3, #174]	; 0xae
  413d44:	ed92 7a00 	vldr	s14, [r2]
  413d48:	005b      	lsls	r3, r3, #1
  413d4a:	eddf 6a08 	vldr	s13, [pc, #32]	; 413d6c <enc_get_omega_shaft_rad_hat+0x30>
  413d4e:	ee07 3a90 	vmov	s15, r3
  413d52:	ee27 7a26 	vmul.f32	s14, s14, s13
  413d56:	eef8 7ae7 	vcvt.f32.s32	s15, s15
}
  413d5a:	eec7 6a27 	vdiv.f32	s13, s14, s15
  413d5e:	ee16 0a90 	vmov	r0, s13
  413d62:	4770      	bx	lr
  413d64:	20404ff0 	.word	0x20404ff0
  413d68:	20400b1c 	.word	0x20400b1c
  413d6c:	40c90fdb 	.word	0x40c90fdb

00413d70 <enc_get_omega_hz_hat>:
	float tmp = filtered_enc_omega_hat / ENC_COUNT_REV;
  413d70:	4b09      	ldr	r3, [pc, #36]	; (413d98 <enc_get_omega_hz_hat+0x28>)
  413d72:	4a0a      	ldr	r2, [pc, #40]	; (413d9c <enc_get_omega_hz_hat+0x2c>)
  413d74:	f8b3 30ae 	ldrh.w	r3, [r3, #174]	; 0xae
  413d78:	edd2 6a00 	vldr	s13, [r2]
  413d7c:	005b      	lsls	r3, r3, #1
  413d7e:	ee07 3a90 	vmov	s15, r3
  413d82:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  413d86:	ee86 7aa7 	vdiv.f32	s14, s13, s15
	return tmp;
  413d8a:	eebe 7ae8 	vcvt.s32.f32	s14, s14, #15

fixedpt enc_get_omega_hz_hat(uint32_t poles)
{
	return enc_get_omega_rev_hat() * poles;
}
  413d8e:	ee17 3a10 	vmov	r3, s14
  413d92:	fb00 f003 	mul.w	r0, r0, r3
  413d96:	4770      	bx	lr
  413d98:	20404ff0 	.word	0x20404ff0
  413d9c:	20400b1c 	.word	0x20400b1c

00413da0 <enc_get_omega_rad_hat>:
	float tmp = filtered_enc_omega_hat / ENC_COUNT_REV;
  413da0:	4b0c      	ldr	r3, [pc, #48]	; (413dd4 <enc_get_omega_rad_hat+0x34>)
  413da2:	4a0d      	ldr	r2, [pc, #52]	; (413dd8 <enc_get_omega_rad_hat+0x38>)
  413da4:	f8b3 30ae 	ldrh.w	r3, [r3, #174]	; 0xae
  413da8:	edd2 6a00 	vldr	s13, [r2]
  413dac:	005b      	lsls	r3, r3, #1
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  413dae:	4a0b      	ldr	r2, [pc, #44]	; (413ddc <enc_get_omega_rad_hat+0x3c>)
  413db0:	ee07 3a90 	vmov	s15, r3
  413db4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  413db8:	eec6 7a87 	vdiv.f32	s15, s13, s14
	return tmp;
  413dbc:	eefe 7ae8 	vcvt.s32.f32	s15, s15, #15
	return enc_get_omega_rev_hat() * poles;
  413dc0:	ee17 3a90 	vmov	r3, s15
  413dc4:	fb00 f003 	mul.w	r0, r0, r3
  413dc8:	fb80 2302 	smull	r2, r3, r0, r2
  413dcc:	0bd0      	lsrs	r0, r2, #15

fixedpt enc_get_omega_rad_hat(uint32_t poles)
{
	return fixedpt_mul(enc_get_omega_hz_hat(poles), FIXEDPT_TWO_PI) ;
}
  413dce:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
  413dd2:	4770      	bx	lr
  413dd4:	20404ff0 	.word	0x20404ff0
  413dd8:	20400b1c 	.word	0x20400b1c
  413ddc:	0003243f 	.word	0x0003243f

00413de0 <enc_set_filter_timeconst>:
}
float enc_filteration_time = 0;
void enc_set_filter_timeconst(float t_cons)
{
	float temp;
	if (enc_filteration_time != t_cons)
  413de0:	4b17      	ldr	r3, [pc, #92]	; (413e40 <enc_set_filter_timeconst+0x60>)
{
  413de2:	ee07 0a90 	vmov	s15, r0
	if (enc_filteration_time != t_cons)
  413de6:	ed93 7a00 	vldr	s14, [r3]
  413dea:	eeb4 7a67 	vcmp.f32	s14, s15
  413dee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413df2:	d01d      	beq.n	413e30 <enc_set_filter_timeconst+0x50>
	{
		enc_filteration_time = t_cons;
		if (t_cons == 0)
  413df4:	eef5 7a40 	vcmp.f32	s15, #0.0
		enc_filteration_time = t_cons;
  413df8:	6018      	str	r0, [r3, #0]
		if (t_cons == 0)
  413dfa:	2300      	movs	r3, #0
  413dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413e00:	d017      	beq.n	413e32 <enc_set_filter_timeconst+0x52>
		{
			speed_weight = 1;
			f_speed_weight = 0;
		}
		else if(t_cons > 0)
  413e02:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  413e06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413e0a:	dd11      	ble.n	413e30 <enc_set_filter_timeconst+0x50>
		{
			temp = t_cons + 1;
  413e0c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
			speed_weight = temp;
			
			temp = 1 / t_cons;
			temp += 1;
			temp = 1 / temp;
			f_speed_weight = temp;
  413e10:	4b0c      	ldr	r3, [pc, #48]	; (413e44 <enc_set_filter_timeconst+0x64>)
			speed_weight = temp;
  413e12:	4a0d      	ldr	r2, [pc, #52]	; (413e48 <enc_set_filter_timeconst+0x68>)
			temp = 1 / t_cons;
  413e14:	eec7 6a27 	vdiv.f32	s13, s14, s15
			temp = t_cons + 1;
  413e18:	ee77 7a87 	vadd.f32	s15, s15, s14
			temp = 1 / temp;
  413e1c:	ee87 6a27 	vdiv.f32	s12, s14, s15
			temp += 1;
  413e20:	ee76 7a87 	vadd.f32	s15, s13, s14
			temp = 1 / temp;
  413e24:	eec7 6a27 	vdiv.f32	s13, s14, s15
			speed_weight = temp;
  413e28:	ed82 6a00 	vstr	s12, [r2]
			f_speed_weight = temp;
  413e2c:	edc3 6a00 	vstr	s13, [r3]
  413e30:	4770      	bx	lr
			speed_weight = 1;
  413e32:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
  413e36:	4904      	ldr	r1, [pc, #16]	; (413e48 <enc_set_filter_timeconst+0x68>)
			f_speed_weight = 0;
  413e38:	4a02      	ldr	r2, [pc, #8]	; (413e44 <enc_set_filter_timeconst+0x64>)
			speed_weight = 1;
  413e3a:	6008      	str	r0, [r1, #0]
			f_speed_weight = 0;
  413e3c:	6013      	str	r3, [r2, #0]
  413e3e:	4770      	bx	lr
  413e40:	20400ad4 	.word	0x20400ad4
  413e44:	20400b14 	.word	0x20400b14
  413e48:	2040038c 	.word	0x2040038c

00413e4c <sincos_detect_error>:
	if (err_counter > 0) err_counter--;
}

void sincos_detect_error(uint16_t *adc_reading)
{
	if ( (adc_reading[0] <= ((2048) + ERR_MARGIN)) && (adc_reading[0] >= ((2048) - ERR_MARGIN)) )
  413e4c:	8803      	ldrh	r3, [r0, #0]
	if (err_counter >= SINCOS_ERR_MAX) sincos_err_set;
  413e4e:	4a0d      	ldr	r2, [pc, #52]	; (413e84 <sincos_detect_error+0x38>)
	if ( (adc_reading[0] <= ((2048) + ERR_MARGIN)) && (adc_reading[0] >= ((2048) - ERR_MARGIN)) )
  413e50:	f2a3 739c 	subw	r3, r3, #1948	; 0x79c
  413e54:	b29b      	uxth	r3, r3
  413e56:	2bc8      	cmp	r3, #200	; 0xc8
  413e58:	d80b      	bhi.n	413e72 <sincos_detect_error+0x26>
	{
		if ( (adc_reading[1] <= ((2048) + ERR_MARGIN)) && (adc_reading[1] >= ((2048) - ERR_MARGIN)) )
  413e5a:	8843      	ldrh	r3, [r0, #2]
  413e5c:	f2a3 739c 	subw	r3, r3, #1948	; 0x79c
  413e60:	b29b      	uxth	r3, r3
  413e62:	2bc8      	cmp	r3, #200	; 0xc8
  413e64:	d805      	bhi.n	413e72 <sincos_detect_error+0x26>
	if (err_counter >= SINCOS_ERR_MAX) sincos_err_set;
  413e66:	7813      	ldrb	r3, [r2, #0]
  413e68:	2b31      	cmp	r3, #49	; 0x31
  413e6a:	d807      	bhi.n	413e7c <sincos_detect_error+0x30>
	else err_counter++;
  413e6c:	3301      	adds	r3, #1
  413e6e:	7013      	strb	r3, [r2, #0]
  413e70:	4770      	bx	lr
	if (err_counter > 0) err_counter--;
  413e72:	7813      	ldrb	r3, [r2, #0]
  413e74:	b10b      	cbz	r3, 413e7a <sincos_detect_error+0x2e>
  413e76:	3b01      	subs	r3, #1
  413e78:	7013      	strb	r3, [r2, #0]
  413e7a:	4770      	bx	lr
	if (err_counter >= SINCOS_ERR_MAX) sincos_err_set;
  413e7c:	4a02      	ldr	r2, [pc, #8]	; (413e88 <sincos_detect_error+0x3c>)
  413e7e:	4b03      	ldr	r3, [pc, #12]	; (413e8c <sincos_detect_error+0x40>)
  413e80:	7810      	ldrb	r0, [r2, #0]
  413e82:	4718      	bx	r3
  413e84:	20406cf8 	.word	0x20406cf8
  413e88:	20406cb6 	.word	0x20406cb6
  413e8c:	0041282d 	.word	0x0041282d

00413e90 <sincos_store_abs_adc_val>:
}

uint16_t adc_reading_abs[2];
void sincos_store_abs_adc_val(uint16_t *adc_reading)
{
	adc_reading_abs[0] = adc_reading[0];
  413e90:	8802      	ldrh	r2, [r0, #0]
  413e92:	4b02      	ldr	r3, [pc, #8]	; (413e9c <sincos_store_abs_adc_val+0xc>)
  413e94:	801a      	strh	r2, [r3, #0]
	adc_reading_abs[1] = adc_reading[1];
  413e96:	8842      	ldrh	r2, [r0, #2]
  413e98:	805a      	strh	r2, [r3, #2]
  413e9a:	4770      	bx	lr
  413e9c:	20406d00 	.word	0x20406d00

00413ea0 <s_edges_detect>:
#define BOUNDRY_DN (500)

uint8_t s_edge = 0;
void s_edges_detect(void)
{
	if (s_edge)
  413ea0:	4b23      	ldr	r3, [pc, #140]	; (413f30 <s_edges_detect+0x90>)
{
  413ea2:	b470      	push	{r4, r5, r6}
	if (s_edge)
  413ea4:	781a      	ldrb	r2, [r3, #0]
  413ea6:	b1ba      	cbz	r2, 413ed8 <s_edges_detect+0x38>
	{
		if (f_sin < (-FIXEDPT_ONE / 4)) //transition occured
  413ea8:	4a22      	ldr	r2, [pc, #136]	; (413f34 <s_edges_detect+0x94>)
  413eaa:	6812      	ldr	r2, [r2, #0]
  413eac:	f512 5f00 	cmn.w	r2, #8192	; 0x2000
  413eb0:	da35      	bge.n	413f1e <s_edges_detect+0x7e>
		{
			s_edge = 0;
			savg_max = (s_max + savg_max)/2;
  413eb2:	4c21      	ldr	r4, [pc, #132]	; (413f38 <s_edges_detect+0x98>)
			s_edge = 0;
  413eb4:	2000      	movs	r0, #0
			savg_max = (s_max + savg_max)/2;
  413eb6:	4921      	ldr	r1, [pc, #132]	; (413f3c <s_edges_detect+0x9c>)
			s_max = 0;
			if(savg_max < BOUNDRY_UP) savg_max = BOUNDRY_UP;
  413eb8:	f640 35b7 	movw	r5, #2999	; 0xbb7
			savg_max = (s_max + savg_max)/2;
  413ebc:	8822      	ldrh	r2, [r4, #0]
  413ebe:	880e      	ldrh	r6, [r1, #0]
			s_edge = 0;
  413ec0:	7018      	strb	r0, [r3, #0]
			savg_max = (s_max + savg_max)/2;
  413ec2:	4432      	add	r2, r6
			s_max = 0;
  413ec4:	8020      	strh	r0, [r4, #0]
			savg_max = (s_max + savg_max)/2;
  413ec6:	1053      	asrs	r3, r2, #1
			if(savg_max < BOUNDRY_UP) savg_max = BOUNDRY_UP;
  413ec8:	42ab      	cmp	r3, r5
			savg_max = (s_max + savg_max)/2;
  413eca:	800b      	strh	r3, [r1, #0]
			if(savg_max < BOUNDRY_UP) savg_max = BOUNDRY_UP;
  413ecc:	dc25      	bgt.n	413f1a <s_edges_detect+0x7a>
  413ece:	f640 33b8 	movw	r3, #3000	; 0xbb8
  413ed2:	800b      	strh	r3, [r1, #0]
		else //detect edge
		{
			if (s_min > adc_reading_abs[1]) s_min = adc_reading_abs[1];
		}
	}
}
  413ed4:	bc70      	pop	{r4, r5, r6}
  413ed6:	4770      	bx	lr
		if (f_sin > (FIXEDPT_ONE / 4)) //transition occured
  413ed8:	4a16      	ldr	r2, [pc, #88]	; (413f34 <s_edges_detect+0x94>)
  413eda:	6812      	ldr	r2, [r2, #0]
  413edc:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  413ee0:	dd14      	ble.n	413f0c <s_edges_detect+0x6c>
			savg_min = (s_min + savg_min)/2;
  413ee2:	4817      	ldr	r0, [pc, #92]	; (413f40 <s_edges_detect+0xa0>)
			s_edge = 1;
  413ee4:	2401      	movs	r4, #1
			savg_min = (s_min + savg_min)/2;
  413ee6:	4917      	ldr	r1, [pc, #92]	; (413f44 <s_edges_detect+0xa4>)
			s_min = (FIXEDPT_ONE / 4);
  413ee8:	f44f 5600 	mov.w	r6, #8192	; 0x2000
			savg_min = (s_min + savg_min)/2;
  413eec:	8802      	ldrh	r2, [r0, #0]
  413eee:	880d      	ldrh	r5, [r1, #0]
			s_edge = 1;
  413ef0:	701c      	strb	r4, [r3, #0]
			savg_min = (s_min + savg_min)/2;
  413ef2:	442a      	add	r2, r5
			s_min = (FIXEDPT_ONE / 4);
  413ef4:	8006      	strh	r6, [r0, #0]
			savg_min = (s_min + savg_min)/2;
  413ef6:	fa42 f304 	asr.w	r3, r2, r4
			if(savg_min > BOUNDRY_DN) savg_min = BOUNDRY_DN;
  413efa:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
			savg_min = (s_min + savg_min)/2;
  413efe:	800b      	strh	r3, [r1, #0]
			if(savg_min > BOUNDRY_DN) savg_min = BOUNDRY_DN;
  413f00:	dd0b      	ble.n	413f1a <s_edges_detect+0x7a>
  413f02:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  413f06:	800b      	strh	r3, [r1, #0]
}
  413f08:	bc70      	pop	{r4, r5, r6}
  413f0a:	4770      	bx	lr
			if (s_min > adc_reading_abs[1]) s_min = adc_reading_abs[1];
  413f0c:	4a0e      	ldr	r2, [pc, #56]	; (413f48 <s_edges_detect+0xa8>)
  413f0e:	4b0c      	ldr	r3, [pc, #48]	; (413f40 <s_edges_detect+0xa0>)
  413f10:	8852      	ldrh	r2, [r2, #2]
  413f12:	8819      	ldrh	r1, [r3, #0]
  413f14:	4291      	cmp	r1, r2
  413f16:	d900      	bls.n	413f1a <s_edges_detect+0x7a>
  413f18:	801a      	strh	r2, [r3, #0]
}
  413f1a:	bc70      	pop	{r4, r5, r6}
  413f1c:	4770      	bx	lr
			if (s_max < adc_reading_abs[1]) s_max = adc_reading_abs[1];
  413f1e:	4a0a      	ldr	r2, [pc, #40]	; (413f48 <s_edges_detect+0xa8>)
  413f20:	4b05      	ldr	r3, [pc, #20]	; (413f38 <s_edges_detect+0x98>)
  413f22:	8852      	ldrh	r2, [r2, #2]
  413f24:	8819      	ldrh	r1, [r3, #0]
  413f26:	4291      	cmp	r1, r2
  413f28:	d3f6      	bcc.n	413f18 <s_edges_detect+0x78>
}
  413f2a:	bc70      	pop	{r4, r5, r6}
  413f2c:	4770      	bx	lr
  413f2e:	bf00      	nop
  413f30:	20400b3c 	.word	0x20400b3c
  413f34:	20400b38 	.word	0x20400b38
  413f38:	20400398 	.word	0x20400398
  413f3c:	2040039c 	.word	0x2040039c
  413f40:	2040039a 	.word	0x2040039a
  413f44:	2040039e 	.word	0x2040039e
  413f48:	20406d00 	.word	0x20406d00

00413f4c <c_edges_detect>:

uint8_t c_edge = 0;
void c_edges_detect(void)
{
	if (c_edge)
  413f4c:	4b23      	ldr	r3, [pc, #140]	; (413fdc <c_edges_detect+0x90>)
{
  413f4e:	b470      	push	{r4, r5, r6}
	if (c_edge)
  413f50:	781a      	ldrb	r2, [r3, #0]
  413f52:	b1ba      	cbz	r2, 413f84 <c_edges_detect+0x38>
	{
		if (f_cos < (-FIXEDPT_ONE / 4)) //transition occured
  413f54:	4a22      	ldr	r2, [pc, #136]	; (413fe0 <c_edges_detect+0x94>)
  413f56:	6812      	ldr	r2, [r2, #0]
  413f58:	f512 5f00 	cmn.w	r2, #8192	; 0x2000
  413f5c:	da35      	bge.n	413fca <c_edges_detect+0x7e>
		{
			c_edge = 0;
			cavg_max = (c_max + cavg_max)/2;
  413f5e:	4c21      	ldr	r4, [pc, #132]	; (413fe4 <c_edges_detect+0x98>)
			c_edge = 0;
  413f60:	2000      	movs	r0, #0
			cavg_max = (c_max + cavg_max)/2;
  413f62:	4921      	ldr	r1, [pc, #132]	; (413fe8 <c_edges_detect+0x9c>)
			c_max = 0;
			if(cavg_max < BOUNDRY_UP) cavg_max = BOUNDRY_UP;
  413f64:	f640 35b7 	movw	r5, #2999	; 0xbb7
			cavg_max = (c_max + cavg_max)/2;
  413f68:	8822      	ldrh	r2, [r4, #0]
  413f6a:	880e      	ldrh	r6, [r1, #0]
			c_edge = 0;
  413f6c:	7018      	strb	r0, [r3, #0]
			cavg_max = (c_max + cavg_max)/2;
  413f6e:	4432      	add	r2, r6
			c_max = 0;
  413f70:	8020      	strh	r0, [r4, #0]
			cavg_max = (c_max + cavg_max)/2;
  413f72:	1053      	asrs	r3, r2, #1
			if(cavg_max < BOUNDRY_UP) cavg_max = BOUNDRY_UP;
  413f74:	42ab      	cmp	r3, r5
			cavg_max = (c_max + cavg_max)/2;
  413f76:	800b      	strh	r3, [r1, #0]
			if(cavg_max < BOUNDRY_UP) cavg_max = BOUNDRY_UP;
  413f78:	dc25      	bgt.n	413fc6 <c_edges_detect+0x7a>
  413f7a:	f640 33b8 	movw	r3, #3000	; 0xbb8
  413f7e:	800b      	strh	r3, [r1, #0]
		else //detect edge
		{
			if (c_min > adc_reading_abs[0]) c_min = adc_reading_abs[0];
		}
	}
}
  413f80:	bc70      	pop	{r4, r5, r6}
  413f82:	4770      	bx	lr
		if (f_cos > (FIXEDPT_ONE / 4)) //transition occured
  413f84:	4a16      	ldr	r2, [pc, #88]	; (413fe0 <c_edges_detect+0x94>)
  413f86:	6812      	ldr	r2, [r2, #0]
  413f88:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
  413f8c:	dd14      	ble.n	413fb8 <c_edges_detect+0x6c>
			cavg_min = (c_min + cavg_min)/2;
  413f8e:	4817      	ldr	r0, [pc, #92]	; (413fec <c_edges_detect+0xa0>)
			c_edge = 1;
  413f90:	2401      	movs	r4, #1
			cavg_min = (c_min + cavg_min)/2;
  413f92:	4917      	ldr	r1, [pc, #92]	; (413ff0 <c_edges_detect+0xa4>)
			c_min = (FIXEDPT_ONE / 4);
  413f94:	f44f 5600 	mov.w	r6, #8192	; 0x2000
			cavg_min = (c_min + cavg_min)/2;
  413f98:	8802      	ldrh	r2, [r0, #0]
  413f9a:	880d      	ldrh	r5, [r1, #0]
			c_edge = 1;
  413f9c:	701c      	strb	r4, [r3, #0]
			cavg_min = (c_min + cavg_min)/2;
  413f9e:	442a      	add	r2, r5
			c_min = (FIXEDPT_ONE / 4);
  413fa0:	8006      	strh	r6, [r0, #0]
			cavg_min = (c_min + cavg_min)/2;
  413fa2:	fa42 f304 	asr.w	r3, r2, r4
			if(cavg_min > BOUNDRY_DN) cavg_min = BOUNDRY_DN;
  413fa6:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
			cavg_min = (c_min + cavg_min)/2;
  413faa:	800b      	strh	r3, [r1, #0]
			if(cavg_min > BOUNDRY_DN) cavg_min = BOUNDRY_DN;
  413fac:	dd0b      	ble.n	413fc6 <c_edges_detect+0x7a>
  413fae:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  413fb2:	800b      	strh	r3, [r1, #0]
}
  413fb4:	bc70      	pop	{r4, r5, r6}
  413fb6:	4770      	bx	lr
			if (c_min > adc_reading_abs[0]) c_min = adc_reading_abs[0];
  413fb8:	4a0e      	ldr	r2, [pc, #56]	; (413ff4 <c_edges_detect+0xa8>)
  413fba:	4b0c      	ldr	r3, [pc, #48]	; (413fec <c_edges_detect+0xa0>)
  413fbc:	8812      	ldrh	r2, [r2, #0]
  413fbe:	8819      	ldrh	r1, [r3, #0]
  413fc0:	4291      	cmp	r1, r2
  413fc2:	d900      	bls.n	413fc6 <c_edges_detect+0x7a>
  413fc4:	801a      	strh	r2, [r3, #0]
}
  413fc6:	bc70      	pop	{r4, r5, r6}
  413fc8:	4770      	bx	lr
			if (c_max < adc_reading_abs[0]) c_max = adc_reading_abs[0];
  413fca:	4a0a      	ldr	r2, [pc, #40]	; (413ff4 <c_edges_detect+0xa8>)
  413fcc:	4b05      	ldr	r3, [pc, #20]	; (413fe4 <c_edges_detect+0x98>)
  413fce:	8812      	ldrh	r2, [r2, #0]
  413fd0:	8819      	ldrh	r1, [r3, #0]
  413fd2:	4291      	cmp	r1, r2
  413fd4:	d3f6      	bcc.n	413fc4 <c_edges_detect+0x78>
}
  413fd6:	bc70      	pop	{r4, r5, r6}
  413fd8:	4770      	bx	lr
  413fda:	bf00      	nop
  413fdc:	20400b30 	.word	0x20400b30
  413fe0:	20400b34 	.word	0x20400b34
  413fe4:	20400390 	.word	0x20400390
  413fe8:	20400394 	.word	0x20400394
  413fec:	20400392 	.word	0x20400392
  413ff0:	20400396 	.word	0x20400396
  413ff4:	20406d00 	.word	0x20406d00

00413ff8 <sincos_store_val_abs>:
void sincos_store_val_abs(void)
{
  413ff8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t i;
	sincos_detect_error(adc_reading_abs);
  413ffc:	4d3c      	ldr	r5, [pc, #240]	; (4140f0 <sincos_store_val_abs+0xf8>)
  413ffe:	4b3d      	ldr	r3, [pc, #244]	; (4140f4 <sincos_store_val_abs+0xfc>)
  414000:	4628      	mov	r0, r5
  414002:	4798      	blx	r3
// 	abs_angle = adc_reading_abs[0] * FIXEDPT_ONE;
// 	return;

	s_edges_detect();
  414004:	4b3c      	ldr	r3, [pc, #240]	; (4140f8 <sincos_store_val_abs+0x100>)
  414006:	4798      	blx	r3
	c_edges_detect();
  414008:	4b3c      	ldr	r3, [pc, #240]	; (4140fc <sincos_store_val_abs+0x104>)
  41400a:	4798      	blx	r3
	if( adc_reading_abs[0] > COSVALMAX) adc_reading_abs[0] = COSVALMAX;
  41400c:	4b3c      	ldr	r3, [pc, #240]	; (414100 <sincos_store_val_abs+0x108>)
  41400e:	8829      	ldrh	r1, [r5, #0]
  414010:	881b      	ldrh	r3, [r3, #0]
	if( adc_reading_abs[1] > SINVALMAX) adc_reading_abs[1] = SINVALMAX;
  414012:	4a3c      	ldr	r2, [pc, #240]	; (414104 <sincos_store_val_abs+0x10c>)
  414014:	886c      	ldrh	r4, [r5, #2]
	if( adc_reading_abs[0] > COSVALMAX) adc_reading_abs[0] = COSVALMAX;
  414016:	4299      	cmp	r1, r3
	if( adc_reading_abs[1] > SINVALMAX) adc_reading_abs[1] = SINVALMAX;
  414018:	8812      	ldrh	r2, [r2, #0]
	
	if( adc_reading_abs[0] < COSVALMIN) adc_reading_abs[0] = COSVALMIN;
  41401a:	483b      	ldr	r0, [pc, #236]	; (414108 <sincos_store_val_abs+0x110>)
	if( adc_reading_abs[0] > COSVALMAX) adc_reading_abs[0] = COSVALMAX;
  41401c:	bf28      	it	cs
  41401e:	4619      	movcs	r1, r3
	if( adc_reading_abs[1] > SINVALMAX) adc_reading_abs[1] = SINVALMAX;
  414020:	4294      	cmp	r4, r2
	if( adc_reading_abs[0] < COSVALMIN) adc_reading_abs[0] = COSVALMIN;
  414022:	8806      	ldrh	r6, [r0, #0]
	if( adc_reading_abs[1] > SINVALMAX) adc_reading_abs[1] = SINVALMAX;
  414024:	bf28      	it	cs
  414026:	4614      	movcs	r4, r2
	if( adc_reading_abs[0] < COSVALMIN) adc_reading_abs[0] = COSVALMIN;
  414028:	428e      	cmp	r6, r1
  41402a:	d854      	bhi.n	4140d6 <sincos_store_val_abs+0xde>
  41402c:	1b89      	subs	r1, r1, r6
  41402e:	b288      	uxth	r0, r1
	if( adc_reading_abs[1] < SINVALMIN) adc_reading_abs[1] = SINVALMIN;
  414030:	4936      	ldr	r1, [pc, #216]	; (41410c <sincos_store_val_abs+0x114>)
  414032:	f8b1 e000 	ldrh.w	lr, [r1]
  414036:	4607      	mov	r7, r0
  414038:	45a6      	cmp	lr, r4
  41403a:	d953      	bls.n	4140e4 <sincos_store_val_abs+0xec>
  41403c:	2100      	movs	r1, #0
  41403e:	460c      	mov	r4, r1
	
	adc_reading_abs[0] -= COSVALMIN;
	adc_reading_abs[1] -= SINVALMIN;
  414040:	806c      	strh	r4, [r5, #2]
	
	fixedpt fsin = adc_reading_abs[1];
	fsin -= SINVALAVG/2;
  414042:	eba2 020e 	sub.w	r2, r2, lr
	

	fsin /= (SINVALAVG/2);
	fcos /= (COSVALAVG/2);
	
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  414046:	4c32      	ldr	r4, [pc, #200]	; (414110 <sincos_store_val_abs+0x118>)
	fcos -= COSVALAVG/2;
  414048:	1b9b      	subs	r3, r3, r6
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  41404a:	eddf 6a32 	vldr	s13, [pc, #200]	; 414114 <sincos_store_val_abs+0x11c>
	fsin -= SINVALAVG/2;
  41404e:	2a00      	cmp	r2, #0
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  414050:	ed94 7a00 	vldr	s14, [r4]
	adc_reading_abs[0] -= COSVALMIN;
  414054:	8028      	strh	r0, [r5, #0]
	fsin -= SINVALAVG/2;
  414056:	4610      	mov	r0, r2
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  414058:	eec6 7a87 	vdiv.f32	s15, s13, s14
	fsin -= SINVALAVG/2;
  41405c:	bfb8      	it	lt
  41405e:	1c50      	addlt	r0, r2, #1
	fcos -= COSVALAVG/2;
  414060:	2b00      	cmp	r3, #0
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  414062:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 414124 <sincos_store_val_abs+0x12c>
	fsin -= SINVALAVG/2;
  414066:	eba1 0160 	sub.w	r1, r1, r0, asr #1
	fcos -= COSVALAVG/2;
  41406a:	4618      	mov	r0, r3
  41406c:	bfb8      	it	lt
  41406e:	1c58      	addlt	r0, r3, #1
	fsin /= (SINVALAVG/2);
  414070:	2a00      	cmp	r2, #0
	fsin *= FIXEDPT_ONE;
  414072:	ea4f 31c1 	mov.w	r1, r1, lsl #15
	f_cos += fixedpt_mul((fcos - f_cos), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  414076:	4e28      	ldr	r6, [pc, #160]	; (414118 <sincos_store_val_abs+0x120>)
	fsin /= (SINVALAVG/2);
  414078:	bfb8      	it	lt
  41407a:	3201      	addlt	r2, #1
	fcos /= (COSVALAVG/2);
  41407c:	2b00      	cmp	r3, #0
	fcos -= COSVALAVG/2;
  41407e:	eba7 0760 	sub.w	r7, r7, r0, asr #1
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  414082:	f8de c000 	ldr.w	ip, [lr]
	fcos /= (COSVALAVG/2);
  414086:	bfb8      	it	lt
  414088:	3301      	addlt	r3, #1
	fsin /= (SINVALAVG/2);
  41408a:	1052      	asrs	r2, r2, #1
	fcos *= FIXEDPT_ONE;
  41408c:	03ff      	lsls	r7, r7, #15
	f_cos += fixedpt_mul((fcos - f_cos), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  41408e:	6830      	ldr	r0, [r6, #0]
	fcos /= (COSVALAVG/2);
  414090:	105b      	asrs	r3, r3, #1
	fsin /= (SINVALAVG/2);
  414092:	fb91 f2f2 	sdiv	r2, r1, r2
	fcos /= (COSVALAVG/2);
  414096:	fb97 f3f3 	sdiv	r3, r7, r3
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  41409a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	f_cos += fixedpt_mul((fcos - f_cos), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  41409e:	1a1b      	subs	r3, r3, r0
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  4140a0:	eba2 020c 	sub.w	r2, r2, ip
  4140a4:	ee17 8a90 	vmov	r8, s15
  4140a8:	fb82 4508 	smull	r4, r5, r2, r8
  4140ac:	fb83 8908 	smull	r8, r9, r3, r8
  4140b0:	0be1      	lsrs	r1, r4, #15
	//dacc_interface_writeData(1, f_cos, FIXEDPT_ONE*2, 1);
	
	//fsin = arm_sin_f32(TST_ANGLE) * FIXEDPT_ONE;
	//fcos = arm_cos_f32(TST_ANGLE) * FIXEDPT_ONE;;
	
	abs_angle = arctan2(fcos, fsin); // get sincos phase val
  4140b2:	4c1a      	ldr	r4, [pc, #104]	; (41411c <sincos_store_val_abs+0x124>)
  4140b4:	ea4f 32d8 	mov.w	r2, r8, lsr #15
  4140b8:	ea41 4145 	orr.w	r1, r1, r5, lsl #17
  4140bc:	ea42 4249 	orr.w	r2, r2, r9, lsl #17
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  4140c0:	4461      	add	r1, ip
	f_cos += fixedpt_mul((fcos - f_cos), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  4140c2:	4402      	add	r2, r0
	f_sin += fixedpt_mul((fsin - f_sin), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  4140c4:	f8ce 1000 	str.w	r1, [lr]
	abs_angle = arctan2(fcos, fsin); // get sincos phase val
  4140c8:	4610      	mov	r0, r2
	f_cos += fixedpt_mul((fcos - f_cos), (TSAMPLE * ANG_FILTER * FIXEDPT_ONE));
  4140ca:	6032      	str	r2, [r6, #0]
	abs_angle = arctan2(fcos, fsin); // get sincos phase val
  4140cc:	47a0      	blx	r4
  4140ce:	4b14      	ldr	r3, [pc, #80]	; (414120 <sincos_store_val_abs+0x128>)
  4140d0:	6018      	str	r0, [r3, #0]
  4140d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if( adc_reading_abs[1] < SINVALMIN) adc_reading_abs[1] = SINVALMIN;
  4140d6:	490d      	ldr	r1, [pc, #52]	; (41410c <sincos_store_val_abs+0x114>)
	if( adc_reading_abs[0] < COSVALMIN) adc_reading_abs[0] = COSVALMIN;
  4140d8:	2700      	movs	r7, #0
	if( adc_reading_abs[1] < SINVALMIN) adc_reading_abs[1] = SINVALMIN;
  4140da:	f8b1 e000 	ldrh.w	lr, [r1]
	if( adc_reading_abs[0] < COSVALMIN) adc_reading_abs[0] = COSVALMIN;
  4140de:	4638      	mov	r0, r7
	if( adc_reading_abs[1] < SINVALMIN) adc_reading_abs[1] = SINVALMIN;
  4140e0:	45a6      	cmp	lr, r4
  4140e2:	d8ab      	bhi.n	41403c <sincos_store_val_abs+0x44>
  4140e4:	eba4 040e 	sub.w	r4, r4, lr
  4140e8:	b2a4      	uxth	r4, r4
  4140ea:	4621      	mov	r1, r4
  4140ec:	e7a8      	b.n	414040 <sincos_store_val_abs+0x48>
  4140ee:	bf00      	nop
  4140f0:	20406d00 	.word	0x20406d00
  4140f4:	00413e4d 	.word	0x00413e4d
  4140f8:	00413ea1 	.word	0x00413ea1
  4140fc:	00413f4d 	.word	0x00413f4d
  414100:	20400394 	.word	0x20400394
  414104:	2040039c 	.word	0x2040039c
  414108:	20400396 	.word	0x20400396
  41410c:	2040039e 	.word	0x2040039e
  414110:	204003c8 	.word	0x204003c8
  414114:	4c6b9e95 	.word	0x4c6b9e95
  414118:	20400b34 	.word	0x20400b34
  41411c:	00409755 	.word	0x00409755
  414120:	20406cfc 	.word	0x20406cfc
  414124:	20400b38 	.word	0x20400b38

00414128 <sincos_getangle_elec>:
float sincos_getangle_elec(uint32_t pole_pair)
{
	float ret_val;
	uint64_t tmp;
	
	tmp = abs_angle;
  414128:	490b      	ldr	r1, [pc, #44]	; (414158 <sincos_getangle_elec+0x30>)
	tmp = ((tmp * pole_pair) % fixedpt_rconst(360));
  41412a:	f44f 0234 	mov.w	r2, #11796480	; 0xb40000
{
  41412e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  414130:	4604      	mov	r4, r0
	tmp = abs_angle;
  414132:	6808      	ldr	r0, [r1, #0]
	tmp = ((tmp * pole_pair) % fixedpt_rconst(360));
  414134:	4d09      	ldr	r5, [pc, #36]	; (41415c <sincos_getangle_elec+0x34>)
  414136:	2300      	movs	r3, #0
	tmp = abs_angle;
  414138:	17c7      	asrs	r7, r0, #31
	tmp = ((tmp * pole_pair) % fixedpt_rconst(360));
  41413a:	fba0 0104 	umull	r0, r1, r0, r4
  41413e:	fb04 1107 	mla	r1, r4, r7, r1
  414142:	47a8      	blx	r5
	ret_val = tmp / FIXEDPT_ONE;
  414144:	0bd2      	lsrs	r2, r2, #15
  414146:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	
	return ret_val;
  41414a:	ee07 2a90 	vmov	s15, r2
  41414e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  414152:	ee17 0a90 	vmov	r0, s15
  414156:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  414158:	20406cfc 	.word	0x20406cfc
  41415c:	004190fd 	.word	0x004190fd

00414160 <ersdstates_move_exe>:
void ersdstates_move_exit(void)
{

}
void ersdstates_move_exe(void)
{
  414160:	4770      	bx	lr
  414162:	bf00      	nop

00414164 <ersdstates_find_ldir_exe>:
	if (MOTOR_PM_CVC)
  414164:	4b5b      	ldr	r3, [pc, #364]	; (4142d4 <ersdstates_find_ldir_exe+0x170>)
{
  414166:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  41416a:	ed2d 8b02 	vpush	{d8}
	if (MOTOR_PM_CVC)
  41416e:	f893 20c5 	ldrb.w	r2, [r3, #197]	; 0xc5
  414172:	2a01      	cmp	r2, #1
  414174:	d036      	beq.n	4141e4 <ersdstates_find_ldir_exe+0x80>
	if ((stage == 1) || (stage == 3))
  414176:	4e58      	ldr	r6, [pc, #352]	; (4142d8 <ersdstates_find_ldir_exe+0x174>)
		stage_time = ERSD_LDIR_WAIT_TIME;
  414178:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  41417c:	4c57      	ldr	r4, [pc, #348]	; (4142dc <ersdstates_find_ldir_exe+0x178>)
	if ((stage == 1) || (stage == 3))
  41417e:	f996 1000 	ldrsb.w	r1, [r6]
  414182:	f021 0302 	bic.w	r3, r1, #2
  414186:	2b01      	cmp	r3, #1
  414188:	d028      	beq.n	4141dc <ersdstates_find_ldir_exe+0x78>
		stage_time = ERSD_LDIR_TEST_TIME;
  41418a:	8ba3      	ldrh	r3, [r4, #28]
  41418c:	fb02 f203 	mul.w	r2, r2, r3
  414190:	f502 62fa 	add.w	r2, r2, #2000	; 0x7d0
	if (++ersd_test_ldir_counter > stage_time)
  414194:	4d52      	ldr	r5, [pc, #328]	; (4142e0 <ersdstates_find_ldir_exe+0x17c>)
  414196:	682b      	ldr	r3, [r5, #0]
  414198:	3301      	adds	r3, #1
  41419a:	429a      	cmp	r2, r3
  41419c:	602b      	str	r3, [r5, #0]
  41419e:	d219      	bcs.n	4141d4 <ersdstates_find_ldir_exe+0x70>
		if (stage == 0)
  4141a0:	2900      	cmp	r1, #0
  4141a2:	d03c      	beq.n	41421e <ersdstates_find_ldir_exe+0xba>
		else if(stage == 1)
  4141a4:	2901      	cmp	r1, #1
  4141a6:	d069      	beq.n	41427c <ersdstates_find_ldir_exe+0x118>
		else if(stage == 2)
  4141a8:	2902      	cmp	r1, #2
  4141aa:	d049      	beq.n	414240 <ersdstates_find_ldir_exe+0xdc>
			vfd_set_motion_acc (ERSD_ACC);
  4141ac:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  4141ae:	4b4d      	ldr	r3, [pc, #308]	; (4142e4 <ersdstates_find_ldir_exe+0x180>)
  4141b0:	4798      	blx	r3
			vfd_set_motion_j1  (ERSD_J);
  4141b2:	6f20      	ldr	r0, [r4, #112]	; 0x70
  4141b4:	4b4c      	ldr	r3, [pc, #304]	; (4142e8 <ersdstates_find_ldir_exe+0x184>)
  4141b6:	4798      	blx	r3
			vfd_set_motion_j2  (ERSD_J);
  4141b8:	6f20      	ldr	r0, [r4, #112]	; 0x70
  4141ba:	4b4c      	ldr	r3, [pc, #304]	; (4142ec <ersdstates_find_ldir_exe+0x188>)
  4141bc:	4798      	blx	r3
			vfd_set_ref_speed(ersd_ldir * ERSD_SPEED);
  4141be:	4b4c      	ldr	r3, [pc, #304]	; (4142f0 <ersdstates_find_ldir_exe+0x18c>)
  4141c0:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  4141c2:	f993 2000 	ldrsb.w	r2, [r3]
  4141c6:	4b4b      	ldr	r3, [pc, #300]	; (4142f4 <ersdstates_find_ldir_exe+0x190>)
  4141c8:	fb00 f002 	mul.w	r0, r0, r2
  4141cc:	4798      	blx	r3
	ersdstate_ptr = &ersdstates_move_exe;
  4141ce:	4b4a      	ldr	r3, [pc, #296]	; (4142f8 <ersdstates_find_ldir_exe+0x194>)
  4141d0:	4a4a      	ldr	r2, [pc, #296]	; (4142fc <ersdstates_find_ldir_exe+0x198>)
  4141d2:	601a      	str	r2, [r3, #0]
}
  4141d4:	ecbd 8b02 	vpop	{d8}
  4141d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		stage_time = ERSD_LDIR_WAIT_TIME;
  4141dc:	8b63      	ldrh	r3, [r4, #26]
  4141de:	fb02 f203 	mul.w	r2, r2, r3
  4141e2:	e7d7      	b.n	414194 <ersdstates_find_ldir_exe+0x30>
	if (MOTOR_PM_CVC)
  4141e4:	781b      	ldrb	r3, [r3, #0]
  4141e6:	2b01      	cmp	r3, #1
  4141e8:	d1c5      	bne.n	414176 <ersdstates_find_ldir_exe+0x12>
		ersd_ldir = vfd_get_l_dir();
  4141ea:	4b45      	ldr	r3, [pc, #276]	; (414300 <ersdstates_find_ldir_exe+0x19c>)
  4141ec:	4798      	blx	r3
  4141ee:	4c40      	ldr	r4, [pc, #256]	; (4142f0 <ersdstates_find_ldir_exe+0x18c>)
  4141f0:	b240      	sxtb	r0, r0
  4141f2:	7020      	strb	r0, [r4, #0]
		if (ersd_ldir)
  4141f4:	2800      	cmp	r0, #0
  4141f6:	d0ed      	beq.n	4141d4 <ersdstates_find_ldir_exe+0x70>
			vfd_set_ref_speed(ersd_ldir * ERSD_SPEED);
  4141f8:	4d38      	ldr	r5, [pc, #224]	; (4142dc <ersdstates_find_ldir_exe+0x178>)
  4141fa:	4b3e      	ldr	r3, [pc, #248]	; (4142f4 <ersdstates_find_ldir_exe+0x190>)
  4141fc:	6eaa      	ldr	r2, [r5, #104]	; 0x68
  4141fe:	fb02 f000 	mul.w	r0, r2, r0
  414202:	4798      	blx	r3
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  414204:	7aeb      	ldrb	r3, [r5, #11]
			ers_set_dirup(ersd_ldir);
  414206:	f994 2000 	ldrsb.w	r2, [r4]
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  41420a:	2b00      	cmp	r3, #0
  41420c:	d05c      	beq.n	4142c8 <ersdstates_find_ldir_exe+0x164>
	else if ((menue_lift_data_applied.m_up_dir == 1) && (speed_sign < 0))
  41420e:	2a00      	cmp	r2, #0
  414210:	da01      	bge.n	414216 <ersdstates_find_ldir_exe+0xb2>
  414212:	2b01      	cmp	r3, #1
  414214:	d05a      	beq.n	4142cc <ersdstates_find_ldir_exe+0x168>
		direction_up = 0;
  414216:	4b3b      	ldr	r3, [pc, #236]	; (414304 <ersdstates_find_ldir_exe+0x1a0>)
  414218:	2200      	movs	r2, #0
  41421a:	701a      	strb	r2, [r3, #0]
  41421c:	e7d7      	b.n	4141ce <ersdstates_find_ldir_exe+0x6a>
			stage ++;
  41421e:	2201      	movs	r2, #1
			ard_motor_current = axt_get_current_avg(); // get current val to be tested later
  414220:	4b39      	ldr	r3, [pc, #228]	; (414308 <ersdstates_find_ldir_exe+0x1a4>)
			stage ++;
  414222:	7032      	strb	r2, [r6, #0]
			ard_motor_current = axt_get_current_avg(); // get current val to be tested later
  414224:	4798      	blx	r3
  414226:	ee07 0a90 	vmov	s15, r0
  41422a:	4a38      	ldr	r2, [pc, #224]	; (41430c <ersdstates_find_ldir_exe+0x1a8>)
			vfd_estop();
  41422c:	4b38      	ldr	r3, [pc, #224]	; (414310 <ersdstates_find_ldir_exe+0x1ac>)
			ard_motor_current = axt_get_current_avg(); // get current val to be tested later
  41422e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  414232:	edc2 7a00 	vstr	s15, [r2]
}
  414236:	ecbd 8b02 	vpop	{d8}
  41423a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			vfd_estop();
  41423e:	4718      	bx	r3
			if(ard_motor_current > axt_get_current_avg())
  414240:	4a32      	ldr	r2, [pc, #200]	; (41430c <ersdstates_find_ldir_exe+0x1a8>)
  414242:	4b31      	ldr	r3, [pc, #196]	; (414308 <ersdstates_find_ldir_exe+0x1a4>)
  414244:	ed92 8a00 	vldr	s16, [r2]
  414248:	4798      	blx	r3
  41424a:	ee07 0a90 	vmov	s15, r0
  41424e:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
  414252:	eeb4 8ae7 	vcmpe.f32	s16, s15
  414256:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41425a:	dcb8      	bgt.n	4141ce <ersdstates_find_ldir_exe+0x6a>
				stage++;
  41425c:	7833      	ldrb	r3, [r6, #0]
				vfd_estop();
  41425e:	4a2c      	ldr	r2, [pc, #176]	; (414310 <ersdstates_find_ldir_exe+0x1ac>)
				stage++;
  414260:	3301      	adds	r3, #1
  414262:	7033      	strb	r3, [r6, #0]
				vfd_estop();
  414264:	4790      	blx	r2
				ersd_ldir = 1;
  414266:	2001      	movs	r0, #1
  414268:	4921      	ldr	r1, [pc, #132]	; (4142f0 <ersdstates_find_ldir_exe+0x18c>)
				ersd_test_ldir_counter = 0;
  41426a:	2200      	movs	r2, #0
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  41426c:	7ae3      	ldrb	r3, [r4, #11]
				ersd_ldir = 1;
  41426e:	7008      	strb	r0, [r1, #0]
				ersd_test_ldir_counter = 0;
  414270:	602a      	str	r2, [r5, #0]
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  414272:	bb03      	cbnz	r3, 4142b6 <ersdstates_find_ldir_exe+0x152>
		direction_up = 1;
  414274:	4b23      	ldr	r3, [pc, #140]	; (414304 <ersdstates_find_ldir_exe+0x1a0>)
  414276:	2201      	movs	r2, #1
  414278:	701a      	strb	r2, [r3, #0]
  41427a:	e7ab      	b.n	4141d4 <ersdstates_find_ldir_exe+0x70>
			ersd_test_ldir_counter = 0;
  41427c:	2300      	movs	r3, #0
			ersd_ldir = -1;
  41427e:	21ff      	movs	r1, #255	; 0xff
			stage++;
  414280:	2202      	movs	r2, #2
			ersd_ldir = -1;
  414282:	4f1b      	ldr	r7, [pc, #108]	; (4142f0 <ersdstates_find_ldir_exe+0x18c>)
			vfd_set_motion_acc (ERSD_ACC);
  414284:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
			ersd_test_ldir_counter = 0;
  414286:	602b      	str	r3, [r5, #0]
			vfd_set_motion_acc (ERSD_ACC);
  414288:	4b16      	ldr	r3, [pc, #88]	; (4142e4 <ersdstates_find_ldir_exe+0x180>)
			ersd_ldir = -1;
  41428a:	7039      	strb	r1, [r7, #0]
			stage++;
  41428c:	7032      	strb	r2, [r6, #0]
			vfd_set_motion_acc (ERSD_ACC);
  41428e:	4798      	blx	r3
			vfd_set_motion_j1  (ERSD_J);
  414290:	6f20      	ldr	r0, [r4, #112]	; 0x70
  414292:	4b15      	ldr	r3, [pc, #84]	; (4142e8 <ersdstates_find_ldir_exe+0x184>)
  414294:	4798      	blx	r3
			vfd_set_motion_j2  (ERSD_J);
  414296:	6f20      	ldr	r0, [r4, #112]	; 0x70
  414298:	4b14      	ldr	r3, [pc, #80]	; (4142ec <ersdstates_find_ldir_exe+0x188>)
  41429a:	4798      	blx	r3
			vfd_set_ref_speed(ersd_ldir * ERSD_SPEED);
  41429c:	f997 2000 	ldrsb.w	r2, [r7]
  4142a0:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  4142a2:	4b14      	ldr	r3, [pc, #80]	; (4142f4 <ersdstates_find_ldir_exe+0x190>)
  4142a4:	fb00 f002 	mul.w	r0, r0, r2
  4142a8:	4798      	blx	r3
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  4142aa:	7ae3      	ldrb	r3, [r4, #11]
			ers_set_dirup(ersd_ldir);
  4142ac:	f997 2000 	ldrsb.w	r2, [r7]
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  4142b0:	b92b      	cbnz	r3, 4142be <ersdstates_find_ldir_exe+0x15a>
  4142b2:	2a00      	cmp	r2, #0
  4142b4:	dcde      	bgt.n	414274 <ersdstates_find_ldir_exe+0x110>
		direction_up = 0;
  4142b6:	4b13      	ldr	r3, [pc, #76]	; (414304 <ersdstates_find_ldir_exe+0x1a0>)
  4142b8:	2200      	movs	r2, #0
  4142ba:	701a      	strb	r2, [r3, #0]
  4142bc:	e78a      	b.n	4141d4 <ersdstates_find_ldir_exe+0x70>
	else if ((menue_lift_data_applied.m_up_dir == 1) && (speed_sign < 0))
  4142be:	2a00      	cmp	r2, #0
  4142c0:	daf9      	bge.n	4142b6 <ersdstates_find_ldir_exe+0x152>
  4142c2:	2b01      	cmp	r3, #1
  4142c4:	d1f7      	bne.n	4142b6 <ersdstates_find_ldir_exe+0x152>
  4142c6:	e7d5      	b.n	414274 <ersdstates_find_ldir_exe+0x110>
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  4142c8:	2a00      	cmp	r2, #0
  4142ca:	dda4      	ble.n	414216 <ersdstates_find_ldir_exe+0xb2>
		direction_up = 1;
  4142cc:	4b0d      	ldr	r3, [pc, #52]	; (414304 <ersdstates_find_ldir_exe+0x1a0>)
  4142ce:	2201      	movs	r2, #1
  4142d0:	701a      	strb	r2, [r3, #0]
  4142d2:	e77c      	b.n	4141ce <ersdstates_find_ldir_exe+0x6a>
  4142d4:	20404ff0 	.word	0x20404ff0
  4142d8:	20400b59 	.word	0x20400b59
  4142dc:	204052b4 	.word	0x204052b4
  4142e0:	20400b4c 	.word	0x20400b4c
  4142e4:	00416f41 	.word	0x00416f41
  4142e8:	00416f4d 	.word	0x00416f4d
  4142ec:	00416f59 	.word	0x00416f59
  4142f0:	204003a0 	.word	0x204003a0
  4142f4:	00416f8d 	.word	0x00416f8d
  4142f8:	20400b54 	.word	0x20400b54
  4142fc:	00414161 	.word	0x00414161
  414300:	00416c0d 	.word	0x00416c0d
  414304:	20400c66 	.word	0x20400c66
  414308:	0040e379 	.word	0x0040e379
  41430c:	20406d04 	.word	0x20406d04
  414310:	00417215 	.word	0x00417215

00414314 <ersd_force_turn_off>:
	turnoff_battery_mode = 1;
  414314:	4b01      	ldr	r3, [pc, #4]	; (41431c <ersd_force_turn_off+0x8>)
  414316:	2201      	movs	r2, #1
  414318:	701a      	strb	r2, [r3, #0]
  41431a:	4770      	bx	lr
  41431c:	20400b5a 	.word	0x20400b5a

00414320 <ersd_allowTo_turn_on>:
	turnoff_battery_mode = 0;
  414320:	4b01      	ldr	r3, [pc, #4]	; (414328 <ersd_allowTo_turn_on+0x8>)
  414322:	2200      	movs	r2, #0
  414324:	701a      	strb	r2, [r3, #0]
  414326:	4770      	bx	lr
  414328:	20400b5a 	.word	0x20400b5a

0041432c <ersdstates_init_exit>:
	vfd_states_set_softcharge_mode(0); //clear softcharge
  41432c:	4b0a      	ldr	r3, [pc, #40]	; (414358 <ersdstates_init_exit+0x2c>)
  41432e:	2000      	movs	r0, #0
{
  414330:	b510      	push	{r4, lr}
	vfd_states_set_softcharge_mode(0); //clear softcharge
  414332:	4798      	blx	r3
	if(menue_drive_data_applied.m_ard_type == 0)
  414334:	4b09      	ldr	r3, [pc, #36]	; (41435c <ersdstates_init_exit+0x30>)

}

void ersdstates_idle_enter(void)
{
	ersdstate_ptr = &ersdstates_idle_exe;
  414336:	4a0a      	ldr	r2, [pc, #40]	; (414360 <ersdstates_init_exit+0x34>)
  414338:	490a      	ldr	r1, [pc, #40]	; (414364 <ersdstates_init_exit+0x38>)
	if(menue_drive_data_applied.m_ard_type == 0)
  41433a:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
	ersdstate_ptr = &ersdstates_idle_exe;
  41433e:	6011      	str	r1, [r2, #0]
	if(menue_drive_data_applied.m_ard_type == 0)
  414340:	b123      	cbz	r3, 41434c <ersdstates_init_exit+0x20>
		inverter_set_manual_dcVal(fixedpt_rconst(0));	
  414342:	2000      	movs	r0, #0
  414344:	4b08      	ldr	r3, [pc, #32]	; (414368 <ersdstates_init_exit+0x3c>)
}
  414346:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		inverter_set_manual_dcVal(fixedpt_rconst(0));	
  41434a:	4718      	bx	r3
		inverter_set_manual_dcVal(fixedpt_rconst(48));
  41434c:	f44f 10c0 	mov.w	r0, #1572864	; 0x180000
  414350:	4b05      	ldr	r3, [pc, #20]	; (414368 <ersdstates_init_exit+0x3c>)
}
  414352:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		inverter_set_manual_dcVal(fixedpt_rconst(48));
  414356:	4718      	bx	r3
  414358:	00416279 	.word	0x00416279
  41435c:	20404ff0 	.word	0x20404ff0
  414360:	20400b54 	.word	0x20400b54
  414364:	00414469 	.word	0x00414469
  414368:	004156fd 	.word	0x004156fd

0041436c <ersdstates_init_exe>:
	if(ersd_init_delay_counter++ > INIT_DELAY)
  41436c:	4a05      	ldr	r2, [pc, #20]	; (414384 <ersdstates_init_exe+0x18>)
  41436e:	f241 3188 	movw	r1, #5000	; 0x1388
  414372:	6813      	ldr	r3, [r2, #0]
  414374:	1c58      	adds	r0, r3, #1
  414376:	428b      	cmp	r3, r1
  414378:	6010      	str	r0, [r2, #0]
  41437a:	d800      	bhi.n	41437e <ersdstates_init_exe+0x12>
  41437c:	4770      	bx	lr
		ersdstates_init_exit();
  41437e:	4b02      	ldr	r3, [pc, #8]	; (414388 <ersdstates_init_exe+0x1c>)
  414380:	4718      	bx	r3
  414382:	bf00      	nop
  414384:	20400b48 	.word	0x20400b48
  414388:	0041432d 	.word	0x0041432d

0041438c <ersdstates_find_ldir_enter>:
{
  41438c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	vfd_set_motion_acc (ERSD_ACC);
  41438e:	4c1d      	ldr	r4, [pc, #116]	; (414404 <ersdstates_find_ldir_enter+0x78>)
	stage = 0;
  414390:	2100      	movs	r1, #0
	ersdstate_ptr = &ersdstates_find_ldir_exe;
  414392:	4b1d      	ldr	r3, [pc, #116]	; (414408 <ersdstates_find_ldir_enter+0x7c>)
	ersd_ldir = 1;
  414394:	2601      	movs	r6, #1
	ersdstate_ptr = &ersdstates_find_ldir_exe;
  414396:	4f1d      	ldr	r7, [pc, #116]	; (41440c <ersdstates_find_ldir_enter+0x80>)
	stage = 0;
  414398:	4a1d      	ldr	r2, [pc, #116]	; (414410 <ersdstates_find_ldir_enter+0x84>)
	ersd_ldir = 1;
  41439a:	4d1e      	ldr	r5, [pc, #120]	; (414414 <ersdstates_find_ldir_enter+0x88>)
	vfd_set_motion_acc (ERSD_ACC);
  41439c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
	ersdstate_ptr = &ersdstates_find_ldir_exe;
  41439e:	601f      	str	r7, [r3, #0]
	vfd_set_motion_acc (ERSD_ACC);
  4143a0:	4b1d      	ldr	r3, [pc, #116]	; (414418 <ersdstates_find_ldir_enter+0x8c>)
	stage = 0;
  4143a2:	7011      	strb	r1, [r2, #0]
	ersd_ldir = 1;
  4143a4:	702e      	strb	r6, [r5, #0]
	vfd_set_motion_acc (ERSD_ACC);
  4143a6:	4798      	blx	r3
	vfd_set_motion_j1  (ERSD_J);
  4143a8:	6f20      	ldr	r0, [r4, #112]	; 0x70
  4143aa:	4b1c      	ldr	r3, [pc, #112]	; (41441c <ersdstates_find_ldir_enter+0x90>)
  4143ac:	4798      	blx	r3
	vfd_set_motion_j2  (ERSD_J);
  4143ae:	4b1c      	ldr	r3, [pc, #112]	; (414420 <ersdstates_find_ldir_enter+0x94>)
  4143b0:	6f20      	ldr	r0, [r4, #112]	; 0x70
  4143b2:	4798      	blx	r3
	if(MOTOR_PM_CVC) vfd_set_ref_speed(ersd_ldir * fixedpt_rconst(0.0005));
  4143b4:	4b1b      	ldr	r3, [pc, #108]	; (414424 <ersdstates_find_ldir_enter+0x98>)
  4143b6:	f893 20c5 	ldrb.w	r2, [r3, #197]	; 0xc5
  4143ba:	42b2      	cmp	r2, r6
  4143bc:	d018      	beq.n	4143f0 <ersdstates_find_ldir_enter+0x64>
	else vfd_set_ref_speed(ersd_ldir * ERSD_SPEED);
  4143be:	f995 2000 	ldrsb.w	r2, [r5]
  4143c2:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  4143c4:	4b18      	ldr	r3, [pc, #96]	; (414428 <ersdstates_find_ldir_enter+0x9c>)
  4143c6:	fb00 f002 	mul.w	r0, r0, r2
  4143ca:	4798      	blx	r3
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  4143cc:	7ae3      	ldrb	r3, [r4, #11]
	ers_set_dirup(ersd_ldir);
  4143ce:	f995 2000 	ldrsb.w	r2, [r5]
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  4143d2:	b13b      	cbz	r3, 4143e4 <ersdstates_find_ldir_enter+0x58>
	else if ((menue_lift_data_applied.m_up_dir == 1) && (speed_sign < 0))
  4143d4:	2b01      	cmp	r3, #1
  4143d6:	d101      	bne.n	4143dc <ersdstates_find_ldir_enter+0x50>
  4143d8:	2a00      	cmp	r2, #0
  4143da:	db05      	blt.n	4143e8 <ersdstates_find_ldir_enter+0x5c>
		direction_up = 0;
  4143dc:	4b13      	ldr	r3, [pc, #76]	; (41442c <ersdstates_find_ldir_enter+0xa0>)
  4143de:	2200      	movs	r2, #0
  4143e0:	701a      	strb	r2, [r3, #0]
  4143e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((menue_lift_data_applied.m_up_dir == 0) && (speed_sign > 0))
  4143e4:	2a00      	cmp	r2, #0
  4143e6:	ddf9      	ble.n	4143dc <ersdstates_find_ldir_enter+0x50>
		direction_up = 1;
  4143e8:	4b10      	ldr	r3, [pc, #64]	; (41442c <ersdstates_find_ldir_enter+0xa0>)
  4143ea:	2201      	movs	r2, #1
  4143ec:	701a      	strb	r2, [r3, #0]
  4143ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(MOTOR_PM_CVC) vfd_set_ref_speed(ersd_ldir * fixedpt_rconst(0.0005));
  4143f0:	781b      	ldrb	r3, [r3, #0]
  4143f2:	42b3      	cmp	r3, r6
  4143f4:	d1e3      	bne.n	4143be <ersdstates_find_ldir_enter+0x32>
  4143f6:	f995 0000 	ldrsb.w	r0, [r5]
  4143fa:	4b0b      	ldr	r3, [pc, #44]	; (414428 <ersdstates_find_ldir_enter+0x9c>)
  4143fc:	0100      	lsls	r0, r0, #4
  4143fe:	4798      	blx	r3
  414400:	e7e4      	b.n	4143cc <ersdstates_find_ldir_enter+0x40>
  414402:	bf00      	nop
  414404:	204052b4 	.word	0x204052b4
  414408:	20400b54 	.word	0x20400b54
  41440c:	00414165 	.word	0x00414165
  414410:	20400b59 	.word	0x20400b59
  414414:	204003a0 	.word	0x204003a0
  414418:	00416f41 	.word	0x00416f41
  41441c:	00416f4d 	.word	0x00416f4d
  414420:	00416f59 	.word	0x00416f59
  414424:	20404ff0 	.word	0x20404ff0
  414428:	00416f8d 	.word	0x00416f8d
  41442c:	20400c66 	.word	0x20400c66

00414430 <ersdstates_turningOff_enter>:

// a delay state to turnoff battery mode
uint32_t ersd_turningoff_counter = 0;
void ersdstates_turningOff_enter(void)
{
	ersdstate_ptr = &ersdstates_turningOff_exe;
  414430:	4a07      	ldr	r2, [pc, #28]	; (414450 <ersdstates_turningOff_enter+0x20>)
  414432:	4908      	ldr	r1, [pc, #32]	; (414454 <ersdstates_turningOff_enter+0x24>)
{
  414434:	b508      	push	{r3, lr}
	if(vfd_states_initialized())
  414436:	4b08      	ldr	r3, [pc, #32]	; (414458 <ersdstates_turningOff_enter+0x28>)
	ersdstate_ptr = &ersdstates_turningOff_exe;
  414438:	6011      	str	r1, [r2, #0]
	if(vfd_states_initialized())
  41443a:	4798      	blx	r3
  41443c:	b120      	cbz	r0, 414448 <ersdstates_turningOff_enter+0x18>
	{
		vfd_states_set_softcharge_mode(1); //set softcharge
  41443e:	4b07      	ldr	r3, [pc, #28]	; (41445c <ersdstates_turningOff_enter+0x2c>)
  414440:	2001      	movs	r0, #1
  414442:	4798      	blx	r3
		vfd_trip();
  414444:	4b06      	ldr	r3, [pc, #24]	; (414460 <ersdstates_turningOff_enter+0x30>)
  414446:	4798      	blx	r3
	}
	ersd_turningoff_counter = 0;
  414448:	4b06      	ldr	r3, [pc, #24]	; (414464 <ersdstates_turningOff_enter+0x34>)
  41444a:	2200      	movs	r2, #0
  41444c:	601a      	str	r2, [r3, #0]
  41444e:	bd08      	pop	{r3, pc}
  414450:	20400b54 	.word	0x20400b54
  414454:	004144e1 	.word	0x004144e1
  414458:	00416335 	.word	0x00416335
  41445c:	00416279 	.word	0x00416279
  414460:	0041724d 	.word	0x0041724d
  414464:	20400b50 	.word	0x20400b50

00414468 <ersdstates_idle_exe>:
	if(ERSD_TURNING_OFF_SIG) ersdstates_turningOff_enter();
  414468:	4b00      	ldr	r3, [pc, #0]	; (41446c <ersdstates_idle_exe+0x4>)
  41446a:	4718      	bx	r3
  41446c:	00414431 	.word	0x00414431

00414470 <ersdstates_off_exe>:
	if(ERSD_TURNING_ON_SIG) 
	{
		ersdstates_off_exit();
		prev_ersin = 1;
	}
	else if(prev_ersin == 1) ersdstates_turningOff_enter();
  414470:	4b04      	ldr	r3, [pc, #16]	; (414484 <ersdstates_off_exe+0x14>)
  414472:	781b      	ldrb	r3, [r3, #0]
  414474:	2b01      	cmp	r3, #1
  414476:	d003      	beq.n	414480 <ersdstates_off_exe+0x10>
	else ersd_exitingAuto = 0;
  414478:	4b03      	ldr	r3, [pc, #12]	; (414488 <ersdstates_off_exe+0x18>)
  41447a:	2200      	movs	r2, #0
  41447c:	701a      	strb	r2, [r3, #0]
  41447e:	4770      	bx	lr
	else if(prev_ersin == 1) ersdstates_turningOff_enter();
  414480:	4b02      	ldr	r3, [pc, #8]	; (41448c <ersdstates_off_exe+0x1c>)
  414482:	4718      	bx	r3
  414484:	20400b58 	.word	0x20400b58
  414488:	20400b44 	.word	0x20400b44
  41448c:	00414431 	.word	0x00414431

00414490 <ersdstates_off_enter>:
	ersdstate_ptr = &ersdstates_off_exe;
  414490:	4a0b      	ldr	r2, [pc, #44]	; (4144c0 <ersdstates_off_enter+0x30>)
	inverter_ignore_uv(0);
  414492:	2000      	movs	r0, #0
	ersdstate_ptr = &ersdstates_off_exe;
  414494:	490b      	ldr	r1, [pc, #44]	; (4144c4 <ersdstates_off_enter+0x34>)
	inverter_ignore_uv(0);
  414496:	4b0c      	ldr	r3, [pc, #48]	; (4144c8 <ersdstates_off_enter+0x38>)
{
  414498:	b570      	push	{r4, r5, r6, lr}
	ersdstate_ptr = &ersdstates_off_exe;
  41449a:	6011      	str	r1, [r2, #0]
	inverter_ignore_uv(0);
  41449c:	4798      	blx	r3
	inverter_set_manual_dcVal(0); // set the DC bus to its original val
  41449e:	2000      	movs	r0, #0
  4144a0:	4b0a      	ldr	r3, [pc, #40]	; (4144cc <ersdstates_off_enter+0x3c>)
  4144a2:	4798      	blx	r3
	ersd_exit_delay_counter = 0;
  4144a4:	4e0a      	ldr	r6, [pc, #40]	; (4144d0 <ersdstates_off_enter+0x40>)
  4144a6:	2300      	movs	r3, #0
	ersd_exitingAuto = 0;
  4144a8:	4d0a      	ldr	r5, [pc, #40]	; (4144d4 <ersdstates_off_enter+0x44>)
	prev_ersin = 0;
  4144aa:	4c0b      	ldr	r4, [pc, #44]	; (4144d8 <ersdstates_off_enter+0x48>)
	m_ers(0);
  4144ac:	2003      	movs	r0, #3
	ersd_exit_delay_counter = 0;
  4144ae:	6033      	str	r3, [r6, #0]
	m_ers(0);
  4144b0:	4619      	mov	r1, r3
	ersd_exitingAuto = 0;
  4144b2:	702b      	strb	r3, [r5, #0]
	prev_ersin = 0;
  4144b4:	7023      	strb	r3, [r4, #0]
	m_ers(0);
  4144b6:	4a09      	ldr	r2, [pc, #36]	; (4144dc <ersdstates_off_enter+0x4c>)
}
  4144b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	m_ers(0);
  4144bc:	4710      	bx	r2
  4144be:	bf00      	nop
  4144c0:	20400b54 	.word	0x20400b54
  4144c4:	00414471 	.word	0x00414471
  4144c8:	00414c09 	.word	0x00414c09
  4144cc:	004156fd 	.word	0x004156fd
  4144d0:	20400b40 	.word	0x20400b40
  4144d4:	20400b44 	.word	0x20400b44
  4144d8:	20400b58 	.word	0x20400b58
  4144dc:	00400941 	.word	0x00400941

004144e0 <ersdstates_turningOff_exe>:
	if(++ersd_turningoff_counter == (ERSD_TURNING_OFF_DELAY/4))
  4144e0:	490e      	ldr	r1, [pc, #56]	; (41451c <ersdstates_turningOff_exe+0x3c>)
  4144e2:	22fa      	movs	r2, #250	; 0xfa
  4144e4:	480e      	ldr	r0, [pc, #56]	; (414520 <ersdstates_turningOff_exe+0x40>)
  4144e6:	680b      	ldr	r3, [r1, #0]
  4144e8:	8ac0      	ldrh	r0, [r0, #22]
  4144ea:	3301      	adds	r3, #1
  4144ec:	fb02 f200 	mul.w	r2, r2, r0
  4144f0:	600b      	str	r3, [r1, #0]
  4144f2:	4293      	cmp	r3, r2
  4144f4:	d00e      	beq.n	414514 <ersdstates_turningOff_exe+0x34>
	else if(ersd_turningoff_counter > (ERSD_TURNING_OFF_DELAY))
  4144f6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4144fa:	fb02 f200 	mul.w	r2, r2, r0
  4144fe:	4293      	cmp	r3, r2
  414500:	d800      	bhi.n	414504 <ersdstates_turningOff_exe+0x24>
  414502:	4770      	bx	lr
{
  414504:	b510      	push	{r4, lr}
	vfd_states_set_softcharge_mode(0); //clear softcharge
  414506:	4b07      	ldr	r3, [pc, #28]	; (414524 <ersdstates_turningOff_exe+0x44>)
  414508:	2000      	movs	r0, #0
  41450a:	4798      	blx	r3
	ersdstates_off_enter();
  41450c:	4b06      	ldr	r3, [pc, #24]	; (414528 <ersdstates_turningOff_exe+0x48>)
}
  41450e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	ersdstates_off_enter();
  414512:	4718      	bx	r3
		m_ers(0);
  414514:	2100      	movs	r1, #0
  414516:	2003      	movs	r0, #3
  414518:	4b04      	ldr	r3, [pc, #16]	; (41452c <ersdstates_turningOff_exe+0x4c>)
  41451a:	4718      	bx	r3
  41451c:	20400b50 	.word	0x20400b50
  414520:	204052b4 	.word	0x204052b4
  414524:	00416279 	.word	0x00416279
  414528:	00414491 	.word	0x00414491
  41452c:	00400941 	.word	0x00400941

00414530 <ersd_isOff>:
}

uint32_t ersd_isOff(void)
{
	if(ersdstate_ptr == &ersdstates_off_exe) return 1;
  414530:	4a03      	ldr	r2, [pc, #12]	; (414540 <ersd_isOff+0x10>)
  414532:	4b04      	ldr	r3, [pc, #16]	; (414544 <ersd_isOff+0x14>)
  414534:	6810      	ldr	r0, [r2, #0]
	return 0;
}
  414536:	1ac0      	subs	r0, r0, r3
  414538:	fab0 f080 	clz	r0, r0
  41453c:	0940      	lsrs	r0, r0, #5
  41453e:	4770      	bx	lr
  414540:	20400b54 	.word	0x20400b54
  414544:	00414471 	.word	0x00414471

00414548 <ersd_isReady>:

uint32_t ersd_isReady(void)
{
	
	if(ersdstate_ptr == &ersdstates_idle_exe)
  414548:	4a03      	ldr	r2, [pc, #12]	; (414558 <ersd_isReady+0x10>)
  41454a:	4b04      	ldr	r3, [pc, #16]	; (41455c <ersd_isReady+0x14>)
  41454c:	6810      	ldr	r0, [r2, #0]
	else
	{
		return 0;
	}
	
}
  41454e:	1ac0      	subs	r0, r0, r3
  414550:	fab0 f080 	clz	r0, r0
  414554:	0940      	lsrs	r0, r0, #5
  414556:	4770      	bx	lr
  414558:	20400b54 	.word	0x20400b54
  41455c:	00414469 	.word	0x00414469

00414560 <ersd_move>:
void ersd_move(void)
{
	if(ersd_isReady) ersdstates_find_ldir_enter();
  414560:	4b00      	ldr	r3, [pc, #0]	; (414564 <ersd_move+0x4>)
  414562:	4718      	bx	r3
  414564:	0041438d 	.word	0x0041438d

00414568 <ersd_stop>:
}
void ersd_stop(void)
{
	if(ersdstate_ptr == &ersdstates_init_exe) return;
  414568:	4a05      	ldr	r2, [pc, #20]	; (414580 <ersd_stop+0x18>)
	if(ersdstate_ptr == &ersdstates_off_exe) return;
  41456a:	4806      	ldr	r0, [pc, #24]	; (414584 <ersd_stop+0x1c>)
	if(ersdstate_ptr == &ersdstates_init_exe) return;
  41456c:	6813      	ldr	r3, [r2, #0]
  41456e:	4906      	ldr	r1, [pc, #24]	; (414588 <ersd_stop+0x20>)
	if(ersdstate_ptr == 0) return;
  414570:	428b      	cmp	r3, r1
  414572:	bf18      	it	ne
  414574:	4283      	cmpne	r3, r0
  414576:	d002      	beq.n	41457e <ersd_stop+0x16>
  414578:	b10b      	cbz	r3, 41457e <ersd_stop+0x16>
	ersdstate_ptr = &ersdstates_idle_exe;
  41457a:	4b04      	ldr	r3, [pc, #16]	; (41458c <ersd_stop+0x24>)
  41457c:	6013      	str	r3, [r2, #0]
  41457e:	4770      	bx	lr
  414580:	20400b54 	.word	0x20400b54
  414584:	00414471 	.word	0x00414471
  414588:	0041436d 	.word	0x0041436d
  41458c:	00414469 	.word	0x00414469

00414590 <ersdstates_handler>:
	ersdstates_idle_enter();
}

void ersdstates_handler(void)
{
  414590:	b510      	push	{r4, lr}
	if(ersdstate_ptr == 0) 
  414592:	4c06      	ldr	r4, [pc, #24]	; (4145ac <ersdstates_handler+0x1c>)
  414594:	6823      	ldr	r3, [r4, #0]
  414596:	b113      	cbz	r3, 41459e <ersdstates_handler+0xe>
		ersdstates_off_enter();
	(*ersdstate_ptr)();
  414598:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(*ersdstate_ptr)();
  41459c:	4718      	bx	r3
		ersdstates_off_enter();
  41459e:	4b04      	ldr	r3, [pc, #16]	; (4145b0 <ersdstates_handler+0x20>)
  4145a0:	4798      	blx	r3
  4145a2:	6823      	ldr	r3, [r4, #0]
  4145a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(*ersdstate_ptr)();
  4145a8:	4718      	bx	r3
  4145aa:	bf00      	nop
  4145ac:	20400b54 	.word	0x20400b54
  4145b0:	00414491 	.word	0x00414491

004145b4 <overload_check>:
	return (a * a);
}

void overload_check(float ia, float ib, float ic)
{
	overload_integrate(&olIaVal, olsqr(ia) - insqr);
  4145b4:	4b19      	ldr	r3, [pc, #100]	; (41461c <overload_check+0x68>)
  4145b6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  4145ba:	ee05 0a10 	vmov	s10, r0
	overload_integrate(&olIbVal, olsqr(ib) - insqr);
  4145be:	ee04 1a10 	vmov	s8, r1
{
  4145c2:	b430      	push	{r4, r5}
	*ol_integratorVal += (sqrPhase_current / sample_freq);	
  4145c4:	4c16      	ldr	r4, [pc, #88]	; (414620 <overload_check+0x6c>)
	overload_integrate(&olIaVal, olsqr(ia) - insqr);
  4145c6:	edd3 7a00 	vldr	s15, [r3]
  4145ca:	ed94 7a00 	vldr	s14, [r4]
  4145ce:	eef1 7a67 	vneg.f32	s15, s15
	*ol_integratorVal += (sqrPhase_current / sample_freq);	
  4145d2:	4d14      	ldr	r5, [pc, #80]	; (414624 <overload_check+0x70>)
  4145d4:	eec6 5a87 	vdiv.f32	s11, s13, s14
  4145d8:	4c13      	ldr	r4, [pc, #76]	; (414628 <overload_check+0x74>)
  4145da:	4b14      	ldr	r3, [pc, #80]	; (41462c <overload_check+0x78>)
  4145dc:	ed95 6a00 	vldr	s12, [r5]
  4145e0:	edd4 6a00 	vldr	s13, [r4]
  4145e4:	ed93 7a00 	vldr	s14, [r3]
	overload_integrate(&olIaVal, olsqr(ia) - insqr);
  4145e8:	eef0 4a67 	vmov.f32	s9, s15
  4145ec:	eee5 4a05 	vfma.f32	s9, s10, s10
	overload_integrate(&olIbVal, olsqr(ib) - insqr);
  4145f0:	eeb0 5a67 	vmov.f32	s10, s15
  4145f4:	eea4 5a04 	vfma.f32	s10, s8, s8
	overload_integrate(&olIcVal, olsqr(ic) - insqr);
  4145f8:	ee04 2a10 	vmov	s8, r2
  4145fc:	eee4 7a04 	vfma.f32	s15, s8, s8
	*ol_integratorVal += (sqrPhase_current / sample_freq);	
  414600:	eea4 6aa5 	vfma.f32	s12, s9, s11
  414604:	eee5 6a25 	vfma.f32	s13, s10, s11
  414608:	eea7 7aa5 	vfma.f32	s14, s15, s11
  41460c:	ed85 6a00 	vstr	s12, [r5]
  414610:	edc4 6a00 	vstr	s13, [r4]
  414614:	ed83 7a00 	vstr	s14, [r3]
}
  414618:	bc30      	pop	{r4, r5}
  41461a:	4770      	bx	lr
  41461c:	20406d10 	.word	0x20406d10
  414620:	20406d0c 	.word	0x20406d0c
  414624:	20400b5c 	.word	0x20400b5c
  414628:	20400b60 	.word	0x20400b60
  41462c:	20400b64 	.word	0x20400b64

00414630 <overload_update>:
	overload_integrate(&olImVal, imSqr - insqr);
}

void overload_update(void)
{
	if (menue_drive_data_setup.m_overload_type == 2)
  414630:	4b5c      	ldr	r3, [pc, #368]	; (4147a4 <overload_update+0x174>)
  414632:	f893 30cf 	ldrb.w	r3, [r3, #207]	; 0xcf
  414636:	2b02      	cmp	r3, #2
  414638:	f000 809f 	beq.w	41477a <overload_update+0x14a>
{
  41463c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	{
		return;
	}
	
	if(olImVal < 0)
  414640:	4d59      	ldr	r5, [pc, #356]	; (4147a8 <overload_update+0x178>)
{
  414642:	ed2d 8b02 	vpush	{d8}
	if(olImVal < 0)
  414646:	edd5 7a00 	vldr	s15, [r5]
  41464a:	ed9f 8a58 	vldr	s16, [pc, #352]	; 4147ac <overload_update+0x17c>
  41464e:	eef4 7ac8 	vcmpe.f32	s15, s16
  414652:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  414656:	d44f      	bmi.n	4146f8 <overload_update+0xc8>
	{
		olImVal = 0;
	}
	else if(olImVal >= oval)
  414658:	4c55      	ldr	r4, [pc, #340]	; (4147b0 <overload_update+0x180>)
  41465a:	ed94 7a00 	vldr	s14, [r4]
  41465e:	eef4 7ac7 	vcmpe.f32	s15, s14
  414662:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  414666:	da4a      	bge.n	4146fe <overload_update+0xce>
		overload_reset();
	}
	
	//return;
	
	if(olIaVal < 0)
  414668:	4e52      	ldr	r6, [pc, #328]	; (4147b4 <overload_update+0x184>)
  41466a:	2300      	movs	r3, #0
  41466c:	edd6 7a00 	vldr	s15, [r6]
  414670:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  414674:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  414678:	d438      	bmi.n	4146ec <overload_update+0xbc>
	{
		olIaVal = 0;
	}
	else if(olIaVal >= oval)
  41467a:	4c4d      	ldr	r4, [pc, #308]	; (4147b0 <overload_update+0x180>)
  41467c:	ed94 7a00 	vldr	s14, [r4]
  414680:	eef4 7ac7 	vcmpe.f32	s15, s14
  414684:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  414688:	da7e      	bge.n	414788 <overload_update+0x158>
	{
		ol_err_set;
		overload_reset();
	}	

	if(olIbVal < 0)
  41468a:	4f4b      	ldr	r7, [pc, #300]	; (4147b8 <overload_update+0x188>)
  41468c:	2300      	movs	r3, #0
  41468e:	ed97 8a00 	vldr	s16, [r7]
  414692:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  414696:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41469a:	d429      	bmi.n	4146f0 <overload_update+0xc0>
  41469c:	4c44      	ldr	r4, [pc, #272]	; (4147b0 <overload_update+0x180>)
  41469e:	f8df 8124 	ldr.w	r8, [pc, #292]	; 4147c4 <overload_update+0x194>
	{
		olIbVal = 0;
	}
	else if(olIbVal >= oval)
  4146a2:	edd4 7a00 	vldr	s15, [r4]
  4146a6:	eef4 7ac8 	vcmpe.f32	s15, s16
  4146aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4146ae:	d973      	bls.n	414798 <overload_update+0x168>
	{
		ol_err_set;
		overload_reset();
	}

	if(olIcVal < 0)
  4146b0:	edd8 7a00 	vldr	s15, [r8]
  4146b4:	2300      	movs	r3, #0
  4146b6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4146ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4146be:	d45d      	bmi.n	41477c <overload_update+0x14c>
  4146c0:	4c3b      	ldr	r4, [pc, #236]	; (4147b0 <overload_update+0x180>)
	{
		olIcVal = 0;
	}
	else if(olIcVal >= oval)
  4146c2:	ed94 7a00 	vldr	s14, [r4]
  4146c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4146ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4146ce:	d809      	bhi.n	4146e4 <overload_update+0xb4>
	{
		ol_err_set;
  4146d0:	4a3a      	ldr	r2, [pc, #232]	; (4147bc <overload_update+0x18c>)
  4146d2:	4b3b      	ldr	r3, [pc, #236]	; (4147c0 <overload_update+0x190>)
  4146d4:	7810      	ldrb	r0, [r2, #0]
  4146d6:	4798      	blx	r3
	olIaVal = 0;
  4146d8:	2300      	movs	r3, #0
  4146da:	6033      	str	r3, [r6, #0]
	olIbVal = 0;
  4146dc:	603b      	str	r3, [r7, #0]
	olIcVal = 0;
  4146de:	f8c8 3000 	str.w	r3, [r8]
	olImVal = 0;
  4146e2:	602b      	str	r3, [r5, #0]
		overload_reset();
	}
}
  4146e4:	ecbd 8b02 	vpop	{d8}
  4146e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		olIaVal = 0;
  4146ec:	6033      	str	r3, [r6, #0]
  4146ee:	e7cc      	b.n	41468a <overload_update+0x5a>
		olIbVal = 0;
  4146f0:	603b      	str	r3, [r7, #0]
  4146f2:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 4147c4 <overload_update+0x194>
  4146f6:	e7db      	b.n	4146b0 <overload_update+0x80>
		olImVal = 0;
  4146f8:	ed85 8a00 	vstr	s16, [r5]
  4146fc:	e7b4      	b.n	414668 <overload_update+0x38>
		ol_err_set;
  4146fe:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 4147bc <overload_update+0x18c>
  414702:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 4147c0 <overload_update+0x190>
  414706:	f89a 0000 	ldrb.w	r0, [sl]
  41470a:	47c8      	blx	r9
	else if(olIaVal >= oval)
  41470c:	edd4 7a00 	vldr	s15, [r4]
	olIaVal = 0;
  414710:	4e28      	ldr	r6, [pc, #160]	; (4147b4 <overload_update+0x184>)
	else if(olIaVal >= oval)
  414712:	eef5 7ac0 	vcmpe.f32	s15, #0.0
	olIbVal = 0;
  414716:	4f28      	ldr	r7, [pc, #160]	; (4147b8 <overload_update+0x188>)
	olIcVal = 0;
  414718:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 4147c4 <overload_update+0x194>
	olImVal = 0;
  41471c:	ed85 8a00 	vstr	s16, [r5]
	else if(olIaVal >= oval)
  414720:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	olIaVal = 0;
  414724:	ed86 8a00 	vstr	s16, [r6]
	olIbVal = 0;
  414728:	ed87 8a00 	vstr	s16, [r7]
	olIcVal = 0;
  41472c:	ed88 8a00 	vstr	s16, [r8]
	else if(olIaVal >= oval)
  414730:	d8b7      	bhi.n	4146a2 <overload_update+0x72>
		ol_err_set;
  414732:	f89a 0000 	ldrb.w	r0, [sl]
  414736:	47c8      	blx	r9
	olIaVal = 0;
  414738:	eddf 7a1c 	vldr	s15, [pc, #112]	; 4147ac <overload_update+0x17c>
	else if(olIbVal >= oval)
  41473c:	ed94 7a00 	vldr	s14, [r4]
	olIaVal = 0;
  414740:	edc6 7a00 	vstr	s15, [r6]
	else if(olIbVal >= oval)
  414744:	eeb4 7ae7 	vcmpe.f32	s14, s15
	olIbVal = 0;
  414748:	edc7 7a00 	vstr	s15, [r7]
	olIcVal = 0;
  41474c:	edc8 7a00 	vstr	s15, [r8]
	olImVal = 0;
  414750:	edc5 7a00 	vstr	s15, [r5]
	else if(olIbVal >= oval)
  414754:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  414758:	d8b3      	bhi.n	4146c2 <overload_update+0x92>
		ol_err_set;
  41475a:	f89a 0000 	ldrb.w	r0, [sl]
  41475e:	47c8      	blx	r9
	olIaVal = 0;
  414760:	ed9f 7a12 	vldr	s14, [pc, #72]	; 4147ac <overload_update+0x17c>
  414764:	ed86 7a00 	vstr	s14, [r6]
	if(olIcVal < 0)
  414768:	eef0 7a47 	vmov.f32	s15, s14
	olIbVal = 0;
  41476c:	ed87 7a00 	vstr	s14, [r7]
	olIcVal = 0;
  414770:	ed88 7a00 	vstr	s14, [r8]
	olImVal = 0;
  414774:	ed85 7a00 	vstr	s14, [r5]
  414778:	e7a3      	b.n	4146c2 <overload_update+0x92>
  41477a:	4770      	bx	lr
}
  41477c:	ecbd 8b02 	vpop	{d8}
		olIcVal = 0;
  414780:	f8c8 3000 	str.w	r3, [r8]
}
  414784:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  414788:	f8df a030 	ldr.w	sl, [pc, #48]	; 4147bc <overload_update+0x18c>
  41478c:	f8df 9030 	ldr.w	r9, [pc, #48]	; 4147c0 <overload_update+0x190>
  414790:	4f09      	ldr	r7, [pc, #36]	; (4147b8 <overload_update+0x188>)
  414792:	f8df 8030 	ldr.w	r8, [pc, #48]	; 4147c4 <overload_update+0x194>
  414796:	e7cc      	b.n	414732 <overload_update+0x102>
  414798:	f8df a020 	ldr.w	sl, [pc, #32]	; 4147bc <overload_update+0x18c>
  41479c:	f8df 9020 	ldr.w	r9, [pc, #32]	; 4147c0 <overload_update+0x190>
  4147a0:	e7db      	b.n	41475a <overload_update+0x12a>
  4147a2:	bf00      	nop
  4147a4:	204050e8 	.word	0x204050e8
  4147a8:	20400b68 	.word	0x20400b68
  4147ac:	00000000 	.word	0x00000000
  4147b0:	20406d08 	.word	0x20406d08
  4147b4:	20400b5c 	.word	0x20400b5c
  4147b8:	20400b60 	.word	0x20400b60
  4147bc:	20406ca5 	.word	0x20406ca5
  4147c0:	0041282d 	.word	0x0041282d
  4147c4:	20400b64 	.word	0x20400b64

004147c8 <overload_init>:
void overload_init(void)
{
	oval = OVERLOAD_VAL;
  4147c8:	481c      	ldr	r0, [pc, #112]	; (41483c <overload_init+0x74>)
  4147ca:	491d      	ldr	r1, [pc, #116]	; (414840 <overload_init+0x78>)
  4147cc:	4a1d      	ldr	r2, [pc, #116]	; (414844 <overload_init+0x7c>)
  4147ce:	eddf 6a1e 	vldr	s13, [pc, #120]	; 414848 <overload_init+0x80>
{
  4147d2:	b470      	push	{r4, r5, r6}
	oval = OVERLOAD_VAL;
  4147d4:	f8d0 30d4 	ldr.w	r3, [r0, #212]	; 0xd4
  4147d8:	6952      	ldr	r2, [r2, #20]
  4147da:	fb81 4103 	smull	r4, r1, r1, r3
  4147de:	17db      	asrs	r3, r3, #31
	insqr = olsqr(fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current));
  4147e0:	ee07 2a10 	vmov	s14, r2
  4147e4:	4e19      	ldr	r6, [pc, #100]	; (41484c <overload_init+0x84>)
	oval = OVERLOAD_VAL;
  4147e6:	ebc3 1361 	rsb	r3, r3, r1, asr #5
  4147ea:	f890 10d0 	ldrb.w	r1, [r0, #208]	; 0xd0
	insqr = olsqr(fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current));
  4147ee:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	//insqrmax = insqr * 2;
	sample_freq = PWM_FREQUENCY;
  4147f2:	4c17      	ldr	r4, [pc, #92]	; (414850 <overload_init+0x88>)
  4147f4:	fb83 2302 	smull	r2, r3, r3, r2
	oval = OVERLOAD_VAL;
  4147f8:	ee07 1a90 	vmov	s15, r1
	sample_freq = PWM_FREQUENCY;
  4147fc:	4915      	ldr	r1, [pc, #84]	; (414854 <overload_init+0x8c>)
  4147fe:	0bd0      	lsrs	r0, r2, #15
	oval = OVERLOAD_VAL;
  414800:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	sample_freq = PWM_FREQUENCY;
  414804:	680d      	ldr	r5, [r1, #0]
	insqr = olsqr(fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current));
  414806:	ee27 7a26 	vmul.f32	s14, s14, s13
  41480a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	oval = OVERLOAD_VAL;
  41480e:	4a12      	ldr	r2, [pc, #72]	; (414858 <overload_init+0x90>)
  414810:	ee67 6aa6 	vmul.f32	s13, s15, s13
	sample_freq = PWM_FREQUENCY;
  414814:	6025      	str	r5, [r4, #0]
  414816:	fb80 0100 	smull	r0, r1, r0, r0
	return (a * a);
  41481a:	ee27 7a07 	vmul.f32	s14, s14, s14
  41481e:	0bc3      	lsrs	r3, r0, #15
	insqr = olsqr(fixedpt_tofloat(menue_drive_data_applied.m_motor_rated_current));
  414820:	ed86 7a00 	vstr	s14, [r6]
  414824:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
	oval = OVERLOAD_VAL;
  414828:	ee07 3a90 	vmov	s15, r3
  41482c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  414830:	ee67 7aa6 	vmul.f32	s15, s15, s13
  414834:	edc2 7a00 	vstr	s15, [r2]
}
  414838:	bc70      	pop	{r4, r5, r6}
  41483a:	4770      	bx	lr
  41483c:	204050e8 	.word	0x204050e8
  414840:	51eb851f 	.word	0x51eb851f
  414844:	20404ff0 	.word	0x20404ff0
  414848:	38000000 	.word	0x38000000
  41484c:	20406d10 	.word	0x20406d10
  414850:	20406d0c 	.word	0x20406d0c
  414854:	204003c8 	.word	0x204003c8
  414858:	20406d08 	.word	0x20406d08

0041485c <get_olval>:

float get_olval()
{
	return oval;
  41485c:	4b01      	ldr	r3, [pc, #4]	; (414864 <get_olval+0x8>)
}
  41485e:	6818      	ldr	r0, [r3, #0]
  414860:	4770      	bx	lr
  414862:	bf00      	nop
  414864:	20406d08 	.word	0x20406d08

00414868 <phasefail_handler>:
#define PHF_FILTER_MAX 250

char phfail_stage = 0;
void phasefail_handler(void)
{
	if (menue_drive_data_applied.m_input_phase_fail == 1) return;
  414868:	4b2f      	ldr	r3, [pc, #188]	; (414928 <phasefail_handler+0xc0>)
  41486a:	f893 30ce 	ldrb.w	r3, [r3, #206]	; 0xce
  41486e:	2b01      	cmp	r3, #1
  414870:	d049      	beq.n	414906 <phasefail_handler+0x9e>
	
	if (phfail_stage == 0)
  414872:	4a2e      	ldr	r2, [pc, #184]	; (41492c <phasefail_handler+0xc4>)
{
  414874:	b570      	push	{r4, r5, r6, lr}
	if (phfail_stage == 0)
  414876:	7813      	ldrb	r3, [r2, #0]
  414878:	b9d3      	cbnz	r3, 4148b0 <phasefail_handler+0x48>
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  41487a:	4b2d      	ldr	r3, [pc, #180]	; (414930 <phasefail_handler+0xc8>)
  41487c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
	{
		if ((IO_PHR == 0) && (IO_PHS == 0) && (IO_PHT == 1))
  41487e:	0708      	lsls	r0, r1, #28
  414880:	d402      	bmi.n	414888 <phasefail_handler+0x20>
  414882:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  414884:	0749      	lsls	r1, r1, #29
  414886:	d535      	bpl.n	4148f4 <phasefail_handler+0x8c>
  414888:	4c2a      	ldr	r4, [pc, #168]	; (414934 <phasefail_handler+0xcc>)
  41488a:	4d2b      	ldr	r5, [pc, #172]	; (414938 <phasefail_handler+0xd0>)
			phf_t_f = 0;
		}
	}
	
	
	if(phf_r_f < PHF_FILTER_MAX) phf_r_f++;
  41488c:	4a2b      	ldr	r2, [pc, #172]	; (41493c <phasefail_handler+0xd4>)
  41488e:	8813      	ldrh	r3, [r2, #0]
  414890:	2bf9      	cmp	r3, #249	; 0xf9
  414892:	d82a      	bhi.n	4148ea <phasefail_handler+0x82>
  414894:	3301      	adds	r3, #1
  414896:	b29b      	uxth	r3, r3
  414898:	8013      	strh	r3, [r2, #0]
	else phfail_err_set;
	
	if(phf_s_f < PHF_FILTER_MAX) phf_s_f++;
  41489a:	8823      	ldrh	r3, [r4, #0]
  41489c:	2bf9      	cmp	r3, #249	; 0xf9
  41489e:	d81f      	bhi.n	4148e0 <phasefail_handler+0x78>
  4148a0:	3301      	adds	r3, #1
  4148a2:	8023      	strh	r3, [r4, #0]
	else phfail_err_set;
	
	if(phf_t_f < PHF_FILTER_MAX) phf_t_f++;
  4148a4:	882b      	ldrh	r3, [r5, #0]
  4148a6:	2bf9      	cmp	r3, #249	; 0xf9
  4148a8:	d814      	bhi.n	4148d4 <phasefail_handler+0x6c>
  4148aa:	3301      	adds	r3, #1
  4148ac:	802b      	strh	r3, [r5, #0]
  4148ae:	bd70      	pop	{r4, r5, r6, pc}
	else if (phfail_stage == 1)
  4148b0:	2b01      	cmp	r3, #1
  4148b2:	4b1f      	ldr	r3, [pc, #124]	; (414930 <phasefail_handler+0xc8>)
  4148b4:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  4148b6:	d027      	beq.n	414908 <phasefail_handler+0xa0>
		if ((IO_PHR == 0) && (IO_PHS == 1) && (IO_PHT == 0))
  4148b8:	0708      	lsls	r0, r1, #28
  4148ba:	d4e5      	bmi.n	414888 <phasefail_handler+0x20>
  4148bc:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  4148be:	0749      	lsls	r1, r1, #29
  4148c0:	d5e2      	bpl.n	414888 <phasefail_handler+0x20>
  4148c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4148c4:	f013 0302 	ands.w	r3, r3, #2
  4148c8:	d1de      	bne.n	414888 <phasefail_handler+0x20>
			phf_t_f = 0;
  4148ca:	4d1b      	ldr	r5, [pc, #108]	; (414938 <phasefail_handler+0xd0>)
  4148cc:	4c19      	ldr	r4, [pc, #100]	; (414934 <phasefail_handler+0xcc>)
			phfail_stage = 0;
  4148ce:	7013      	strb	r3, [r2, #0]
			phf_t_f = 0;
  4148d0:	802b      	strh	r3, [r5, #0]
  4148d2:	e7db      	b.n	41488c <phasefail_handler+0x24>
	else phfail_err_set;
  4148d4:	4a1a      	ldr	r2, [pc, #104]	; (414940 <phasefail_handler+0xd8>)
  4148d6:	4b1b      	ldr	r3, [pc, #108]	; (414944 <phasefail_handler+0xdc>)
  4148d8:	7810      	ldrb	r0, [r2, #0]
  4148da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	else phfail_err_set;
  4148de:	4718      	bx	r3
	else phfail_err_set;
  4148e0:	4a17      	ldr	r2, [pc, #92]	; (414940 <phasefail_handler+0xd8>)
  4148e2:	4b18      	ldr	r3, [pc, #96]	; (414944 <phasefail_handler+0xdc>)
  4148e4:	7810      	ldrb	r0, [r2, #0]
  4148e6:	4798      	blx	r3
  4148e8:	e7dc      	b.n	4148a4 <phasefail_handler+0x3c>
	else phfail_err_set;
  4148ea:	4a15      	ldr	r2, [pc, #84]	; (414940 <phasefail_handler+0xd8>)
  4148ec:	4b15      	ldr	r3, [pc, #84]	; (414944 <phasefail_handler+0xdc>)
  4148ee:	7810      	ldrb	r0, [r2, #0]
  4148f0:	4798      	blx	r3
  4148f2:	e7d2      	b.n	41489a <phasefail_handler+0x32>
  4148f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
		if ((IO_PHR == 0) && (IO_PHS == 0) && (IO_PHT == 1))
  4148f6:	079e      	lsls	r6, r3, #30
  4148f8:	d5c6      	bpl.n	414888 <phasefail_handler+0x20>
			phfail_stage++;
  4148fa:	2301      	movs	r3, #1
  4148fc:	4c0d      	ldr	r4, [pc, #52]	; (414934 <phasefail_handler+0xcc>)
  4148fe:	4d0e      	ldr	r5, [pc, #56]	; (414938 <phasefail_handler+0xd0>)
  414900:	7013      	strb	r3, [r2, #0]
  414902:	4a0e      	ldr	r2, [pc, #56]	; (41493c <phasefail_handler+0xd4>)
  414904:	e7c8      	b.n	414898 <phasefail_handler+0x30>
  414906:	4770      	bx	lr
		if ((IO_PHR == 1) && (IO_PHS == 0) && (IO_PHT == 0))
  414908:	070d      	lsls	r5, r1, #28
  41490a:	d5bd      	bpl.n	414888 <phasefail_handler+0x20>
  41490c:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  41490e:	074c      	lsls	r4, r1, #29
  414910:	d4ba      	bmi.n	414888 <phasefail_handler+0x20>
  414912:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  414914:	f013 0302 	ands.w	r3, r3, #2
  414918:	d1b6      	bne.n	414888 <phasefail_handler+0x20>
			phfail_stage++;
  41491a:	2102      	movs	r1, #2
			phf_s_f = 0;
  41491c:	4c05      	ldr	r4, [pc, #20]	; (414934 <phasefail_handler+0xcc>)
  41491e:	4d06      	ldr	r5, [pc, #24]	; (414938 <phasefail_handler+0xd0>)
			phfail_stage++;
  414920:	7011      	strb	r1, [r2, #0]
			phf_s_f = 0;
  414922:	8023      	strh	r3, [r4, #0]
  414924:	e7b2      	b.n	41488c <phasefail_handler+0x24>
  414926:	bf00      	nop
  414928:	20404ff0 	.word	0x20404ff0
  41492c:	20400b72 	.word	0x20400b72
  414930:	400e1400 	.word	0x400e1400
  414934:	20400b6e 	.word	0x20400b6e
  414938:	20400b70 	.word	0x20400b70
  41493c:	20400b6c 	.word	0x20400b6c
  414940:	20406cb4 	.word	0x20406cb4
  414944:	0041282d 	.word	0x0041282d

00414948 <adc_interface_init>:
#include <asf.h>
#include <adc_interface.h>


void adc_interface_init(void)
{
  414948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//AFEC0 Adc initialization routines
	const enum afec_channel_num chan_list[] = {AFEC_CHANNEL_0, AFEC_CHANNEL_1, AFEC_CHANNEL_2}; //channel sequence
	
	pmc_enable_periph_clk(ID_AFEC0);
	
	afec_enable(AFEC0);
  41494c:	4c5f      	ldr	r4, [pc, #380]	; (414acc <adc_interface_init+0x184>)
{
  41494e:	b08f      	sub	sp, #60	; 0x3c
	pmc_enable_periph_clk(ID_AFEC0);
  414950:	4b5f      	ldr	r3, [pc, #380]	; (414ad0 <adc_interface_init+0x188>)
  414952:	201d      	movs	r0, #29
  414954:	4798      	blx	r3
	afec_enable(AFEC0);
  414956:	4620      	mov	r0, r4
  414958:	4b5e      	ldr	r3, [pc, #376]	; (414ad4 <adc_interface_init+0x18c>)
    afec_init(AFEC0, &afec_cfg);
    afec_set_trigger(AFEC0, AFEC_TRIG_PWM_EVENT_LINE_0); /*PWM EVENT LINE0 Trigger*/

    struct afec_ch_config afec_ch_cfg;
    afec_ch_get_config_defaults(&afec_ch_cfg);
	afec_ch_cfg.gain = AFEC_GAINVALUE_0;
  41495a:	f04f 0800 	mov.w	r8, #0
	afec_enable(AFEC0);
  41495e:	4798      	blx	r3
    afec_get_config_defaults(&afec_cfg); /*AFEC0 defaults settings changed in "afec.c"*/
  414960:	f8df b198 	ldr.w	fp, [pc, #408]	; 414afc <adc_interface_init+0x1b4>
  414964:	a802      	add	r0, sp, #8
	afec_ch_cfg.diff = 0;
    afec_ch_set_config(AFEC0, AFEC_CHANNEL_0, &afec_ch_cfg);
  414966:	4e5c      	ldr	r6, [pc, #368]	; (414ad8 <adc_interface_init+0x190>)
    afec_get_config_defaults(&afec_cfg); /*AFEC0 defaults settings changed in "afec.c"*/
  414968:	47d8      	blx	fp
    afec_init(AFEC0, &afec_cfg);
  41496a:	a902      	add	r1, sp, #8
  41496c:	4620      	mov	r0, r4
  41496e:	4b5b      	ldr	r3, [pc, #364]	; (414adc <adc_interface_init+0x194>)
  414970:	4798      	blx	r3
static inline void afec_set_trigger(Afec *const afec,
		const enum afec_trigger trigger)
{
	uint32_t reg;

	reg = afec->AFEC_MR;
  414972:	6863      	ldr	r3, [r4, #4]
    afec_ch_get_config_defaults(&afec_ch_cfg);
  414974:	4668      	mov	r0, sp
static inline void afec_channel_set_analog_offset(Afec *const afec,
		enum afec_channel_num afec_ch, uint16_t aoffset)
{
	afec_ch_sanity_check(afec, afec_ch);

	afec->AFEC_CSELR = afec_ch;
  414976:	f04f 0a09 	mov.w	sl, #9
		reg &= ~(AFEC_MR_TRGSEL_Msk | AFEC_MR_TRGEN | AFEC_MR_FREERUN_ON);
  41497a:	f023 038f 	bic.w	r3, r3, #143	; 0x8f
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  41497e:	f44f 7500 	mov.w	r5, #512	; 0x200
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  414982:	2701      	movs	r7, #1
  414984:	f04f 0908 	mov.w	r9, #8
		reg |= trigger;
  414988:	f043 0309 	orr.w	r3, r3, #9
	afec->AFEC_MR = reg;
  41498c:	6063      	str	r3, [r4, #4]
  41498e:	4b54      	ldr	r3, [pc, #336]	; (414ae0 <adc_interface_init+0x198>)
  414990:	4798      	blx	r3
    afec_ch_set_config(AFEC0, AFEC_CHANNEL_0, &afec_ch_cfg);
  414992:	466a      	mov	r2, sp
  414994:	4620      	mov	r0, r4
  414996:	4641      	mov	r1, r8
	afec_ch_cfg.gain = AFEC_GAINVALUE_0;
  414998:	f88d 8001 	strb.w	r8, [sp, #1]
	afec_ch_cfg.diff = 0;
  41499c:	f88d 8000 	strb.w	r8, [sp]
    afec_ch_set_config(AFEC0, AFEC_CHANNEL_0, &afec_ch_cfg);
  4149a0:	47b0      	blx	r6
    afec_ch_set_config(AFEC0, AFEC_CHANNEL_3, &afec_ch_cfg);
  4149a2:	466a      	mov	r2, sp
  4149a4:	4620      	mov	r0, r4
  4149a6:	2103      	movs	r1, #3
  4149a8:	47b0      	blx	r6
    //afec_ch_set_config(AFEC0, AFEC_CHANNEL_2, &afec_ch_cfg);
    afec_ch_set_config(AFEC0, AFEC_CHANNEL_6, &afec_ch_cfg);
  4149aa:	466a      	mov	r2, sp
  4149ac:	4620      	mov	r0, r4
  4149ae:	2106      	movs	r1, #6
  4149b0:	47b0      	blx	r6
    afec_ch_set_config(AFEC0, AFEC_CHANNEL_9, &afec_ch_cfg);
  4149b2:	466a      	mov	r2, sp
  4149b4:	4620      	mov	r0, r4
  4149b6:	4651      	mov	r1, sl
  4149b8:	47b0      	blx	r6
	afec->AFEC_CSELR = afec_ch;
  4149ba:	f04f 0e06 	mov.w	lr, #6
  4149be:	2303      	movs	r3, #3
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  4149c0:	6167      	str	r7, [r4, #20]
	afec_channel_set_analog_offset(AFEC0, AFEC_CHANNEL_9, 0x200);

	//afec_channel_enable(AFEC0, AFEC_CHANNEL_8);
	//afec_channel_set_analog_offset(AFEC0, AFEC_CHANNEL_8, 0x200);

	afec_set_sample_hold_mode(AFEC0, AFEC_CHANNEL_ALL, AFEC_SAMPLE_HOLD_MODE_1); //set dual sample and hold mode for all channels
  4149c2:	463a      	mov	r2, r7
	afec->AFEC_CSELR = afec_ch;
  4149c4:	f8c4 8064 	str.w	r8, [r4, #100]	; 0x64
  4149c8:	4620      	mov	r0, r4
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  4149ca:	66e5      	str	r5, [r4, #108]	; 0x6c
  4149cc:	f640 71ff 	movw	r1, #4095	; 0xfff
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  4149d0:	f8c4 9014 	str.w	r9, [r4, #20]
	afec->AFEC_CSELR = afec_ch;
  4149d4:	6663      	str	r3, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  4149d6:	66e5      	str	r5, [r4, #108]	; 0x6c
  4149d8:	4b42      	ldr	r3, [pc, #264]	; (414ae4 <adc_interface_init+0x19c>)
	afec->AFEC_CSELR = afec_ch;
  4149da:	f8c4 e064 	str.w	lr, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  4149de:	66e5      	str	r5, [r4, #108]	; 0x6c
	afec->AFEC_CSELR = afec_ch;
  4149e0:	f8c4 a064 	str.w	sl, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  4149e4:	66e5      	str	r5, [r4, #108]	; 0x6c
  4149e6:	4798      	blx	r3
	
	//afec_set_trigger(AFEC0, AFEC_TRIG_PWM_EVENT_LINE_0);
	//NVIC_EnableIRQ(AFEC0_IRQn);

    /*SET AFEC CALLBACK FUNCTION*/
    afec_set_callback(AFEC0, AFEC_INTERRUPT_EOC_9, afec_EOC_handler, 1);
  4149e8:	4651      	mov	r1, sl
  4149ea:	4a3f      	ldr	r2, [pc, #252]	; (414ae8 <adc_interface_init+0x1a0>)
  4149ec:	463b      	mov	r3, r7
  4149ee:	4620      	mov	r0, r4
  4149f0:	4c3e      	ldr	r4, [pc, #248]	; (414aec <adc_interface_init+0x1a4>)
  4149f2:	47a0      	blx	r4
	//AFEC1 Adc initialization routines
	const enum afec_channel_num chan_list1[] = {AFEC_CHANNEL_0, AFEC_CHANNEL_1}; //channel sequence
	
	pmc_enable_periph_clk(ID_AFEC1);
	
	afec_enable(AFEC1);
  4149f4:	4c3e      	ldr	r4, [pc, #248]	; (414af0 <adc_interface_init+0x1a8>)
	pmc_enable_periph_clk(ID_AFEC1);
  4149f6:	4b36      	ldr	r3, [pc, #216]	; (414ad0 <adc_interface_init+0x188>)
  4149f8:	2028      	movs	r0, #40	; 0x28
  4149fa:	4798      	blx	r3
	afec_enable(AFEC1);
  4149fc:	4620      	mov	r0, r4
  4149fe:	4b35      	ldr	r3, [pc, #212]	; (414ad4 <adc_interface_init+0x18c>)
  414a00:	4798      	blx	r3
	
	struct afec_config afec_cfg1;
	afec_get_config_defaults(&afec_cfg1); /*AFEC1 defaults settings changed in "afec.c"*/
  414a02:	a808      	add	r0, sp, #32
  414a04:	47d8      	blx	fp
	afec_cfg1.afec_clock = 1000000UL;
  414a06:	4b3b      	ldr	r3, [pc, #236]	; (414af4 <adc_interface_init+0x1ac>)
	//afec_cfg1.tracktim = 1;
	//afec_cfg1.transfer = 0;
	//afec_cfg1.startup_time = AFEC_STARTUP_TIME_0;
	
	afec_init(AFEC1, &afec_cfg1);
  414a08:	a908      	add	r1, sp, #32
  414a0a:	4620      	mov	r0, r4
	afec_cfg1.afec_clock = 1000000UL;
  414a0c:	930a      	str	r3, [sp, #40]	; 0x28
	afec->AFEC_CSELR = afec_ch;
  414a0e:	f04f 0b0a 	mov.w	fp, #10
	afec_init(AFEC1, &afec_cfg1);
  414a12:	4b32      	ldr	r3, [pc, #200]	; (414adc <adc_interface_init+0x194>)
  414a14:	4798      	blx	r3
	reg = afec->AFEC_MR;
  414a16:	6862      	ldr	r2, [r4, #4]
	afec_set_trigger(AFEC1, AFEC_TRIG_SW); /*SW Trigger*/

	struct afec_ch_config afec_ch_cfg1;
	afec_ch_get_config_defaults(&afec_ch_cfg1);
  414a18:	4b31      	ldr	r3, [pc, #196]	; (414ae0 <adc_interface_init+0x198>)
  414a1a:	a801      	add	r0, sp, #4
		reg &= ~(AFEC_MR_TRGSEL_Msk | AFEC_MR_TRGEN | AFEC_MR_FREERUN_ON);
  414a1c:	f022 028f 	bic.w	r2, r2, #143	; 0x8f
	afec->AFEC_MR = reg;
  414a20:	6062      	str	r2, [r4, #4]
  414a22:	4798      	blx	r3
	afec_ch_cfg1.gain = AFEC_GAINVALUE_0;
	afec_ch_cfg1.diff = 0;
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_1, &afec_ch_cfg1);
  414a24:	aa01      	add	r2, sp, #4
  414a26:	4639      	mov	r1, r7
  414a28:	4620      	mov	r0, r4
	afec_ch_cfg1.gain = AFEC_GAINVALUE_0;
  414a2a:	f88d 8005 	strb.w	r8, [sp, #5]
	afec_ch_cfg1.diff = 0;
  414a2e:	f88d 8004 	strb.w	r8, [sp, #4]
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_1, &afec_ch_cfg1);
  414a32:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_2, &afec_ch_cfg1);
  414a34:	aa01      	add	r2, sp, #4
  414a36:	4620      	mov	r0, r4
  414a38:	2102      	movs	r1, #2
  414a3a:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_3, &afec_ch_cfg1);
  414a3c:	aa01      	add	r2, sp, #4
  414a3e:	4620      	mov	r0, r4
  414a40:	2103      	movs	r1, #3
  414a42:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_4, &afec_ch_cfg1);
  414a44:	aa01      	add	r2, sp, #4
  414a46:	4620      	mov	r0, r4
  414a48:	2104      	movs	r1, #4
  414a4a:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_7, &afec_ch_cfg1);
  414a4c:	aa01      	add	r2, sp, #4
  414a4e:	4620      	mov	r0, r4
  414a50:	2107      	movs	r1, #7
  414a52:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_8, &afec_ch_cfg1);
  414a54:	aa01      	add	r2, sp, #4
  414a56:	4649      	mov	r1, r9
  414a58:	4620      	mov	r0, r4
  414a5a:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_9, &afec_ch_cfg1);
  414a5c:	aa01      	add	r2, sp, #4
  414a5e:	4651      	mov	r1, sl
  414a60:	4620      	mov	r0, r4
  414a62:	47b0      	blx	r6
	afec_ch_set_config(AFEC1, AFEC_CHANNEL_10, &afec_ch_cfg1);
  414a64:	aa01      	add	r2, sp, #4
  414a66:	4620      	mov	r0, r4
  414a68:	4659      	mov	r1, fp
  414a6a:	47b0      	blx	r6
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  414a6c:	2202      	movs	r2, #2
  414a6e:	2604      	movs	r6, #4
  414a70:	f04f 0c10 	mov.w	ip, #16
  414a74:	6162      	str	r2, [r4, #20]
	afec_channel_set_analog_offset(AFEC1, AFEC_CHANNEL_9, 0x200);

	//afec_channel_enable(AFEC1, AFEC_CHANNEL_10);
	afec_channel_set_analog_offset(AFEC1, AFEC_CHANNEL_10, 0x200);
	
	afec_set_sample_hold_mode(AFEC1, AFEC_CHANNEL_ALL, AFEC_SAMPLE_HOLD_MODE_1); //set dual sample and hold mode for all channels
  414a76:	463a      	mov	r2, r7
	afec->AFEC_CSELR = afec_ch;
  414a78:	6667      	str	r7, [r4, #100]	; 0x64
  414a7a:	2702      	movs	r7, #2
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414a7c:	66e5      	str	r5, [r4, #108]	; 0x6c
	afec->AFEC_CSELR = afec_ch;
  414a7e:	2307      	movs	r3, #7
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  414a80:	6166      	str	r6, [r4, #20]
  414a82:	4620      	mov	r0, r4
	afec->AFEC_CSELR = afec_ch;
  414a84:	6667      	str	r7, [r4, #100]	; 0x64
  414a86:	2703      	movs	r7, #3
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414a88:	66e5      	str	r5, [r4, #108]	; 0x6c
  414a8a:	f640 71ff 	movw	r1, #4095	; 0xfff
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  414a8e:	f8c4 9014 	str.w	r9, [r4, #20]
	afec->AFEC_CSELR = afec_ch;
  414a92:	6667      	str	r7, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414a94:	66e5      	str	r5, [r4, #108]	; 0x6c
	afec->AFEC_CHER = (afec_ch == AFEC_CHANNEL_ALL) ?
  414a96:	f8c4 c014 	str.w	ip, [r4, #20]
	afec->AFEC_CSELR = afec_ch;
  414a9a:	6666      	str	r6, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414a9c:	66e5      	str	r5, [r4, #108]	; 0x6c
	afec->AFEC_CSELR = afec_ch;
  414a9e:	6663      	str	r3, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414aa0:	66e5      	str	r5, [r4, #108]	; 0x6c
  414aa2:	4b10      	ldr	r3, [pc, #64]	; (414ae4 <adc_interface_init+0x19c>)
	afec->AFEC_CSELR = afec_ch;
  414aa4:	f8c4 9064 	str.w	r9, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414aa8:	66e5      	str	r5, [r4, #108]	; 0x6c
	afec->AFEC_CSELR = afec_ch;
  414aaa:	f8c4 a064 	str.w	sl, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414aae:	66e5      	str	r5, [r4, #108]	; 0x6c
	afec->AFEC_CSELR = afec_ch;
  414ab0:	f8c4 b064 	str.w	fp, [r4, #100]	; 0x64
	afec->AFEC_COCR = (aoffset & AFEC_COCR_AOFF_Msk);
  414ab4:	66e5      	str	r5, [r4, #108]	; 0x6c
  414ab6:	4798      	blx	r3
	
	//afec_set_trigger(AFEC1, AFEC_TRIG_PWM_EVENT_LINE_0);
	//NVIC_EnableIRQ(AFEC1_IRQn);

	/*SET AFEC CALLBACK FUNCTION*/
	afec_set_callback(AFEC1, AFEC_INTERRUPT_EOC_10, afec1_EOC_handler, 2);	
  414ab8:	4620      	mov	r0, r4
  414aba:	2302      	movs	r3, #2
  414abc:	4659      	mov	r1, fp
  414abe:	4a0e      	ldr	r2, [pc, #56]	; (414af8 <adc_interface_init+0x1b0>)
  414ac0:	4c0a      	ldr	r4, [pc, #40]	; (414aec <adc_interface_init+0x1a4>)
  414ac2:	47a0      	blx	r4
	//NVIC_DisableIRQ(AFEC1_IRQn);
	//NVIC_ClearPendingIRQ(AFEC1_IRQn);
	//NVIC_SetPriority(AFEC1_IRQn, 0);
	//NVIC_EnableIRQ(AFEC1_IRQn);
  414ac4:	b00f      	add	sp, #60	; 0x3c
  414ac6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  414aca:	bf00      	nop
  414acc:	4003c000 	.word	0x4003c000
  414ad0:	00417a25 	.word	0x00417a25
  414ad4:	00417851 	.word	0x00417851
  414ad8:	00417665 	.word	0x00417665
  414adc:	004176d9 	.word	0x004176d9
  414ae0:	004176cd 	.word	0x004176cd
  414ae4:	004178b1 	.word	0x004178b1
  414ae8:	00417d69 	.word	0x00417d69
  414aec:	004177d5 	.word	0x004177d5
  414af0:	40064000 	.word	0x40064000
  414af4:	000f4240 	.word	0x000f4240
  414af8:	00417cb9 	.word	0x00417cb9
  414afc:	00417699 	.word	0x00417699

00414b00 <fan_timer_toff>:
{
	if (IGBT_temp >= FAN_TMR_ON_TEMP) Fan_On;
}
void fan_timer_toff(void)
{
	Fan_Off;
  414b00:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  414b04:	4801      	ldr	r0, [pc, #4]	; (414b0c <fan_timer_toff+0xc>)
  414b06:	4b02      	ldr	r3, [pc, #8]	; (414b10 <fan_timer_toff+0x10>)
  414b08:	4718      	bx	r3
  414b0a:	bf00      	nop
  414b0c:	400e1400 	.word	0x400e1400
  414b10:	00417441 	.word	0x00417441

00414b14 <fan_timer_ton>:
	if (IGBT_temp >= FAN_TMR_ON_TEMP) Fan_On;
  414b14:	4b05      	ldr	r3, [pc, #20]	; (414b2c <fan_timer_ton+0x18>)
  414b16:	681b      	ldr	r3, [r3, #0]
  414b18:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
  414b1c:	da00      	bge.n	414b20 <fan_timer_ton+0xc>
  414b1e:	4770      	bx	lr
  414b20:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  414b24:	4802      	ldr	r0, [pc, #8]	; (414b30 <fan_timer_ton+0x1c>)
  414b26:	4b03      	ldr	r3, [pc, #12]	; (414b34 <fan_timer_ton+0x20>)
  414b28:	4718      	bx	r3
  414b2a:	bf00      	nop
  414b2c:	204003a4 	.word	0x204003a4
  414b30:	400e1400 	.word	0x400e1400
  414b34:	0041743d 	.word	0x0041743d

00414b38 <PWM0_Handler>:
{
  414b38:	b570      	push	{r4, r5, r6, lr}
	pwm_i_status = p_pwm->PWM_IMR1;
  414b3a:	4c26      	ldr	r4, [pc, #152]	; (414bd4 <PWM0_Handler+0x9c>)
 	pwm_i_status = pwm_channel_get_interrupt_status(PWM0);
  414b3c:	4b26      	ldr	r3, [pc, #152]	; (414bd8 <PWM0_Handler+0xa0>)
  414b3e:	4620      	mov	r0, r4
	pwm_i_status = p_pwm->PWM_IMR1;
  414b40:	69a2      	ldr	r2, [r4, #24]
 	pwm_i_status = pwm_channel_get_interrupt_status(PWM0);
  414b42:	4798      	blx	r3
 	pwm_fault_status = pwm_fault_get_status(PWM0);
  414b44:	4b25      	ldr	r3, [pc, #148]	; (414bdc <PWM0_Handler+0xa4>)
 	pwm_i_status = pwm_i_status >> 16; 
  414b46:	0c05      	lsrs	r5, r0, #16
 	pwm_fault_status = pwm_fault_get_status(PWM0);
  414b48:	4620      	mov	r0, r4
  414b4a:	4798      	blx	r3
  414b4c:	4606      	mov	r6, r0
 	if (pwm_i_status & 0x07)
  414b4e:	0768      	lsls	r0, r5, #29
  414b50:	d001      	beq.n	414b56 <PWM0_Handler+0x1e>
 		if( pwm_fault_status & (1 << 1))
  414b52:	07b1      	lsls	r1, r6, #30
  414b54:	d410      	bmi.n	414b78 <PWM0_Handler+0x40>
	if (pwm_i_status & 0x08)
  414b56:	072a      	lsls	r2, r5, #28
  414b58:	d501      	bpl.n	414b5e <PWM0_Handler+0x26>
 		if( pwm_fault_status & (1 << 2))
  414b5a:	0773      	lsls	r3, r6, #29
  414b5c:	d400      	bmi.n	414b60 <PWM0_Handler+0x28>
  414b5e:	bd70      	pop	{r4, r5, r6, pc}
 			brk_err_set;
  414b60:	4a1f      	ldr	r2, [pc, #124]	; (414be0 <PWM0_Handler+0xa8>)
  414b62:	4b20      	ldr	r3, [pc, #128]	; (414be4 <PWM0_Handler+0xac>)
  414b64:	7810      	ldrb	r0, [r2, #0]
  414b66:	4798      	blx	r3
 			vfd_trip();
  414b68:	4b1f      	ldr	r3, [pc, #124]	; (414be8 <PWM0_Handler+0xb0>)
  414b6a:	4798      	blx	r3
 			pwm_fault_clear_status(PWM0, (1 << 2));
  414b6c:	2104      	movs	r1, #4
  414b6e:	4819      	ldr	r0, [pc, #100]	; (414bd4 <PWM0_Handler+0x9c>)
  414b70:	4b1e      	ldr	r3, [pc, #120]	; (414bec <PWM0_Handler+0xb4>)
}
  414b72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 			pwm_fault_clear_status(PWM0, (1 << 2));
  414b76:	4718      	bx	r3
			if (vfd_states_is_sctest_mode())
  414b78:	4b1d      	ldr	r3, [pc, #116]	; (414bf0 <PWM0_Handler+0xb8>)
  414b7a:	4798      	blx	r3
  414b7c:	b150      	cbz	r0, 414b94 <PWM0_Handler+0x5c>
				sc_err_set;
  414b7e:	4a1d      	ldr	r2, [pc, #116]	; (414bf4 <PWM0_Handler+0xbc>)
  414b80:	4b18      	ldr	r3, [pc, #96]	; (414be4 <PWM0_Handler+0xac>)
  414b82:	7810      	ldrb	r0, [r2, #0]
  414b84:	4798      	blx	r3
				vfd_trip();
  414b86:	4b18      	ldr	r3, [pc, #96]	; (414be8 <PWM0_Handler+0xb0>)
  414b88:	4798      	blx	r3
				pwm_fault_clear_status(PWM0, (1 << 1));
  414b8a:	4620      	mov	r0, r4
  414b8c:	2102      	movs	r1, #2
  414b8e:	4b17      	ldr	r3, [pc, #92]	; (414bec <PWM0_Handler+0xb4>)
  414b90:	4798      	blx	r3
  414b92:	e7e0      	b.n	414b56 <PWM0_Handler+0x1e>
				if (vfd_get_accelerating_stage() == 0) oc_err_set;
  414b94:	4c18      	ldr	r4, [pc, #96]	; (414bf8 <PWM0_Handler+0xc0>)
  414b96:	47a0      	blx	r4
  414b98:	b160      	cbz	r0, 414bb4 <PWM0_Handler+0x7c>
				else if (vfd_get_accelerating_stage() == 1) acc_oc_err_set;
  414b9a:	47a0      	blx	r4
  414b9c:	2801      	cmp	r0, #1
  414b9e:	d00e      	beq.n	414bbe <PWM0_Handler+0x86>
				else if (vfd_get_accelerating_stage() == 2) dec_oc_err_set;
  414ba0:	47a0      	blx	r4
  414ba2:	2802      	cmp	r0, #2
  414ba4:	d010      	beq.n	414bc8 <PWM0_Handler+0x90>
				vfd_trip();
  414ba6:	4b10      	ldr	r3, [pc, #64]	; (414be8 <PWM0_Handler+0xb0>)
  414ba8:	4798      	blx	r3
				pwm_fault_clear_status(PWM0, (1 << 1));
  414baa:	2102      	movs	r1, #2
  414bac:	4809      	ldr	r0, [pc, #36]	; (414bd4 <PWM0_Handler+0x9c>)
  414bae:	4b0f      	ldr	r3, [pc, #60]	; (414bec <PWM0_Handler+0xb4>)
  414bb0:	4798      	blx	r3
  414bb2:	e7d0      	b.n	414b56 <PWM0_Handler+0x1e>
				if (vfd_get_accelerating_stage() == 0) oc_err_set;
  414bb4:	4a11      	ldr	r2, [pc, #68]	; (414bfc <PWM0_Handler+0xc4>)
  414bb6:	4b0b      	ldr	r3, [pc, #44]	; (414be4 <PWM0_Handler+0xac>)
  414bb8:	7810      	ldrb	r0, [r2, #0]
  414bba:	4798      	blx	r3
  414bbc:	e7f3      	b.n	414ba6 <PWM0_Handler+0x6e>
				else if (vfd_get_accelerating_stage() == 1) acc_oc_err_set;
  414bbe:	4a10      	ldr	r2, [pc, #64]	; (414c00 <PWM0_Handler+0xc8>)
  414bc0:	4b08      	ldr	r3, [pc, #32]	; (414be4 <PWM0_Handler+0xac>)
  414bc2:	7810      	ldrb	r0, [r2, #0]
  414bc4:	4798      	blx	r3
  414bc6:	e7ee      	b.n	414ba6 <PWM0_Handler+0x6e>
				else if (vfd_get_accelerating_stage() == 2) dec_oc_err_set;
  414bc8:	4a0e      	ldr	r2, [pc, #56]	; (414c04 <PWM0_Handler+0xcc>)
  414bca:	4b06      	ldr	r3, [pc, #24]	; (414be4 <PWM0_Handler+0xac>)
  414bcc:	7810      	ldrb	r0, [r2, #0]
  414bce:	4798      	blx	r3
  414bd0:	e7e9      	b.n	414ba6 <PWM0_Handler+0x6e>
  414bd2:	bf00      	nop
  414bd4:	40020000 	.word	0x40020000
  414bd8:	004120cd 	.word	0x004120cd
  414bdc:	00412185 	.word	0x00412185
  414be0:	20406caf 	.word	0x20406caf
  414be4:	0041282d 	.word	0x0041282d
  414be8:	0041724d 	.word	0x0041724d
  414bec:	0041218d 	.word	0x0041218d
  414bf0:	00416355 	.word	0x00416355
  414bf4:	20406c9f 	.word	0x20406c9f
  414bf8:	004169c9 	.word	0x004169c9
  414bfc:	20406cac 	.word	0x20406cac
  414c00:	20406cae 	.word	0x20406cae
  414c04:	20406ca4 	.word	0x20406ca4

00414c08 <inverter_ignore_uv>:
	if (ignore) inverter_uv_ignore = 1;
  414c08:	4b03      	ldr	r3, [pc, #12]	; (414c18 <inverter_ignore_uv+0x10>)
  414c0a:	b908      	cbnz	r0, 414c10 <inverter_ignore_uv+0x8>
	else inverter_uv_ignore = 0;
  414c0c:	7018      	strb	r0, [r3, #0]
  414c0e:	4770      	bx	lr
	if (ignore) inverter_uv_ignore = 1;
  414c10:	2201      	movs	r2, #1
  414c12:	701a      	strb	r2, [r3, #0]
  414c14:	4770      	bx	lr
  414c16:	bf00      	nop
  414c18:	20400b91 	.word	0x20400b91

00414c1c <inverter_init_dc_filter>:
	float t_ov_ts = PWM_FREQUENCY *	DC_FILTER_TIME;
  414c1c:	4b10      	ldr	r3, [pc, #64]	; (414c60 <inverter_init_dc_filter+0x44>)
	float tmp = 1 / (t_ov_ts + 1);
  414c1e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	t_ov_ts = 1 / t_ov_ts;
  414c22:	ed9f 6a10 	vldr	s12, [pc, #64]	; 414c64 <inverter_init_dc_filter+0x48>
	float t_ov_ts = PWM_FREQUENCY *	DC_FILTER_TIME;
  414c26:	ed93 7a00 	vldr	s14, [r3]
	float tmp = 1 / (t_ov_ts + 1);
  414c2a:	eeb0 5a67 	vmov.f32	s10, s15
  414c2e:	eddf 5a0e 	vldr	s11, [pc, #56]	; 414c68 <inverter_init_dc_filter+0x4c>
	t_ov_ts = 1 / t_ov_ts;
  414c32:	eec6 6a07 	vdiv.f32	s13, s12, s14
	tmp *= FIXEDPT_ONE;
  414c36:	ed9f 6a0d 	vldr	s12, [pc, #52]	; 414c6c <inverter_init_dc_filter+0x50>
	vout_filter_weight = tmp;
  414c3a:	4b0d      	ldr	r3, [pc, #52]	; (414c70 <inverter_init_dc_filter+0x54>)
	vin_filter_weight = tmp;
  414c3c:	4a0d      	ldr	r2, [pc, #52]	; (414c74 <inverter_init_dc_filter+0x58>)
	float tmp = 1 / (t_ov_ts + 1);
  414c3e:	eea7 5a25 	vfma.f32	s10, s14, s11
	tmp *= FIXEDPT_ONE;
  414c42:	ee86 7a05 	vdiv.f32	s14, s12, s10
	tmp = 1 / (t_ov_ts + 1);
  414c46:	ee76 6aa7 	vadd.f32	s13, s13, s15
	tmp *= FIXEDPT_ONE;
  414c4a:	eec6 7a26 	vdiv.f32	s15, s12, s13
	vin_filter_weight = tmp;
  414c4e:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  414c52:	ed82 7a00 	vstr	s14, [r2]
	vout_filter_weight = tmp;
  414c56:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  414c5a:	edc3 7a00 	vstr	s15, [r3]
  414c5e:	4770      	bx	lr
  414c60:	204003c8 	.word	0x204003c8
  414c64:	4395b35a 	.word	0x4395b35a
  414c68:	3b5ae3e7 	.word	0x3b5ae3e7
  414c6c:	47000000 	.word	0x47000000
  414c70:	20400b94 	.word	0x20400b94
  414c74:	204003c0 	.word	0x204003c0

00414c78 <inverter_update_dcbus_val>:
{
  414c78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	temp_dcbus = fixedpt_div( fixedpt_mul(fixedpt_rconst (adc_reading), fixedpt_rconst(3) ), fixedpt_rconst(4095));
  414c7c:	03c0      	lsls	r0, r0, #15
  414c7e:	4b24      	ldr	r3, [pc, #144]	; (414d10 <inverter_update_dcbus_val+0x98>)
  414c80:	4798      	blx	r3
  414c82:	4c24      	ldr	r4, [pc, #144]	; (414d14 <inverter_update_dcbus_val+0x9c>)
  414c84:	2200      	movs	r2, #0
  414c86:	4b24      	ldr	r3, [pc, #144]	; (414d18 <inverter_update_dcbus_val+0xa0>)
  414c88:	47a0      	blx	r4
  414c8a:	f44f 34c0 	mov.w	r4, #98304	; 0x18000
  414c8e:	4b23      	ldr	r3, [pc, #140]	; (414d1c <inverter_update_dcbus_val+0xa4>)
  414c90:	4798      	blx	r3
  414c92:	fb80 4504 	smull	r4, r5, r0, r4
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  414c96:	4e22      	ldr	r6, [pc, #136]	; (414d20 <inverter_update_dcbus_val+0xa8>)
  414c98:	2300      	movs	r3, #0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  414c9a:	0be1      	lsrs	r1, r4, #15
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  414c9c:	4a21      	ldr	r2, [pc, #132]	; (414d24 <inverter_update_dcbus_val+0xac>)
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  414c9e:	4f22      	ldr	r7, [pc, #136]	; (414d28 <inverter_update_dcbus_val+0xb0>)
  414ca0:	ea41 4145 	orr.w	r1, r1, r5, lsl #17
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  414ca4:	17cd      	asrs	r5, r1, #31
  414ca6:	03c8      	lsls	r0, r1, #15
  414ca8:	03ec      	lsls	r4, r5, #15
	dc_bus_v_f_reading = fixedpt_mul(dc_bus_v_f_reading, vout_filter_weight) + fixedpt_mul(dc_bus_v_reading, vin_filter_weight);
  414caa:	4d20      	ldr	r5, [pc, #128]	; (414d2c <inverter_update_dcbus_val+0xb4>)
  414cac:	ea44 4151 	orr.w	r1, r4, r1, lsr #17
  414cb0:	47b0      	blx	r6
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  414cb2:	4a1f      	ldr	r2, [pc, #124]	; (414d30 <inverter_update_dcbus_val+0xb8>)
	temp_dcbus += fixedpt_rconst(0.8);
  414cb4:	f246 6366 	movw	r3, #26214	; 0x6666
  414cb8:	682e      	ldr	r6, [r5, #0]
  414cba:	fba0 8902 	umull	r8, r9, r0, r2
	dc_bus_v_f_reading = fixedpt_mul(dc_bus_v_f_reading, vout_filter_weight) + fixedpt_mul(dc_bus_v_reading, vin_filter_weight);
  414cbe:	481d      	ldr	r0, [pc, #116]	; (414d34 <inverter_update_dcbus_val+0xbc>)
  414cc0:	fb02 9901 	mla	r9, r2, r1, r9
  414cc4:	ea4f 31d8 	mov.w	r1, r8, lsr #15
  414cc8:	6802      	ldr	r2, [r0, #0]
  414cca:	ea41 4149 	orr.w	r1, r1, r9, lsl #17
  414cce:	481a      	ldr	r0, [pc, #104]	; (414d38 <inverter_update_dcbus_val+0xc0>)
  414cd0:	ea4f 79e2 	mov.w	r9, r2, asr #31
	temp_dcbus += fixedpt_rconst(0.8);
  414cd4:	440b      	add	r3, r1
  414cd6:	6804      	ldr	r4, [r0, #0]
  414cd8:	fb83 0107 	smull	r0, r1, r3, r7
  414cdc:	fb86 6704 	smull	r6, r7, r6, r4
  414ce0:	0bc0      	lsrs	r0, r0, #15
  414ce2:	13cc      	asrs	r4, r1, #15
  414ce4:	ea40 4041 	orr.w	r0, r0, r1, lsl #17
  414ce8:	fb02 f404 	mul.w	r4, r2, r4
  414cec:	0bf1      	lsrs	r1, r6, #15
  414cee:	fba2 2300 	umull	r2, r3, r2, r0
	dc_bus_v_reading = temp_dcbus;
  414cf2:	4e12      	ldr	r6, [pc, #72]	; (414d3c <inverter_update_dcbus_val+0xc4>)
  414cf4:	fb00 4409 	mla	r4, r0, r9, r4
  414cf8:	ea41 4147 	orr.w	r1, r1, r7, lsl #17
  414cfc:	0bd2      	lsrs	r2, r2, #15
  414cfe:	6030      	str	r0, [r6, #0]
  414d00:	4423      	add	r3, r4
  414d02:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	dc_bus_v_f_reading = fixedpt_mul(dc_bus_v_f_reading, vout_filter_weight) + fixedpt_mul(dc_bus_v_reading, vin_filter_weight);
  414d06:	4411      	add	r1, r2
  414d08:	6029      	str	r1, [r5, #0]
  414d0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  414d0e:	bf00      	nop
  414d10:	00418725 	.word	0x00418725
  414d14:	0041848d 	.word	0x0041848d
  414d18:	3fe00000 	.word	0x3fe00000
  414d1c:	00418d51 	.word	0x00418d51
  414d20:	0041905d 	.word	0x0041905d
  414d24:	07ff8000 	.word	0x07ff8000
  414d28:	00052148 	.word	0x00052148
  414d2c:	20400b74 	.word	0x20400b74
  414d30:	001396c9 	.word	0x001396c9
  414d34:	204003c0 	.word	0x204003c0
  414d38:	20400b94 	.word	0x20400b94
  414d3c:	20400b78 	.word	0x20400b78

00414d40 <inverter_check_dcbus_val_handler>:
{
  414d40:	b510      	push	{r4, lr}
	if(!vfd_states_initialized()) return;
  414d42:	4b15      	ldr	r3, [pc, #84]	; (414d98 <inverter_check_dcbus_val_handler+0x58>)
  414d44:	4798      	blx	r3
  414d46:	b1b0      	cbz	r0, 414d76 <inverter_check_dcbus_val_handler+0x36>
	if(dc_bus_v_f_reading > DC_BUS_MAX)
  414d48:	4b14      	ldr	r3, [pc, #80]	; (414d9c <inverter_check_dcbus_val_handler+0x5c>)
  414d4a:	681b      	ldr	r3, [r3, #0]
  414d4c:	f1b3 7fbe 	cmp.w	r3, #24903680	; 0x17c0000
  414d50:	dc12      	bgt.n	414d78 <inverter_check_dcbus_val_handler+0x38>
	else if ((dc_bus_v_f_reading < DC_BUS_MIN) && (inverter_uv_ignore != 1) && (1/*vfd_states_allowedtomove()*/))
  414d52:	f5b3 0f2f 	cmp.w	r3, #11468800	; 0xaf0000
  414d56:	da0e      	bge.n	414d76 <inverter_check_dcbus_val_handler+0x36>
  414d58:	4a11      	ldr	r2, [pc, #68]	; (414da0 <inverter_check_dcbus_val_handler+0x60>)
  414d5a:	7812      	ldrb	r2, [r2, #0]
  414d5c:	2a01      	cmp	r2, #1
  414d5e:	d113      	bne.n	414d88 <inverter_check_dcbus_val_handler+0x48>
	else if ((dc_bus_v_f_reading < DC_BUS_ARD_MIN) && (inverter_uv_ignore == 1) && (1/*vfd_states_allowedtomove()*/))
  414d60:	f5b3 0f96 	cmp.w	r3, #4915200	; 0x4b0000
  414d64:	da07      	bge.n	414d76 <inverter_check_dcbus_val_handler+0x36>
		vfd_trip();
  414d66:	4b0f      	ldr	r3, [pc, #60]	; (414da4 <inverter_check_dcbus_val_handler+0x64>)
  414d68:	4798      	blx	r3
		uv_ard_err_set;
  414d6a:	4a0f      	ldr	r2, [pc, #60]	; (414da8 <inverter_check_dcbus_val_handler+0x68>)
  414d6c:	4b0f      	ldr	r3, [pc, #60]	; (414dac <inverter_check_dcbus_val_handler+0x6c>)
  414d6e:	7810      	ldrb	r0, [r2, #0]
}
  414d70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		uv_ard_err_set;
  414d74:	4718      	bx	r3
  414d76:	bd10      	pop	{r4, pc}
		ov_err_set;
  414d78:	4a0d      	ldr	r2, [pc, #52]	; (414db0 <inverter_check_dcbus_val_handler+0x70>)
  414d7a:	4b0c      	ldr	r3, [pc, #48]	; (414dac <inverter_check_dcbus_val_handler+0x6c>)
  414d7c:	7810      	ldrb	r0, [r2, #0]
  414d7e:	4798      	blx	r3
		vfd_trip();
  414d80:	4b08      	ldr	r3, [pc, #32]	; (414da4 <inverter_check_dcbus_val_handler+0x64>)
}
  414d82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vfd_trip();
  414d86:	4718      	bx	r3
		vfd_trip();
  414d88:	4b06      	ldr	r3, [pc, #24]	; (414da4 <inverter_check_dcbus_val_handler+0x64>)
  414d8a:	4798      	blx	r3
		uv_err_set;
  414d8c:	4a09      	ldr	r2, [pc, #36]	; (414db4 <inverter_check_dcbus_val_handler+0x74>)
  414d8e:	4b07      	ldr	r3, [pc, #28]	; (414dac <inverter_check_dcbus_val_handler+0x6c>)
  414d90:	7810      	ldrb	r0, [r2, #0]
}
  414d92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		uv_err_set;
  414d96:	4718      	bx	r3
  414d98:	00416335 	.word	0x00416335
  414d9c:	20400b74 	.word	0x20400b74
  414da0:	20400b91 	.word	0x20400b91
  414da4:	0041724d 	.word	0x0041724d
  414da8:	20406cad 	.word	0x20406cad
  414dac:	0041282d 	.word	0x0041282d
  414db0:	20406cb1 	.word	0x20406cb1
  414db4:	20406cb2 	.word	0x20406cb2

00414db8 <inverter_update_currents_val>:
			i_adc_v_offset[i]   += ((floatadc - i_adc_v_offset[i]) * (TSAMPLE / C_READOUT_AVG_FILTER));
  414db8:	4a18      	ldr	r2, [pc, #96]	; (414e1c <inverter_update_currents_val+0x64>)
  414dba:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
  414dbe:	4b18      	ldr	r3, [pc, #96]	; (414e20 <inverter_update_currents_val+0x68>)
		current_read_out = (current_read_out * (I_I_OV_V * I_ADC_REF));
  414dc0:	eddf 6a18 	vldr	s13, [pc, #96]	; 414e24 <inverter_update_currents_val+0x6c>
{
  414dc4:	b530      	push	{r4, r5, lr}
			i_adc_v_offset[i]   += ((floatadc - i_adc_v_offset[i]) * (TSAMPLE / C_READOUT_AVG_FILTER));
  414dc6:	edd2 7a00 	vldr	s15, [r2]
  414dca:	1e82      	subs	r2, r0, #2
  414dcc:	4c16      	ldr	r4, [pc, #88]	; (414e28 <inverter_update_currents_val+0x70>)
  414dce:	3004      	adds	r0, #4
  414dd0:	eec7 5a27 	vdiv.f32	s11, s14, s15
  414dd4:	781d      	ldrb	r5, [r3, #0]
  414dd6:	4621      	mov	r1, r4
  414dd8:	4b14      	ldr	r3, [pc, #80]	; (414e2c <inverter_update_currents_val+0x74>)
		floatadc = (*adc_reading);
  414dda:	f832 ef02 	ldrh.w	lr, [r2, #2]!
			i_adc_v_offset[i]   += ((floatadc - i_adc_v_offset[i]) * (TSAMPLE / C_READOUT_AVG_FILTER));
  414dde:	ed93 7a00 	vldr	s14, [r3]
		floatadc = (*adc_reading);
  414de2:	ee07 ea90 	vmov	s15, lr
  414de6:	eef8 7a67 	vcvt.f32.u32	s15, s15
		if(start_avg)
  414dea:	b12d      	cbz	r5, 414df8 <inverter_update_currents_val+0x40>
			i_adc_v_offset[i]   += ((floatadc - i_adc_v_offset[i]) * (TSAMPLE / C_READOUT_AVG_FILTER));
  414dec:	ee37 6ac7 	vsub.f32	s12, s15, s14
  414df0:	eea6 7a25 	vfma.f32	s14, s12, s11
  414df4:	ed83 7a00 	vstr	s14, [r3]
		float32_t current_read_out = floatadc - i_adc_v_offset[i];
  414df8:	ee77 7ac7 	vsub.f32	s15, s15, s14
	for (i=0; i<3; i++)
  414dfc:	4282      	cmp	r2, r0
  414dfe:	f103 0304 	add.w	r3, r3, #4
		current_read_out = (current_read_out * (I_I_OV_V * I_ADC_REF));
  414e02:	ee67 7aa6 	vmul.f32	s15, s15, s13
		i_readout[i] = current_read_out;
  414e06:	ece1 7a01 	vstmia	r1!, {s15}
	for (i=0; i<3; i++)
  414e0a:	d1e6      	bne.n	414dda <inverter_update_currents_val+0x22>
	scCheck_current_handler(i_readout[0], i_readout[1], i_readout[2]);
  414e0c:	68a2      	ldr	r2, [r4, #8]
  414e0e:	6861      	ldr	r1, [r4, #4]
  414e10:	6820      	ldr	r0, [r4, #0]
  414e12:	4b07      	ldr	r3, [pc, #28]	; (414e30 <inverter_update_currents_val+0x78>)
}
  414e14:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	scCheck_current_handler(i_readout[0], i_readout[1], i_readout[2]);
  414e18:	4718      	bx	r3
  414e1a:	bf00      	nop
  414e1c:	204003c8 	.word	0x204003c8
  414e20:	204003bc 	.word	0x204003bc
  414e24:	3d160961 	.word	0x3d160961
  414e28:	20400b84 	.word	0x20400b84
  414e2c:	204003ac 	.word	0x204003ac
  414e30:	00415bd1 	.word	0x00415bd1

00414e34 <inverter_getADCcurrent>:
}
  414e34:	4800      	ldr	r0, [pc, #0]	; (414e38 <inverter_getADCcurrent+0x4>)
  414e36:	4770      	bx	lr
  414e38:	204003ac 	.word	0x204003ac

00414e3c <inverter_out_single_axis>:
	m = dc_bus_v_f_reading;
  414e3c:	4b36      	ldr	r3, [pc, #216]	; (414f18 <inverter_out_single_axis+0xdc>)
{
  414e3e:	ee06 0a10 	vmov	s12, r0
  414e42:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	if(volts >= 0)
  414e46:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
{
  414e4a:	b530      	push	{r4, r5, lr}
	m = dc_bus_v_f_reading;
  414e4c:	ed93 7a00 	vldr	s14, [r3]
	if(volts >= 0)
  414e50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
  414e54:	b095      	sub	sp, #84	; 0x54
	m /= FIXEDPT_ONE;
  414e56:	eeba 7ae8 	vcvt.f32.s32	s14, s14, #15
	m =  volts / m;
  414e5a:	eec6 7a07 	vdiv.f32	s15, s12, s14
	m = fixedpt_abs(m);
  414e5e:	eef0 7ae7 	vabs.f32	s15, s15
  414e62:	fec7 7ae6 	vminnm.f32	s15, s15, s13
	if(volts >= 0)
  414e66:	db4e      	blt.n	414f06 <inverter_out_single_axis+0xca>
		pwm_a = (m * 4095);
  414e68:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 414f1c <inverter_out_single_axis+0xe0>
		pwm_b = 0;
  414e6c:	2200      	movs	r2, #0
		pwm_a = (m * 4095);
  414e6e:	ee67 7a87 	vmul.f32	s15, s15, s14
		pwm_a = ((1.0f - m) * 4095);
  414e72:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  414e76:	edcd 7a01 	vstr	s15, [sp, #4]
  414e7a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  414e7e:	f8ad 300e 	strh.w	r3, [sp, #14]
	if(inverter_dead_comp == 0) return 0;
  414e82:	4b27      	ldr	r3, [pc, #156]	; (414f20 <inverter_out_single_axis+0xe4>)
		pwm_b = 4095;
  414e84:	f8ad 2010 	strh.w	r2, [sp, #16]
	if(inverter_dead_comp == 0) return 0;
  414e88:	681c      	ldr	r4, [r3, #0]
		pwm_c = 4095;
  414e8a:	f8ad 2012 	strh.w	r2, [sp, #18]
	dead_time_comp = pwm_a;
  414e8e:	f8bd 500e 	ldrh.w	r5, [sp, #14]
  414e92:	b2ad      	uxth	r5, r5
	if(inverter_dead_comp == 0) return 0;
  414e94:	b154      	cbz	r4, 414eac <inverter_out_single_axis+0x70>
		if (i_readout[axis] >= 0)
  414e96:	4b23      	ldr	r3, [pc, #140]	; (414f24 <inverter_out_single_axis+0xe8>)
  414e98:	edd3 7a00 	vldr	s15, [r3]
  414e9c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  414ea0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  414ea4:	bfac      	ite	ge
  414ea6:	2401      	movge	r4, #1
  414ea8:	f04f 34ff 	movlt.w	r4, #4294967295
	dead_time_comp += inverter_get_current_sign(0) * DEAD_TIME_INTERVAL;
  414eac:	4b1e      	ldr	r3, [pc, #120]	; (414f28 <inverter_out_single_axis+0xec>)
  414eae:	4798      	blx	r3
  414eb0:	fb00 5304 	mla	r3, r0, r4, r5
	pwm_a = dead_time_comp;
  414eb4:	f640 72ff 	movw	r2, #4095	; 0xfff
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  414eb8:	2500      	movs	r5, #0
  414eba:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414ebe:	4c1b      	ldr	r4, [pc, #108]	; (414f2c <inverter_out_single_axis+0xf0>)
	pwm_channel_instance.ul_period = 0xfff;
  414ec0:	9209      	str	r2, [sp, #36]	; 0x24
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414ec2:	a905      	add	r1, sp, #20
	pwm_a = dead_time_comp;
  414ec4:	4293      	cmp	r3, r2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414ec6:	481a      	ldr	r0, [pc, #104]	; (414f30 <inverter_out_single_axis+0xf4>)
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  414ec8:	9505      	str	r5, [sp, #20]
	pwm_a = dead_time_comp;
  414eca:	bfa8      	it	ge
  414ecc:	4613      	movge	r3, r2
  414ece:	b29b      	uxth	r3, r3
  414ed0:	f8ad 300e 	strh.w	r3, [sp, #14]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414ed4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
  414ed8:	b292      	uxth	r2, r2
  414eda:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  414edc:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  414ee0:	2301      	movs	r3, #1
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  414ee2:	a905      	add	r1, sp, #20
  414ee4:	b292      	uxth	r2, r2
  414ee6:	4812      	ldr	r0, [pc, #72]	; (414f30 <inverter_out_single_axis+0xf4>)
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  414ee8:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  414eea:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  414eec:	f8bd 2012 	ldrh.w	r2, [sp, #18]
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  414ef0:	2302      	movs	r3, #2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  414ef2:	a905      	add	r1, sp, #20
  414ef4:	480e      	ldr	r0, [pc, #56]	; (414f30 <inverter_out_single_axis+0xf4>)
  414ef6:	b292      	uxth	r2, r2
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  414ef8:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  414efa:	47a0      	blx	r4
	pwm_sync_unlock_update(PWM0);
  414efc:	480c      	ldr	r0, [pc, #48]	; (414f30 <inverter_out_single_axis+0xf4>)
  414efe:	4b0d      	ldr	r3, [pc, #52]	; (414f34 <inverter_out_single_axis+0xf8>)
  414f00:	4798      	blx	r3
}
  414f02:	b015      	add	sp, #84	; 0x54
  414f04:	bd30      	pop	{r4, r5, pc}
		pwm_a = ((1.0f - m) * 4095);
  414f06:	ee76 7ae7 	vsub.f32	s15, s13, s15
  414f0a:	eddf 6a04 	vldr	s13, [pc, #16]	; 414f1c <inverter_out_single_axis+0xe0>
		pwm_b = 4095;
  414f0e:	f640 72ff 	movw	r2, #4095	; 0xfff
		pwm_a = ((1.0f - m) * 4095);
  414f12:	ee67 7aa6 	vmul.f32	s15, s15, s13
  414f16:	e7ac      	b.n	414e72 <inverter_out_single_axis+0x36>
  414f18:	20400b74 	.word	0x20400b74
  414f1c:	457ff000 	.word	0x457ff000
  414f20:	204003b8 	.word	0x204003b8
  414f24:	20400b84 	.word	0x20400b84
  414f28:	00415721 	.word	0x00415721
  414f2c:	0041208d 	.word	0x0041208d
  414f30:	40020000 	.word	0x40020000
  414f34:	00412255 	.word	0x00412255

00414f38 <inverter_out_single_axis_b>:
	m = dc_bus_v_f_reading;
  414f38:	4b28      	ldr	r3, [pc, #160]	; (414fdc <inverter_out_single_axis_b+0xa4>)
{
  414f3a:	ee06 0a10 	vmov	s12, r0
  414f3e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	if(volts >= 0)
  414f42:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
{
  414f46:	b530      	push	{r4, r5, lr}
	m = dc_bus_v_f_reading;
  414f48:	ed93 7a00 	vldr	s14, [r3]
	if(volts >= 0)
  414f4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
  414f50:	b095      	sub	sp, #84	; 0x54
	m /= FIXEDPT_ONE;
  414f52:	eeba 7ae8 	vcvt.f32.s32	s14, s14, #15
	m =  volts / m;
  414f56:	eec6 7a07 	vdiv.f32	s15, s12, s14
	m = fixedpt_abs(m);
  414f5a:	eef0 7ae7 	vabs.f32	s15, s15
  414f5e:	fec7 7ae6 	vminnm.f32	s15, s15, s13
	if(volts >= 0)
  414f62:	db31      	blt.n	414fc8 <inverter_out_single_axis_b+0x90>
		pwm_b = (m * 4095);
  414f64:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 414fe0 <inverter_out_single_axis_b+0xa8>
		pwm_a = 0;
  414f68:	2200      	movs	r2, #0
		pwm_b = (m * 4095);
  414f6a:	ee67 7a87 	vmul.f32	s15, s15, s14
		pwm_b = ((1.0f - m) * 4095);
  414f6e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	pwm_channel_instance.ul_period = 0xfff;
  414f72:	f640 75ff 	movw	r5, #4095	; 0xfff
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414f76:	4c1b      	ldr	r4, [pc, #108]	; (414fe4 <inverter_out_single_axis_b+0xac>)
  414f78:	a905      	add	r1, sp, #20
  414f7a:	481b      	ldr	r0, [pc, #108]	; (414fe8 <inverter_out_single_axis_b+0xb0>)
		pwm_b = ((1.0f - m) * 4095);
  414f7c:	edcd 7a01 	vstr	s15, [sp, #4]
  414f80:	f8bd 3004 	ldrh.w	r3, [sp, #4]
	pwm_channel_instance.ul_period = 0xfff;
  414f84:	9509      	str	r5, [sp, #36]	; 0x24
		pwm_b = ((1.0f - m) * 4095);
  414f86:	f8ad 3010 	strh.w	r3, [sp, #16]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  414f8a:	2300      	movs	r3, #0
		pwm_a = 4095;
  414f8c:	f8ad 200e 	strh.w	r2, [sp, #14]
		pwm_c = 4095;
  414f90:	f8ad 2012 	strh.w	r2, [sp, #18]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414f94:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  414f98:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  414f9a:	b292      	uxth	r2, r2
  414f9c:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  414f9e:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  414fa2:	2301      	movs	r3, #1
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  414fa4:	a905      	add	r1, sp, #20
  414fa6:	b292      	uxth	r2, r2
  414fa8:	480f      	ldr	r0, [pc, #60]	; (414fe8 <inverter_out_single_axis_b+0xb0>)
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  414faa:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  414fac:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  414fae:	f8bd 2012 	ldrh.w	r2, [sp, #18]
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  414fb2:	2302      	movs	r3, #2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  414fb4:	a905      	add	r1, sp, #20
  414fb6:	480c      	ldr	r0, [pc, #48]	; (414fe8 <inverter_out_single_axis_b+0xb0>)
  414fb8:	b292      	uxth	r2, r2
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  414fba:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  414fbc:	47a0      	blx	r4
	pwm_sync_unlock_update(PWM0);
  414fbe:	480a      	ldr	r0, [pc, #40]	; (414fe8 <inverter_out_single_axis_b+0xb0>)
  414fc0:	4b0a      	ldr	r3, [pc, #40]	; (414fec <inverter_out_single_axis_b+0xb4>)
  414fc2:	4798      	blx	r3
}
  414fc4:	b015      	add	sp, #84	; 0x54
  414fc6:	bd30      	pop	{r4, r5, pc}
		pwm_b = ((1.0f - m) * 4095);
  414fc8:	ee76 7ae7 	vsub.f32	s15, s13, s15
  414fcc:	eddf 6a04 	vldr	s13, [pc, #16]	; 414fe0 <inverter_out_single_axis_b+0xa8>
		pwm_a = 4095;
  414fd0:	f640 72ff 	movw	r2, #4095	; 0xfff
		pwm_b = ((1.0f - m) * 4095);
  414fd4:	ee67 7aa6 	vmul.f32	s15, s15, s13
  414fd8:	e7c9      	b.n	414f6e <inverter_out_single_axis_b+0x36>
  414fda:	bf00      	nop
  414fdc:	20400b74 	.word	0x20400b74
  414fe0:	457ff000 	.word	0x457ff000
  414fe4:	0041208d 	.word	0x0041208d
  414fe8:	40020000 	.word	0x40020000
  414fec:	00412255 	.word	0x00412255

00414ff0 <inverter_out_single_axis_c>:
	m = dc_bus_v_f_reading;
  414ff0:	4b28      	ldr	r3, [pc, #160]	; (415094 <inverter_out_single_axis_c+0xa4>)
{
  414ff2:	ee06 0a10 	vmov	s12, r0
  414ff6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
	if(volts >= 0)
  414ffa:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
{
  414ffe:	b530      	push	{r4, r5, lr}
	m = dc_bus_v_f_reading;
  415000:	ed93 7a00 	vldr	s14, [r3]
	if(volts >= 0)
  415004:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
  415008:	b095      	sub	sp, #84	; 0x54
	m /= FIXEDPT_ONE;
  41500a:	eeba 7ae8 	vcvt.f32.s32	s14, s14, #15
	m =  volts / m;
  41500e:	eec6 7a07 	vdiv.f32	s15, s12, s14
	m = fixedpt_abs(m);
  415012:	eef0 7ae7 	vabs.f32	s15, s15
  415016:	fec7 7ae6 	vminnm.f32	s15, s15, s13
	if(volts >= 0)
  41501a:	db31      	blt.n	415080 <inverter_out_single_axis_c+0x90>
		pwm_c = (m * 4095);
  41501c:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 415098 <inverter_out_single_axis_c+0xa8>
		pwm_b = 0;
  415020:	2200      	movs	r2, #0
		pwm_c = (m * 4095);
  415022:	ee67 7a87 	vmul.f32	s15, s15, s14
		pwm_c = ((1.0f - m) * 4095);
  415026:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	pwm_channel_instance.ul_period = 0xfff;
  41502a:	f640 75ff 	movw	r5, #4095	; 0xfff
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  41502e:	4c1b      	ldr	r4, [pc, #108]	; (41509c <inverter_out_single_axis_c+0xac>)
  415030:	a905      	add	r1, sp, #20
  415032:	481b      	ldr	r0, [pc, #108]	; (4150a0 <inverter_out_single_axis_c+0xb0>)
		pwm_c = ((1.0f - m) * 4095);
  415034:	edcd 7a01 	vstr	s15, [sp, #4]
  415038:	f8bd 3004 	ldrh.w	r3, [sp, #4]
	pwm_channel_instance.ul_period = 0xfff;
  41503c:	9509      	str	r5, [sp, #36]	; 0x24
		pwm_c = ((1.0f - m) * 4095);
  41503e:	f8ad 3012 	strh.w	r3, [sp, #18]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  415042:	2300      	movs	r3, #0
		pwm_b = 4095;
  415044:	f8ad 2010 	strh.w	r2, [sp, #16]
		pwm_a = 4095;
  415048:	f8ad 200e 	strh.w	r2, [sp, #14]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  41504c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  415050:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  415052:	b292      	uxth	r2, r2
  415054:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  415056:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  41505a:	2301      	movs	r3, #1
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  41505c:	a905      	add	r1, sp, #20
  41505e:	b292      	uxth	r2, r2
  415060:	480f      	ldr	r0, [pc, #60]	; (4150a0 <inverter_out_single_axis_c+0xb0>)
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  415062:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  415064:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  415066:	f8bd 2012 	ldrh.w	r2, [sp, #18]
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  41506a:	2302      	movs	r3, #2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  41506c:	a905      	add	r1, sp, #20
  41506e:	480c      	ldr	r0, [pc, #48]	; (4150a0 <inverter_out_single_axis_c+0xb0>)
  415070:	b292      	uxth	r2, r2
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  415072:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  415074:	47a0      	blx	r4
	pwm_sync_unlock_update(PWM0);
  415076:	480a      	ldr	r0, [pc, #40]	; (4150a0 <inverter_out_single_axis_c+0xb0>)
  415078:	4b0a      	ldr	r3, [pc, #40]	; (4150a4 <inverter_out_single_axis_c+0xb4>)
  41507a:	4798      	blx	r3
}
  41507c:	b015      	add	sp, #84	; 0x54
  41507e:	bd30      	pop	{r4, r5, pc}
		pwm_c = ((1.0f - m) * 4095);
  415080:	ee76 7ae7 	vsub.f32	s15, s13, s15
  415084:	eddf 6a04 	vldr	s13, [pc, #16]	; 415098 <inverter_out_single_axis_c+0xa8>
		pwm_b = 4095;
  415088:	f640 72ff 	movw	r2, #4095	; 0xfff
		pwm_c = ((1.0f - m) * 4095);
  41508c:	ee67 7aa6 	vmul.f32	s15, s15, s13
  415090:	e7c9      	b.n	415026 <inverter_out_single_axis_c+0x36>
  415092:	bf00      	nop
  415094:	20400b74 	.word	0x20400b74
  415098:	457ff000 	.word	0x457ff000
  41509c:	0041208d 	.word	0x0041208d
  4150a0:	40020000 	.word	0x40020000
  4150a4:	00412255 	.word	0x00412255

004150a8 <inverter_out_polar>:
{
  4150a8:	b570      	push	{r4, r5, r6, lr}
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  4150aa:	17cb      	asrs	r3, r1, #31
	m = fixedpt_div( volts , dc_bus_v_f_reading);
  4150ac:	4c1f      	ldr	r4, [pc, #124]	; (41512c <inverter_out_polar+0x84>)
{
  4150ae:	b094      	sub	sp, #80	; 0x50
  4150b0:	4606      	mov	r6, r0
  4150b2:	6822      	ldr	r2, [r4, #0]
  4150b4:	03dc      	lsls	r4, r3, #15
  4150b6:	4d1e      	ldr	r5, [pc, #120]	; (415130 <inverter_out_polar+0x88>)
  4150b8:	03c8      	lsls	r0, r1, #15
  4150ba:	17d3      	asrs	r3, r2, #31
  4150bc:	ea44 4151 	orr.w	r1, r4, r1, lsr #17
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  4150c0:	4c1c      	ldr	r4, [pc, #112]	; (415134 <inverter_out_polar+0x8c>)
  4150c2:	47a8      	blx	r5
	svm_polar_to_ABC(&pwm_a, &pwm_b, &pwm_c, alfa ,m);
  4150c4:	4633      	mov	r3, r6
	m = fixedpt_abs(m);
  4150c6:	ea80 75e0 	eor.w	r5, r0, r0, asr #31
	svm_polar_to_ABC(&pwm_a, &pwm_b, &pwm_c, alfa ,m);
  4150ca:	f10d 0212 	add.w	r2, sp, #18
  4150ce:	a904      	add	r1, sp, #16
  4150d0:	4e19      	ldr	r6, [pc, #100]	; (415138 <inverter_out_polar+0x90>)
	m = fixedpt_abs(m);
  4150d2:	eba5 75e0 	sub.w	r5, r5, r0, asr #31
	svm_polar_to_ABC(&pwm_a, &pwm_b, &pwm_c, alfa ,m);
  4150d6:	f10d 000e 	add.w	r0, sp, #14
  4150da:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
  4150de:	bfa8      	it	ge
  4150e0:	f44f 4500 	movge.w	r5, #32768	; 0x8000
  4150e4:	9500      	str	r5, [sp, #0]
  4150e6:	47b0      	blx	r6
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  4150e8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  4150ec:	2300      	movs	r3, #0
	pwm_channel_instance.ul_period = 0xfff;
  4150ee:	f640 76ff 	movw	r6, #4095	; 0xfff
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  4150f2:	4d12      	ldr	r5, [pc, #72]	; (41513c <inverter_out_polar+0x94>)
  4150f4:	a905      	add	r1, sp, #20
  4150f6:	b292      	uxth	r2, r2
  4150f8:	4620      	mov	r0, r4
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  4150fa:	9305      	str	r3, [sp, #20]
	pwm_channel_instance.ul_period = 0xfff;
  4150fc:	9609      	str	r6, [sp, #36]	; 0x24
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  4150fe:	47a8      	blx	r5
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  415100:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  415104:	2301      	movs	r3, #1
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  415106:	a905      	add	r1, sp, #20
  415108:	4620      	mov	r0, r4
  41510a:	b292      	uxth	r2, r2
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  41510c:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  41510e:	47a8      	blx	r5
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  415110:	f8bd 2012 	ldrh.w	r2, [sp, #18]
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  415114:	2302      	movs	r3, #2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  415116:	a905      	add	r1, sp, #20
  415118:	b292      	uxth	r2, r2
  41511a:	4620      	mov	r0, r4
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  41511c:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  41511e:	47a8      	blx	r5
	pwm_sync_unlock_update(PWM0);
  415120:	4620      	mov	r0, r4
  415122:	4b07      	ldr	r3, [pc, #28]	; (415140 <inverter_out_polar+0x98>)
  415124:	4798      	blx	r3
}
  415126:	b014      	add	sp, #80	; 0x50
  415128:	bd70      	pop	{r4, r5, r6, pc}
  41512a:	bf00      	nop
  41512c:	20400b74 	.word	0x20400b74
  415130:	0041905d 	.word	0x0041905d
  415134:	40020000 	.word	0x40020000
  415138:	00415e0d 	.word	0x00415e0d
  41513c:	0041208d 	.word	0x0041208d
  415140:	00412255 	.word	0x00412255

00415144 <inverter_out_0>:
{
  415144:	b5f0      	push	{r4, r5, r6, r7, lr}
  415146:	b091      	sub	sp, #68	; 0x44
	pwm_channel_instance.ul_period = 0xfff;
  415148:	f640 76ff 	movw	r6, #4095	; 0xfff
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  41514c:	4d0d      	ldr	r5, [pc, #52]	; (415184 <inverter_out_0+0x40>)
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  41514e:	2300      	movs	r3, #0
  415150:	ac10      	add	r4, sp, #64	; 0x40
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  415152:	4f0d      	ldr	r7, [pc, #52]	; (415188 <inverter_out_0+0x44>)
  415154:	4632      	mov	r2, r6
  415156:	4628      	mov	r0, r5
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  415158:	f844 3d3c 	str.w	r3, [r4, #-60]!
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  41515c:	4621      	mov	r1, r4
	pwm_channel_instance.ul_period = 0xfff;
  41515e:	9605      	str	r6, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  415160:	47b8      	blx	r7
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  415162:	2301      	movs	r3, #1
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  415164:	4621      	mov	r1, r4
  415166:	4632      	mov	r2, r6
  415168:	4628      	mov	r0, r5
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  41516a:	9301      	str	r3, [sp, #4]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  41516c:	47b8      	blx	r7
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  41516e:	2302      	movs	r3, #2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  415170:	4621      	mov	r1, r4
  415172:	4632      	mov	r2, r6
  415174:	4628      	mov	r0, r5
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  415176:	9301      	str	r3, [sp, #4]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  415178:	47b8      	blx	r7
	pwm_sync_unlock_update(PWM0);
  41517a:	4628      	mov	r0, r5
  41517c:	4b03      	ldr	r3, [pc, #12]	; (41518c <inverter_out_0+0x48>)
  41517e:	4798      	blx	r3
}
  415180:	b011      	add	sp, #68	; 0x44
  415182:	bdf0      	pop	{r4, r5, r6, r7, pc}
  415184:	40020000 	.word	0x40020000
  415188:	0041208d 	.word	0x0041208d
  41518c:	00412255 	.word	0x00412255

00415190 <inverter_out_rect>:
	alfa = fixedpt_div (alfa, dc_bus_v_f_reading);
  415190:	4a22      	ldr	r2, [pc, #136]	; (41521c <inverter_out_rect+0x8c>)
{
  415192:	4603      	mov	r3, r0
  415194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  415198:	17c5      	asrs	r5, r0, #31
  41519a:	6814      	ldr	r4, [r2, #0]
  41519c:	460e      	mov	r6, r1
  41519e:	b094      	sub	sp, #80	; 0x50
  4151a0:	03e9      	lsls	r1, r5, #15
  4151a2:	4f1f      	ldr	r7, [pc, #124]	; (415220 <inverter_out_rect+0x90>)
  4151a4:	17e5      	asrs	r5, r4, #31
  4151a6:	4622      	mov	r2, r4
  4151a8:	ea41 4153 	orr.w	r1, r1, r3, lsr #17
  4151ac:	03c0      	lsls	r0, r0, #15
  4151ae:	462b      	mov	r3, r5
  4151b0:	47b8      	blx	r7
  4151b2:	4680      	mov	r8, r0
  4151b4:	17f1      	asrs	r1, r6, #31
  4151b6:	4622      	mov	r2, r4
  4151b8:	462b      	mov	r3, r5
  4151ba:	03f0      	lsls	r0, r6, #15
  4151bc:	03c9      	lsls	r1, r1, #15
	svm_rectangular_to_ABC(&pwm_a, &pwm_b, &pwm_c, alfa, beta);
  4151be:	4c19      	ldr	r4, [pc, #100]	; (415224 <inverter_out_rect+0x94>)
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  4151c0:	4d19      	ldr	r5, [pc, #100]	; (415228 <inverter_out_rect+0x98>)
  4151c2:	ea41 4156 	orr.w	r1, r1, r6, lsr #17
	pwm_channel_instance.ul_period = 0xfff;
  4151c6:	f640 76ff 	movw	r6, #4095	; 0xfff
  4151ca:	47b8      	blx	r7
	svm_rectangular_to_ABC(&pwm_a, &pwm_b, &pwm_c, alfa, beta);
  4151cc:	4643      	mov	r3, r8
  4151ce:	9000      	str	r0, [sp, #0]
  4151d0:	f10d 0212 	add.w	r2, sp, #18
  4151d4:	a904      	add	r1, sp, #16
  4151d6:	f10d 000e 	add.w	r0, sp, #14
  4151da:	47a0      	blx	r4
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  4151dc:	4c13      	ldr	r4, [pc, #76]	; (41522c <inverter_out_rect+0x9c>)
  4151de:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  4151e2:	2301      	movs	r3, #1
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  4151e4:	a905      	add	r1, sp, #20
  4151e6:	4620      	mov	r0, r4
  4151e8:	b292      	uxth	r2, r2
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  4151ea:	9305      	str	r3, [sp, #20]
	pwm_channel_instance.ul_period = 0xfff;
  4151ec:	9609      	str	r6, [sp, #36]	; 0x24
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_b);
  4151ee:	47a8      	blx	r5
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  4151f0:	f8bd 2012 	ldrh.w	r2, [sp, #18]
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  4151f4:	2302      	movs	r3, #2
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  4151f6:	a905      	add	r1, sp, #20
  4151f8:	4620      	mov	r0, r4
  4151fa:	b292      	uxth	r2, r2
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  4151fc:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_c);
  4151fe:	47a8      	blx	r5
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  415200:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  415204:	2300      	movs	r3, #0
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  415206:	a905      	add	r1, sp, #20
  415208:	b292      	uxth	r2, r2
  41520a:	4620      	mov	r0, r4
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  41520c:	9305      	str	r3, [sp, #20]
	pwm_channel_update_duty(PWM0, &pwm_channel_instance, pwm_a);
  41520e:	47a8      	blx	r5
	pwm_sync_unlock_update(PWM0);
  415210:	4620      	mov	r0, r4
  415212:	4b07      	ldr	r3, [pc, #28]	; (415230 <inverter_out_rect+0xa0>)
  415214:	4798      	blx	r3
}
  415216:	b014      	add	sp, #80	; 0x50
  415218:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41521c:	20400b74 	.word	0x20400b74
  415220:	0041905d 	.word	0x0041905d
  415224:	00415c49 	.word	0x00415c49
  415228:	0041208d 	.word	0x0041208d
  41522c:	40020000 	.word	0x40020000
  415230:	00412255 	.word	0x00412255

00415234 <inverter_set_override>:
{
  415234:	b5f0      	push	{r4, r5, r6, r7, lr}
	pwm_output_instance.override_level_pwmh = LOW;
  415236:	2400      	movs	r4, #0
{
  415238:	b091      	sub	sp, #68	; 0x44
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  41523a:	4f18      	ldr	r7, [pc, #96]	; (41529c <inverter_set_override+0x68>)
	pwm_output_instance.b_override_pwmh = true;
  41523c:	2501      	movs	r5, #1
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  41523e:	4e18      	ldr	r6, [pc, #96]	; (4152a0 <inverter_set_override+0x6c>)
  415240:	4623      	mov	r3, r4
  415242:	466a      	mov	r2, sp
  415244:	a901      	add	r1, sp, #4
  415246:	4638      	mov	r0, r7
	pwm_output_instance.override_level_pwmh = LOW;
  415248:	f88d 4002 	strb.w	r4, [sp, #2]
	pwm_output_instance.override_level_pwml = LOW;
  41524c:	f88d 4003 	strb.w	r4, [sp, #3]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  415250:	9401      	str	r4, [sp, #4]
	pwm_output_instance.b_override_pwmh = true;
  415252:	f88d 5000 	strb.w	r5, [sp]
	pwm_output_instance.b_override_pwml = true;
  415256:	f88d 5001 	strb.w	r5, [sp, #1]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  41525a:	47b0      	blx	r6
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  41525c:	4623      	mov	r3, r4
  41525e:	466a      	mov	r2, sp
  415260:	a901      	add	r1, sp, #4
  415262:	4638      	mov	r0, r7
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  415264:	9501      	str	r5, [sp, #4]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  415266:	47b0      	blx	r6
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  415268:	f04f 0e02 	mov.w	lr, #2
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);	
  41526c:	4623      	mov	r3, r4
  41526e:	466a      	mov	r2, sp
  415270:	a901      	add	r1, sp, #4
  415272:	4638      	mov	r0, r7
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  415274:	f8cd e004 	str.w	lr, [sp, #4]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);	
  415278:	47b0      	blx	r6
	pwm_channel_instance.channel = PWM_CHANNEL_3;
  41527a:	f04f 0e03 	mov.w	lr, #3
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  41527e:	4623      	mov	r3, r4
  415280:	466a      	mov	r2, sp
  415282:	a901      	add	r1, sp, #4
  415284:	4638      	mov	r0, r7
	pwm_channel_instance.channel = PWM_CHANNEL_3;
  415286:	f8cd e004 	str.w	lr, [sp, #4]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  41528a:	47b0      	blx	r6
	start_avg = 1; //start avarraging the offset current
  41528c:	4a05      	ldr	r2, [pc, #20]	; (4152a4 <inverter_set_override+0x70>)
	SC_LEVEL_LOW;
  41528e:	2110      	movs	r1, #16
  415290:	4805      	ldr	r0, [pc, #20]	; (4152a8 <inverter_set_override+0x74>)
  415292:	4b06      	ldr	r3, [pc, #24]	; (4152ac <inverter_set_override+0x78>)
	start_avg = 1; //start avarraging the offset current
  415294:	7015      	strb	r5, [r2, #0]
	SC_LEVEL_LOW;
  415296:	4798      	blx	r3
}
  415298:	b011      	add	sp, #68	; 0x44
  41529a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41529c:	40020000 	.word	0x40020000
  4152a0:	004120d1 	.word	0x004120d1
  4152a4:	204003bc 	.word	0x204003bc
  4152a8:	400e1600 	.word	0x400e1600
  4152ac:	0041743d 	.word	0x0041743d

004152b0 <inverter_clear_override>:
{
  4152b0:	b5f0      	push	{r4, r5, r6, r7, lr}
	start_avg = 0; //stop avarraging the offset current
  4152b2:	2400      	movs	r4, #0
  4152b4:	4f14      	ldr	r7, [pc, #80]	; (415308 <inverter_clear_override+0x58>)
{
  4152b6:	b091      	sub	sp, #68	; 0x44
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152b8:	4e14      	ldr	r6, [pc, #80]	; (41530c <inverter_clear_override+0x5c>)
	start_avg = 0; //stop avarraging the offset current
  4152ba:	703c      	strb	r4, [r7, #0]
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  4152bc:	2701      	movs	r7, #1
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152be:	4d14      	ldr	r5, [pc, #80]	; (415310 <inverter_clear_override+0x60>)
  4152c0:	4623      	mov	r3, r4
  4152c2:	466a      	mov	r2, sp
  4152c4:	a901      	add	r1, sp, #4
  4152c6:	4630      	mov	r0, r6
	pwm_output_instance.b_override_pwmh = false;
  4152c8:	f88d 4000 	strb.w	r4, [sp]
	pwm_output_instance.b_override_pwml = false;
  4152cc:	f88d 4001 	strb.w	r4, [sp, #1]
	pwm_output_instance.override_level_pwmh = LOW;
  4152d0:	f88d 4002 	strb.w	r4, [sp, #2]
	pwm_output_instance.override_level_pwml = LOW;
  4152d4:	f88d 4003 	strb.w	r4, [sp, #3]
	pwm_channel_instance.channel = PWM_CHANNEL_0;
  4152d8:	9401      	str	r4, [sp, #4]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152da:	47a8      	blx	r5
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152dc:	4623      	mov	r3, r4
  4152de:	466a      	mov	r2, sp
  4152e0:	a901      	add	r1, sp, #4
  4152e2:	4630      	mov	r0, r6
	pwm_channel_instance.channel = PWM_CHANNEL_1;
  4152e4:	9701      	str	r7, [sp, #4]
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  4152e6:	2702      	movs	r7, #2
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152e8:	47a8      	blx	r5
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152ea:	4623      	mov	r3, r4
  4152ec:	466a      	mov	r2, sp
  4152ee:	a901      	add	r1, sp, #4
  4152f0:	4630      	mov	r0, r6
	pwm_channel_instance.channel = PWM_CHANNEL_2;
  4152f2:	9701      	str	r7, [sp, #4]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152f4:	47a8      	blx	r5
	pwm_channel_instance.channel = PWM_CHANNEL_3;
  4152f6:	2703      	movs	r7, #3
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  4152f8:	4623      	mov	r3, r4
  4152fa:	466a      	mov	r2, sp
  4152fc:	a901      	add	r1, sp, #4
  4152fe:	4630      	mov	r0, r6
	pwm_channel_instance.channel = PWM_CHANNEL_3;
  415300:	9701      	str	r7, [sp, #4]
	pwm_channel_update_output(PWM0, &pwm_channel_instance, &pwm_output_instance, false);
  415302:	47a8      	blx	r5
}
  415304:	b011      	add	sp, #68	; 0x44
  415306:	bdf0      	pop	{r4, r5, r6, r7, pc}
  415308:	204003bc 	.word	0x204003bc
  41530c:	40020000 	.word	0x40020000
  415310:	004120d1 	.word	0x004120d1

00415314 <inverter_brake_chopper_handler>:
	if ((dc_bus_voltage >= BRAKE_TON_VOLTAGE))
  415314:	4a21      	ldr	r2, [pc, #132]	; (41539c <inverter_brake_chopper_handler+0x88>)
  415316:	4b22      	ldr	r3, [pc, #136]	; (4153a0 <inverter_brake_chopper_handler+0x8c>)
{
  415318:	b5f0      	push	{r4, r5, r6, r7, lr}
	if ((dc_bus_voltage >= BRAKE_TON_VOLTAGE))
  41531a:	6810      	ldr	r0, [r2, #0]
{
  41531c:	b091      	sub	sp, #68	; 0x44
	if ((dc_bus_voltage >= BRAKE_TON_VOLTAGE))
  41531e:	4298      	cmp	r0, r3
  415320:	dd26      	ble.n	415370 <inverter_brake_chopper_handler+0x5c>
		inverter_braking_state = 1;
  415322:	4b20      	ldr	r3, [pc, #128]	; (4153a4 <inverter_brake_chopper_handler+0x90>)
  415324:	2201      	movs	r2, #1
  415326:	701a      	strb	r2, [r3, #0]
	D = dc_bus_voltage - BRAKE_TOFF_VOLTAGE;
  415328:	491f      	ldr	r1, [pc, #124]	; (4153a8 <inverter_brake_chopper_handler+0x94>)
  41532a:	f44f 1270 	mov.w	r2, #3932160	; 0x3c0000
  41532e:	2300      	movs	r3, #0
  415330:	4c1e      	ldr	r4, [pc, #120]	; (4153ac <inverter_brake_chopper_handler+0x98>)
  415332:	4401      	add	r1, r0
  415334:	17cf      	asrs	r7, r1, #31
  415336:	03c8      	lsls	r0, r1, #15
  415338:	03fd      	lsls	r5, r7, #15
  41533a:	ea45 4151 	orr.w	r1, r5, r1, lsr #17
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  41533e:	4d1c      	ldr	r5, [pc, #112]	; (4153b0 <inverter_brake_chopper_handler+0x9c>)
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  415340:	47a0      	blx	r4
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415342:	f247 3433 	movw	r4, #29491	; 0x7333
		pwm_channel_instance.channel = PWM_CHANNEL_3;
  415346:	a910      	add	r1, sp, #64	; 0x40
  415348:	2203      	movs	r2, #3
  41534a:	4284      	cmp	r4, r0
		pwm_channel_instance.ul_period = 0xfff;
  41534c:	f640 73ff 	movw	r3, #4095	; 0xfff
		pwm_channel_instance.channel = PWM_CHANNEL_3;
  415350:	f841 2d3c 	str.w	r2, [r1, #-60]!
  415354:	bfa8      	it	ge
  415356:	4604      	movge	r4, r0
		pwm_channel_instance.ul_period = 0xfff;
  415358:	9305      	str	r3, [sp, #20]
		pwm_channel_update_duty(PWM0, &pwm_channel_instance, b_duty);
  41535a:	4b16      	ldr	r3, [pc, #88]	; (4153b4 <inverter_brake_chopper_handler+0xa0>)
  41535c:	fb84 4505 	smull	r4, r5, r4, r5
  415360:	4815      	ldr	r0, [pc, #84]	; (4153b8 <inverter_brake_chopper_handler+0xa4>)
  415362:	0be2      	lsrs	r2, r4, #15
  415364:	ea42 4245 	orr.w	r2, r2, r5, lsl #17
  415368:	13d2      	asrs	r2, r2, #15
  41536a:	4798      	blx	r3
}
  41536c:	b011      	add	sp, #68	; 0x44
  41536e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if((dc_bus_voltage < BRAKE_TOFF_VOLTAGE) || (inverter_braking_state == 0))
  415370:	4b12      	ldr	r3, [pc, #72]	; (4153bc <inverter_brake_chopper_handler+0xa8>)
  415372:	4c0c      	ldr	r4, [pc, #48]	; (4153a4 <inverter_brake_chopper_handler+0x90>)
  415374:	4298      	cmp	r0, r3
  415376:	dd02      	ble.n	41537e <inverter_brake_chopper_handler+0x6a>
  415378:	7823      	ldrb	r3, [r4, #0]
  41537a:	2b00      	cmp	r3, #0
  41537c:	d1d4      	bne.n	415328 <inverter_brake_chopper_handler+0x14>
		pwm_channel_instance.channel = PWM_CHANNEL_3;
  41537e:	a910      	add	r1, sp, #64	; 0x40
  415380:	2303      	movs	r3, #3
		pwm_channel_instance.ul_period = 0xfff;
  415382:	f640 75ff 	movw	r5, #4095	; 0xfff
		pwm_channel_update_duty(PWM0, &pwm_channel_instance, b_duty);
  415386:	2200      	movs	r2, #0
		pwm_channel_instance.channel = PWM_CHANNEL_3;
  415388:	f841 3d3c 	str.w	r3, [r1, #-60]!
		pwm_channel_update_duty(PWM0, &pwm_channel_instance, b_duty);
  41538c:	480a      	ldr	r0, [pc, #40]	; (4153b8 <inverter_brake_chopper_handler+0xa4>)
  41538e:	4b09      	ldr	r3, [pc, #36]	; (4153b4 <inverter_brake_chopper_handler+0xa0>)
		pwm_channel_instance.ul_period = 0xfff;
  415390:	9505      	str	r5, [sp, #20]
		pwm_channel_update_duty(PWM0, &pwm_channel_instance, b_duty);
  415392:	4798      	blx	r3
		inverter_braking_state = 0;
  415394:	2300      	movs	r3, #0
  415396:	7023      	strb	r3, [r4, #0]
}
  415398:	b011      	add	sp, #68	; 0x44
  41539a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41539c:	20400b74 	.word	0x20400b74
  4153a0:	0144ffff 	.word	0x0144ffff
  4153a4:	20400b90 	.word	0x20400b90
  4153a8:	fecf0000 	.word	0xfecf0000
  4153ac:	0041905d 	.word	0x0041905d
  4153b0:	07ff8000 	.word	0x07ff8000
  4153b4:	0041208d 	.word	0x0041208d
  4153b8:	40020000 	.word	0x40020000
  4153bc:	0130ffff 	.word	0x0130ffff

004153c0 <inverter_get_creadings>:
	*ria = i_readout[0];
  4153c0:	4b05      	ldr	r3, [pc, #20]	; (4153d8 <inverter_get_creadings+0x18>)
{
  4153c2:	b410      	push	{r4}
	*ria = i_readout[0];
  4153c4:	681c      	ldr	r4, [r3, #0]
  4153c6:	6004      	str	r4, [r0, #0]
	*rib = i_readout[1];
  4153c8:	6858      	ldr	r0, [r3, #4]
}
  4153ca:	f85d 4b04 	ldr.w	r4, [sp], #4
	*rib = i_readout[1];
  4153ce:	6008      	str	r0, [r1, #0]
	*ric = i_readout[2];
  4153d0:	689b      	ldr	r3, [r3, #8]
  4153d2:	6013      	str	r3, [r2, #0]
}
  4153d4:	4770      	bx	lr
  4153d6:	bf00      	nop
  4153d8:	20400b84 	.word	0x20400b84

004153dc <inverter_set_dead_comp>:
	inverter_dead_comp = 1;//val;
  4153dc:	4b01      	ldr	r3, [pc, #4]	; (4153e4 <inverter_set_dead_comp+0x8>)
  4153de:	2201      	movs	r2, #1
  4153e0:	601a      	str	r2, [r3, #0]
  4153e2:	4770      	bx	lr
  4153e4:	204003b8 	.word	0x204003b8

004153e8 <inverter_get_current_sign>:
	if(inverter_dead_comp == 0) return 0;
  4153e8:	4b11      	ldr	r3, [pc, #68]	; (415430 <inverter_get_current_sign+0x48>)
  4153ea:	681b      	ldr	r3, [r3, #0]
  4153ec:	b1f3      	cbz	r3, 41542c <inverter_get_current_sign+0x44>
	if (axis < 3)
  4153ee:	2802      	cmp	r0, #2
		if (i_readout[axis] >= 0)
  4153f0:	4b10      	ldr	r3, [pc, #64]	; (415434 <inverter_get_current_sign+0x4c>)
	if (axis < 3)
  4153f2:	d80c      	bhi.n	41540e <inverter_get_current_sign+0x26>
		if (i_readout[axis] >= 0)
  4153f4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  4153f8:	edd0 7a00 	vldr	s15, [r0]
			return -1;
  4153fc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  415400:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  415404:	bfac      	ite	ge
  415406:	2001      	movge	r0, #1
  415408:	f04f 30ff 	movlt.w	r0, #4294967295
  41540c:	4770      	bx	lr
		if ((-i_readout[0] - i_readout[1]) >= 0)
  41540e:	edd3 7a00 	vldr	s15, [r3]
  415412:	ed93 7a01 	vldr	s14, [r3, #4]
  415416:	ee77 7a87 	vadd.f32	s15, s15, s14
			return -1;
  41541a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  41541e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  415422:	bf94      	ite	ls
  415424:	2001      	movls	r0, #1
  415426:	f04f 30ff 	movhi.w	r0, #4294967295
  41542a:	4770      	bx	lr
	if(inverter_dead_comp == 0) return 0;
  41542c:	4618      	mov	r0, r3
}
  41542e:	4770      	bx	lr
  415430:	204003b8 	.word	0x204003b8
  415434:	20400b84 	.word	0x20400b84

00415438 <inverter_fan_timer_init>:
}
uint8_t fan_timer_val = 1;
void inverter_fan_timer_init(void)
{
  415438:	b510      	push	{r4, lr}
	fan_timer_indx = sph_timer_add(&fan_timer_val, 60000, &fan_timer_ton, &fan_timer_toff);
  41543a:	4b05      	ldr	r3, [pc, #20]	; (415450 <inverter_fan_timer_init+0x18>)
  41543c:	f64e 2160 	movw	r1, #60000	; 0xea60
  415440:	4a04      	ldr	r2, [pc, #16]	; (415454 <inverter_fan_timer_init+0x1c>)
  415442:	4805      	ldr	r0, [pc, #20]	; (415458 <inverter_fan_timer_init+0x20>)
  415444:	4c05      	ldr	r4, [pc, #20]	; (41545c <inverter_fan_timer_init+0x24>)
  415446:	47a0      	blx	r4
  415448:	4b05      	ldr	r3, [pc, #20]	; (415460 <inverter_fan_timer_init+0x28>)
  41544a:	6018      	str	r0, [r3, #0]
  41544c:	bd10      	pop	{r4, pc}
  41544e:	bf00      	nop
  415450:	00414b01 	.word	0x00414b01
  415454:	00414b15 	.word	0x00414b15
  415458:	204003a8 	.word	0x204003a8
  41545c:	0040d05d 	.word	0x0040d05d
  415460:	20406d14 	.word	0x20406d14

00415464 <inverter_fan_timer_reset>:
}
void inverter_fan_timer_reset(void)
{
	sph_timer_reset(fan_timer_indx);
  415464:	4a01      	ldr	r2, [pc, #4]	; (41546c <inverter_fan_timer_reset+0x8>)
  415466:	4b02      	ldr	r3, [pc, #8]	; (415470 <inverter_fan_timer_reset+0xc>)
  415468:	6810      	ldr	r0, [r2, #0]
  41546a:	4718      	bx	r3
  41546c:	20406d14 	.word	0x20406d14
  415470:	0040d099 	.word	0x0040d099

00415474 <fan_temp_control>:
}
void fan_temp_control(void)
{
	if (IGBT_temp >= FAN_ON_TEMP)
  415474:	4b08      	ldr	r3, [pc, #32]	; (415498 <fan_temp_control+0x24>)
  415476:	681b      	ldr	r3, [r3, #0]
  415478:	f5b3 1fdc 	cmp.w	r3, #1802240	; 0x1b8000
  41547c:	da08      	bge.n	415490 <fan_temp_control+0x1c>
	{
		//Fan_On;
		inverter_fan_timer_reset();
	}
	else if(IGBT_temp <= FAN_OFF_TEMP)
  41547e:	f5b3 2f70 	cmp.w	r3, #983040	; 0xf0000
  415482:	dd00      	ble.n	415486 <fan_temp_control+0x12>
  415484:	4770      	bx	lr
	{
		Fan_Off;
  415486:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  41548a:	4804      	ldr	r0, [pc, #16]	; (41549c <fan_temp_control+0x28>)
  41548c:	4b04      	ldr	r3, [pc, #16]	; (4154a0 <fan_temp_control+0x2c>)
  41548e:	4718      	bx	r3
	sph_timer_reset(fan_timer_indx);
  415490:	4a04      	ldr	r2, [pc, #16]	; (4154a4 <fan_temp_control+0x30>)
  415492:	4b05      	ldr	r3, [pc, #20]	; (4154a8 <fan_temp_control+0x34>)
  415494:	6810      	ldr	r0, [r2, #0]
  415496:	4718      	bx	r3
  415498:	204003a4 	.word	0x204003a4
  41549c:	400e1400 	.word	0x400e1400
  4154a0:	00417441 	.word	0x00417441
  4154a4:	20406d14 	.word	0x20406d14
  4154a8:	0040d099 	.word	0x0040d099

004154ac <IGBT_temp_handler>:
	}
}
void IGBT_temp_handler(void)
{
	fixedpt NTC_temp = fixedpt_mul( NTC_readout, Cth); // get NTC resistance in ohms
  4154ac:	4a87      	ldr	r2, [pc, #540]	; (4156cc <IGBT_temp_handler+0x220>)
  4154ae:	f640 73c9 	movw	r3, #4041	; 0xfc9
  4154b2:	4987      	ldr	r1, [pc, #540]	; (4156d0 <IGBT_temp_handler+0x224>)
{
  4154b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4154b8:	6812      	ldr	r2, [r2, #0]
  4154ba:	b085      	sub	sp, #20
  4154bc:	fb82 2303 	smull	r2, r3, r2, r3
  4154c0:	0bd2      	lsrs	r2, r2, #15
  4154c2:	13d8      	asrs	r0, r3, #15
  4154c4:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  4154c8:	fba2 2301 	umull	r2, r3, r2, r1
  4154cc:	fb01 3300 	mla	r3, r1, r0, r3
  4154d0:	0bd2      	lsrs	r2, r2, #15
  4154d2:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
		fixedpt_rconst(1.818357216161805012e-01),
		fixedpt_rconst(1.531383769920937332e-01),
		fixedpt_rconst(1.479819860511658591e-01)
	};

	if (x < 0)
  4154d6:	2a00      	cmp	r2, #0
  4154d8:	f2c0 80ec 	blt.w	4156b4 <IGBT_temp_handler+0x208>
		return (0);
	if (x == 0)
  4154dc:	f000 80f0 	beq.w	4156c0 <IGBT_temp_handler+0x214>
		return 0xffffffff;

	log2 = 0;
	xi = x;
	while (xi > FIXEDPT_TWO) {
  4154e0:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
  4154e4:	f340 80ea 	ble.w	4156bc <IGBT_temp_handler+0x210>
  4154e8:	2000      	movs	r0, #0
		xi >>= 1;
  4154ea:	1052      	asrs	r2, r2, #1
		log2++;
  4154ec:	3001      	adds	r0, #1
	while (xi > FIXEDPT_TWO) {
  4154ee:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
  4154f2:	dcfa      	bgt.n	4154ea <IGBT_temp_handler+0x3e>
  4154f4:	03c0      	lsls	r0, r0, #15
  4154f6:	f645 03b9 	movw	r3, #22713	; 0x58b9
  4154fa:	fb80 0103 	smull	r0, r1, r0, r3
  4154fe:	0bc6      	lsrs	r6, r0, #15
  415500:	ea46 4641 	orr.w	r6, r6, r1, lsl #17
	}
	f = xi - FIXEDPT_ONE;
  415504:	f5a2 4a00 	sub.w	sl, r2, #32768	; 0x8000
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  415508:	4b72      	ldr	r3, [pc, #456]	; (4156d4 <IGBT_temp_handler+0x228>)
	s = fixedpt_div(f, FIXEDPT_TWO + f);
  41550a:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  41550e:	4654      	mov	r4, sl
  415510:	461f      	mov	r7, r3
  415512:	9300      	str	r3, [sp, #0]
  415514:	ea4f 30ca 	mov.w	r0, sl, lsl #15
  415518:	17e5      	asrs	r5, r4, #31
  41551a:	17d3      	asrs	r3, r2, #31
  41551c:	03e9      	lsls	r1, r5, #15
  41551e:	ea41 415a 	orr.w	r1, r1, sl, lsr #17
  415522:	47b8      	blx	r7
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415524:	fba0 2300 	umull	r2, r3, r0, r0
  415528:	9103      	str	r1, [sp, #12]
	z = fixedpt_mul(s, s);
	w = fixedpt_mul(z, z);
	R = fixedpt_mul(w, LG[1] + fixedpt_mul(w, LG[3]
	    + fixedpt_mul(w, LG[5]))) + fixedpt_mul(z, LG[0]
	    + fixedpt_mul(w, LG[2] + fixedpt_mul(w, LG[4]
  41552a:	f241 7746 	movw	r7, #5958	; 0x1746
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  41552e:	fb01 f100 	mul.w	r1, r1, r0
  415532:	f241 3e9a 	movw	lr, #5018	; 0x139a
  415536:	9002      	str	r0, [sp, #8]
	    + fixedpt_mul(w, LG[6]))));
	return (fixedpt_mul(LN2, (log2 << FIXEDPT_FBITS)) + f
  415538:	eb0a 0006 	add.w	r0, sl, r6
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  41553c:	eb03 0341 	add.w	r3, r3, r1, lsl #1
	    + fixedpt_mul(w, LG[2] + fixedpt_mul(w, LG[4]
  415540:	f242 4192 	movw	r1, #9362	; 0x2492
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415544:	0bd6      	lsrs	r6, r2, #15
	return (fixedpt_mul(LN2, (log2 << FIXEDPT_FBITS)) + f
  415546:	9001      	str	r0, [sp, #4]
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415548:	13d8      	asrs	r0, r3, #15
  41554a:	ea46 4643 	orr.w	r6, r6, r3, lsl #17
  41554e:	fb06 fc00 	mul.w	ip, r6, r0
  415552:	fba6 2306 	umull	r2, r3, r6, r6
  415556:	eb03 034c 	add.w	r3, r3, ip, lsl #1
  41555a:	0bd4      	lsrs	r4, r2, #15
  41555c:	13dd      	asrs	r5, r3, #15
  41555e:	ea44 4443 	orr.w	r4, r4, r3, lsl #17
  415562:	ea4f 0c85 	mov.w	ip, r5, lsl #2
  415566:	00a2      	lsls	r2, r4, #2
  415568:	ea4c 7394 	orr.w	r3, ip, r4, lsr #30
  41556c:	1912      	adds	r2, r2, r4
  41556e:	416b      	adcs	r3, r5
  415570:	ea4f 0882 	mov.w	r8, r2, lsl #2
  415574:	ea4f 0c83 	mov.w	ip, r3, lsl #2
  415578:	ea4c 7c92 	orr.w	ip, ip, r2, lsr #30
  41557c:	ebb8 0204 	subs.w	r2, r8, r4
  415580:	eb6c 0305 	sbc.w	r3, ip, r5
  415584:	ea4f 1802 	mov.w	r8, r2, lsl #4
  415588:	ea4f 1c03 	mov.w	ip, r3, lsl #4
  41558c:	ea4c 7c12 	orr.w	ip, ip, r2, lsr #28
  415590:	ebb8 0204 	subs.w	r2, r8, r4
  415594:	eb6c 0305 	sbc.w	r3, ip, r5
  415598:	ea4f 1802 	mov.w	r8, r2, lsl #4
  41559c:	ea4f 1c03 	mov.w	ip, r3, lsl #4
  4155a0:	ea4c 7c12 	orr.w	ip, ip, r2, lsr #28
  4155a4:	eb18 0204 	adds.w	r2, r8, r4
  4155a8:	fba4 890e 	umull	r8, r9, r4, lr
  4155ac:	eb4c 0305 	adc.w	r3, ip, r5
  4155b0:	0bd2      	lsrs	r2, r2, #15
  4155b2:	fb0e 9905 	mla	r9, lr, r5, r9
  4155b6:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	    + fixedpt_mul(w, LG[2] + fixedpt_mul(w, LG[4]
  4155ba:	4417      	add	r7, r2
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4155bc:	fb07 f205 	mul.w	r2, r7, r5
  4155c0:	17fb      	asrs	r3, r7, #31
  4155c2:	fba7 bc04 	umull	fp, ip, r7, r4
  4155c6:	fb04 2303 	mla	r3, r4, r3, r2
	R = fixedpt_mul(w, LG[1] + fixedpt_mul(w, LG[3]
  4155ca:	f641 4272 	movw	r2, #7282	; 0x1c72
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4155ce:	ea4f 37db 	mov.w	r7, fp, lsr #15
  4155d2:	449c      	add	ip, r3
  4155d4:	ea4f 33d8 	mov.w	r3, r8, lsr #15
  4155d8:	ea47 474c 	orr.w	r7, r7, ip, lsl #17
  4155dc:	ea43 4349 	orr.w	r3, r3, r9, lsl #17
	    + fixedpt_mul(w, LG[2] + fixedpt_mul(w, LG[4]
  4155e0:	4439      	add	r1, r7
	    + fixedpt_mul(w, LG[5]))) + fixedpt_mul(z, LG[0]
  4155e2:	f245 5755 	movw	r7, #21845	; 0x5555
	R = fixedpt_mul(w, LG[1] + fixedpt_mul(w, LG[3]
  4155e6:	441a      	add	r2, r3
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  4155e8:	ea4f 79e1 	mov.w	r9, r1, asr #31
  4155ec:	fb01 fe05 	mul.w	lr, r1, r5
  4155f0:	fb02 f305 	mul.w	r3, r2, r5
  4155f4:	ea4f 7ce2 	mov.w	ip, r2, asr #31
  4155f8:	fb04 ee09 	mla	lr, r4, r9, lr
  4155fc:	fba1 8904 	umull	r8, r9, r1, r4
  415600:	fb04 310c 	mla	r1, r4, ip, r3
  415604:	44f1      	add	r9, lr
  415606:	fba2 2304 	umull	r2, r3, r2, r4
  41560a:	ea4f 3ed8 	mov.w	lr, r8, lsr #15
  41560e:	440b      	add	r3, r1
  415610:	0bd2      	lsrs	r2, r2, #15
  415612:	ea4e 4e49 	orr.w	lr, lr, r9, lsl #17
	R = fixedpt_mul(w, LG[1] + fixedpt_mul(w, LG[3]
  415616:	f243 3133 	movw	r1, #13107	; 0x3333
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  41561a:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	    + fixedpt_mul(w, LG[5]))) + fixedpt_mul(z, LG[0]
  41561e:	4477      	add	r7, lr
	R = fixedpt_mul(w, LG[1] + fixedpt_mul(w, LG[3]
  415620:	4411      	add	r1, r2
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415622:	fb07 fe00 	mul.w	lr, r7, r0
  415626:	ea4f 79e7 	mov.w	r9, r7, asr #31
  41562a:	fba7 2306 	umull	r2, r3, r7, r6
  41562e:	fb01 f505 	mul.w	r5, r1, r5
  415632:	fb06 e609 	mla	r6, r6, r9, lr
  415636:	ea4f 79e1 	mov.w	r9, r1, asr #31
  41563a:	0bd2      	lsrs	r2, r2, #15
  41563c:	4433      	add	r3, r6
  41563e:	fba1 6704 	umull	r6, r7, r1, r4
  415642:	fb04 5409 	mla	r4, r4, r9, r5
  415646:	9903      	ldr	r1, [sp, #12]
  415648:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  41564c:	4427      	add	r7, r4
  41564e:	0bf3      	lsrs	r3, r6, #15
  415650:	9c02      	ldr	r4, [sp, #8]
  415652:	ea43 4347 	orr.w	r3, r3, r7, lsl #17
	R = fixedpt_mul(w, LG[1] + fixedpt_mul(w, LG[3]
  415656:	441a      	add	r2, r3
	    - fixedpt_mul(s, f - R));
  415658:	ebaa 0a02 	sub.w	sl, sl, r2
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  41565c:	4652      	mov	r2, sl
  41565e:	fb0a f101 	mul.w	r1, sl, r1
  415662:	fbaa ab04 	umull	sl, fp, sl, r4
  415666:	17d3      	asrs	r3, r2, #31
  415668:	ea4f 36da 	mov.w	r6, sl, lsr #15
  41566c:	fb04 1003 	mla	r0, r4, r3, r1
  415670:	4483      	add	fp, r0
	    - fixedpt_mul(s, f - R));
  415672:	9801      	ldr	r0, [sp, #4]
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415674:	ea46 464b 	orr.w	r6, r6, fp, lsl #17
	    - fixedpt_mul(s, f - R));
  415678:	1b86      	subs	r6, r0, r6
	
	//NTC_temp = NTC_TEST_R;
	NTC_temp = fixedpt_mul(NTC_R_INF_INV, NTC_temp);
	NTC_temp = fixedpt_ln( NTC_temp ) + fixedpt_ln( NTC_MULTIPLIER ); // multiply for precision keeping
  41567a:	4a17      	ldr	r2, [pc, #92]	; (4156d8 <IGBT_temp_handler+0x22c>)
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  41567c:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000
  415680:	9d00      	ldr	r5, [sp, #0]
  415682:	f240 314b 	movw	r1, #843	; 0x34b
  415686:	4432      	add	r2, r6
	NTC_temp = fixedpt_div(NTC_BETA, NTC_temp) - NTC_KELVIN_TO_C;
	IGBT_temp = NTC_temp;
  415688:	4c14      	ldr	r4, [pc, #80]	; (4156dc <IGBT_temp_handler+0x230>)
  41568a:	17d3      	asrs	r3, r2, #31
  41568c:	47a8      	blx	r5
	NTC_temp = fixedpt_div(NTC_BETA, NTC_temp) - NTC_KELVIN_TO_C;
  41568e:	4b14      	ldr	r3, [pc, #80]	; (4156e0 <IGBT_temp_handler+0x234>)
	
	fan_temp_control();
  415690:	4a14      	ldr	r2, [pc, #80]	; (4156e4 <IGBT_temp_handler+0x238>)
	NTC_temp = fixedpt_div(NTC_BETA, NTC_temp) - NTC_KELVIN_TO_C;
  415692:	4403      	add	r3, r0
	IGBT_temp = NTC_temp;
  415694:	6023      	str	r3, [r4, #0]
	fan_temp_control();
  415696:	4790      	blx	r2
	if(IGBT_temp >= MAX_OP_TEMP)
  415698:	6823      	ldr	r3, [r4, #0]
  41569a:	f5b3 1f34 	cmp.w	r3, #2949120	; 0x2d0000
  41569e:	da02      	bge.n	4156a6 <IGBT_temp_handler+0x1fa>
		ot_err_set;
	}
	//volatile float testlin = fixedpt_tofloat( NTC_temp);
	//testlin *= 1;

}
  4156a0:	b005      	add	sp, #20
  4156a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		ot_err_set;
  4156a6:	4a10      	ldr	r2, [pc, #64]	; (4156e8 <IGBT_temp_handler+0x23c>)
  4156a8:	4b10      	ldr	r3, [pc, #64]	; (4156ec <IGBT_temp_handler+0x240>)
  4156aa:	7810      	ldrb	r0, [r2, #0]
}
  4156ac:	b005      	add	sp, #20
  4156ae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		ot_err_set;
  4156b2:	4718      	bx	r3
  4156b4:	4b07      	ldr	r3, [pc, #28]	; (4156d4 <IGBT_temp_handler+0x228>)
		return (0);
  4156b6:	2600      	movs	r6, #0
  4156b8:	9300      	str	r3, [sp, #0]
  4156ba:	e7de      	b.n	41567a <IGBT_temp_handler+0x1ce>
	while (xi > FIXEDPT_TWO) {
  4156bc:	2600      	movs	r6, #0
  4156be:	e721      	b.n	415504 <IGBT_temp_handler+0x58>
  4156c0:	4b04      	ldr	r3, [pc, #16]	; (4156d4 <IGBT_temp_handler+0x228>)
		return 0xffffffff;
  4156c2:	f04f 36ff 	mov.w	r6, #4294967295
  4156c6:	9300      	str	r3, [sp, #0]
  4156c8:	e7d7      	b.n	41567a <IGBT_temp_handler+0x1ce>
  4156ca:	bf00      	nop
  4156cc:	204003cc 	.word	0x204003cc
  4156d0:	00083e6c 	.word	0x00083e6c
  4156d4:	0041905d 	.word	0x0041905d
  4156d8:	000126bb 	.word	0x000126bb
  4156dc:	204003a4 	.word	0x204003a4
  4156e0:	ff776ccd 	.word	0xff776ccd
  4156e4:	00415475 	.word	0x00415475
  4156e8:	20406ca1 	.word	0x20406ca1
  4156ec:	0041282d 	.word	0x0041282d

004156f0 <iverter_get_igbt_temp>:

fixedpt iverter_get_igbt_temp(void)
{
	return IGBT_temp;
  4156f0:	4b01      	ldr	r3, [pc, #4]	; (4156f8 <iverter_get_igbt_temp+0x8>)
}
  4156f2:	6818      	ldr	r0, [r3, #0]
  4156f4:	4770      	bx	lr
  4156f6:	bf00      	nop
  4156f8:	204003a4 	.word	0x204003a4

004156fc <inverter_set_manual_dcVal>:
fixedpt dc_ers_manual_val = 0;
void inverter_set_manual_dcVal(fixedpt dc_val)
{
	dc_ers_manual_val = fixedpt_abs(dc_val);	
  4156fc:	2800      	cmp	r0, #0
  4156fe:	4b02      	ldr	r3, [pc, #8]	; (415708 <inverter_set_manual_dcVal+0xc>)
  415700:	bfb8      	it	lt
  415702:	4240      	neglt	r0, r0
  415704:	6018      	str	r0, [r3, #0]
  415706:	4770      	bx	lr
  415708:	20400b7c 	.word	0x20400b7c

0041570c <iverter_get_dc_v>:
}

fixedpt iverter_get_dc_v(void)
{
	if(dc_ers_manual_val == 0) return dc_bus_v_f_reading;
  41570c:	4b02      	ldr	r3, [pc, #8]	; (415718 <iverter_get_dc_v+0xc>)
  41570e:	6818      	ldr	r0, [r3, #0]
  415710:	b908      	cbnz	r0, 415716 <iverter_get_dc_v+0xa>
  415712:	4b02      	ldr	r3, [pc, #8]	; (41571c <iverter_get_dc_v+0x10>)
  415714:	6818      	ldr	r0, [r3, #0]
	else return dc_ers_manual_val;
}
  415716:	4770      	bx	lr
  415718:	20400b7c 	.word	0x20400b7c
  41571c:	20400b74 	.word	0x20400b74

00415720 <get_dead_time_interval>:
}

uint32_t dead_time = 150;
uint32_t get_dead_time_interval(void)
{
	return dead_time;
  415720:	4b01      	ldr	r3, [pc, #4]	; (415728 <get_dead_time_interval+0x8>)
}
  415722:	6818      	ldr	r0, [r3, #0]
  415724:	4770      	bx	lr
  415726:	bf00      	nop
  415728:	204003c4 	.word	0x204003c4

0041572c <pwm_interface_init>:
void pwm_interface_init(void)
{
				
		//Config the PWMs
		// Period value of PWM output waveform.
		uint32_t ul_tmp = pwm_inv_freq;
  41572c:	4abd      	ldr	r2, [pc, #756]	; (415a24 <pwm_interface_init+0x2f8>)
		if(ul_tmp >= 9000) ul_tmp = 9000;
  41572e:	f242 3327 	movw	r3, #8999	; 0x2327
{
  415732:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		uint32_t ul_tmp = pwm_inv_freq;
  415736:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  41573a:	f892 20c4 	ldrb.w	r2, [r2, #196]	; 0xc4
{
  41573e:	b09f      	sub	sp, #124	; 0x7c
		uint32_t ul_tmp = pwm_inv_freq;
  415740:	fb05 f502 	mul.w	r5, r5, r2
		if(ul_tmp >= 9000) ul_tmp = 9000;
  415744:	429d      	cmp	r5, r3
  415746:	f300 81a1 	bgt.w	415a8c <pwm_interface_init+0x360>
  41574a:	f641 3358 	movw	r3, #7000	; 0x1b58
  41574e:	429d      	cmp	r5, r3
  415750:	bf28      	it	cs
  415752:	461d      	movcs	r5, r3
  415754:	ebc5 3505 	rsb	r5, r5, r5, lsl #12
  415758:	ea4f 0845 	mov.w	r8, r5, lsl #1
		// Initial deadtimel value.
		#define INIT_DEADTIMEL_VALUE dead_time
		
		pwm_channel_t pwm_channel_instance;
		pwm_fault_t pwm_fault_instance;
		pmc_enable_periph_clk(ID_PWM0);
  41575c:	4bb2      	ldr	r3, [pc, #712]	; (415a28 <pwm_interface_init+0x2fc>)
  41575e:	201f      	movs	r0, #31
  415760:	4798      	blx	r3
		
		pwm_channel_disable(PWM0, PWM_CHANNEL_0);
  415762:	4cb2      	ldr	r4, [pc, #712]	; (415a2c <pwm_interface_init+0x300>)
  415764:	2100      	movs	r1, #0
  415766:	48b2      	ldr	r0, [pc, #712]	; (415a30 <pwm_interface_init+0x304>)
  415768:	47a0      	blx	r4
		pwm_channel_disable(PWM0, PWM_CHANNEL_1);
  41576a:	2101      	movs	r1, #1
  41576c:	48b0      	ldr	r0, [pc, #704]	; (415a30 <pwm_interface_init+0x304>)
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  41576e:	ae0f      	add	r6, sp, #60	; 0x3c
		pwm_channel_disable(PWM0, PWM_CHANNEL_1);
  415770:	47a0      	blx	r4
		pwm_channel_disable(PWM0, PWM_CHANNEL_2);
  415772:	2102      	movs	r1, #2
  415774:	48ae      	ldr	r0, [pc, #696]	; (415a30 <pwm_interface_init+0x304>)
  415776:	47a0      	blx	r4
		pwm_channel_disable(PWM0, PWM_CHANNEL_3);
  415778:	2103      	movs	r1, #3
  41577a:	48ad      	ldr	r0, [pc, #692]	; (415a30 <pwm_interface_init+0x304>)
  41577c:	47a0      	blx	r4
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  41577e:	4cad      	ldr	r4, [pc, #692]	; (415a34 <pwm_interface_init+0x308>)
		
		// Set PWM clock A as PWM_FREQUENCY * PERIOD_VALUE (clock B is not used).
		pwm_clock_t clock_setting = {
  415780:	4fad      	ldr	r7, [pc, #692]	; (415a38 <pwm_interface_init+0x30c>)
  415782:	f8cd 8010 	str.w	r8, [sp, #16]
  415786:	9706      	str	r7, [sp, #24]
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  415788:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  41578a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  41578c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  41578e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  415790:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
		pwm_clock_t clock_setting = {
  415794:	4ba9      	ldr	r3, [pc, #676]	; (415a3c <pwm_interface_init+0x310>)
  415796:	ac0f      	add	r4, sp, #60	; 0x3c
	uint32_t ul_divisors[PWM_CLOCK_PRE_MAX] =
  415798:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  41579c:	a91a      	add	r1, sp, #104	; 0x68
		pwm_clock_t clock_setting = {
  41579e:	9305      	str	r3, [sp, #20]
		ul_div = (ul_mck / ul_divisors[ul_pre]) / ul_frequency;
  4157a0:	f854 2b04 	ldr.w	r2, [r4], #4
  4157a4:	fbb7 f3f2 	udiv	r3, r7, r2
  4157a8:	fbb3 f3f5 	udiv	r3, r3, r5
		if (ul_div <= PWM_CLOCK_DIV_MAX) {
  4157ac:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  4157b0:	f240 8170 	bls.w	415a94 <pwm_interface_init+0x368>
	} while (ul_pre < PWM_CLOCK_PRE_MAX);
  4157b4:	42a1      	cmp	r1, r4
  4157b6:	d1f3      	bne.n	4157a0 <pwm_interface_init+0x74>
			.ul_clkb = 1 * PWM_BRAKE_FREQUENCY * PERIOD_VALUE,
			.ul_mck = sysclk_get_peripheral_hz(),
		};
		pwm_real_inv_freq = sysclk_get_peripheral_hz();
		pwm_real_inv_freq /= PERIOD_VALUE;
		pwm_real_inv_freq /= pwm_clocks_generate(ul_tmp * PERIOD_VALUE, sysclk_get_peripheral_hz());
  4157b8:	4ba1      	ldr	r3, [pc, #644]	; (415a40 <pwm_interface_init+0x314>)
  4157ba:	4aa2      	ldr	r2, [pc, #648]	; (415a44 <pwm_interface_init+0x318>)
  4157bc:	4fa2      	ldr	r7, [pc, #648]	; (415a48 <pwm_interface_init+0x31c>)
  4157be:	601a      	str	r2, [r3, #0]
			 init_f_set;
		}
		if (dead_time < 50)
		{
			dead_time = 150;
			init_f_set;
  4157c0:	49a2      	ldr	r1, [pc, #648]	; (415a4c <pwm_interface_init+0x320>)
			dead_time = 150;
  4157c2:	2296      	movs	r2, #150	; 0x96
			init_f_set;
  4157c4:	4ba2      	ldr	r3, [pc, #648]	; (415a50 <pwm_interface_init+0x324>)
  4157c6:	7808      	ldrb	r0, [r1, #0]
			dead_time = 150;
  4157c8:	603a      	str	r2, [r7, #0]
			init_f_set;
  4157ca:	4798      	blx	r3
		}
		//dead_time = 0xfff/1 -100;
		pwm_init(PWM0, &clock_setting);
  4157cc:	4e98      	ldr	r6, [pc, #608]	; (415a30 <pwm_interface_init+0x304>)
  4157ce:	a904      	add	r1, sp, #16
  4157d0:	4ba0      	ldr	r3, [pc, #640]	; (415a54 <pwm_interface_init+0x328>)
		
		
		// Use PWM clock A as source clock.
		pwm_channel_instance.ul_prescaler = PWM_CMR_CPRE_CLKA;
		// channel output inverted
		pwm_channel_instance.b_pwmh_output_inverted = false;
  4157d2:	2400      	movs	r4, #0
		pwm_init(PWM0, &clock_setting);
  4157d4:	4630      	mov	r0, r6
		pwm_channel_instance.b_pwml_output_inverted = false;
		// enable deadtime generation for half bridge configuration
		pwm_channel_instance.b_deadtime_generator = true;
  4157d6:	2501      	movs	r5, #1
		pwm_init(PWM0, &clock_setting);
  4157d8:	4798      	blx	r3
		// Period value of output waveform.
		pwm_channel_instance.ul_period = PERIOD_VALUE;
		// Duty cycle value of output waveform.
		pwm_channel_instance.ul_duty = INIT_DUTY_VALUE;
		//set deadtime high and low value
		pwm_channel_instance.us_deadtime_pwmh = INIT_DEADTIMEH_VALUE;
  4157da:	883b      	ldrh	r3, [r7, #0]
		pwm_channel_instance.ul_prescaler = PWM_CMR_CPRE_CLKA;
  4157dc:	220b      	movs	r2, #11

		//set fault output state
		pwm_channel_instance.ul_fault_output_pwml = PWM_LOW;
		pwm_channel_instance.ul_fault_output_pwmh = PWM_LOW;
		//set fault Input 1 as external fault trigger
		pwm_channel_instance.fault_id = (1 << 1); //PWM_FAULT_PWMFI1;
  4157de:	f04f 0802 	mov.w	r8, #2
		pwm_channel_instance.counter_event = PWM_EVENT_PERIOD_HALF_END;
  4157e2:	f44f 6a80 	mov.w	sl, #1024	; 0x400
		pwm_channel_instance.alignment = PWM_ALIGN_CENTER;
  4157e6:	f44f 7b80 	mov.w	fp, #256	; 0x100
		pwm_channel_instance.us_deadtime_pwmh = INIT_DEADTIMEH_VALUE;
  4157ea:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
		
		//set channel Sync state
		pwm_channel_instance.b_sync_ch = true;
		
		pwm_channel_instance.channel = PWM_CHANNEL_0;
		pwm_channel_init(PWM0, &pwm_channel_instance);
  4157ee:	a90f      	add	r1, sp, #60	; 0x3c
		pwm_channel_instance.us_deadtime_pwml = INIT_DEADTIMEL_VALUE;
  4157f0:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
		pwm_channel_instance.ul_period = PERIOD_VALUE;
  4157f4:	f640 73ff 	movw	r3, #4095	; 0xfff
		pwm_channel_init(PWM0, &pwm_channel_instance);
  4157f8:	f8df 9278 	ldr.w	r9, [pc, #632]	; 415a74 <pwm_interface_init+0x348>
  4157fc:	4630      	mov	r0, r6
		pwm_channel_instance.ul_prescaler = PWM_CMR_CPRE_CLKA;
  4157fe:	9210      	str	r2, [sp, #64]	; 0x40

		//set fault output state
		pwm_channel_instance.ul_fault_output_pwml = PWM_LOW;
		pwm_channel_instance.ul_fault_output_pwmh = PWM_LOW;
		//set fault Input 2 as external fault trigger
		pwm_channel_instance.fault_id = (1 << 2); //PWM_FAULTI2
  415800:	2704      	movs	r7, #4
		pwm_channel_instance.ul_period = PERIOD_VALUE;
  415802:	9313      	str	r3, [sp, #76]	; 0x4c
		pwm_channel_instance.counter_event = PWM_EVENT_PERIOD_HALF_END;
  415804:	f8ad a050 	strh.w	sl, [sp, #80]	; 0x50
		pwm_channel_instance.b_pwmh_output_inverted = false;
  415808:	f88d 4053 	strb.w	r4, [sp, #83]	; 0x53
		pwm_channel_instance.b_pwml_output_inverted = false;
  41580c:	f88d 4054 	strb.w	r4, [sp, #84]	; 0x54
		pwm_channel_instance.polarity = PWM_LOW;
  415810:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
		pwm_channel_instance.ul_duty = INIT_DUTY_VALUE;
  415814:	9412      	str	r4, [sp, #72]	; 0x48
		pwm_channel_instance.output_selection.override_level_pwmh = PWM_LOW;
  415816:	f88d 405c 	strb.w	r4, [sp, #92]	; 0x5c
		pwm_channel_instance.output_selection.override_level_pwml = PWM_LOW;
  41581a:	f88d 405d 	strb.w	r4, [sp, #93]	; 0x5d
		pwm_channel_instance.ul_fault_output_pwml = PWM_LOW;
  41581e:	f88d 4061 	strb.w	r4, [sp, #97]	; 0x61
		pwm_channel_instance.ul_fault_output_pwmh = PWM_LOW;
  415822:	f88d 4060 	strb.w	r4, [sp, #96]	; 0x60
		pwm_channel_instance.ul_spread = 0; //disable spread spectrum mode
  415826:	9419      	str	r4, [sp, #100]	; 0x64
		pwm_channel_instance.channel = PWM_CHANNEL_0;
  415828:	940f      	str	r4, [sp, #60]	; 0x3c
		pwm_channel_instance.b_deadtime_generator = true;
  41582a:	f88d 5052 	strb.w	r5, [sp, #82]	; 0x52
		pwm_channel_instance.output_selection.b_override_pwml = true;
  41582e:	f88d 505b 	strb.w	r5, [sp, #91]	; 0x5b
		pwm_channel_instance.output_selection.b_override_pwmh = true;
  415832:	f88d 505a 	strb.w	r5, [sp, #90]	; 0x5a
		pwm_channel_instance.b_sync_ch = true;
  415836:	f88d 505e 	strb.w	r5, [sp, #94]	; 0x5e
		pwm_channel_instance.alignment = PWM_ALIGN_CENTER;
  41583a:	f8ad b044 	strh.w	fp, [sp, #68]	; 0x44
		pwm_channel_instance.fault_id = (1 << 1); //PWM_FAULT_PWMFI1;
  41583e:	f88d 805f 	strb.w	r8, [sp, #95]	; 0x5f
		pwm_channel_init(PWM0, &pwm_channel_instance);
  415842:	47c8      	blx	r9
		pwm_channel_init(PWM0, &pwm_channel_instance);
  415844:	a90f      	add	r1, sp, #60	; 0x3c
  415846:	4630      	mov	r0, r6
		pwm_channel_instance.channel = PWM_CHANNEL_1;
  415848:	950f      	str	r5, [sp, #60]	; 0x3c
		pwm_channel_init(PWM0, &pwm_channel_instance);
  41584a:	47c8      	blx	r9
		pwm_channel_init(PWM0, &pwm_channel_instance);
  41584c:	a90f      	add	r1, sp, #60	; 0x3c
  41584e:	4630      	mov	r0, r6
		pwm_channel_instance.channel = PWM_CHANNEL_2;
  415850:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
		pwm_channel_init(PWM0, &pwm_channel_instance);
  415854:	47c8      	blx	r9
		pwm_sync_init(PWM0,PWM_SYNC_UPDATE_MODE_0, 0);
  415856:	4622      	mov	r2, r4
  415858:	4621      	mov	r1, r4
  41585a:	4630      	mov	r0, r6
  41585c:	4b7e      	ldr	r3, [pc, #504]	; (415a58 <pwm_interface_init+0x32c>)
  41585e:	4798      	blx	r3
		pwm_channel_instance.ul_prescaler = PWM_CMR_CPRE_CLKB;
  415860:	230c      	movs	r3, #12
		pwm_channel_instance.ul_period = PERIOD_VALUE;
  415862:	f640 72ff 	movw	r2, #4095	; 0xfff
		
		//set channel Sync state
		pwm_channel_instance.b_sync_ch = false;
		
		pwm_channel_instance.channel = PWM_CHANNEL_3;
		pwm_channel_init(PWM0, &pwm_channel_instance);
  415866:	a90f      	add	r1, sp, #60	; 0x3c
		pwm_channel_instance.ul_prescaler = PWM_CMR_CPRE_CLKB;
  415868:	9310      	str	r3, [sp, #64]	; 0x40
		pwm_channel_instance.channel = PWM_CHANNEL_3;
  41586a:	2303      	movs	r3, #3
		pwm_channel_init(PWM0, &pwm_channel_instance);
  41586c:	4630      	mov	r0, r6
		pwm_channel_instance.ul_period = PERIOD_VALUE;
  41586e:	9213      	str	r2, [sp, #76]	; 0x4c
		pwm_channel_instance.channel = PWM_CHANNEL_3;
  415870:	930f      	str	r3, [sp, #60]	; 0x3c
		pwm_channel_instance.b_deadtime_generator = true;
  415872:	f88d 5052 	strb.w	r5, [sp, #82]	; 0x52
		pwm_channel_instance.polarity = PWM_LOW;
  415876:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
		pwm_channel_instance.alignment = PWM_ALIGN_LEFT;
  41587a:	f8ad 4044 	strh.w	r4, [sp, #68]	; 0x44
		pwm_channel_instance.ul_duty = (0);
  41587e:	9412      	str	r4, [sp, #72]	; 0x48
		pwm_channel_instance.us_deadtime_pwmh = 0;
  415880:	f8ad 4056 	strh.w	r4, [sp, #86]	; 0x56
		pwm_channel_instance.us_deadtime_pwml = 0;		
  415884:	f8ad 4058 	strh.w	r4, [sp, #88]	; 0x58
		pwm_channel_instance.output_selection.override_level_pwmh = PWM_LOW;
  415888:	f88d 405c 	strb.w	r4, [sp, #92]	; 0x5c
		pwm_channel_instance.output_selection.override_level_pwml = PWM_LOW;
  41588c:	f88d 405d 	strb.w	r4, [sp, #93]	; 0x5d
		pwm_channel_instance.output_selection.b_override_pwml = true;
  415890:	f88d 505b 	strb.w	r5, [sp, #91]	; 0x5b
		pwm_channel_instance.output_selection.b_override_pwmh = true;
  415894:	f88d 505a 	strb.w	r5, [sp, #90]	; 0x5a
		pwm_channel_instance.ul_fault_output_pwml = PWM_LOW;
  415898:	f88d 4061 	strb.w	r4, [sp, #97]	; 0x61
		pwm_channel_instance.ul_fault_output_pwmh = PWM_LOW;
  41589c:	f88d 4060 	strb.w	r4, [sp, #96]	; 0x60
		pwm_channel_instance.b_sync_ch = false;
  4158a0:	f88d 405e 	strb.w	r4, [sp, #94]	; 0x5e
		pwm_channel_instance.fault_id = (1 << 2); //PWM_FAULTI2
  4158a4:	f88d 705f 	strb.w	r7, [sp, #95]	; 0x5f
		pwm_channel_init(PWM0, &pwm_channel_instance);
  4158a8:	47c8      	blx	r9
		//set pulse to be on event line 1
		//pwm_cmp_instance.b_pulse_on_line_1 = true;
		//enable the comparison unit
		pwm_cmp_instance.b_enable = true;
		//set the value to be the pwm period
		pwm_cmp_instance.ul_value =  PERIOD_VALUE;
  4158aa:	f640 72ff 	movw	r2, #4095	; 0xfff
		//set the periodicity of the comparison unit
		pwm_cmp_instance.ul_period = 0;
		pwm_cmp_instance.ul_trigger = 0;
		pwm_cmp_instance.ul_update_period = 0;
		
		pwm_cmp_init(PWM0, &pwm_cmp_instance);
  4158ae:	a907      	add	r1, sp, #28
  4158b0:	4630      	mov	r0, r6
  4158b2:	4b6a      	ldr	r3, [pc, #424]	; (415a5c <pwm_interface_init+0x330>)
		
		//Config PIO
		//PWML0
		pio_set_output(PIOD, PIO_PD10, LOW, DISABLE, ENABLE);
  4158b4:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 415a78 <pwm_interface_init+0x34c>
		pwm_cmp_instance.ul_value =  PERIOD_VALUE;
  4158b8:	9209      	str	r2, [sp, #36]	; 0x24
		pwm_cmp_instance.unit = 0;
  4158ba:	9407      	str	r4, [sp, #28]
		pwm_cmp_instance.b_is_decrementing = false;
  4158bc:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
		pwm_cmp_instance.b_pulse_on_line_0 = true;
  4158c0:	f88d 5038 	strb.w	r5, [sp, #56]	; 0x38
		pwm_cmp_instance.b_enable = true;
  4158c4:	f88d 5020 	strb.w	r5, [sp, #32]
		pwm_cmp_instance.ul_period = 0;
  4158c8:	940c      	str	r4, [sp, #48]	; 0x30
		pwm_cmp_instance.ul_trigger = 0;
  4158ca:	940b      	str	r4, [sp, #44]	; 0x2c
		pwm_cmp_instance.ul_update_period = 0;
  4158cc:	940d      	str	r4, [sp, #52]	; 0x34
		pwm_cmp_init(PWM0, &pwm_cmp_instance);
  4158ce:	4798      	blx	r3
		pio_set_output(PIOD, PIO_PD10, LOW, DISABLE, ENABLE);
  4158d0:	4623      	mov	r3, r4
  4158d2:	4622      	mov	r2, r4
  4158d4:	4651      	mov	r1, sl
  4158d6:	9500      	str	r5, [sp, #0]
  4158d8:	4861      	ldr	r0, [pc, #388]	; (415a60 <pwm_interface_init+0x334>)
  4158da:	47c8      	blx	r9
		pio_set_peripheral(PIOD,PIO_PERIPH_B,PIO_PD10);
  4158dc:	4652      	mov	r2, sl
  4158de:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4158e2:	f8df a198 	ldr.w	sl, [pc, #408]	; 415a7c <pwm_interface_init+0x350>
  4158e6:	485e      	ldr	r0, [pc, #376]	; (415a60 <pwm_interface_init+0x334>)
  4158e8:	47d0      	blx	sl
		//PWMH0
		pio_set_output(PIOD, PIO_PD11, LOW, DISABLE, ENABLE);
  4158ea:	4623      	mov	r3, r4
  4158ec:	4622      	mov	r2, r4
  4158ee:	9500      	str	r5, [sp, #0]
  4158f0:	f44f 6100 	mov.w	r1, #2048	; 0x800
  4158f4:	485a      	ldr	r0, [pc, #360]	; (415a60 <pwm_interface_init+0x334>)
  4158f6:	47c8      	blx	r9
		pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD11);
  4158f8:	f44f 6200 	mov.w	r2, #2048	; 0x800
  4158fc:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  415900:	4857      	ldr	r0, [pc, #348]	; (415a60 <pwm_interface_init+0x334>)
  415902:	47d0      	blx	sl
		//PWML1
		//SET PB12 AS GPIO INSTEAD OF ERASE FUNCTION
		//matrix_set_system_io(CCFG_SYSIO_SYSIO12);
		pio_set_output(PIOB, PIO_PB12, LOW, DISABLE, ENABLE);
  415904:	4623      	mov	r3, r4
  415906:	4622      	mov	r2, r4
  415908:	9500      	str	r5, [sp, #0]
  41590a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  41590e:	4855      	ldr	r0, [pc, #340]	; (415a64 <pwm_interface_init+0x338>)
  415910:	47c8      	blx	r9
		pio_set_peripheral(PIOB,PIO_PERIPH_A,PIO_PB12);
  415912:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  415916:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  41591a:	4852      	ldr	r0, [pc, #328]	; (415a64 <pwm_interface_init+0x338>)
  41591c:	47d0      	blx	sl
		//PWMH1
		pio_set_output(PIOA, PIO_PA2, LOW, DISABLE, ENABLE);
  41591e:	4623      	mov	r3, r4
  415920:	4622      	mov	r2, r4
  415922:	4639      	mov	r1, r7
  415924:	9500      	str	r5, [sp, #0]
  415926:	4850      	ldr	r0, [pc, #320]	; (415a68 <pwm_interface_init+0x33c>)
  415928:	47c8      	blx	r9
		pio_set_peripheral(PIOA,PIO_PERIPH_A,PIO_PA2);
  41592a:	463a      	mov	r2, r7
  41592c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  415930:	484d      	ldr	r0, [pc, #308]	; (415a68 <pwm_interface_init+0x33c>)
  415932:	47d0      	blx	sl
		//PWML2
		pio_set_output(PIOA, PIO_PA30, LOW, DISABLE, ENABLE);
  415934:	4623      	mov	r3, r4
  415936:	4622      	mov	r2, r4
  415938:	9500      	str	r5, [sp, #0]
  41593a:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  41593e:	484a      	ldr	r0, [pc, #296]	; (415a68 <pwm_interface_init+0x33c>)
  415940:	47c8      	blx	r9
		pio_set_peripheral(PIOA,PIO_PERIPH_A,PIO_PA30);
  415942:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  415946:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  41594a:	4847      	ldr	r0, [pc, #284]	; (415a68 <pwm_interface_init+0x33c>)
  41594c:	47d0      	blx	sl
		//PWMH2
		pio_set_output(PIOC, PIO_PC19, LOW, DISABLE, ENABLE);
  41594e:	4623      	mov	r3, r4
  415950:	4622      	mov	r2, r4
  415952:	9500      	str	r5, [sp, #0]
  415954:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  415958:	4844      	ldr	r0, [pc, #272]	; (415a6c <pwm_interface_init+0x340>)
  41595a:	47c8      	blx	r9
		pio_set_peripheral(PIOC,PIO_PERIPH_B,PIO_PC19);
  41595c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  415960:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  415964:	4841      	ldr	r0, [pc, #260]	; (415a6c <pwm_interface_init+0x340>)
  415966:	47d0      	blx	sl

		//PWML3
		pio_set_output(PIOC, PIO_PC22, LOW, DISABLE, ENABLE);
  415968:	4623      	mov	r3, r4
  41596a:	4622      	mov	r2, r4
  41596c:	9500      	str	r5, [sp, #0]
  41596e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  415972:	483e      	ldr	r0, [pc, #248]	; (415a6c <pwm_interface_init+0x340>)
  415974:	47c8      	blx	r9
		pio_set_peripheral(PIOC,PIO_PERIPH_B,PIO_PC22);
  415976:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  41597a:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  41597e:	483b      	ldr	r0, [pc, #236]	; (415a6c <pwm_interface_init+0x340>)
  415980:	47d0      	blx	sl
		
		//configure PWMFI1
		//PWM0_FI1, FI2
		pio_set_input(PIOD, PIO_PD8, 0);
  415982:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 415a80 <pwm_interface_init+0x354>
  415986:	4622      	mov	r2, r4
  415988:	4659      	mov	r1, fp
  41598a:	4835      	ldr	r0, [pc, #212]	; (415a60 <pwm_interface_init+0x334>)
  41598c:	47c8      	blx	r9
		pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD8);
  41598e:	465a      	mov	r2, fp
  415990:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  415994:	4832      	ldr	r0, [pc, #200]	; (415a60 <pwm_interface_init+0x334>)
  415996:	47d0      	blx	sl
		
		pio_set_input(PIOD, PIO_PD9, PIO_PULLUP);
  415998:	462a      	mov	r2, r5
  41599a:	f44f 7100 	mov.w	r1, #512	; 0x200
  41599e:	4830      	ldr	r0, [pc, #192]	; (415a60 <pwm_interface_init+0x334>)
  4159a0:	47c8      	blx	r9
		pio_set_peripheral(PIOD, PIO_PERIPH_B, PIO_PD9);
  4159a2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4159a6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  4159aa:	482d      	ldr	r0, [pc, #180]	; (415a60 <pwm_interface_init+0x334>)
  4159ac:	47d0      	blx	sl
		
		pwm_fault_instance.fault_id = (1 << 1); //faultI 1
		pwm_fault_instance.b_clear = false;
		pwm_fault_instance.b_filtered = true;
		pwm_fault_instance.polarity = PWM_HIGH;
		pwm_fault_init(PWM0, &pwm_fault_instance);
  4159ae:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 415a84 <pwm_interface_init+0x358>
  4159b2:	a903      	add	r1, sp, #12
  4159b4:	4630      	mov	r0, r6
		pwm_fault_instance.fault_id = (1 << 1); //faultI 1
  4159b6:	f88d 800c 	strb.w	r8, [sp, #12]
		pwm_fault_instance.b_clear = false;
  4159ba:	f88d 400e 	strb.w	r4, [sp, #14]
		pwm_fault_instance.b_filtered = true;
  4159be:	f88d 500f 	strb.w	r5, [sp, #15]
		pwm_fault_instance.polarity = PWM_HIGH;
  4159c2:	f88d 500d 	strb.w	r5, [sp, #13]
		pwm_fault_init(PWM0, &pwm_fault_instance);
  4159c6:	47c8      	blx	r9
		
		pwm_fault_instance.fault_id = (1 << 2);//faultI 2
		pwm_fault_instance.polarity = PWM_LOW;
		pwm_fault_instance.b_filtered = false;
		pwm_fault_init(PWM0, &pwm_fault_instance);
  4159c8:	a903      	add	r1, sp, #12
  4159ca:	4630      	mov	r0, r6
		pwm_fault_instance.fault_id = (1 << 2);//faultI 2
  4159cc:	f88d 700c 	strb.w	r7, [sp, #12]
		pwm_fault_instance.polarity = PWM_LOW;
  4159d0:	f88d 400d 	strb.w	r4, [sp, #13]
		pwm_fault_instance.b_filtered = false;
  4159d4:	f88d 400f 	strb.w	r4, [sp, #15]
		pwm_fault_init(PWM0, &pwm_fault_instance);
  4159d8:	47c8      	blx	r9
  4159da:	4b25      	ldr	r3, [pc, #148]	; (415a70 <pwm_interface_init+0x344>)
  4159dc:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000
		
		((Pwm *)(PWM0))->PWM_IER1 = (0xF << 16); //enable 4 channels fault interrupt
  4159e0:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
		NVIC_EnableIRQ(PWM0_IRQn);
		
		pwm_enable_protect(PWM0, 0, 0);
  4159e4:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 415a88 <pwm_interface_init+0x35c>
  4159e8:	4622      	mov	r2, r4
  4159ea:	4630      	mov	r0, r6
		((Pwm *)(PWM0))->PWM_IER1 = (0xF << 16); //enable 4 channels fault interrupt
  4159ec:	6131      	str	r1, [r6, #16]
		pwm_enable_protect(PWM0, 0, 0);
  4159ee:	4621      	mov	r1, r4
  4159f0:	f8c3 e000 	str.w	lr, [r3]
  4159f4:	47c8      	blx	r9
		pwm_enable_protect(PWM0, 1, 0);
  4159f6:	4622      	mov	r2, r4
  4159f8:	4629      	mov	r1, r5
  4159fa:	4630      	mov	r0, r6
  4159fc:	47c8      	blx	r9
		pwm_enable_protect(PWM0, 2, 0);
  4159fe:	4622      	mov	r2, r4
  415a00:	4641      	mov	r1, r8
  415a02:	4630      	mov	r0, r6
  415a04:	47c8      	blx	r9
		pwm_enable_protect(PWM0, 3, 0);
  415a06:	4622      	mov	r2, r4
  415a08:	4630      	mov	r0, r6
  415a0a:	2103      	movs	r1, #3
  415a0c:	47c8      	blx	r9
		pwm_enable_protect(PWM0, 4, 0);
  415a0e:	4622      	mov	r2, r4
  415a10:	4639      	mov	r1, r7
  415a12:	4630      	mov	r0, r6
  415a14:	47c8      	blx	r9
		pwm_enable_protect(PWM0, 5, 0);
  415a16:	4622      	mov	r2, r4
  415a18:	4630      	mov	r0, r6
  415a1a:	2105      	movs	r1, #5
  415a1c:	47c8      	blx	r9
}
  415a1e:	b01f      	add	sp, #124	; 0x7c
  415a20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415a24:	20404ff0 	.word	0x20404ff0
  415a28:	00417a25 	.word	0x00417a25
  415a2c:	004120c1 	.word	0x004120c1
  415a30:	40020000 	.word	0x40020000
  415a34:	0041cc58 	.word	0x0041cc58
  415a38:	08f0d180 	.word	0x08f0d180
  415a3c:	01f3e0c0 	.word	0x01f3e0c0
  415a40:	204003c8 	.word	0x204003c8
  415a44:	3f0f1699 	.word	0x3f0f1699
  415a48:	204003c4 	.word	0x204003c4
  415a4c:	20406ca9 	.word	0x20406ca9
  415a50:	0041282d 	.word	0x0041282d
  415a54:	00411edd 	.word	0x00411edd
  415a58:	00412239 	.word	0x00412239
  415a5c:	00412191 	.word	0x00412191
  415a60:	400e1400 	.word	0x400e1400
  415a64:	400e1000 	.word	0x400e1000
  415a68:	400e0e00 	.word	0x400e0e00
  415a6c:	400e1200 	.word	0x400e1200
  415a70:	e000e100 	.word	0xe000e100
  415a74:	00411f21 	.word	0x00411f21
  415a78:	00417515 	.word	0x00417515
  415a7c:	00417445 	.word	0x00417445
  415a80:	004174dd 	.word	0x004174dd
  415a84:	00412141 	.word	0x00412141
  415a88:	0041225d 	.word	0x0041225d
  415a8c:	4d17      	ldr	r5, [pc, #92]	; (415aec <pwm_interface_init+0x3c0>)
  415a8e:	f8df 807c 	ldr.w	r8, [pc, #124]	; 415b0c <pwm_interface_init+0x3e0>
  415a92:	e663      	b.n	41575c <pwm_interface_init+0x30>
		return ul_div * (ul_divisors[ul_pre]);
  415a94:	fb03 f302 	mul.w	r3, r3, r2
		pwm_real_inv_freq /= pwm_clocks_generate(ul_tmp * PERIOD_VALUE, sysclk_get_peripheral_hz());
  415a98:	ed9f 6a15 	vldr	s12, [pc, #84]	; 415af0 <pwm_interface_init+0x3c4>
		dead_time = DEAD_TIME * (pwm_real_inv_freq * PERIOD_VALUE * 2);
  415a9c:	ed9f 7a15 	vldr	s14, [pc, #84]	; 415af4 <pwm_interface_init+0x3c8>
		pwm_real_inv_freq /= pwm_clocks_generate(ul_tmp * PERIOD_VALUE, sysclk_get_peripheral_hz());
  415aa0:	ee07 3a90 	vmov	s15, r3
  415aa4:	4b14      	ldr	r3, [pc, #80]	; (415af8 <pwm_interface_init+0x3cc>)
		dead_time /= 1000000;
  415aa6:	4a15      	ldr	r2, [pc, #84]	; (415afc <pwm_interface_init+0x3d0>)
		pwm_real_inv_freq /= pwm_clocks_generate(ul_tmp * PERIOD_VALUE, sysclk_get_peripheral_hz());
  415aa8:	eef8 7a67 	vcvt.f32.u32	s15, s15
  415aac:	eec6 6a27 	vdiv.f32	s13, s12, s15
		dead_time = DEAD_TIME * (pwm_real_inv_freq * PERIOD_VALUE * 2);
  415ab0:	ee66 7a87 	vmul.f32	s15, s13, s14
		pwm_real_inv_freq /= pwm_clocks_generate(ul_tmp * PERIOD_VALUE, sysclk_get_peripheral_hz());
  415ab4:	edc3 6a00 	vstr	s13, [r3]
		dead_time = DEAD_TIME * (pwm_real_inv_freq * PERIOD_VALUE * 2);
  415ab8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  415abc:	ee17 3a90 	vmov	r3, s15
		dead_time /= 1000000;
  415ac0:	fba2 2303 	umull	r2, r3, r2, r3
  415ac4:	0c9b      	lsrs	r3, r3, #18
		if (dead_time > PERIOD_VALUE)
  415ac6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  415aca:	d30b      	bcc.n	415ae4 <pwm_interface_init+0x3b8>
			 init_f_set;
  415acc:	4b0c      	ldr	r3, [pc, #48]	; (415b00 <pwm_interface_init+0x3d4>)
			 dead_time = 150;
  415ace:	2296      	movs	r2, #150	; 0x96
  415ad0:	4f0c      	ldr	r7, [pc, #48]	; (415b04 <pwm_interface_init+0x3d8>)
			 init_f_set;
  415ad2:	7818      	ldrb	r0, [r3, #0]
  415ad4:	4b0c      	ldr	r3, [pc, #48]	; (415b08 <pwm_interface_init+0x3dc>)
			 dead_time = 150;
  415ad6:	603a      	str	r2, [r7, #0]
			 init_f_set;
  415ad8:	4798      	blx	r3
  415ada:	683b      	ldr	r3, [r7, #0]
		if (dead_time < 50)
  415adc:	2b31      	cmp	r3, #49	; 0x31
  415ade:	f63f ae75 	bhi.w	4157cc <pwm_interface_init+0xa0>
  415ae2:	e66d      	b.n	4157c0 <pwm_interface_init+0x94>
		dead_time /= 1000000;
  415ae4:	4f07      	ldr	r7, [pc, #28]	; (415b04 <pwm_interface_init+0x3d8>)
  415ae6:	603b      	str	r3, [r7, #0]
  415ae8:	e7f8      	b.n	415adc <pwm_interface_init+0x3b0>
  415aea:	bf00      	nop
  415aec:	02325cd8 	.word	0x02325cd8
  415af0:	470f160a 	.word	0x470f160a
  415af4:	46bff400 	.word	0x46bff400
  415af8:	204003c8 	.word	0x204003c8
  415afc:	431bde83 	.word	0x431bde83
  415b00:	20406ca9 	.word	0x20406ca9
  415b04:	204003c4 	.word	0x204003c4
  415b08:	0041282d 	.word	0x0041282d
  415b0c:	0464b9b0 	.word	0x0464b9b0

00415b10 <pwm_interface_enablesynchchannels>:

void pwm_interface_enablesynchchannels(void)
{
  415b10:	b570      	push	{r4, r5, r6, lr}
	pwm_channel_enable(PWM0, PWM_CHANNEL_0);
  415b12:	4d05      	ldr	r5, [pc, #20]	; (415b28 <pwm_interface_enablesynchchannels+0x18>)
  415b14:	2100      	movs	r1, #0
  415b16:	4c05      	ldr	r4, [pc, #20]	; (415b2c <pwm_interface_enablesynchchannels+0x1c>)
  415b18:	4628      	mov	r0, r5
  415b1a:	47a0      	blx	r4
	pwm_channel_enable(PWM0, PWM_CHANNEL_3);
  415b1c:	4628      	mov	r0, r5
  415b1e:	4623      	mov	r3, r4
  415b20:	2103      	movs	r1, #3
}
  415b22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	pwm_channel_enable(PWM0, PWM_CHANNEL_3);
  415b26:	4718      	bx	r3
  415b28:	40020000 	.word	0x40020000
  415b2c:	004120b5 	.word	0x004120b5

00415b30 <scCheck_testVector>:
#define SC_TEST_VOLTAGE (30)
#define SC_CURRENT ((15.0f))

void scCheck_testVector(uint32_t vectorId)
{
	if (vectorId == 0)
  415b30:	b128      	cbz	r0, 415b3e <scCheck_testVector+0xe>
	{
		inverter_out_single_axis(SC_TEST_VOLTAGE);
	} 
	else if (vectorId == 1)
  415b32:	2801      	cmp	r0, #1
  415b34:	d009      	beq.n	415b4a <scCheck_testVector+0x1a>
	{
		inverter_out_single_axis_b(SC_TEST_VOLTAGE);
	}
	else if (vectorId == 2)
  415b36:	2802      	cmp	r0, #2
  415b38:	d004      	beq.n	415b44 <scCheck_testVector+0x14>
	{
		inverter_out_single_axis_c(SC_TEST_VOLTAGE);
	}
	else
	{
		inverter_out_0();
  415b3a:	4b05      	ldr	r3, [pc, #20]	; (415b50 <scCheck_testVector+0x20>)
  415b3c:	4718      	bx	r3
		inverter_out_single_axis(SC_TEST_VOLTAGE);
  415b3e:	4805      	ldr	r0, [pc, #20]	; (415b54 <scCheck_testVector+0x24>)
  415b40:	4b05      	ldr	r3, [pc, #20]	; (415b58 <scCheck_testVector+0x28>)
  415b42:	4718      	bx	r3
		inverter_out_single_axis_c(SC_TEST_VOLTAGE);
  415b44:	4803      	ldr	r0, [pc, #12]	; (415b54 <scCheck_testVector+0x24>)
  415b46:	4b05      	ldr	r3, [pc, #20]	; (415b5c <scCheck_testVector+0x2c>)
  415b48:	4718      	bx	r3
		inverter_out_single_axis_b(SC_TEST_VOLTAGE);
  415b4a:	4802      	ldr	r0, [pc, #8]	; (415b54 <scCheck_testVector+0x24>)
  415b4c:	4b04      	ldr	r3, [pc, #16]	; (415b60 <scCheck_testVector+0x30>)
  415b4e:	4718      	bx	r3
  415b50:	00415145 	.word	0x00415145
  415b54:	41f00000 	.word	0x41f00000
  415b58:	00414e3d 	.word	0x00414e3d
  415b5c:	00414ff1 	.word	0x00414ff1
  415b60:	00414f39 	.word	0x00414f39

00415b64 <scCheck_init>:
		
}
uint16_t scCheck_timer = 0, scCheck_phase = 0;
void scCheck_init(void)
{
	scCheck_timer = 0;
  415b64:	2300      	movs	r3, #0
  415b66:	4806      	ldr	r0, [pc, #24]	; (415b80 <scCheck_init+0x1c>)
	scCheck_phase = 0;
  415b68:	4906      	ldr	r1, [pc, #24]	; (415b84 <scCheck_init+0x20>)
	inverter_out_0();
  415b6a:	4a07      	ldr	r2, [pc, #28]	; (415b88 <scCheck_init+0x24>)
{
  415b6c:	b510      	push	{r4, lr}
	scCheck_timer = 0;
  415b6e:	8003      	strh	r3, [r0, #0]
	scCheck_phase = 0;
  415b70:	800b      	strh	r3, [r1, #0]
	inverter_out_0();
  415b72:	4790      	blx	r2
	SC_LEVEL_LOW;
  415b74:	2110      	movs	r1, #16
  415b76:	4805      	ldr	r0, [pc, #20]	; (415b8c <scCheck_init+0x28>)
  415b78:	4b05      	ldr	r3, [pc, #20]	; (415b90 <scCheck_init+0x2c>)
}
  415b7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SC_LEVEL_LOW;
  415b7e:	4718      	bx	r3
  415b80:	20400b9a 	.word	0x20400b9a
  415b84:	20400b98 	.word	0x20400b98
  415b88:	00415145 	.word	0x00415145
  415b8c:	400e1600 	.word	0x400e1600
  415b90:	0041743d 	.word	0x0041743d

00415b94 <scCheck_exe>:

//#pragma GCC optimize("O1")
uint32_t scCheck_exe(void)
{
  415b94:	b510      	push	{r4, lr}
	scCheck_testVector(scCheck_phase);
  415b96:	4c0b      	ldr	r4, [pc, #44]	; (415bc4 <scCheck_exe+0x30>)
  415b98:	4b0b      	ldr	r3, [pc, #44]	; (415bc8 <scCheck_exe+0x34>)
  415b9a:	8820      	ldrh	r0, [r4, #0]
  415b9c:	4798      	blx	r3

	if(++scCheck_timer >= SC_TEST_TIME_MS) 
  415b9e:	4a0b      	ldr	r2, [pc, #44]	; (415bcc <scCheck_exe+0x38>)
	{
		scCheck_phase++;
  415ba0:	8820      	ldrh	r0, [r4, #0]
	if(++scCheck_timer >= SC_TEST_TIME_MS) 
  415ba2:	8813      	ldrh	r3, [r2, #0]
  415ba4:	3301      	adds	r3, #1
  415ba6:	b29b      	uxth	r3, r3
  415ba8:	2b02      	cmp	r3, #2
  415baa:	8013      	strh	r3, [r2, #0]
  415bac:	d904      	bls.n	415bb8 <scCheck_exe+0x24>
		scCheck_phase++;
  415bae:	3001      	adds	r0, #1
		scCheck_timer = 0;
  415bb0:	2300      	movs	r3, #0
		scCheck_phase++;
  415bb2:	b280      	uxth	r0, r0
		scCheck_timer = 0;
  415bb4:	8013      	strh	r3, [r2, #0]
		scCheck_phase++;
  415bb6:	8020      	strh	r0, [r4, #0]
		//sc check complete		
		return 1;
		
	}
	return 0;
}
  415bb8:	2805      	cmp	r0, #5
  415bba:	bf94      	ite	ls
  415bbc:	2000      	movls	r0, #0
  415bbe:	2001      	movhi	r0, #1
  415bc0:	bd10      	pop	{r4, pc}
  415bc2:	bf00      	nop
  415bc4:	20400b98 	.word	0x20400b98
  415bc8:	00415b31 	.word	0x00415b31
  415bcc:	20400b9a 	.word	0x20400b9a

00415bd0 <scCheck_current_handler>:

void scCheck_current_handler(float ia, float ib, float ic)
{
  415bd0:	b510      	push	{r4, lr}
	if(!vfd_states_is_sctest_mode()) return;
  415bd2:	4b18      	ldr	r3, [pc, #96]	; (415c34 <scCheck_current_handler+0x64>)
{
  415bd4:	ed2d 8b04 	vpush	{d8-d9}
  415bd8:	ee08 0a10 	vmov	s16, r0
  415bdc:	ee08 1a90 	vmov	s17, r1
  415be0:	ee09 2a10 	vmov	s18, r2
	if(!vfd_states_is_sctest_mode()) return;
  415be4:	4798      	blx	r3
  415be6:	b310      	cbz	r0, 415c2e <scCheck_current_handler+0x5e>
	
	if ((fixedpt_abs(ia) >= SC_CURRENT) || (fixedpt_abs(ib) >= SC_CURRENT) || (fixedpt_abs(ic) >= SC_CURRENT))
  415be8:	eeb0 8ac8 	vabs.f32	s16, s16
  415bec:	eef2 7a0e 	vmov.f32	s15, #46	; 0x41700000  15.0
  415bf0:	eeb4 8ae7 	vcmpe.f32	s16, s15
  415bf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  415bf8:	da0d      	bge.n	415c16 <scCheck_current_handler+0x46>
  415bfa:	eef0 8ae8 	vabs.f32	s17, s17
  415bfe:	eef4 8ae7 	vcmpe.f32	s17, s15
  415c02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  415c06:	da06      	bge.n	415c16 <scCheck_current_handler+0x46>
  415c08:	eeb0 9ac9 	vabs.f32	s18, s18
  415c0c:	eeb4 9ae7 	vcmpe.f32	s18, s15
  415c10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  415c14:	db0b      	blt.n	415c2e <scCheck_current_handler+0x5e>
	{
		inverter_set_override();
  415c16:	4b08      	ldr	r3, [pc, #32]	; (415c38 <scCheck_current_handler+0x68>)
  415c18:	4798      	blx	r3
		vfd_states_trip();
  415c1a:	4b08      	ldr	r3, [pc, #32]	; (415c3c <scCheck_current_handler+0x6c>)
  415c1c:	4798      	blx	r3
		sc_err_set;
  415c1e:	4a08      	ldr	r2, [pc, #32]	; (415c40 <scCheck_current_handler+0x70>)
  415c20:	4b08      	ldr	r3, [pc, #32]	; (415c44 <scCheck_current_handler+0x74>)
  415c22:	7810      	ldrb	r0, [r2, #0]
	}
}
  415c24:	ecbd 8b04 	vpop	{d8-d9}
  415c28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sc_err_set;
  415c2c:	4718      	bx	r3
}
  415c2e:	ecbd 8b04 	vpop	{d8-d9}
  415c32:	bd10      	pop	{r4, pc}
  415c34:	00416355 	.word	0x00416355
  415c38:	00415235 	.word	0x00415235
  415c3c:	004167d1 	.word	0x004167d1
  415c40:	20406c9f 	.word	0x20406c9f
  415c44:	0041282d 	.word	0x0041282d

00415c48 <svm_rectangular_to_ABC>:

#define svm_sign(x) ((x<0)?0:1)
#define SVM_SQRT3_OV_2 fixedpt_rconst(0.8660254038)

void svm_rectangular_to_ABC(uint16_t * a, uint16_t * b, uint16_t * c, fixedpt alpha, fixedpt beta)
{
  415c48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  415c4c:	4691      	mov	r9, r2
	fixedpt fp_a, fp_b, fp_c;
	fixedpt t1, t2, t0_2, i, j, k;
	uint32_t sector ;
	int32_t dead_time_comp;
	
	if(fixedpt_abs(alpha) > FIXEDPT_ONE) alpha = fixedpt_div(alpha, fixedpt_abs(alpha));
  415c4e:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
{
  415c52:	b085      	sub	sp, #20
  415c54:	4698      	mov	r8, r3
	if(fixedpt_abs(alpha) > FIXEDPT_ONE) alpha = fixedpt_div(alpha, fixedpt_abs(alpha));
  415c56:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
{
  415c5a:	4683      	mov	fp, r0
  415c5c:	468a      	mov	sl, r1
  415c5e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	if(fixedpt_abs(alpha) > FIXEDPT_ONE) alpha = fixedpt_div(alpha, fixedpt_abs(alpha));
  415c60:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
  415c64:	dd0c      	ble.n	415c80 <svm_rectangular_to_ABC+0x38>
	return (((fixedptd)A << FIXEDPT_FBITS) / (fixedptd)B);
  415c66:	4618      	mov	r0, r3
  415c68:	17d9      	asrs	r1, r3, #31
  415c6a:	4d64      	ldr	r5, [pc, #400]	; (415dfc <svm_rectangular_to_ABC+0x1b4>)
  415c6c:	e9cd 0102 	strd	r0, r1, [sp, #8]
  415c70:	03d8      	lsls	r0, r3, #15
  415c72:	9b03      	ldr	r3, [sp, #12]
  415c74:	03d9      	lsls	r1, r3, #15
  415c76:	17d3      	asrs	r3, r2, #31
  415c78:	ea41 4158 	orr.w	r1, r1, r8, lsr #17
  415c7c:	47a8      	blx	r5
  415c7e:	4680      	mov	r8, r0
	if(fixedpt_abs(beta) > FIXEDPT_ONE) beta = fixedpt_div(beta, fixedpt_abs(beta));
  415c80:	ea84 72e4 	eor.w	r2, r4, r4, asr #31
  415c84:	eba2 72e4 	sub.w	r2, r2, r4, asr #31
  415c88:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
  415c8c:	dd0c      	ble.n	415ca8 <svm_rectangular_to_ABC+0x60>
  415c8e:	4620      	mov	r0, r4
  415c90:	17e1      	asrs	r1, r4, #31
  415c92:	e9cd 0102 	strd	r0, r1, [sp, #8]
  415c96:	9b03      	ldr	r3, [sp, #12]
  415c98:	03e0      	lsls	r0, r4, #15
  415c9a:	03d9      	lsls	r1, r3, #15
  415c9c:	17d3      	asrs	r3, r2, #31
  415c9e:	ea41 4154 	orr.w	r1, r1, r4, lsr #17
  415ca2:	4c56      	ldr	r4, [pc, #344]	; (415dfc <svm_rectangular_to_ABC+0x1b4>)
  415ca4:	47a0      	blx	r4
  415ca6:	4604      	mov	r4, r0
	return (((fixedptd)A * (fixedptd)B) >> FIXEDPT_FBITS);
  415ca8:	f646 61da 	movw	r1, #28378	; 0x6eda
	
	j= beta;
	beta = (beta >> 1);
  415cac:	ea4f 0e64 	mov.w	lr, r4, asr #1
	alpha = fixedpt_mul(SVM_SQRT3_OV_2, alpha);
	i = alpha - beta;
	k = -alpha - beta; 
	
	sector = svm_sign(i) + 2 * svm_sign(j) + 4 * svm_sign(k);
  415cb0:	2c00      	cmp	r4, #0
  415cb2:	fb88 1201 	smull	r1, r2, r8, r1
  415cb6:	bfac      	ite	ge
  415cb8:	2302      	movge	r3, #2
  415cba:	2300      	movlt	r3, #0
  415cbc:	0bc9      	lsrs	r1, r1, #15
  415cbe:	ea41 4142 	orr.w	r1, r1, r2, lsl #17
	i = alpha - beta;
  415cc2:	4672      	mov	r2, lr
	k = -alpha - beta; 
  415cc4:	4248      	negs	r0, r1
	i = alpha - beta;
  415cc6:	1a89      	subs	r1, r1, r2
	sector = svm_sign(i) + 2 * svm_sign(j) + 4 * svm_sign(k);
  415cc8:	ebb0 020e 	subs.w	r2, r0, lr
  415ccc:	eb03 73e1 	add.w	r3, r3, r1, asr #31
  415cd0:	bf54      	ite	pl
  415cd2:	2004      	movpl	r0, #4
  415cd4:	2000      	movmi	r0, #0
		
	
	switch (sector)
  415cd6:	4403      	add	r3, r0
  415cd8:	2b05      	cmp	r3, #5
  415cda:	d810      	bhi.n	415cfe <svm_rectangular_to_ABC+0xb6>
  415cdc:	e8df f003 	tbb	[pc, r3]
  415ce0:	74675a03 	.word	0x74675a03
  415ce4:	4d81      	.short	0x4d81
			fp_b = t0_2;
			fp_c = t1 + t2 + t0_2;
			break;
		case 1:
			//sector 6
			t1 = -j * (0xfff);
  415ce6:	eba4 3404 	sub.w	r4, r4, r4, lsl #12
			t2 = -k * (0xfff);
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415cea:	4d45      	ldr	r5, [pc, #276]	; (415e00 <svm_rectangular_to_ABC+0x1b8>)
			t2 = -k * (0xfff);
  415cec:	eba2 3202 	sub.w	r2, r2, r2, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415cf0:	1b2d      	subs	r5, r5, r4
			
			fp_a = t1 + t2 + t0_2;
  415cf2:	18a7      	adds	r7, r4, r2
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415cf4:	1aaa      	subs	r2, r5, r2
  415cf6:	1053      	asrs	r3, r2, #1
			fp_a = t1 + t2 + t0_2;
  415cf8:	441f      	add	r7, r3
			fp_b = t0_2;
			fp_c = t1 + t0_2; 
  415cfa:	18e6      	adds	r6, r4, r3
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415cfc:	9301      	str	r3, [sp, #4]
			break;
	}
	
	*a = fixedpt_toint(fp_a);
	*b = fixedpt_toint(fp_b);
  415cfe:	9b01      	ldr	r3, [sp, #4]
	*a = fixedpt_toint(fp_a);
  415d00:	13fc      	asrs	r4, r7, #15
	*c = fixedpt_toint(fp_c);
  415d02:	13f6      	asrs	r6, r6, #15
	
	dead_time_comp = *a;
	dead_time_comp += inverter_get_current_sign(0) * DEAD_TIME_INTERVAL;
  415d04:	4f3f      	ldr	r7, [pc, #252]	; (415e04 <svm_rectangular_to_ABC+0x1bc>)
	*b = fixedpt_toint(fp_b);
  415d06:	13dd      	asrs	r5, r3, #15
	*a = fixedpt_toint(fp_a);
  415d08:	f8ab 4000 	strh.w	r4, [fp]
	dead_time_comp += inverter_get_current_sign(0) * DEAD_TIME_INTERVAL;
  415d0c:	2000      	movs	r0, #0
	*b = fixedpt_toint(fp_b);
  415d0e:	f8aa 5000 	strh.w	r5, [sl]
	} 
	else if (dead_time_comp < 0)
	{
		dead_time_comp = 0;
	}
	*a = dead_time_comp;
  415d12:	f640 75ff 	movw	r5, #4095	; 0xfff
	*c = fixedpt_toint(fp_c);
  415d16:	f8a9 6000 	strh.w	r6, [r9]
	dead_time_comp = *a;
  415d1a:	f8bb 8000 	ldrh.w	r8, [fp]
	dead_time_comp += inverter_get_current_sign(0) * DEAD_TIME_INTERVAL;
  415d1e:	47b8      	blx	r7
  415d20:	4604      	mov	r4, r0
  415d22:	4e39      	ldr	r6, [pc, #228]	; (415e08 <svm_rectangular_to_ABC+0x1c0>)
  415d24:	47b0      	blx	r6
  415d26:	fb00 8304 	mla	r3, r0, r4, r8
	
	dead_time_comp = *b;
	dead_time_comp += inverter_get_current_sign(1) * DEAD_TIME_INTERVAL;
  415d2a:	2001      	movs	r0, #1
  415d2c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
	*a = dead_time_comp;
  415d30:	42ab      	cmp	r3, r5
  415d32:	bfa8      	it	ge
  415d34:	462b      	movge	r3, r5
  415d36:	f8ab 3000 	strh.w	r3, [fp]
	dead_time_comp = *b;
  415d3a:	f8ba 8000 	ldrh.w	r8, [sl]
	dead_time_comp += inverter_get_current_sign(1) * DEAD_TIME_INTERVAL;
  415d3e:	47b8      	blx	r7
  415d40:	4604      	mov	r4, r0
  415d42:	47b0      	blx	r6
  415d44:	fb00 8304 	mla	r3, r0, r4, r8
		dead_time_comp = 0;
	}
	*b = dead_time_comp;
	
	dead_time_comp = *c;
	dead_time_comp += inverter_get_current_sign(2) * DEAD_TIME_INTERVAL;
  415d48:	2002      	movs	r0, #2
  415d4a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
	*b = dead_time_comp;
  415d4e:	42ab      	cmp	r3, r5
  415d50:	bfa8      	it	ge
  415d52:	462b      	movge	r3, r5
  415d54:	f8aa 3000 	strh.w	r3, [sl]
	dead_time_comp = *c;
  415d58:	f8b9 8000 	ldrh.w	r8, [r9]
	dead_time_comp += inverter_get_current_sign(2) * DEAD_TIME_INTERVAL;
  415d5c:	47b8      	blx	r7
  415d5e:	4604      	mov	r4, r0
  415d60:	47b0      	blx	r6
  415d62:	fb00 8004 	mla	r0, r0, r4, r8
  415d66:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	}
	else if (dead_time_comp < 0)
	{
		dead_time_comp = 0;
	}
	*c = dead_time_comp;
  415d6a:	42a8      	cmp	r0, r5
  415d6c:	bfa8      	it	ge
  415d6e:	4628      	movge	r0, r5
  415d70:	f8a9 0000 	strh.w	r0, [r9]
}
  415d74:	b005      	add	sp, #20
  415d76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			t1 = j * (0xfff);
  415d7a:	ebc4 3404 	rsb	r4, r4, r4, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415d7e:	4b20      	ldr	r3, [pc, #128]	; (415e00 <svm_rectangular_to_ABC+0x1b8>)
			t2 = k * (0xfff);
  415d80:	ebc2 3202 	rsb	r2, r2, r2, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415d84:	1b1b      	subs	r3, r3, r4
			fp_b = t1 + t2 + t0_2;
  415d86:	4414      	add	r4, r2
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415d88:	1a9b      	subs	r3, r3, r2
  415d8a:	105f      	asrs	r7, r3, #1
			fp_b = t1 + t2 + t0_2;
  415d8c:	19e3      	adds	r3, r4, r7
			fp_c = t2 + t0_2;
  415d8e:	19d6      	adds	r6, r2, r7
			fp_b = t1 + t2 + t0_2;
  415d90:	9301      	str	r3, [sp, #4]
			break;
  415d92:	e7b4      	b.n	415cfe <svm_rectangular_to_ABC+0xb6>
			t1 = -k * (0xfff);
  415d94:	eba2 3202 	sub.w	r2, r2, r2, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415d98:	4b19      	ldr	r3, [pc, #100]	; (415e00 <svm_rectangular_to_ABC+0x1b8>)
			t2 = -i * (0xfff);
  415d9a:	eba1 3101 	sub.w	r1, r1, r1, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415d9e:	1a9b      	subs	r3, r3, r2
			fp_b = t1 + t2 + t0_2; 
  415da0:	1855      	adds	r5, r2, r1
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415da2:	1a5b      	subs	r3, r3, r1
  415da4:	105e      	asrs	r6, r3, #1
			fp_b = t1 + t2 + t0_2; 
  415da6:	19ab      	adds	r3, r5, r6
			fp_a = t1 + t0_2;
  415da8:	1997      	adds	r7, r2, r6
			fp_b = t1 + t2 + t0_2; 
  415daa:	9301      	str	r3, [sp, #4]
			break;
  415dac:	e7a7      	b.n	415cfe <svm_rectangular_to_ABC+0xb6>
			t1 = i * (0xfff);
  415dae:	ebc1 3101 	rsb	r1, r1, r1, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415db2:	4e13      	ldr	r6, [pc, #76]	; (415e00 <svm_rectangular_to_ABC+0x1b8>)
			t2 = j * (0xfff);
  415db4:	ebc4 3404 	rsb	r4, r4, r4, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415db8:	1a76      	subs	r6, r6, r1
			fp_a = t1 + t2 + t0_2;
  415dba:	4421      	add	r1, r4
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415dbc:	1b36      	subs	r6, r6, r4
  415dbe:	1076      	asrs	r6, r6, #1
			fp_b = t2 + t0_2;
  415dc0:	19a3      	adds	r3, r4, r6
			fp_a = t1 + t2 + t0_2;
  415dc2:	198f      	adds	r7, r1, r6
			fp_b = t2 + t0_2;
  415dc4:	9301      	str	r3, [sp, #4]
			break;
  415dc6:	e79a      	b.n	415cfe <svm_rectangular_to_ABC+0xb6>
			t1 = -i * (0xfff);
  415dc8:	eba1 3101 	sub.w	r1, r1, r1, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415dcc:	4b0c      	ldr	r3, [pc, #48]	; (415e00 <svm_rectangular_to_ABC+0x1b8>)
			t2 = -j * (0xfff);
  415dce:	eba4 3404 	sub.w	r4, r4, r4, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415dd2:	1a5b      	subs	r3, r3, r1
			fp_c = t1 + t2 + t0_2;
  415dd4:	190e      	adds	r6, r1, r4
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415dd6:	1b1b      	subs	r3, r3, r4
  415dd8:	105f      	asrs	r7, r3, #1
			fp_b = t1 + t0_2;
  415dda:	19cb      	adds	r3, r1, r7
			fp_c = t1 + t2 + t0_2;
  415ddc:	443e      	add	r6, r7
			fp_b = t1 + t0_2;
  415dde:	9301      	str	r3, [sp, #4]
			break;
  415de0:	e78d      	b.n	415cfe <svm_rectangular_to_ABC+0xb6>
			t1 = k * (0xfff);
  415de2:	ebc2 3202 	rsb	r2, r2, r2, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415de6:	4d06      	ldr	r5, [pc, #24]	; (415e00 <svm_rectangular_to_ABC+0x1b8>)
			t2 = i * (0xfff);
  415de8:	ebc1 3101 	rsb	r1, r1, r1, lsl #12
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415dec:	1aad      	subs	r5, r5, r2
			fp_c = t1 + t2 + t0_2;
  415dee:	440a      	add	r2, r1
			t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415df0:	1a6d      	subs	r5, r5, r1
  415df2:	106b      	asrs	r3, r5, #1
  415df4:	9301      	str	r3, [sp, #4]
			fp_a = t2 + t0_2;  
  415df6:	18cf      	adds	r7, r1, r3
			fp_c = t1 + t2 + t0_2;
  415df8:	18d6      	adds	r6, r2, r3
			break;
  415dfa:	e780      	b.n	415cfe <svm_rectangular_to_ABC+0xb6>
  415dfc:	0041905d 	.word	0x0041905d
  415e00:	07ff8000 	.word	0x07ff8000
  415e04:	004153e9 	.word	0x004153e9
  415e08:	00415721 	.word	0x00415721

00415e0c <svm_polar_to_ABC>:

void svm_polar_to_ABC(uint16_t * a, uint16_t * b, uint16_t * c, fixedpt ang, fixedpt m)
{
  415e0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  415e10:	9d09      	ldr	r5, [sp, #36]	; 0x24
	
	m = fixedpt_abs(m);
	
	if(m > fixedpt_rconst(1)) m = fixedpt_rconst(1);
	
	while (ang >= fixedpt_rconst(360)) ang-= fixedpt_rconst(360); // round it to the minimum
  415e12:	4e40      	ldr	r6, [pc, #256]	; (415f14 <svm_polar_to_ABC+0x108>)
	m = fixedpt_abs(m);
  415e14:	ea85 74e5 	eor.w	r4, r5, r5, asr #31
  415e18:	eba4 74e5 	sub.w	r4, r4, r5, asr #31
  415e1c:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
  415e20:	bfa8      	it	ge
  415e22:	f44f 4400 	movge.w	r4, #32768	; 0x8000
	while (ang >= fixedpt_rconst(360)) ang-= fixedpt_rconst(360); // round it to the minimum
  415e26:	42b3      	cmp	r3, r6
  415e28:	46a3      	mov	fp, r4
  415e2a:	dd6d      	ble.n	415f08 <svm_polar_to_ABC+0xfc>
  415e2c:	4634      	mov	r4, r6
  415e2e:	f5a3 0334 	sub.w	r3, r3, #11796480	; 0xb40000
  415e32:	42a3      	cmp	r3, r4
  415e34:	dcfb      	bgt.n	415e2e <svm_polar_to_ABC+0x22>
	while (ang < 0) ang += fixedpt_rconst(360);		// get the equivalent positive angle
	
	while(ang >= fixedpt_rconst(60)) // get SVM sector
  415e36:	4c38      	ldr	r4, [pc, #224]	; (415f18 <svm_polar_to_ABC+0x10c>)
  415e38:	2601      	movs	r6, #1
  415e3a:	42a3      	cmp	r3, r4
  415e3c:	dd04      	ble.n	415e48 <svm_polar_to_ABC+0x3c>
	{
		ang -= fixedpt_rconst(60);
  415e3e:	f5a3 13f0 	sub.w	r3, r3, #1966080	; 0x1e0000
		sector++;
  415e42:	3601      	adds	r6, #1
	while(ang >= fixedpt_rconst(60)) // get SVM sector
  415e44:	42a3      	cmp	r3, r4
  415e46:	dcfa      	bgt.n	415e3e <svm_polar_to_ABC+0x32>
	}
	
	angle_ptr = fixedpt_toint( fixedpt_xmul(ang, fixedpt_rconst(5)) ); //pointer for the lookup table
  415e48:	f44f 3420 	mov.w	r4, #163840	; 0x28000
	t2 = fixedpt_mul(m, SVM_SIN_tab[angle_ptr]);
  415e4c:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 415f1c <svm_polar_to_ABC+0x110>
	t1 = fixedpt_mul(m, SVM_SIN_tab[(60 * 5) - angle_ptr]);
	t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415e50:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 415f20 <svm_polar_to_ABC+0x114>
	
	
	
	switch (sector)
  415e54:	3e01      	subs	r6, #1
	angle_ptr = fixedpt_toint( fixedpt_xmul(ang, fixedpt_rconst(5)) ); //pointer for the lookup table
  415e56:	fb83 4504 	smull	r4, r5, r3, r4
  415e5a:	0be3      	lsrs	r3, r4, #15
  415e5c:	ea43 4345 	orr.w	r3, r3, r5, lsl #17
  415e60:	13db      	asrs	r3, r3, #15
	t1 = fixedpt_mul(m, SVM_SIN_tab[(60 * 5) - angle_ptr]);
  415e62:	f5c3 7496 	rsb	r4, r3, #300	; 0x12c
  415e66:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
  415e6a:	f859 4024 	ldr.w	r4, [r9, r4, lsl #2]
  415e6e:	fb8b 8903 	smull	r8, r9, fp, r3
  415e72:	fb8b 4504 	smull	r4, r5, fp, r4
  415e76:	ea4f 33d8 	mov.w	r3, r8, lsr #15
  415e7a:	0be4      	lsrs	r4, r4, #15
  415e7c:	ea43 4349 	orr.w	r3, r3, r9, lsl #17
  415e80:	ea44 4445 	orr.w	r4, r4, r5, lsl #17
	t0_2 = (fixedpt_rconst(4095) - t1 - t2) >> 1; //divided by 2
  415e84:	ebaa 0a04 	sub.w	sl, sl, r4
  415e88:	ebaa 0a03 	sub.w	sl, sl, r3
  415e8c:	ea4f 0a6a 	mov.w	sl, sl, asr #1
	switch (sector)
  415e90:	2e05      	cmp	r6, #5
  415e92:	d80a      	bhi.n	415eaa <svm_polar_to_ABC+0x9e>
  415e94:	e8df f006 	tbb	[pc, r6]
  415e98:	2a231c15 	.word	0x2a231c15
  415e9c:	0331      	.short	0x0331
		fp_a = t2 + t0_2;
		fp_b = t0_2;
		fp_c = t1 + t2 + t0_2;
		break;
		case 6:
		fp_a = t1 + t2 + t0_2;
  415e9e:	4423      	add	r3, r4
		fp_b = t0_2;
		fp_c = t1 + t0_2;
  415ea0:	eb0a 0704 	add.w	r7, sl, r4
		fp_b = t0_2;
  415ea4:	46d6      	mov	lr, sl
		fp_a = t1 + t2 + t0_2;
  415ea6:	eb03 0c0a 	add.w	ip, r3, sl
		break;
	}
	*a = fixedpt_toint(fp_a);
  415eaa:	ea4f 3cec 	mov.w	ip, ip, asr #15
	*b = fixedpt_toint(fp_b);
  415eae:	ea4f 3eee 	mov.w	lr, lr, asr #15
	*c = fixedpt_toint(fp_c);
  415eb2:	13ff      	asrs	r7, r7, #15
	*a = fixedpt_toint(fp_a);
  415eb4:	f8a0 c000 	strh.w	ip, [r0]
	*b = fixedpt_toint(fp_b);
  415eb8:	f8a1 e000 	strh.w	lr, [r1]
	*c = fixedpt_toint(fp_c);
  415ebc:	8017      	strh	r7, [r2, #0]
  415ebe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		fp_a = t1 + t2 + t0_2;
  415ec2:	441c      	add	r4, r3
		fp_b = t2 + t0_2;
  415ec4:	eb0a 0e03 	add.w	lr, sl, r3
		fp_c = t0_2;
  415ec8:	4657      	mov	r7, sl
		fp_a = t1 + t2 + t0_2;
  415eca:	eb04 0c0a 	add.w	ip, r4, sl
		break;
  415ece:	e7ec      	b.n	415eaa <svm_polar_to_ABC+0x9e>
		fp_b = t1 + t2 + t0_2;
  415ed0:	4423      	add	r3, r4
		fp_a = t1 + t0_2;
  415ed2:	eb0a 0c04 	add.w	ip, sl, r4
		fp_c = t0_2;
  415ed6:	4657      	mov	r7, sl
		fp_b = t1 + t2 + t0_2;
  415ed8:	eb03 0e0a 	add.w	lr, r3, sl
		break;
  415edc:	e7e5      	b.n	415eaa <svm_polar_to_ABC+0x9e>
		fp_b = t1 + t2 + t0_2;
  415ede:	441c      	add	r4, r3
		fp_c = t2 + t0_2;
  415ee0:	eb0a 0703 	add.w	r7, sl, r3
		fp_a = t0_2;
  415ee4:	46d4      	mov	ip, sl
		fp_b = t1 + t2 + t0_2;
  415ee6:	eb04 0e0a 	add.w	lr, r4, sl
		break;
  415eea:	e7de      	b.n	415eaa <svm_polar_to_ABC+0x9e>
		fp_c = t1 + t2 + t0_2;
  415eec:	4423      	add	r3, r4
		fp_b = t1 + t0_2;
  415eee:	eb0a 0e04 	add.w	lr, sl, r4
		fp_a = t0_2;
  415ef2:	46d4      	mov	ip, sl
		fp_c = t1 + t2 + t0_2;
  415ef4:	eb03 070a 	add.w	r7, r3, sl
		break;
  415ef8:	e7d7      	b.n	415eaa <svm_polar_to_ABC+0x9e>
		fp_c = t1 + t2 + t0_2;
  415efa:	441c      	add	r4, r3
		fp_a = t2 + t0_2;
  415efc:	eb0a 0c03 	add.w	ip, sl, r3
		fp_b = t0_2;
  415f00:	46d6      	mov	lr, sl
		fp_c = t1 + t2 + t0_2;
  415f02:	eb04 070a 	add.w	r7, r4, sl
		break;
  415f06:	e7d0      	b.n	415eaa <svm_polar_to_ABC+0x9e>
	while (ang < 0) ang += fixedpt_rconst(360);		// get the equivalent positive angle
  415f08:	2b00      	cmp	r3, #0
  415f0a:	da94      	bge.n	415e36 <svm_polar_to_ABC+0x2a>
  415f0c:	f513 0334 	adds.w	r3, r3, #11796480	; 0xb40000
  415f10:	d4fc      	bmi.n	415f0c <svm_polar_to_ABC+0x100>
  415f12:	e790      	b.n	415e36 <svm_polar_to_ABC+0x2a>
  415f14:	00b3ffff 	.word	0x00b3ffff
  415f18:	001dffff 	.word	0x001dffff
  415f1c:	0041cc84 	.word	0x0041cc84
  415f20:	07ff8000 	.word	0x07ff8000

00415f24 <motor_excitation_stage1_exe.part.2>:
	else
	{
		motor_excitation_stage0_enter();
	}
}
void motor_excitation_stage1_exe(void)
  415f24:	b508      	push	{r3, lr}
	if (disconnect_motor)
	{
		motor_excitation_stage1_exit();
		return;
	}
	if (sedacio_is_output_assigned(MOC) == 0)
  415f26:	2006      	movs	r0, #6
  415f28:	4b07      	ldr	r3, [pc, #28]	; (415f48 <motor_excitation_stage1_exe.part.2+0x24>)
  415f2a:	4798      	blx	r3
	if (fxConFB == 0)
	{
		set_fx_err();
	}
	
	if(moc_ta_counter < MOC_TA_TIMER)
  415f2c:	4a07      	ldr	r2, [pc, #28]	; (415f4c <motor_excitation_stage1_exe.part.2+0x28>)
		motor_connected = 1;
  415f2e:	4908      	ldr	r1, [pc, #32]	; (415f50 <motor_excitation_stage1_exe.part.2+0x2c>)
  415f30:	2001      	movs	r0, #1
	if(moc_ta_counter < MOC_TA_TIMER)
  415f32:	8813      	ldrh	r3, [r2, #0]
		motor_connected = 1;
  415f34:	7008      	strb	r0, [r1, #0]
	if(moc_ta_counter < MOC_TA_TIMER)
  415f36:	2bf9      	cmp	r3, #249	; 0xf9
  415f38:	d903      	bls.n	415f42 <motor_excitation_stage1_exe.part.2+0x1e>
	else
	{
		if (mConFB == 1)
		{
			motor_connected = 1;
			moc_trials = 0;
  415f3a:	4b06      	ldr	r3, [pc, #24]	; (415f54 <motor_excitation_stage1_exe.part.2+0x30>)
  415f3c:	2200      	movs	r2, #0
  415f3e:	801a      	strh	r2, [r3, #0]
  415f40:	bd08      	pop	{r3, pc}
		moc_ta_counter++;
  415f42:	4403      	add	r3, r0
  415f44:	8013      	strh	r3, [r2, #0]
  415f46:	bd08      	pop	{r3, pc}
  415f48:	004009dd 	.word	0x004009dd
  415f4c:	20400ba8 	.word	0x20400ba8
  415f50:	20400bac 	.word	0x20400bac
  415f54:	20400baa 	.word	0x20400baa

00415f58 <motor_excitation_stage1_enter>:
{
  415f58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	motor_connected = 0;
  415f5c:	2300      	movs	r3, #0
	motor_excitation_stage = 1;
  415f5e:	2401      	movs	r4, #1
  415f60:	4e0a      	ldr	r6, [pc, #40]	; (415f8c <motor_excitation_stage1_enter+0x34>)
	m_fx(1);
  415f62:	2009      	movs	r0, #9
	motor_connected = 0;
  415f64:	4a0a      	ldr	r2, [pc, #40]	; (415f90 <motor_excitation_stage1_enter+0x38>)
	m_fx(1);
  415f66:	4621      	mov	r1, r4
	connect_motor = 0;
  415f68:	4d0a      	ldr	r5, [pc, #40]	; (415f94 <motor_excitation_stage1_enter+0x3c>)
	motor_excitation_stage = 1;
  415f6a:	7034      	strb	r4, [r6, #0]
	motor_connected = 0;
  415f6c:	7013      	strb	r3, [r2, #0]
	connect_motor = 0;
  415f6e:	702b      	strb	r3, [r5, #0]
	moc_counter = 0;
  415f70:	4f09      	ldr	r7, [pc, #36]	; (415f98 <motor_excitation_stage1_enter+0x40>)
	m_fx(1);
  415f72:	4d0a      	ldr	r5, [pc, #40]	; (415f9c <motor_excitation_stage1_enter+0x44>)
	moc_ta_counter = 0;
  415f74:	4e0a      	ldr	r6, [pc, #40]	; (415fa0 <motor_excitation_stage1_enter+0x48>)
	moc_trials = 0;
  415f76:	4a0b      	ldr	r2, [pc, #44]	; (415fa4 <motor_excitation_stage1_enter+0x4c>)
	moc_counter = 0;
  415f78:	803b      	strh	r3, [r7, #0]
	moc_ta_counter = 0;
  415f7a:	8033      	strh	r3, [r6, #0]
	moc_trials = 0;
  415f7c:	8013      	strh	r3, [r2, #0]
	m_fx(1);
  415f7e:	47a8      	blx	r5
	m_mainOutput(1);
  415f80:	4621      	mov	r1, r4
  415f82:	462b      	mov	r3, r5
  415f84:	2006      	movs	r0, #6
}
  415f86:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	m_mainOutput(1);
  415f8a:	4718      	bx	r3
  415f8c:	20400bad 	.word	0x20400bad
  415f90:	20400bac 	.word	0x20400bac
  415f94:	20400ba2 	.word	0x20400ba2
  415f98:	20400ba6 	.word	0x20400ba6
  415f9c:	00400941 	.word	0x00400941
  415fa0:	20400ba8 	.word	0x20400ba8
  415fa4:	20400baa 	.word	0x20400baa

00415fa8 <motor_excitation_stage0_exit>:
{
  415fa8:	b510      	push	{r4, lr}
	if (sedacio_is_output_assigned(FX) == 0)
  415faa:	2009      	movs	r0, #9
  415fac:	4b07      	ldr	r3, [pc, #28]	; (415fcc <motor_excitation_stage0_exit+0x24>)
  415fae:	4798      	blx	r3
  415fb0:	b140      	cbz	r0, 415fc4 <motor_excitation_stage0_exit+0x1c>
	if(fx_counter < FX_TIMER)
  415fb2:	4a07      	ldr	r2, [pc, #28]	; (415fd0 <motor_excitation_stage0_exit+0x28>)
  415fb4:	f240 2125 	movw	r1, #549	; 0x225
  415fb8:	8813      	ldrh	r3, [r2, #0]
  415fba:	428b      	cmp	r3, r1
  415fbc:	d802      	bhi.n	415fc4 <motor_excitation_stage0_exit+0x1c>
		fx_counter++;
  415fbe:	3301      	adds	r3, #1
  415fc0:	8013      	strh	r3, [r2, #0]
  415fc2:	bd10      	pop	{r4, pc}
		motor_excitation_stage1_enter();
  415fc4:	4b03      	ldr	r3, [pc, #12]	; (415fd4 <motor_excitation_stage0_exit+0x2c>)
}
  415fc6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		motor_excitation_stage1_enter();
  415fca:	4718      	bx	r3
  415fcc:	004009dd 	.word	0x004009dd
  415fd0:	20400ba4 	.word	0x20400ba4
  415fd4:	00415f59 	.word	0x00415f59

00415fd8 <motor_excitation_stage0_exe>:
{
  415fd8:	b510      	push	{r4, lr}
	m_mainOutput(0);
  415fda:	2100      	movs	r1, #0
  415fdc:	2006      	movs	r0, #6
  415fde:	4c08      	ldr	r4, [pc, #32]	; (416000 <motor_excitation_stage0_exe+0x28>)
  415fe0:	47a0      	blx	r4
	if (connect_motor)
  415fe2:	4b08      	ldr	r3, [pc, #32]	; (416004 <motor_excitation_stage0_exe+0x2c>)
  415fe4:	7819      	ldrb	r1, [r3, #0]
  415fe6:	b921      	cbnz	r1, 415ff2 <motor_excitation_stage0_exe+0x1a>
		m_fx(0);
  415fe8:	4623      	mov	r3, r4
  415fea:	2009      	movs	r0, #9
}
  415fec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		m_fx(0);
  415ff0:	4718      	bx	r3
		m_fx(1);
  415ff2:	2101      	movs	r1, #1
  415ff4:	2009      	movs	r0, #9
  415ff6:	47a0      	blx	r4
		motor_excitation_stage0_exit();
  415ff8:	4b03      	ldr	r3, [pc, #12]	; (416008 <motor_excitation_stage0_exe+0x30>)
}
  415ffa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		motor_excitation_stage0_exit();
  415ffe:	4718      	bx	r3
  416000:	00400941 	.word	0x00400941
  416004:	20400ba2 	.word	0x20400ba2
  416008:	00415fa9 	.word	0x00415fa9

0041600c <motor_excitation_stage1_exit>:
{
  41600c:	b510      	push	{r4, lr}
	m_mainOutput(0);
  41600e:	2006      	movs	r0, #6
  416010:	4b10      	ldr	r3, [pc, #64]	; (416054 <motor_excitation_stage1_exit+0x48>)
  416012:	2100      	movs	r1, #0
	motor_connected = 0;
  416014:	4c10      	ldr	r4, [pc, #64]	; (416058 <motor_excitation_stage1_exit+0x4c>)
	m_mainOutput(0);
  416016:	4798      	blx	r3
	motor_connected = 0;
  416018:	2200      	movs	r2, #0
	if (sedacio_is_output_assigned(FX) == 0)
  41601a:	2009      	movs	r0, #9
  41601c:	4b0f      	ldr	r3, [pc, #60]	; (41605c <motor_excitation_stage1_exit+0x50>)
	motor_connected = 0;
  41601e:	7022      	strb	r2, [r4, #0]
	if (sedacio_is_output_assigned(FX) == 0)
  416020:	4798      	blx	r3
  416022:	b930      	cbnz	r0, 416032 <motor_excitation_stage1_exit+0x26>
	motor_excitation_stage = 0;
  416024:	490e      	ldr	r1, [pc, #56]	; (416060 <motor_excitation_stage1_exit+0x54>)
	disconnect_motor = 0;
  416026:	4a0f      	ldr	r2, [pc, #60]	; (416064 <motor_excitation_stage1_exit+0x58>)
	fx_counter = 0;
  416028:	4b0f      	ldr	r3, [pc, #60]	; (416068 <motor_excitation_stage1_exit+0x5c>)
	motor_connected = 0;
  41602a:	7020      	strb	r0, [r4, #0]
	motor_excitation_stage = 0;
  41602c:	7008      	strb	r0, [r1, #0]
	disconnect_motor = 0;
  41602e:	7010      	strb	r0, [r2, #0]
	fx_counter = 0;
  416030:	8018      	strh	r0, [r3, #0]
	if(moc_counter < MOC_TIMER)
  416032:	4a0e      	ldr	r2, [pc, #56]	; (41606c <motor_excitation_stage1_exit+0x60>)
  416034:	8813      	ldrh	r3, [r2, #0]
  416036:	f5b3 7faf 	cmp.w	r3, #350	; 0x15e
  41603a:	d308      	bcc.n	41604e <motor_excitation_stage1_exit+0x42>
	motor_excitation_stage = 0;
  41603c:	2300      	movs	r3, #0
  41603e:	4808      	ldr	r0, [pc, #32]	; (416060 <motor_excitation_stage1_exit+0x54>)
	disconnect_motor = 0;
  416040:	4908      	ldr	r1, [pc, #32]	; (416064 <motor_excitation_stage1_exit+0x58>)
	fx_counter = 0;
  416042:	4a09      	ldr	r2, [pc, #36]	; (416068 <motor_excitation_stage1_exit+0x5c>)
	motor_excitation_stage = 0;
  416044:	7003      	strb	r3, [r0, #0]
	motor_connected = 0;
  416046:	7023      	strb	r3, [r4, #0]
	disconnect_motor = 0;
  416048:	700b      	strb	r3, [r1, #0]
	fx_counter = 0;
  41604a:	8013      	strh	r3, [r2, #0]
  41604c:	bd10      	pop	{r4, pc}
		moc_counter++;
  41604e:	3301      	adds	r3, #1
  416050:	8013      	strh	r3, [r2, #0]
  416052:	bd10      	pop	{r4, pc}
  416054:	00400941 	.word	0x00400941
  416058:	20400bac 	.word	0x20400bac
  41605c:	004009dd 	.word	0x004009dd
  416060:	20400bad 	.word	0x20400bad
  416064:	20400ba3 	.word	0x20400ba3
  416068:	20400ba4 	.word	0x20400ba4
  41606c:	20400ba6 	.word	0x20400ba6

00416070 <motor_excitation_handler>:
		}
	}
}

void motor_excitation_handler(void)
{
  416070:	b508      	push	{r3, lr}
	if (motor_excitation_stage == 0)
  416072:	4b10      	ldr	r3, [pc, #64]	; (4160b4 <motor_excitation_handler+0x44>)
  416074:	781b      	ldrb	r3, [r3, #0]
  416076:	b183      	cbz	r3, 41609a <motor_excitation_handler+0x2a>
	{
		motor_excitation_stage0_exe();
	} 
	else if (motor_excitation_stage == 1)
  416078:	2b01      	cmp	r3, #1
  41607a:	d011      	beq.n	4160a0 <motor_excitation_handler+0x30>
	{
		motor_excitation_stage1_exe();
	}
	
	
	if (bk_state)
  41607c:	4b0e      	ldr	r3, [pc, #56]	; (4160b8 <motor_excitation_handler+0x48>)
  41607e:	781b      	ldrb	r3, [r3, #0]
  416080:	b13b      	cbz	r3, 416092 <motor_excitation_handler+0x22>
	{
		if(bk_counter < BK_TIMER)
  416082:	4a0e      	ldr	r2, [pc, #56]	; (4160bc <motor_excitation_handler+0x4c>)
  416084:	8813      	ldrh	r3, [r2, #0]
  416086:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  41608a:	d303      	bcc.n	416094 <motor_excitation_handler+0x24>
		}
		else
		{
			if (bkConFB == 1)
			{
				bk_trials = 0;
  41608c:	4b0c      	ldr	r3, [pc, #48]	; (4160c0 <motor_excitation_handler+0x50>)
  41608e:	2200      	movs	r2, #0
  416090:	801a      	strh	r2, [r3, #0]
  416092:	bd08      	pop	{r3, pc}
			bk_counter++;
  416094:	3301      	adds	r3, #1
  416096:	8013      	strh	r3, [r2, #0]
  416098:	bd08      	pop	{r3, pc}
		motor_excitation_stage0_exe();
  41609a:	4b0a      	ldr	r3, [pc, #40]	; (4160c4 <motor_excitation_handler+0x54>)
  41609c:	4798      	blx	r3
  41609e:	e7ed      	b.n	41607c <motor_excitation_handler+0xc>
	if (disconnect_motor)
  4160a0:	4b09      	ldr	r3, [pc, #36]	; (4160c8 <motor_excitation_handler+0x58>)
  4160a2:	781b      	ldrb	r3, [r3, #0]
  4160a4:	b113      	cbz	r3, 4160ac <motor_excitation_handler+0x3c>
		motor_excitation_stage1_exit();
  4160a6:	4b09      	ldr	r3, [pc, #36]	; (4160cc <motor_excitation_handler+0x5c>)
  4160a8:	4798      	blx	r3
  4160aa:	e7e7      	b.n	41607c <motor_excitation_handler+0xc>
  4160ac:	4b08      	ldr	r3, [pc, #32]	; (4160d0 <motor_excitation_handler+0x60>)
  4160ae:	4798      	blx	r3
  4160b0:	e7e4      	b.n	41607c <motor_excitation_handler+0xc>
  4160b2:	bf00      	nop
  4160b4:	20400bad 	.word	0x20400bad
  4160b8:	20400b9e 	.word	0x20400b9e
  4160bc:	20400b9c 	.word	0x20400b9c
  4160c0:	20400ba0 	.word	0x20400ba0
  4160c4:	00415fd9 	.word	0x00415fd9
  4160c8:	20400ba3 	.word	0x20400ba3
  4160cc:	0041600d 	.word	0x0041600d
  4160d0:	00415f25 	.word	0x00415f25

004160d4 <motor_excitation_connect_motor>:
		}
	}
}
void motor_excitation_connect_motor(void)
{
	if (connect_motor == 0)
  4160d4:	4a06      	ldr	r2, [pc, #24]	; (4160f0 <motor_excitation_connect_motor+0x1c>)
  4160d6:	7813      	ldrb	r3, [r2, #0]
  4160d8:	b943      	cbnz	r3, 4160ec <motor_excitation_connect_motor+0x18>
	{
		fx_counter = 0;
		disconnect_motor = 0;
		connect_motor = 1;
  4160da:	2101      	movs	r1, #1
		disconnect_motor = 0;
  4160dc:	4805      	ldr	r0, [pc, #20]	; (4160f4 <motor_excitation_connect_motor+0x20>)
{
  4160de:	b410      	push	{r4}
		fx_counter = 0;
  4160e0:	4c05      	ldr	r4, [pc, #20]	; (4160f8 <motor_excitation_connect_motor+0x24>)
		disconnect_motor = 0;
  4160e2:	7003      	strb	r3, [r0, #0]
		connect_motor = 1;
  4160e4:	7011      	strb	r1, [r2, #0]
		fx_counter = 0;
  4160e6:	8023      	strh	r3, [r4, #0]
	}
}
  4160e8:	f85d 4b04 	ldr.w	r4, [sp], #4
  4160ec:	4770      	bx	lr
  4160ee:	bf00      	nop
  4160f0:	20400ba2 	.word	0x20400ba2
  4160f4:	20400ba3 	.word	0x20400ba3
  4160f8:	20400ba4 	.word	0x20400ba4

004160fc <motor_excitation_disconnect_motor>:

void motor_excitation_disconnect_motor(void)
{
	if (disconnect_motor == 0)
  4160fc:	4a06      	ldr	r2, [pc, #24]	; (416118 <motor_excitation_disconnect_motor+0x1c>)
  4160fe:	7813      	ldrb	r3, [r2, #0]
  416100:	b943      	cbnz	r3, 416114 <motor_excitation_disconnect_motor+0x18>
	{
		connect_motor = 0;
		moc_counter = 0;
		disconnect_motor = 1;
  416102:	2101      	movs	r1, #1
		moc_counter = 0;
  416104:	4805      	ldr	r0, [pc, #20]	; (41611c <motor_excitation_disconnect_motor+0x20>)
{
  416106:	b410      	push	{r4}
		connect_motor = 0;
  416108:	4c05      	ldr	r4, [pc, #20]	; (416120 <motor_excitation_disconnect_motor+0x24>)
		moc_counter = 0;
  41610a:	8003      	strh	r3, [r0, #0]
		disconnect_motor = 1;
  41610c:	7011      	strb	r1, [r2, #0]
		connect_motor = 0;
  41610e:	7023      	strb	r3, [r4, #0]
	}
}
  416110:	f85d 4b04 	ldr.w	r4, [sp], #4
  416114:	4770      	bx	lr
  416116:	bf00      	nop
  416118:	20400ba3 	.word	0x20400ba3
  41611c:	20400ba6 	.word	0x20400ba6
  416120:	20400ba2 	.word	0x20400ba2

00416124 <motor_excitation_is_motor_connected>:

uint8_t motor_excitation_is_motor_connected(void)
{
	return motor_connected;
  416124:	4b01      	ldr	r3, [pc, #4]	; (41612c <motor_excitation_is_motor_connected+0x8>)
}
  416126:	7818      	ldrb	r0, [r3, #0]
  416128:	4770      	bx	lr
  41612a:	bf00      	nop
  41612c:	20400bac 	.word	0x20400bac

00416130 <BRKS_set>:


void BRKS_set(uint32_t bsign)
{
  416130:	b510      	push	{r4, lr}
	if (bsign == 0)
  416132:	b138      	cbz	r0, 416144 <BRKS_set+0x14>
		bk_trials = 0;
		bk_state = 0;
	} 
	else
	{
		vfd_brake(1);
  416134:	4b09      	ldr	r3, [pc, #36]	; (41615c <BRKS_set+0x2c>)
  416136:	2101      	movs	r1, #1
  416138:	2000      	movs	r0, #0
  41613a:	4798      	blx	r3
		bk_state = 1;
  41613c:	4b08      	ldr	r3, [pc, #32]	; (416160 <BRKS_set+0x30>)
  41613e:	2201      	movs	r2, #1
  416140:	701a      	strb	r2, [r3, #0]
  416142:	bd10      	pop	{r4, pc}
		vfd_brake(0);
  416144:	4601      	mov	r1, r0
  416146:	4b05      	ldr	r3, [pc, #20]	; (41615c <BRKS_set+0x2c>)
  416148:	4604      	mov	r4, r0
  41614a:	4798      	blx	r3
		bk_counter = 0;
  41614c:	4905      	ldr	r1, [pc, #20]	; (416164 <BRKS_set+0x34>)
		bk_trials = 0;
  41614e:	4a06      	ldr	r2, [pc, #24]	; (416168 <BRKS_set+0x38>)
		bk_state = 0;
  416150:	4b03      	ldr	r3, [pc, #12]	; (416160 <BRKS_set+0x30>)
		bk_counter = 0;
  416152:	800c      	strh	r4, [r1, #0]
		bk_trials = 0;
  416154:	8014      	strh	r4, [r2, #0]
		bk_state = 0;
  416156:	701c      	strb	r4, [r3, #0]
  416158:	bd10      	pop	{r4, pc}
  41615a:	bf00      	nop
  41615c:	00400941 	.word	0x00400941
  416160:	20400b9e 	.word	0x20400b9e
  416164:	20400b9c 	.word	0x20400b9c
  416168:	20400ba0 	.word	0x20400ba0

0041616c <ST1_LED>:
#include <asf.h>
#include <vfdIO.h>

void ST1_LED(void)
{
	LED_ST1_toggle;
  41616c:	205e      	movs	r0, #94	; 0x5e
  41616e:	4b01      	ldr	r3, [pc, #4]	; (416174 <ST1_LED+0x8>)
  416170:	4718      	bx	r3
  416172:	bf00      	nop
  416174:	00417565 	.word	0x00417565

00416178 <ST2_LED>:
}

void ST2_LED(void)
{
	LED_ST2_toggle;
  416178:	205f      	movs	r0, #95	; 0x5f
  41617a:	4b01      	ldr	r3, [pc, #4]	; (416180 <ST2_LED+0x8>)
  41617c:	4718      	bx	r3
  41617e:	bf00      	nop
  416180:	00417565 	.word	0x00417565

00416184 <vfd_states_stop_exe>:
		}
	}
	else vfd_states_break_hold_timer = 0;	
}
void vfd_states_stop_exe(void)
{
  416184:	b570      	push	{r4, r5, r6, lr}
	
	if (vfd_states_break_release_timer < VFD_STATES_BREAK_RELEASE_DELAY)
  416186:	4a29      	ldr	r2, [pc, #164]	; (41622c <vfd_states_stop_exe+0xa8>)
  416188:	4c29      	ldr	r4, [pc, #164]	; (416230 <vfd_states_stop_exe+0xac>)
  41618a:	6813      	ldr	r3, [r2, #0]
  41618c:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
  416190:	4299      	cmp	r1, r3
  416192:	d914      	bls.n	4161be <vfd_states_stop_exe+0x3a>
		//break timer time-out
		//break release routine
		BRKS_set(0);
		if (vfd_states_dcbreak_timer < VFD_STATES_DCBREAK_DELAY)
		{
			vfd_states_dcbreak_timer++;
  416194:	3301      	adds	r3, #1
  416196:	6013      	str	r3, [r2, #0]
	if (vfd_get_ref_speed() != 0)
  416198:	4b26      	ldr	r3, [pc, #152]	; (416234 <vfd_states_stop_exe+0xb0>)
  41619a:	4798      	blx	r3
  41619c:	b158      	cbz	r0, 4161b6 <vfd_states_stop_exe+0x32>
		vfdstate_ptr = &vfd_states_csc_exe;
  41619e:	4a26      	ldr	r2, [pc, #152]	; (416238 <vfd_states_stop_exe+0xb4>)
  4161a0:	4926      	ldr	r1, [pc, #152]	; (41623c <vfd_states_stop_exe+0xb8>)
		regulators_init();
  4161a2:	4b27      	ldr	r3, [pc, #156]	; (416240 <vfd_states_stop_exe+0xbc>)
		vfdstate_ptr = &vfd_states_csc_exe;
  4161a4:	6011      	str	r1, [r2, #0]
		regulators_init();
  4161a6:	4798      	blx	r3
		sc_testing = 1;
  4161a8:	4a26      	ldr	r2, [pc, #152]	; (416244 <vfd_states_stop_exe+0xc0>)
  4161aa:	2101      	movs	r1, #1
		scCheck_init();
  4161ac:	4b26      	ldr	r3, [pc, #152]	; (416248 <vfd_states_stop_exe+0xc4>)
		sc_testing = 1;
  4161ae:	7011      	strb	r1, [r2, #0]
		scCheck_init();
  4161b0:	4798      	blx	r3
		inverter_fan_timer_reset();
  4161b2:	4b26      	ldr	r3, [pc, #152]	; (41624c <vfd_states_stop_exe+0xc8>)
  4161b4:	4798      	blx	r3
			}
			
		}
	}
	vfd_states_csc_enter();	
	inverter_brake_chopper_handler();
  4161b6:	4b26      	ldr	r3, [pc, #152]	; (416250 <vfd_states_stop_exe+0xcc>)
}
  4161b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	inverter_brake_chopper_handler();
  4161bc:	4718      	bx	r3
		BRKS_set(0);
  4161be:	4b25      	ldr	r3, [pc, #148]	; (416254 <vfd_states_stop_exe+0xd0>)
  4161c0:	2000      	movs	r0, #0
  4161c2:	4798      	blx	r3
		if (vfd_states_dcbreak_timer < VFD_STATES_DCBREAK_DELAY)
  4161c4:	4a24      	ldr	r2, [pc, #144]	; (416258 <vfd_states_stop_exe+0xd4>)
  4161c6:	f8b4 10cc 	ldrh.w	r1, [r4, #204]	; 0xcc
  4161ca:	6813      	ldr	r3, [r2, #0]
  4161cc:	4299      	cmp	r1, r3
  4161ce:	d8e1      	bhi.n	416194 <vfd_states_stop_exe+0x10>
		else if (vfd_states_dcbreak_timer == VFD_STATES_DCBREAK_DELAY)
  4161d0:	d1e2      	bne.n	416198 <vfd_states_stop_exe+0x14>
			if ((menue_drive_data_applied.m_control_mode > 0) /*&& (menue_drive_data_applied.m_motor_type == 1)*/)
  4161d2:	f894 50c5 	ldrb.w	r5, [r4, #197]	; 0xc5
  4161d6:	b14d      	cbz	r5, 4161ec <vfd_states_stop_exe+0x68>
				if (vfd_states_tourque_decay_timer == 0)
  4161d8:	4d20      	ldr	r5, [pc, #128]	; (41625c <vfd_states_stop_exe+0xd8>)
					vfd_set_c_decay(VFD_STATES_TOURQUE_DECAY);
  4161da:	f8b4 008c 	ldrh.w	r0, [r4, #140]	; 0x8c
				if (vfd_states_tourque_decay_timer == 0)
  4161de:	682b      	ldr	r3, [r5, #0]
  4161e0:	b17b      	cbz	r3, 416202 <vfd_states_stop_exe+0x7e>
				else if (vfd_states_tourque_decay_timer < VFD_STATES_TOURQUE_DECAY)
  4161e2:	4283      	cmp	r3, r0
  4161e4:	d213      	bcs.n	41620e <vfd_states_stop_exe+0x8a>
					vfd_states_tourque_decay_timer++;
  4161e6:	3301      	adds	r3, #1
  4161e8:	602b      	str	r3, [r5, #0]
  4161ea:	e7d5      	b.n	416198 <vfd_states_stop_exe+0x14>
				vfd_states_dcbreak_timer++;
  4161ec:	3101      	adds	r1, #1
				inverter_set_override();
  4161ee:	4b1c      	ldr	r3, [pc, #112]	; (416260 <vfd_states_stop_exe+0xdc>)
				vfd_states_dcbreak_timer++;
  4161f0:	6011      	str	r1, [r2, #0]
				inverter_set_override();
  4161f2:	4798      	blx	r3
				motor_excitation_disconnect_motor();
  4161f4:	4b1b      	ldr	r3, [pc, #108]	; (416264 <vfd_states_stop_exe+0xe0>)
  4161f6:	4798      	blx	r3
				vfd_activate_reg_reset();
  4161f8:	4b1b      	ldr	r3, [pc, #108]	; (416268 <vfd_states_stop_exe+0xe4>)
  4161fa:	4798      	blx	r3
				is_stopping = 0;
  4161fc:	4b1b      	ldr	r3, [pc, #108]	; (41626c <vfd_states_stop_exe+0xe8>)
  4161fe:	701d      	strb	r5, [r3, #0]
  416200:	e7ca      	b.n	416198 <vfd_states_stop_exe+0x14>
					vfd_set_c_decay(VFD_STATES_TOURQUE_DECAY);
  416202:	4b1b      	ldr	r3, [pc, #108]	; (416270 <vfd_states_stop_exe+0xec>)
  416204:	4798      	blx	r3
					vfd_states_tourque_decay_timer++;
  416206:	682b      	ldr	r3, [r5, #0]
  416208:	3301      	adds	r3, #1
  41620a:	602b      	str	r3, [r5, #0]
  41620c:	e7c4      	b.n	416198 <vfd_states_stop_exe+0x14>
					vfd_states_dcbreak_timer++;
  41620e:	3101      	adds	r1, #1
					inverter_set_override();
  416210:	4b13      	ldr	r3, [pc, #76]	; (416260 <vfd_states_stop_exe+0xdc>)
					vfd_states_dcbreak_timer++;
  416212:	6011      	str	r1, [r2, #0]
					inverter_set_override();
  416214:	4798      	blx	r3
					motor_excitation_disconnect_motor();
  416216:	4b13      	ldr	r3, [pc, #76]	; (416264 <vfd_states_stop_exe+0xe0>)
  416218:	4798      	blx	r3
					vfd_activate_reg_reset();
  41621a:	4b13      	ldr	r3, [pc, #76]	; (416268 <vfd_states_stop_exe+0xe4>)
  41621c:	4798      	blx	r3
					is_stopping = 0;
  41621e:	4a13      	ldr	r2, [pc, #76]	; (41626c <vfd_states_stop_exe+0xe8>)
  416220:	2100      	movs	r1, #0
					vfd_clear_c_decay();
  416222:	4b14      	ldr	r3, [pc, #80]	; (416274 <vfd_states_stop_exe+0xf0>)
					is_stopping = 0;
  416224:	7011      	strb	r1, [r2, #0]
					vfd_clear_c_decay();
  416226:	4798      	blx	r3
  416228:	e7b6      	b.n	416198 <vfd_states_stop_exe+0x14>
  41622a:	bf00      	nop
  41622c:	20400bbc 	.word	0x20400bbc
  416230:	20404ff0 	.word	0x20404ff0
  416234:	00416989 	.word	0x00416989
  416238:	20400bcc 	.word	0x20400bcc
  41623c:	004168d1 	.word	0x004168d1
  416240:	00416b3d 	.word	0x00416b3d
  416244:	20400bb5 	.word	0x20400bb5
  416248:	00415b65 	.word	0x00415b65
  41624c:	00415465 	.word	0x00415465
  416250:	00415315 	.word	0x00415315
  416254:	00416131 	.word	0x00416131
  416258:	20400bc0 	.word	0x20400bc0
  41625c:	20400bc8 	.word	0x20400bc8
  416260:	00415235 	.word	0x00415235
  416264:	004160fd 	.word	0x004160fd
  416268:	00416c89 	.word	0x00416c89
  41626c:	20400bb4 	.word	0x20400bb4
  416270:	00416b5d 	.word	0x00416b5d
  416274:	00416c01 	.word	0x00416c01

00416278 <vfd_states_set_softcharge_mode>:
	if(mode) 
  416278:	b910      	cbnz	r0, 416280 <vfd_states_set_softcharge_mode+0x8>
		softcharge = 0;
  41627a:	4b07      	ldr	r3, [pc, #28]	; (416298 <vfd_states_set_softcharge_mode+0x20>)
  41627c:	7018      	strb	r0, [r3, #0]
  41627e:	4770      	bx	lr
{
  416280:	b410      	push	{r4}
		softcharge = 1;
  416282:	4a05      	ldr	r2, [pc, #20]	; (416298 <vfd_states_set_softcharge_mode+0x20>)
  416284:	2401      	movs	r4, #1
		SCRELAY_Off;
  416286:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  41628a:	4804      	ldr	r0, [pc, #16]	; (41629c <vfd_states_set_softcharge_mode+0x24>)
		softcharge = 1;
  41628c:	7014      	strb	r4, [r2, #0]
		SCRELAY_Off;
  41628e:	4b04      	ldr	r3, [pc, #16]	; (4162a0 <vfd_states_set_softcharge_mode+0x28>)
}
  416290:	f85d 4b04 	ldr.w	r4, [sp], #4
		SCRELAY_Off;
  416294:	4718      	bx	r3
  416296:	bf00      	nop
  416298:	20400bb6 	.word	0x20400bb6
  41629c:	400e1200 	.word	0x400e1200
  4162a0:	00417441 	.word	0x00417441

004162a4 <vfdstates_get_d_state>:
	if (vfdstate_ptr == &vfd_states_init_exe)
  4162a4:	4a10      	ldr	r2, [pc, #64]	; (4162e8 <vfdstates_get_d_state+0x44>)
  4162a6:	4b11      	ldr	r3, [pc, #68]	; (4162ec <vfdstates_get_d_state+0x48>)
  4162a8:	6810      	ldr	r0, [r2, #0]
  4162aa:	4298      	cmp	r0, r3
  4162ac:	d017      	beq.n	4162de <vfdstates_get_d_state+0x3a>
	else if (vfdstate_ptr == &vfd_states_active_exe)
  4162ae:	4b10      	ldr	r3, [pc, #64]	; (4162f0 <vfdstates_get_d_state+0x4c>)
  4162b0:	4298      	cmp	r0, r3
  4162b2:	d016      	beq.n	4162e2 <vfdstates_get_d_state+0x3e>
	else if (vfdstate_ptr == &vfd_states_stop_exe)
  4162b4:	4b0f      	ldr	r3, [pc, #60]	; (4162f4 <vfdstates_get_d_state+0x50>)
  4162b6:	4298      	cmp	r0, r3
  4162b8:	d00b      	beq.n	4162d2 <vfdstates_get_d_state+0x2e>
	else if (vfdstate_ptr == &vfd_states_trip_exe)
  4162ba:	4b0f      	ldr	r3, [pc, #60]	; (4162f8 <vfdstates_get_d_state+0x54>)
  4162bc:	4298      	cmp	r0, r3
  4162be:	d00a      	beq.n	4162d6 <vfdstates_get_d_state+0x32>
	else if (vfdstate_ptr == &vfd_states_csc_exe)
  4162c0:	4b0e      	ldr	r3, [pc, #56]	; (4162fc <vfdstates_get_d_state+0x58>)
  4162c2:	4298      	cmp	r0, r3
  4162c4:	d009      	beq.n	4162da <vfdstates_get_d_state+0x36>
	else if (vfdstate_ptr == &vfd_states_tune_exe)
  4162c6:	4b0e      	ldr	r3, [pc, #56]	; (416300 <vfdstates_get_d_state+0x5c>)
		return 6;
  4162c8:	4298      	cmp	r0, r3
  4162ca:	bf0c      	ite	eq
  4162cc:	2005      	moveq	r0, #5
  4162ce:	2006      	movne	r0, #6
  4162d0:	4770      	bx	lr
		return 2;
  4162d2:	2002      	movs	r0, #2
  4162d4:	4770      	bx	lr
		return 3;
  4162d6:	2003      	movs	r0, #3
  4162d8:	4770      	bx	lr
		return 4;
  4162da:	2004      	movs	r0, #4
}
  4162dc:	4770      	bx	lr
		return 0;
  4162de:	2000      	movs	r0, #0
  4162e0:	4770      	bx	lr
		return 1;
  4162e2:	2001      	movs	r0, #1
  4162e4:	4770      	bx	lr
  4162e6:	bf00      	nop
  4162e8:	20400bcc 	.word	0x20400bcc
  4162ec:	00416439 	.word	0x00416439
  4162f0:	00416489 	.word	0x00416489
  4162f4:	00416185 	.word	0x00416185
  4162f8:	00416705 	.word	0x00416705
  4162fc:	004168d1 	.word	0x004168d1
  416300:	00416911 	.word	0x00416911

00416304 <vfd_states_allowedtomove>:
	if(vfdstate_ptr == &vfd_states_active_exe) return 1;
  416304:	4a03      	ldr	r2, [pc, #12]	; (416314 <vfd_states_allowedtomove+0x10>)
  416306:	4b04      	ldr	r3, [pc, #16]	; (416318 <vfd_states_allowedtomove+0x14>)
  416308:	6810      	ldr	r0, [r2, #0]
}
  41630a:	1ac0      	subs	r0, r0, r3
  41630c:	fab0 f080 	clz	r0, r0
  416310:	0940      	lsrs	r0, r0, #5
  416312:	4770      	bx	lr
  416314:	20400bcc 	.word	0x20400bcc
  416318:	00416489 	.word	0x00416489

0041631c <vfd_states_isTuning>:
	if(vfdstate_ptr == &vfd_states_tune_exe) return 1;
  41631c:	4a03      	ldr	r2, [pc, #12]	; (41632c <vfd_states_isTuning+0x10>)
  41631e:	4b04      	ldr	r3, [pc, #16]	; (416330 <vfd_states_isTuning+0x14>)
  416320:	6810      	ldr	r0, [r2, #0]
}
  416322:	1ac0      	subs	r0, r0, r3
  416324:	fab0 f080 	clz	r0, r0
  416328:	0940      	lsrs	r0, r0, #5
  41632a:	4770      	bx	lr
  41632c:	20400bcc 	.word	0x20400bcc
  416330:	00416911 	.word	0x00416911

00416334 <vfd_states_initialized>:
	if(vfdstate_ptr == &vfd_states_init_exe) return 0;
  416334:	4a05      	ldr	r2, [pc, #20]	; (41634c <vfd_states_initialized+0x18>)
  416336:	4b06      	ldr	r3, [pc, #24]	; (416350 <vfd_states_initialized+0x1c>)
  416338:	6810      	ldr	r0, [r2, #0]
	else if(vfdstate_ptr == 0) return 0;
  41633a:	4298      	cmp	r0, r3
  41633c:	bf18      	it	ne
  41633e:	2800      	cmpne	r0, #0
  416340:	bf0c      	ite	eq
  416342:	2001      	moveq	r0, #1
  416344:	2000      	movne	r0, #0
}
  416346:	f080 0001 	eor.w	r0, r0, #1
  41634a:	4770      	bx	lr
  41634c:	20400bcc 	.word	0x20400bcc
  416350:	00416439 	.word	0x00416439

00416354 <vfd_states_is_sctest_mode>:
	if((vfdstate_ptr == &vfd_states_csc_exe) && (sc_testing)) return 1;
  416354:	4a06      	ldr	r2, [pc, #24]	; (416370 <vfd_states_is_sctest_mode+0x1c>)
  416356:	4b07      	ldr	r3, [pc, #28]	; (416374 <vfd_states_is_sctest_mode+0x20>)
  416358:	6812      	ldr	r2, [r2, #0]
  41635a:	429a      	cmp	r2, r3
  41635c:	d001      	beq.n	416362 <vfd_states_is_sctest_mode+0xe>
  41635e:	2000      	movs	r0, #0
}
  416360:	4770      	bx	lr
	if((vfdstate_ptr == &vfd_states_csc_exe) && (sc_testing)) return 1;
  416362:	4b05      	ldr	r3, [pc, #20]	; (416378 <vfd_states_is_sctest_mode+0x24>)
  416364:	7818      	ldrb	r0, [r3, #0]
  416366:	3000      	adds	r0, #0
  416368:	bf18      	it	ne
  41636a:	2001      	movne	r0, #1
  41636c:	4770      	bx	lr
  41636e:	bf00      	nop
  416370:	20400bcc 	.word	0x20400bcc
  416374:	004168d1 	.word	0x004168d1
  416378:	20400bb5 	.word	0x20400bb5

0041637c <vfd_states_isStopping>:
	if (is_stopping) return 1;
  41637c:	4b02      	ldr	r3, [pc, #8]	; (416388 <vfd_states_isStopping+0xc>)
  41637e:	7818      	ldrb	r0, [r3, #0]
}
  416380:	3000      	adds	r0, #0
  416382:	bf18      	it	ne
  416384:	2001      	movne	r0, #1
  416386:	4770      	bx	lr
  416388:	20400bb4 	.word	0x20400bb4

0041638c <vfd_states_stop_enter>:
	vfdstate_ptr = &vfd_states_stop_exe;
  41638c:	4a17      	ldr	r2, [pc, #92]	; (4163ec <vfd_states_stop_enter+0x60>)
	inverter_set_dead_comp(0);
  41638e:	2000      	movs	r0, #0
	vfdstate_ptr = &vfd_states_stop_exe;
  416390:	4917      	ldr	r1, [pc, #92]	; (4163f0 <vfd_states_stop_enter+0x64>)
	inverter_set_dead_comp(0);
  416392:	4b18      	ldr	r3, [pc, #96]	; (4163f4 <vfd_states_stop_enter+0x68>)
{
  416394:	b570      	push	{r4, r5, r6, lr}
	vfd_states_break_hold_timer = 0;
  416396:	4604      	mov	r4, r0
	vfdstate_ptr = &vfd_states_stop_exe;
  416398:	6011      	str	r1, [r2, #0]
	inverter_set_dead_comp(0);
  41639a:	4798      	blx	r3
	SCRELAY_On;
  41639c:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  4163a0:	4815      	ldr	r0, [pc, #84]	; (4163f8 <vfd_states_stop_enter+0x6c>)
  4163a2:	4b16      	ldr	r3, [pc, #88]	; (4163fc <vfd_states_stop_enter+0x70>)
  4163a4:	4798      	blx	r3
	vfd_states_break_hold_timer = 0;
  4163a6:	4d16      	ldr	r5, [pc, #88]	; (416400 <vfd_states_stop_enter+0x74>)
	vfd_states_motor_move_timer = 0;
  4163a8:	4816      	ldr	r0, [pc, #88]	; (416404 <vfd_states_stop_enter+0x78>)
	is_stopping = 1;
  4163aa:	2101      	movs	r1, #1
  4163ac:	4a16      	ldr	r2, [pc, #88]	; (416408 <vfd_states_stop_enter+0x7c>)
	pwm_interface_enablesynchchannels();
  4163ae:	4b17      	ldr	r3, [pc, #92]	; (41640c <vfd_states_stop_enter+0x80>)
	vfd_states_motor_move_timer = 0;
  4163b0:	6004      	str	r4, [r0, #0]
	is_stopping = 1;
  4163b2:	7011      	strb	r1, [r2, #0]
	vfd_states_break_hold_timer = 0;
  4163b4:	602c      	str	r4, [r5, #0]
	pwm_interface_enablesynchchannels();
  4163b6:	4798      	blx	r3
	stop_zero_servo();
  4163b8:	4b15      	ldr	r3, [pc, #84]	; (416410 <vfd_states_stop_enter+0x84>)
  4163ba:	4798      	blx	r3
	if (vfd_get_desired_speed() != 0)
  4163bc:	4b15      	ldr	r3, [pc, #84]	; (416414 <vfd_states_stop_enter+0x88>)
  4163be:	4798      	blx	r3
  4163c0:	b930      	cbnz	r0, 4163d0 <vfd_states_stop_enter+0x44>
		vfd_states_dcbreak_timer = 0;
  4163c2:	4915      	ldr	r1, [pc, #84]	; (416418 <vfd_states_stop_enter+0x8c>)
		vfd_states_break_release_timer = 0;
  4163c4:	4a15      	ldr	r2, [pc, #84]	; (41641c <vfd_states_stop_enter+0x90>)
		vfd_states_tourque_decay_timer = 0;
  4163c6:	4b16      	ldr	r3, [pc, #88]	; (416420 <vfd_states_stop_enter+0x94>)
		vfd_states_dcbreak_timer = 0;
  4163c8:	6008      	str	r0, [r1, #0]
		vfd_states_break_release_timer = 0;
  4163ca:	6010      	str	r0, [r2, #0]
		vfd_states_tourque_decay_timer = 0;
  4163cc:	6018      	str	r0, [r3, #0]
  4163ce:	bd70      	pop	{r4, r5, r6, pc}
		inverter_set_override();
  4163d0:	4b14      	ldr	r3, [pc, #80]	; (416424 <vfd_states_stop_enter+0x98>)
  4163d2:	4798      	blx	r3
		motor_excitation_disconnect_motor();
  4163d4:	4b14      	ldr	r3, [pc, #80]	; (416428 <vfd_states_stop_enter+0x9c>)
  4163d6:	4798      	blx	r3
		vfd_activate_reg_reset();
  4163d8:	4b14      	ldr	r3, [pc, #80]	; (41642c <vfd_states_stop_enter+0xa0>)
  4163da:	4798      	blx	r3
		BRKS_set(0);
  4163dc:	4620      	mov	r0, r4
  4163de:	4b14      	ldr	r3, [pc, #80]	; (416430 <vfd_states_stop_enter+0xa4>)
  4163e0:	4798      	blx	r3
		vfd_clear_c_decay();
  4163e2:	4b14      	ldr	r3, [pc, #80]	; (416434 <vfd_states_stop_enter+0xa8>)
}
  4163e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		vfd_clear_c_decay();
  4163e8:	4718      	bx	r3
  4163ea:	bf00      	nop
  4163ec:	20400bcc 	.word	0x20400bcc
  4163f0:	00416185 	.word	0x00416185
  4163f4:	004153dd 	.word	0x004153dd
  4163f8:	400e1200 	.word	0x400e1200
  4163fc:	0041743d 	.word	0x0041743d
  416400:	20400bb8 	.word	0x20400bb8
  416404:	20400bc4 	.word	0x20400bc4
  416408:	20400bb4 	.word	0x20400bb4
  41640c:	00415b11 	.word	0x00415b11
  416410:	0040f5bd 	.word	0x0040f5bd
  416414:	00416995 	.word	0x00416995
  416418:	20400bc0 	.word	0x20400bc0
  41641c:	20400bbc 	.word	0x20400bbc
  416420:	20400bc8 	.word	0x20400bc8
  416424:	00415235 	.word	0x00415235
  416428:	004160fd 	.word	0x004160fd
  41642c:	00416c89 	.word	0x00416c89
  416430:	00416131 	.word	0x00416131
  416434:	00416c01 	.word	0x00416c01

00416438 <vfd_states_init_exe>:
	if(init_delay_counter++ == (INIT_DELAY >> 3))
  416438:	4a0d      	ldr	r2, [pc, #52]	; (416470 <vfd_states_init_exe+0x38>)
  41643a:	f240 1077 	movw	r0, #375	; 0x177
{
  41643e:	b510      	push	{r4, lr}
	if(init_delay_counter++ == (INIT_DELAY >> 3))
  416440:	6813      	ldr	r3, [r2, #0]
  416442:	1c59      	adds	r1, r3, #1
  416444:	4283      	cmp	r3, r0
  416446:	6011      	str	r1, [r2, #0]
  416448:	d00a      	beq.n	416460 <vfd_states_init_exe+0x28>
	else if(init_delay_counter > INIT_DELAY)
  41644a:	f640 33b8 	movw	r3, #3000	; 0xbb8
  41644e:	4299      	cmp	r1, r3
  416450:	d800      	bhi.n	416454 <vfd_states_init_exe+0x1c>
  416452:	bd10      	pop	{r4, pc}
		vfd_states_stop_enter();
  416454:	4b07      	ldr	r3, [pc, #28]	; (416474 <vfd_states_init_exe+0x3c>)
  416456:	4798      	blx	r3
		inverter_init_dc_filter();
  416458:	4b07      	ldr	r3, [pc, #28]	; (416478 <vfd_states_init_exe+0x40>)
}
  41645a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		inverter_init_dc_filter();
  41645e:	4718      	bx	r3
		inverter_set_override();
  416460:	4b06      	ldr	r3, [pc, #24]	; (41647c <vfd_states_init_exe+0x44>)
  416462:	4798      	blx	r3
		vfd_activate_reg_reset();
  416464:	4b06      	ldr	r3, [pc, #24]	; (416480 <vfd_states_init_exe+0x48>)
  416466:	4798      	blx	r3
		pwm_interface_enablesynchchannels();	
  416468:	4b06      	ldr	r3, [pc, #24]	; (416484 <vfd_states_init_exe+0x4c>)
}
  41646a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		pwm_interface_enablesynchchannels();	
  41646e:	4718      	bx	r3
  416470:	20400bb0 	.word	0x20400bb0
  416474:	0041638d 	.word	0x0041638d
  416478:	00414c1d 	.word	0x00414c1d
  41647c:	00415235 	.word	0x00415235
  416480:	00416c89 	.word	0x00416c89
  416484:	00415b11 	.word	0x00415b11

00416488 <vfd_states_active_exe>:
	{
		if(vfd_get_desired_speed() == 0) vfd_states_stop_enter();
	}	
}
void vfd_states_active_exe(void)
{
  416488:	b510      	push	{r4, lr}
	if(! vfd_enable_isEnabled()) vfd_states_stop_enter();
  41648a:	4b0b      	ldr	r3, [pc, #44]	; (4164b8 <vfd_states_active_exe+0x30>)
  41648c:	4798      	blx	r3
  41648e:	b178      	cbz	r0, 4164b0 <vfd_states_active_exe+0x28>
	inverter_fan_timer_reset();
  416490:	4b0a      	ldr	r3, [pc, #40]	; (4164bc <vfd_states_active_exe+0x34>)
  416492:	4798      	blx	r3
	inverter_brake_chopper_handler();
  416494:	4b0a      	ldr	r3, [pc, #40]	; (4164c0 <vfd_states_active_exe+0x38>)
  416496:	4798      	blx	r3
	if (vfd_get_ref_speed() == 0)
  416498:	4b0a      	ldr	r3, [pc, #40]	; (4164c4 <vfd_states_active_exe+0x3c>)
  41649a:	4798      	blx	r3
  41649c:	b100      	cbz	r0, 4164a0 <vfd_states_active_exe+0x18>
  41649e:	bd10      	pop	{r4, pc}
		if(vfd_get_desired_speed() == 0) vfd_states_stop_enter();
  4164a0:	4b09      	ldr	r3, [pc, #36]	; (4164c8 <vfd_states_active_exe+0x40>)
  4164a2:	4798      	blx	r3
  4164a4:	2800      	cmp	r0, #0
  4164a6:	d1fa      	bne.n	41649e <vfd_states_active_exe+0x16>
  4164a8:	4b08      	ldr	r3, [pc, #32]	; (4164cc <vfd_states_active_exe+0x44>)
	vfd_states_active_exit();	
}
  4164aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if(vfd_get_desired_speed() == 0) vfd_states_stop_enter();
  4164ae:	4718      	bx	r3
	if(! vfd_enable_isEnabled()) vfd_states_stop_enter();
  4164b0:	4b06      	ldr	r3, [pc, #24]	; (4164cc <vfd_states_active_exe+0x44>)
  4164b2:	4798      	blx	r3
  4164b4:	e7ec      	b.n	416490 <vfd_states_active_exe+0x8>
  4164b6:	bf00      	nop
  4164b8:	00413241 	.word	0x00413241
  4164bc:	00415465 	.word	0x00415465
  4164c0:	00415315 	.word	0x00415315
  4164c4:	00416989 	.word	0x00416989
  4164c8:	00416995 	.word	0x00416995
  4164cc:	0041638d 	.word	0x0041638d

004164d0 <vfd_states_active_enter>:
{
  4164d0:	b510      	push	{r4, lr}
	inverter_fan_timer_reset();
  4164d2:	4b0f      	ldr	r3, [pc, #60]	; (416510 <vfd_states_active_enter+0x40>)
  4164d4:	4798      	blx	r3
	vfd_clear_c_decay();
  4164d6:	4b0f      	ldr	r3, [pc, #60]	; (416514 <vfd_states_active_enter+0x44>)
  4164d8:	4798      	blx	r3
	if(! vfd_enable_isEnabled()) vfd_states_stop_enter();
  4164da:	4b0f      	ldr	r3, [pc, #60]	; (416518 <vfd_states_active_enter+0x48>)
  4164dc:	4798      	blx	r3
  4164de:	b908      	cbnz	r0, 4164e4 <vfd_states_active_enter+0x14>
  4164e0:	4b0e      	ldr	r3, [pc, #56]	; (41651c <vfd_states_active_enter+0x4c>)
  4164e2:	4798      	blx	r3
	is_stopping = 1;
  4164e4:	480e      	ldr	r0, [pc, #56]	; (416520 <vfd_states_active_enter+0x50>)
  4164e6:	2401      	movs	r4, #1
	vfdstate_ptr = &vfd_states_active_exe;
  4164e8:	4a0e      	ldr	r2, [pc, #56]	; (416524 <vfd_states_active_enter+0x54>)
  4164ea:	490f      	ldr	r1, [pc, #60]	; (416528 <vfd_states_active_enter+0x58>)
	inverter_clear_override();
  4164ec:	4b0f      	ldr	r3, [pc, #60]	; (41652c <vfd_states_active_enter+0x5c>)
	is_stopping = 1;
  4164ee:	7004      	strb	r4, [r0, #0]
	vfdstate_ptr = &vfd_states_active_exe;
  4164f0:	6011      	str	r1, [r2, #0]
	inverter_clear_override();
  4164f2:	4798      	blx	r3
	vfd_states_break_hold_timer = 0;
  4164f4:	4a0e      	ldr	r2, [pc, #56]	; (416530 <vfd_states_active_enter+0x60>)
  4164f6:	2100      	movs	r1, #0
	BRKS_set(1);
  4164f8:	4620      	mov	r0, r4
  4164fa:	4b0e      	ldr	r3, [pc, #56]	; (416534 <vfd_states_active_enter+0x64>)
	vfd_states_break_hold_timer = 0;
  4164fc:	6011      	str	r1, [r2, #0]
	BRKS_set(1);
  4164fe:	4798      	blx	r3
	axt_reset_current_avg();
  416500:	4b0d      	ldr	r3, [pc, #52]	; (416538 <vfd_states_active_enter+0x68>)
  416502:	4798      	blx	r3
	speed_PI_changeLSGains();
  416504:	4b0d      	ldr	r3, [pc, #52]	; (41653c <vfd_states_active_enter+0x6c>)
  416506:	4798      	blx	r3
	vectorpm_PI_changeGains();	
  416508:	4b0d      	ldr	r3, [pc, #52]	; (416540 <vfd_states_active_enter+0x70>)
}
  41650a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vectorpm_PI_changeGains();	
  41650e:	4718      	bx	r3
  416510:	00415465 	.word	0x00415465
  416514:	00416c01 	.word	0x00416c01
  416518:	00413241 	.word	0x00413241
  41651c:	0041638d 	.word	0x0041638d
  416520:	20400bb4 	.word	0x20400bb4
  416524:	20400bcc 	.word	0x20400bcc
  416528:	00416489 	.word	0x00416489
  41652c:	004152b1 	.word	0x004152b1
  416530:	20400bb8 	.word	0x20400bb8
  416534:	00416131 	.word	0x00416131
  416538:	0040e385 	.word	0x0040e385
  41653c:	0040f6c1 	.word	0x0040f6c1
  416540:	00411d61 	.word	0x00411d61

00416544 <vfd_states_stop_exit>:
{
  416544:	b510      	push	{r4, lr}
	if (vfd_get_ref_speed() != 0)
  416546:	4b28      	ldr	r3, [pc, #160]	; (4165e8 <vfd_states_stop_exit+0xa4>)
  416548:	4798      	blx	r3
  41654a:	b910      	cbnz	r0, 416552 <vfd_states_stop_exit+0xe>
	else vfd_states_break_hold_timer = 0;	
  41654c:	4b27      	ldr	r3, [pc, #156]	; (4165ec <vfd_states_stop_exit+0xa8>)
  41654e:	6018      	str	r0, [r3, #0]
  416550:	bd10      	pop	{r4, pc}
		motor_excitation_connect_motor();
  416552:	4b27      	ldr	r3, [pc, #156]	; (4165f0 <vfd_states_stop_exit+0xac>)
  416554:	4798      	blx	r3
		if (motor_excitation_is_motor_connected())
  416556:	4b27      	ldr	r3, [pc, #156]	; (4165f4 <vfd_states_stop_exit+0xb0>)
  416558:	4798      	blx	r3
  41655a:	2800      	cmp	r0, #0
  41655c:	d0f8      	beq.n	416550 <vfd_states_stop_exit+0xc>
			vfd_set_flux_raise(VFD_STATES_BREAK_HOLD_DELAY + VFD_STATES_MOTOR_MOVE_DELAY);
  41655e:	4c26      	ldr	r4, [pc, #152]	; (4165f8 <vfd_states_stop_exit+0xb4>)
			vfd_clear_c_decay();
  416560:	4b26      	ldr	r3, [pc, #152]	; (4165fc <vfd_states_stop_exit+0xb8>)
  416562:	4798      	blx	r3
			vfd_set_flux_raise(VFD_STATES_BREAK_HOLD_DELAY + VFD_STATES_MOTOR_MOVE_DELAY);
  416564:	f8b4 20ca 	ldrh.w	r2, [r4, #202]	; 0xca
  416568:	f8b4 00c8 	ldrh.w	r0, [r4, #200]	; 0xc8
  41656c:	4b24      	ldr	r3, [pc, #144]	; (416600 <vfd_states_stop_exit+0xbc>)
  41656e:	4410      	add	r0, r2
  416570:	4798      	blx	r3
			if (vfd_states_break_hold_timer < VFD_STATES_BREAK_HOLD_DELAY)
  416572:	4a1e      	ldr	r2, [pc, #120]	; (4165ec <vfd_states_stop_exit+0xa8>)
  416574:	f8b4 10c8 	ldrh.w	r1, [r4, #200]	; 0xc8
  416578:	6813      	ldr	r3, [r2, #0]
  41657a:	4299      	cmp	r1, r3
  41657c:	d90e      	bls.n	41659c <vfd_states_stop_exit+0x58>
				vfd_states_break_hold_timer++;
  41657e:	3301      	adds	r3, #1
				inverter_clear_override();
  416580:	4920      	ldr	r1, [pc, #128]	; (416604 <vfd_states_stop_exit+0xc0>)
				vfd_states_break_hold_timer++;
  416582:	6013      	str	r3, [r2, #0]
				inverter_clear_override();
  416584:	4788      	blx	r1
				if (MOTOR_PM_CVC) start_zero_servo();
  416586:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
  41658a:	2b01      	cmp	r3, #1
  41658c:	d1e0      	bne.n	416550 <vfd_states_stop_exit+0xc>
  41658e:	7823      	ldrb	r3, [r4, #0]
  416590:	2b01      	cmp	r3, #1
  416592:	d1dd      	bne.n	416550 <vfd_states_stop_exit+0xc>
  416594:	4b1c      	ldr	r3, [pc, #112]	; (416608 <vfd_states_stop_exit+0xc4>)
}
  416596:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				if (MOTOR_PM_CVC) start_zero_servo();
  41659a:	4718      	bx	r3
				inverter_clear_override();
  41659c:	4b19      	ldr	r3, [pc, #100]	; (416604 <vfd_states_stop_exit+0xc0>)
  41659e:	4798      	blx	r3
				if (MOTOR_PM_CVC) start_zero_servo();
  4165a0:	f894 30c5 	ldrb.w	r3, [r4, #197]	; 0xc5
  4165a4:	2b01      	cmp	r3, #1
  4165a6:	d015      	beq.n	4165d4 <vfd_states_stop_exit+0x90>
				spt_vfd_set_ready_to_open_brake();
  4165a8:	4b18      	ldr	r3, [pc, #96]	; (41660c <vfd_states_stop_exit+0xc8>)
  4165aa:	4798      	blx	r3
				if(spt_permission_brake_open())
  4165ac:	4b18      	ldr	r3, [pc, #96]	; (416610 <vfd_states_stop_exit+0xcc>)
  4165ae:	4798      	blx	r3
  4165b0:	2800      	cmp	r0, #0
  4165b2:	d0cd      	beq.n	416550 <vfd_states_stop_exit+0xc>
					BRKS_set(1);
  4165b4:	4b17      	ldr	r3, [pc, #92]	; (416614 <vfd_states_stop_exit+0xd0>)
  4165b6:	2001      	movs	r0, #1
  4165b8:	4798      	blx	r3
					if (vfd_states_motor_move_timer < VFD_STATES_MOTOR_MOVE_DELAY)
  4165ba:	4a17      	ldr	r2, [pc, #92]	; (416618 <vfd_states_stop_exit+0xd4>)
  4165bc:	f8b4 10ca 	ldrh.w	r1, [r4, #202]	; 0xca
  4165c0:	6813      	ldr	r3, [r2, #0]
  4165c2:	4299      	cmp	r1, r3
  4165c4:	d80c      	bhi.n	4165e0 <vfd_states_stop_exit+0x9c>
					else if (vfd_states_motor_move_timer == VFD_STATES_MOTOR_MOVE_DELAY)
  4165c6:	d1c3      	bne.n	416550 <vfd_states_stop_exit+0xc>
						vfd_states_motor_move_timer++;
  4165c8:	3101      	adds	r1, #1
						vfd_states_active_enter();
  4165ca:	4b14      	ldr	r3, [pc, #80]	; (41661c <vfd_states_stop_exit+0xd8>)
						vfd_states_motor_move_timer++;
  4165cc:	6011      	str	r1, [r2, #0]
}
  4165ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
						vfd_states_active_enter();
  4165d2:	4718      	bx	r3
				if (MOTOR_PM_CVC) start_zero_servo();
  4165d4:	7823      	ldrb	r3, [r4, #0]
  4165d6:	2b01      	cmp	r3, #1
  4165d8:	d1e6      	bne.n	4165a8 <vfd_states_stop_exit+0x64>
  4165da:	4b0b      	ldr	r3, [pc, #44]	; (416608 <vfd_states_stop_exit+0xc4>)
  4165dc:	4798      	blx	r3
  4165de:	e7e3      	b.n	4165a8 <vfd_states_stop_exit+0x64>
						vfd_states_motor_move_timer++;
  4165e0:	3301      	adds	r3, #1
  4165e2:	6013      	str	r3, [r2, #0]
  4165e4:	bd10      	pop	{r4, pc}
  4165e6:	bf00      	nop
  4165e8:	00416989 	.word	0x00416989
  4165ec:	20400bb8 	.word	0x20400bb8
  4165f0:	004160d5 	.word	0x004160d5
  4165f4:	00416125 	.word	0x00416125
  4165f8:	20404ff0 	.word	0x20404ff0
  4165fc:	00416c01 	.word	0x00416c01
  416600:	00416bb5 	.word	0x00416bb5
  416604:	004152b1 	.word	0x004152b1
  416608:	0040f529 	.word	0x0040f529
  41660c:	0040fa01 	.word	0x0040fa01
  416610:	0040f9d5 	.word	0x0040f9d5
  416614:	00416131 	.word	0x00416131
  416618:	20400bc4 	.word	0x20400bc4
  41661c:	004164d1 	.word	0x004164d1

00416620 <vfd_states_trip_enter>:


void vfd_states_trip_enter(void)
{
	vfdstate_ptr = &vfd_states_trip_exe;
  416620:	4a09      	ldr	r2, [pc, #36]	; (416648 <vfd_states_trip_enter+0x28>)
  416622:	490a      	ldr	r1, [pc, #40]	; (41664c <vfd_states_trip_enter+0x2c>)
	inverter_set_override();
  416624:	4b0a      	ldr	r3, [pc, #40]	; (416650 <vfd_states_trip_enter+0x30>)
{
  416626:	b510      	push	{r4, lr}
	vfdstate_ptr = &vfd_states_trip_exe;
  416628:	6011      	str	r1, [r2, #0]
	inverter_set_override();
  41662a:	4798      	blx	r3
	pwm_interface_enablesynchchannels();
  41662c:	4b09      	ldr	r3, [pc, #36]	; (416654 <vfd_states_trip_enter+0x34>)
  41662e:	4798      	blx	r3
	BRKS_set(0);
  416630:	2000      	movs	r0, #0
  416632:	4b09      	ldr	r3, [pc, #36]	; (416658 <vfd_states_trip_enter+0x38>)
  416634:	4798      	blx	r3
	motor_excitation_disconnect_motor();
  416636:	4b09      	ldr	r3, [pc, #36]	; (41665c <vfd_states_trip_enter+0x3c>)
  416638:	4798      	blx	r3
	vfd_activate_reg_reset();
  41663a:	4b09      	ldr	r3, [pc, #36]	; (416660 <vfd_states_trip_enter+0x40>)
  41663c:	4798      	blx	r3
	vfd_clear_c_decay();
  41663e:	4b09      	ldr	r3, [pc, #36]	; (416664 <vfd_states_trip_enter+0x44>)
}
  416640:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vfd_clear_c_decay();
  416644:	4718      	bx	r3
  416646:	bf00      	nop
  416648:	20400bcc 	.word	0x20400bcc
  41664c:	00416705 	.word	0x00416705
  416650:	00415235 	.word	0x00415235
  416654:	00415b11 	.word	0x00415b11
  416658:	00416131 	.word	0x00416131
  41665c:	004160fd 	.word	0x004160fd
  416660:	00416c89 	.word	0x00416c89
  416664:	00416c01 	.word	0x00416c01

00416668 <vfd_states_faults>:
}


uint32_t vfd_states_faults(void)
{
	if(ov_err_pre) return 1;
  416668:	4b11      	ldr	r3, [pc, #68]	; (4166b0 <vfd_states_faults+0x48>)
{
  41666a:	b510      	push	{r4, lr}
	if(ov_err_pre) return 1;
  41666c:	4c11      	ldr	r4, [pc, #68]	; (4166b4 <vfd_states_faults+0x4c>)
  41666e:	7818      	ldrb	r0, [r3, #0]
  416670:	47a0      	blx	r4
  416672:	b108      	cbz	r0, 416678 <vfd_states_faults+0x10>
  416674:	2001      	movs	r0, #1
  416676:	bd10      	pop	{r4, pc}
	if(uv_err_pre) return 1;
  416678:	4b0f      	ldr	r3, [pc, #60]	; (4166b8 <vfd_states_faults+0x50>)
  41667a:	7818      	ldrb	r0, [r3, #0]
  41667c:	47a0      	blx	r4
  41667e:	2800      	cmp	r0, #0
  416680:	d1f8      	bne.n	416674 <vfd_states_faults+0xc>
	if(oc_err_pre) return 1;
  416682:	4b0e      	ldr	r3, [pc, #56]	; (4166bc <vfd_states_faults+0x54>)
  416684:	7818      	ldrb	r0, [r3, #0]
  416686:	47a0      	blx	r4
  416688:	2800      	cmp	r0, #0
  41668a:	d1f3      	bne.n	416674 <vfd_states_faults+0xc>
	if(ol_err_pre) return 1;
  41668c:	4b0c      	ldr	r3, [pc, #48]	; (4166c0 <vfd_states_faults+0x58>)
  41668e:	7818      	ldrb	r0, [r3, #0]
  416690:	47a0      	blx	r4
  416692:	2800      	cmp	r0, #0
  416694:	d1ee      	bne.n	416674 <vfd_states_faults+0xc>
	if(ot_err_pre) return 1;
  416696:	4b0b      	ldr	r3, [pc, #44]	; (4166c4 <vfd_states_faults+0x5c>)
  416698:	7818      	ldrb	r0, [r3, #0]
  41669a:	47a0      	blx	r4
  41669c:	2800      	cmp	r0, #0
  41669e:	d1e9      	bne.n	416674 <vfd_states_faults+0xc>
	if(sc_err_pre) return 1;
  4166a0:	4b09      	ldr	r3, [pc, #36]	; (4166c8 <vfd_states_faults+0x60>)
  4166a2:	7818      	ldrb	r0, [r3, #0]
  4166a4:	47a0      	blx	r4
  4166a6:	3000      	adds	r0, #0
  4166a8:	bf18      	it	ne
  4166aa:	2001      	movne	r0, #1
	return 0;	
}
  4166ac:	bd10      	pop	{r4, pc}
  4166ae:	bf00      	nop
  4166b0:	20406cb1 	.word	0x20406cb1
  4166b4:	004128b9 	.word	0x004128b9
  4166b8:	20406cb2 	.word	0x20406cb2
  4166bc:	20406cac 	.word	0x20406cac
  4166c0:	20406ca5 	.word	0x20406ca5
  4166c4:	20406ca1 	.word	0x20406ca1
  4166c8:	20406c9f 	.word	0x20406c9f

004166cc <vfd_states_trip_exit>:
{
  4166cc:	b510      	push	{r4, lr}
	if (!vfd_states_faults() && (!softcharge))
  4166ce:	4b08      	ldr	r3, [pc, #32]	; (4166f0 <vfd_states_trip_exit+0x24>)
  4166d0:	4798      	blx	r3
  4166d2:	b910      	cbnz	r0, 4166da <vfd_states_trip_exit+0xe>
  4166d4:	4b07      	ldr	r3, [pc, #28]	; (4166f4 <vfd_states_trip_exit+0x28>)
  4166d6:	781b      	ldrb	r3, [r3, #0]
  4166d8:	b103      	cbz	r3, 4166dc <vfd_states_trip_exit+0x10>
  4166da:	bd10      	pop	{r4, pc}
		SCRELAY_On;
  4166dc:	4b06      	ldr	r3, [pc, #24]	; (4166f8 <vfd_states_trip_exit+0x2c>)
  4166de:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  4166e2:	4806      	ldr	r0, [pc, #24]	; (4166fc <vfd_states_trip_exit+0x30>)
  4166e4:	4798      	blx	r3
		vfd_states_stop_enter();
  4166e6:	4b06      	ldr	r3, [pc, #24]	; (416700 <vfd_states_trip_exit+0x34>)
}
  4166e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vfd_states_stop_enter();
  4166ec:	4718      	bx	r3
  4166ee:	bf00      	nop
  4166f0:	00416669 	.word	0x00416669
  4166f4:	20400bb6 	.word	0x20400bb6
  4166f8:	0041743d 	.word	0x0041743d
  4166fc:	400e1200 	.word	0x400e1200
  416700:	0041638d 	.word	0x0041638d

00416704 <vfd_states_trip_exe>:
	if (uv_err_pre)
  416704:	4a08      	ldr	r2, [pc, #32]	; (416728 <vfd_states_trip_exe+0x24>)
  416706:	4b09      	ldr	r3, [pc, #36]	; (41672c <vfd_states_trip_exe+0x28>)
{
  416708:	b510      	push	{r4, lr}
	if (uv_err_pre)
  41670a:	7810      	ldrb	r0, [r2, #0]
  41670c:	4798      	blx	r3
  41670e:	b120      	cbz	r0, 41671a <vfd_states_trip_exe+0x16>
		SCRELAY_Off;
  416710:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  416714:	4806      	ldr	r0, [pc, #24]	; (416730 <vfd_states_trip_exe+0x2c>)
  416716:	4b07      	ldr	r3, [pc, #28]	; (416734 <vfd_states_trip_exe+0x30>)
  416718:	4798      	blx	r3
	inverter_brake_chopper_handler();
  41671a:	4b07      	ldr	r3, [pc, #28]	; (416738 <vfd_states_trip_exe+0x34>)
  41671c:	4798      	blx	r3
	vfd_states_trip_exit();	
  41671e:	4b07      	ldr	r3, [pc, #28]	; (41673c <vfd_states_trip_exe+0x38>)
}
  416720:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vfd_states_trip_exit();	
  416724:	4718      	bx	r3
  416726:	bf00      	nop
  416728:	20406cb2 	.word	0x20406cb2
  41672c:	004128b9 	.word	0x004128b9
  416730:	400e1200 	.word	0x400e1200
  416734:	00417441 	.word	0x00417441
  416738:	00415315 	.word	0x00415315
  41673c:	004166cd 	.word	0x004166cd

00416740 <vfd_states_handler>:

void vfd_states_handler(void)
{
  416740:	b570      	push	{r4, r5, r6, lr}
	if(vfdstate_ptr == 0) vfd_states_init_enter();
  416742:	4d0a      	ldr	r5, [pc, #40]	; (41676c <vfd_states_handler+0x2c>)
  416744:	682c      	ldr	r4, [r5, #0]
  416746:	b11c      	cbz	r4, 416750 <vfd_states_handler+0x10>
	(*vfdstate_ptr)();	
  416748:	4623      	mov	r3, r4
}
  41674a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(*vfdstate_ptr)();	
  41674e:	4718      	bx	r3
	vfdstate_ptr = &vfd_states_init_exe;
  416750:	4a07      	ldr	r2, [pc, #28]	; (416770 <vfd_states_handler+0x30>)
	pwm_interface_init();
  416752:	4b08      	ldr	r3, [pc, #32]	; (416774 <vfd_states_handler+0x34>)
	vfdstate_ptr = &vfd_states_init_exe;
  416754:	602a      	str	r2, [r5, #0]
	pwm_interface_init();
  416756:	4798      	blx	r3
	adc_interface_init();
  416758:	4b07      	ldr	r3, [pc, #28]	; (416778 <vfd_states_handler+0x38>)
  41675a:	4798      	blx	r3
	init_delay_counter = 0;	
  41675c:	4b07      	ldr	r3, [pc, #28]	; (41677c <vfd_states_handler+0x3c>)
  41675e:	601c      	str	r4, [r3, #0]
  416760:	682c      	ldr	r4, [r5, #0]
	(*vfdstate_ptr)();	
  416762:	4623      	mov	r3, r4
}
  416764:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	(*vfdstate_ptr)();	
  416768:	4718      	bx	r3
  41676a:	bf00      	nop
  41676c:	20400bcc 	.word	0x20400bcc
  416770:	00416439 	.word	0x00416439
  416774:	0041572d 	.word	0x0041572d
  416778:	00414949 	.word	0x00414949
  41677c:	20400bb0 	.word	0x20400bb0

00416780 <vfd_states_estop>:

void vfd_states_estop(void)
{
  416780:	b510      	push	{r4, lr}
	inverter_set_override();
  416782:	4b0b      	ldr	r3, [pc, #44]	; (4167b0 <vfd_states_estop+0x30>)
  416784:	4798      	blx	r3
	//todo break release routine
	BRKS_set(0);
  416786:	4b0b      	ldr	r3, [pc, #44]	; (4167b4 <vfd_states_estop+0x34>)
  416788:	2000      	movs	r0, #0
  41678a:	4798      	blx	r3
	if(vfdstate_ptr == &vfd_states_trip_exe) return 0;
  41678c:	4b0a      	ldr	r3, [pc, #40]	; (4167b8 <vfd_states_estop+0x38>)
  41678e:	4a0b      	ldr	r2, [pc, #44]	; (4167bc <vfd_states_estop+0x3c>)
  416790:	681b      	ldr	r3, [r3, #0]
	if(vfdstate_ptr == &vfd_states_stop_exe) return 0;
  416792:	4293      	cmp	r3, r2
  416794:	d004      	beq.n	4167a0 <vfd_states_estop+0x20>
  416796:	4a0a      	ldr	r2, [pc, #40]	; (4167c0 <vfd_states_estop+0x40>)
  416798:	4293      	cmp	r3, r2
  41679a:	d001      	beq.n	4167a0 <vfd_states_estop+0x20>
	if(vfd_states_allowedtostop()) vfd_states_stop_enter();	
  41679c:	4b09      	ldr	r3, [pc, #36]	; (4167c4 <vfd_states_estop+0x44>)
  41679e:	4798      	blx	r3
	is_stopping = 0;
  4167a0:	4a09      	ldr	r2, [pc, #36]	; (4167c8 <vfd_states_estop+0x48>)
  4167a2:	2100      	movs	r1, #0
	vfd_clear_c_decay();
  4167a4:	4b09      	ldr	r3, [pc, #36]	; (4167cc <vfd_states_estop+0x4c>)
	is_stopping = 0;
  4167a6:	7011      	strb	r1, [r2, #0]
}
  4167a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vfd_clear_c_decay();
  4167ac:	4718      	bx	r3
  4167ae:	bf00      	nop
  4167b0:	00415235 	.word	0x00415235
  4167b4:	00416131 	.word	0x00416131
  4167b8:	20400bcc 	.word	0x20400bcc
  4167bc:	00416705 	.word	0x00416705
  4167c0:	00416185 	.word	0x00416185
  4167c4:	0041638d 	.word	0x0041638d
  4167c8:	20400bb4 	.word	0x20400bb4
  4167cc:	00416c01 	.word	0x00416c01

004167d0 <vfd_states_trip>:

void vfd_states_trip(void)
{
  4167d0:	b510      	push	{r4, lr}
	inverter_set_override();
  4167d2:	4b04      	ldr	r3, [pc, #16]	; (4167e4 <vfd_states_trip+0x14>)
  4167d4:	4798      	blx	r3
	//todo break release routine
	BRKS_set(0);
  4167d6:	4b04      	ldr	r3, [pc, #16]	; (4167e8 <vfd_states_trip+0x18>)
  4167d8:	2000      	movs	r0, #0
  4167da:	4798      	blx	r3
	vfd_states_trip_enter();
  4167dc:	4b03      	ldr	r3, [pc, #12]	; (4167ec <vfd_states_trip+0x1c>)
}
  4167de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vfd_states_trip_enter();
  4167e2:	4718      	bx	r3
  4167e4:	00415235 	.word	0x00415235
  4167e8:	00416131 	.word	0x00416131
  4167ec:	00416621 	.word	0x00416621

004167f0 <vfd_states_tune_enter>:

void vfd_states_tune_enter(void)
{
  4167f0:	b508      	push	{r3, lr}
	if(! vfd_enable_isEnabled()) vfd_states_stop_enter();
  4167f2:	4b0d      	ldr	r3, [pc, #52]	; (416828 <vfd_states_tune_enter+0x38>)
  4167f4:	4798      	blx	r3
  4167f6:	b908      	cbnz	r0, 4167fc <vfd_states_tune_enter+0xc>
  4167f8:	4b0c      	ldr	r3, [pc, #48]	; (41682c <vfd_states_tune_enter+0x3c>)
  4167fa:	4798      	blx	r3
	is_stopping = 0;
  4167fc:	4a0c      	ldr	r2, [pc, #48]	; (416830 <vfd_states_tune_enter+0x40>)
  4167fe:	2100      	movs	r1, #0

	inverter_clear_override();
  416800:	4b0c      	ldr	r3, [pc, #48]	; (416834 <vfd_states_tune_enter+0x44>)
	is_stopping = 0;
  416802:	7011      	strb	r1, [r2, #0]
	inverter_clear_override();
  416804:	4798      	blx	r3
	motor_excitation_connect_motor();
  416806:	4b0c      	ldr	r3, [pc, #48]	; (416838 <vfd_states_tune_enter+0x48>)
  416808:	4798      	blx	r3
	axt_reset_current_avg();
  41680a:	4b0c      	ldr	r3, [pc, #48]	; (41683c <vfd_states_tune_enter+0x4c>)
  41680c:	4798      	blx	r3
	SPMtune_init();
  41680e:	4b0c      	ldr	r3, [pc, #48]	; (416840 <vfd_states_tune_enter+0x50>)
  416810:	4798      	blx	r3
	pm_param_tune1_init();
  416812:	4b0c      	ldr	r3, [pc, #48]	; (416844 <vfd_states_tune_enter+0x54>)
  416814:	4798      	blx	r3
	PM_param_tune2_init();
  416816:	4b0c      	ldr	r3, [pc, #48]	; (416848 <vfd_states_tune_enter+0x58>)
  416818:	4798      	blx	r3
	IM_param_tune1_init();
  41681a:	4b0c      	ldr	r3, [pc, #48]	; (41684c <vfd_states_tune_enter+0x5c>)
  41681c:	4798      	blx	r3
	
	vfdstate_ptr = &vfd_states_tune_exe;
  41681e:	4b0c      	ldr	r3, [pc, #48]	; (416850 <vfd_states_tune_enter+0x60>)
  416820:	4a0c      	ldr	r2, [pc, #48]	; (416854 <vfd_states_tune_enter+0x64>)
  416822:	601a      	str	r2, [r3, #0]
  416824:	bd08      	pop	{r3, pc}
  416826:	bf00      	nop
  416828:	00413241 	.word	0x00413241
  41682c:	0041638d 	.word	0x0041638d
  416830:	20400bb4 	.word	0x20400bb4
  416834:	004152b1 	.word	0x004152b1
  416838:	004160d5 	.word	0x004160d5
  41683c:	0040e385 	.word	0x0040e385
  416840:	004111a1 	.word	0x004111a1
  416844:	00410561 	.word	0x00410561
  416848:	00410dc9 	.word	0x00410dc9
  41684c:	004104d1 	.word	0x004104d1
  416850:	20400bcc 	.word	0x20400bcc
  416854:	00416911 	.word	0x00416911

00416858 <vfd_states_csc_exit>:
{
  416858:	b510      	push	{r4, lr}
	if (vfd_get_ref_speed() != 0)
  41685a:	4b12      	ldr	r3, [pc, #72]	; (4168a4 <vfd_states_csc_exit+0x4c>)
  41685c:	4798      	blx	r3
  41685e:	b128      	cbz	r0, 41686c <vfd_states_csc_exit+0x14>
		inverter_clear_override();
  416860:	4b11      	ldr	r3, [pc, #68]	; (4168a8 <vfd_states_csc_exit+0x50>)
  416862:	4798      	blx	r3
		if (scCheck_exe())
  416864:	4b11      	ldr	r3, [pc, #68]	; (4168ac <vfd_states_csc_exit+0x54>)
  416866:	4798      	blx	r3
  416868:	b930      	cbnz	r0, 416878 <vfd_states_csc_exit+0x20>
  41686a:	bd10      	pop	{r4, pc}
		sc_testing = 0;
  41686c:	4a10      	ldr	r2, [pc, #64]	; (4168b0 <vfd_states_csc_exit+0x58>)
		vfd_states_stop_enter();
  41686e:	4b11      	ldr	r3, [pc, #68]	; (4168b4 <vfd_states_csc_exit+0x5c>)
		sc_testing = 0;
  416870:	7010      	strb	r0, [r2, #0]
}
  416872:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vfd_states_stop_enter();
  416876:	4718      	bx	r3
			sc_testing = 0;
  416878:	4a0d      	ldr	r2, [pc, #52]	; (4168b0 <vfd_states_csc_exit+0x58>)
  41687a:	2400      	movs	r4, #0
			SC_LEVEL_HIGH;
  41687c:	4b0e      	ldr	r3, [pc, #56]	; (4168b8 <vfd_states_csc_exit+0x60>)
  41687e:	2110      	movs	r1, #16
  416880:	480e      	ldr	r0, [pc, #56]	; (4168bc <vfd_states_csc_exit+0x64>)
			sc_testing = 0;
  416882:	7014      	strb	r4, [r2, #0]
			SC_LEVEL_HIGH;
  416884:	4798      	blx	r3
			if ((MOTOR_TUNE)||(ENCODER_TUNE))
  416886:	4b0e      	ldr	r3, [pc, #56]	; (4168c0 <vfd_states_csc_exit+0x68>)
  416888:	781b      	ldrb	r3, [r3, #0]
  41688a:	b913      	cbnz	r3, 416892 <vfd_states_csc_exit+0x3a>
  41688c:	4b0d      	ldr	r3, [pc, #52]	; (4168c4 <vfd_states_csc_exit+0x6c>)
  41688e:	781b      	ldrb	r3, [r3, #0]
  416890:	b11b      	cbz	r3, 41689a <vfd_states_csc_exit+0x42>
				vfd_states_tune_enter();
  416892:	4b0d      	ldr	r3, [pc, #52]	; (4168c8 <vfd_states_csc_exit+0x70>)
}
  416894:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vfd_states_tune_enter();
  416898:	4718      	bx	r3
				vfd_states_stop_exit();
  41689a:	4b0c      	ldr	r3, [pc, #48]	; (4168cc <vfd_states_csc_exit+0x74>)
}
  41689c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vfd_states_stop_exit();
  4168a0:	4718      	bx	r3
  4168a2:	bf00      	nop
  4168a4:	00416989 	.word	0x00416989
  4168a8:	004152b1 	.word	0x004152b1
  4168ac:	00415b95 	.word	0x00415b95
  4168b0:	20400bb5 	.word	0x20400bb5
  4168b4:	0041638d 	.word	0x0041638d
  4168b8:	00417441 	.word	0x00417441
  4168bc:	400e1600 	.word	0x400e1600
  4168c0:	204008e9 	.word	0x204008e9
  4168c4:	204008e8 	.word	0x204008e8
  4168c8:	004167f1 	.word	0x004167f1
  4168cc:	00416545 	.word	0x00416545

004168d0 <vfd_states_csc_exe>:
	vfd_states_csc_exit();
  4168d0:	4b00      	ldr	r3, [pc, #0]	; (4168d4 <vfd_states_csc_exe+0x4>)
  4168d2:	4718      	bx	r3
  4168d4:	00416859 	.word	0x00416859

004168d8 <vfd_states_tune_exit>:
}
void vfd_states_tune_exit(void)
{
  4168d8:	b510      	push	{r4, lr}
	if (vfd_get_ref_speed() == 0)
  4168da:	4b08      	ldr	r3, [pc, #32]	; (4168fc <vfd_states_tune_exit+0x24>)
  4168dc:	4798      	blx	r3
  4168de:	b100      	cbz	r0, 4168e2 <vfd_states_tune_exit+0xa>
  4168e0:	bd10      	pop	{r4, pc}
	{
		if(vfd_get_desired_speed() == 0) 
  4168e2:	4b07      	ldr	r3, [pc, #28]	; (416900 <vfd_states_tune_exit+0x28>)
  4168e4:	4798      	blx	r3
  4168e6:	4604      	mov	r4, r0
  4168e8:	2800      	cmp	r0, #0
  4168ea:	d1f9      	bne.n	4168e0 <vfd_states_tune_exit+0x8>
		{
			vfd_states_stop_enter();
  4168ec:	4b05      	ldr	r3, [pc, #20]	; (416904 <vfd_states_tune_exit+0x2c>)
  4168ee:	4798      	blx	r3
			MOTOR_TUNE = 0;
  4168f0:	4a05      	ldr	r2, [pc, #20]	; (416908 <vfd_states_tune_exit+0x30>)
			ENCODER_TUNE = 0;
  4168f2:	4b06      	ldr	r3, [pc, #24]	; (41690c <vfd_states_tune_exit+0x34>)
			MOTOR_TUNE = 0;
  4168f4:	7014      	strb	r4, [r2, #0]
			ENCODER_TUNE = 0;
  4168f6:	701c      	strb	r4, [r3, #0]
  4168f8:	bd10      	pop	{r4, pc}
  4168fa:	bf00      	nop
  4168fc:	00416989 	.word	0x00416989
  416900:	00416995 	.word	0x00416995
  416904:	0041638d 	.word	0x0041638d
  416908:	204008e9 	.word	0x204008e9
  41690c:	204008e8 	.word	0x204008e8

00416910 <vfd_states_tune_exe>:
		}
	}
}
void vfd_states_tune_exe(void)
{
  416910:	b510      	push	{r4, lr}
	if(! vfd_enable_isEnabled()) 
  416912:	4b09      	ldr	r3, [pc, #36]	; (416938 <vfd_states_tune_exe+0x28>)
  416914:	4798      	blx	r3
  416916:	b930      	cbnz	r0, 416926 <vfd_states_tune_exe+0x16>
	{
		vfd_states_stop_enter();
  416918:	4b08      	ldr	r3, [pc, #32]	; (41693c <vfd_states_tune_exe+0x2c>)
  41691a:	4604      	mov	r4, r0
  41691c:	4798      	blx	r3
		MOTOR_TUNE = 0;
  41691e:	4a08      	ldr	r2, [pc, #32]	; (416940 <vfd_states_tune_exe+0x30>)
		ENCODER_TUNE = 0;
  416920:	4b08      	ldr	r3, [pc, #32]	; (416944 <vfd_states_tune_exe+0x34>)
		MOTOR_TUNE = 0;
  416922:	7014      	strb	r4, [r2, #0]
		ENCODER_TUNE = 0;
  416924:	701c      	strb	r4, [r3, #0]
	}
	inverter_brake_chopper_handler();
  416926:	4b08      	ldr	r3, [pc, #32]	; (416948 <vfd_states_tune_exe+0x38>)
  416928:	4798      	blx	r3
	vfd_states_tune_exit();
  41692a:	4b08      	ldr	r3, [pc, #32]	; (41694c <vfd_states_tune_exe+0x3c>)
  41692c:	4798      	blx	r3
	inverter_fan_timer_reset();
  41692e:	4b08      	ldr	r3, [pc, #32]	; (416950 <vfd_states_tune_exe+0x40>)
  416930:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	inverter_fan_timer_reset();
  416934:	4718      	bx	r3
  416936:	bf00      	nop
  416938:	00413241 	.word	0x00413241
  41693c:	0041638d 	.word	0x0041638d
  416940:	204008e9 	.word	0x204008e9
  416944:	204008e8 	.word	0x204008e8
  416948:	00415315 	.word	0x00415315
  41694c:	004168d9 	.word	0x004168d9
  416950:	00415465 	.word	0x00415465

00416954 <vfd_flux_raise_exe.part.1>:

void vfd_flux_raise_exe(void)
{
	if (flux_raise_permission == 0) return;
	
	if (flux_ratio < 1)
  416954:	4b0a      	ldr	r3, [pc, #40]	; (416980 <vfd_flux_raise_exe.part.1+0x2c>)
  416956:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  41695a:	ed93 7a00 	vldr	s14, [r3]
  41695e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  416962:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416966:	d402      	bmi.n	41696e <vfd_flux_raise_exe.part.1+0x1a>
	{
		flux_ratio += flux_rat_raise_step;
	}
	else flux_ratio = 1;
  416968:	edc3 7a00 	vstr	s15, [r3]
  41696c:	4770      	bx	lr
		flux_ratio += flux_rat_raise_step;
  41696e:	4a05      	ldr	r2, [pc, #20]	; (416984 <vfd_flux_raise_exe.part.1+0x30>)
  416970:	edd2 7a00 	vldr	s15, [r2]
  416974:	ee37 7a87 	vadd.f32	s14, s15, s14
  416978:	ed83 7a00 	vstr	s14, [r3]
  41697c:	4770      	bx	lr
  41697e:	bf00      	nop
  416980:	20400bf8 	.word	0x20400bf8
  416984:	20400bf0 	.word	0x20400bf0

00416988 <vfd_get_ref_speed>:
	return ref_speed;
  416988:	4b01      	ldr	r3, [pc, #4]	; (416990 <vfd_get_ref_speed+0x8>)
}
  41698a:	6818      	ldr	r0, [r3, #0]
  41698c:	4770      	bx	lr
  41698e:	bf00      	nop
  416990:	20400c00 	.word	0x20400c00

00416994 <vfd_get_desired_speed>:
	return desired_speed;
  416994:	4b01      	ldr	r3, [pc, #4]	; (41699c <vfd_get_desired_speed+0x8>)
}
  416996:	6818      	ldr	r0, [r3, #0]
  416998:	4770      	bx	lr
  41699a:	bf00      	nop
  41699c:	20400be8 	.word	0x20400be8

004169a0 <vfd_get_desired_distance>:
	return desired_distance;
  4169a0:	4b01      	ldr	r3, [pc, #4]	; (4169a8 <vfd_get_desired_distance+0x8>)
}
  4169a2:	6818      	ldr	r0, [r3, #0]
  4169a4:	4770      	bx	lr
  4169a6:	bf00      	nop
  4169a8:	20400be4 	.word	0x20400be4

004169ac <vfd_is_constant_speed>:
	if (fixedpt_abs(ref_speed) > 0)
  4169ac:	4b04      	ldr	r3, [pc, #16]	; (4169c0 <vfd_is_constant_speed+0x14>)
  4169ae:	6818      	ldr	r0, [r3, #0]
  4169b0:	b128      	cbz	r0, 4169be <vfd_is_constant_speed+0x12>
		if(desired_speed == ref_speed)
  4169b2:	4b04      	ldr	r3, [pc, #16]	; (4169c4 <vfd_is_constant_speed+0x18>)
  4169b4:	681b      	ldr	r3, [r3, #0]
  4169b6:	1a18      	subs	r0, r3, r0
  4169b8:	fab0 f080 	clz	r0, r0
  4169bc:	0940      	lsrs	r0, r0, #5
}
  4169be:	4770      	bx	lr
  4169c0:	20400c00 	.word	0x20400c00
  4169c4:	20400be8 	.word	0x20400be8

004169c8 <vfd_get_accelerating_stage>:
	return acc_dec;
  4169c8:	4b01      	ldr	r3, [pc, #4]	; (4169d0 <vfd_get_accelerating_stage+0x8>)
}
  4169ca:	6818      	ldr	r0, [r3, #0]
  4169cc:	4770      	bx	lr
  4169ce:	bf00      	nop
  4169d0:	20400bd0 	.word	0x20400bd0

004169d4 <vfd_scurve_exe>:
{
  4169d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (vfd_states_allowedtomove() == 0)
  4169d8:	4b1d      	ldr	r3, [pc, #116]	; (416a50 <vfd_scurve_exe+0x7c>)
{
  4169da:	b082      	sub	sp, #8
	if (vfd_states_allowedtomove() == 0)
  4169dc:	4798      	blx	r3
  4169de:	b130      	cbz	r0, 4169ee <vfd_scurve_exe+0x1a>
	else if(speed_ref_stage == 1)
  4169e0:	4c1c      	ldr	r4, [pc, #112]	; (416a54 <vfd_scurve_exe+0x80>)
  4169e2:	6825      	ldr	r5, [r4, #0]
  4169e4:	2d01      	cmp	r5, #1
  4169e6:	d007      	beq.n	4169f8 <vfd_scurve_exe+0x24>
}
  4169e8:	b002      	add	sp, #8
  4169ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		desired_speed = 0;
  4169ee:	4b1a      	ldr	r3, [pc, #104]	; (416a58 <vfd_scurve_exe+0x84>)
  4169f0:	6018      	str	r0, [r3, #0]
}
  4169f2:	b002      	add	sp, #8
  4169f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		fixedpt t = fixedpt_rconst(0.001) * time_tick;
  4169f8:	4e18      	ldr	r6, [pc, #96]	; (416a5c <vfd_scurve_exe+0x88>)
		scurve_exe(&scurve_speed, t, &desired_speed, &desired_distance, &c_acceleration, &speed_ref_stage);
  4169fa:	4f17      	ldr	r7, [pc, #92]	; (416a58 <vfd_scurve_exe+0x84>)
		fixedpt t = fixedpt_rconst(0.001) * time_tick;
  4169fc:	6831      	ldr	r1, [r6, #0]
		scurve_exe(&scurve_speed, t, &desired_speed, &desired_distance, &c_acceleration, &speed_ref_stage);
  4169fe:	4b18      	ldr	r3, [pc, #96]	; (416a60 <vfd_scurve_exe+0x8c>)
  416a00:	463a      	mov	r2, r7
  416a02:	eb01 1141 	add.w	r1, r1, r1, lsl #5
  416a06:	9401      	str	r4, [sp, #4]
  416a08:	9300      	str	r3, [sp, #0]
  416a0a:	4816      	ldr	r0, [pc, #88]	; (416a64 <vfd_scurve_exe+0x90>)
  416a0c:	4b16      	ldr	r3, [pc, #88]	; (416a68 <vfd_scurve_exe+0x94>)
  416a0e:	f8df 8064 	ldr.w	r8, [pc, #100]	; 416a74 <vfd_scurve_exe+0xa0>
  416a12:	47c0      	blx	r8
		if (fixedpt_abs(desired_speed) < fixedpt_abs(ref_speed))
  416a14:	4a15      	ldr	r2, [pc, #84]	; (416a6c <vfd_scurve_exe+0x98>)
  416a16:	683b      	ldr	r3, [r7, #0]
  416a18:	6812      	ldr	r2, [r2, #0]
  416a1a:	2b00      	cmp	r3, #0
  416a1c:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
  416a20:	bfb8      	it	lt
  416a22:	425b      	neglt	r3, r3
  416a24:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
  416a28:	428b      	cmp	r3, r1
  416a2a:	da0c      	bge.n	416a46 <vfd_scurve_exe+0x72>
			acc_dec = 1;
  416a2c:	4b10      	ldr	r3, [pc, #64]	; (416a70 <vfd_scurve_exe+0x9c>)
  416a2e:	601d      	str	r5, [r3, #0]
		if (speed_ref_stage == 0)
  416a30:	6823      	ldr	r3, [r4, #0]
  416a32:	b913      	cbnz	r3, 416a3a <vfd_scurve_exe+0x66>
			acc_dec = 0;
  416a34:	490e      	ldr	r1, [pc, #56]	; (416a70 <vfd_scurve_exe+0x9c>)
			desired_speed = ref_speed;
  416a36:	603a      	str	r2, [r7, #0]
			acc_dec = 0;
  416a38:	600b      	str	r3, [r1, #0]
		time_tick++;
  416a3a:	6833      	ldr	r3, [r6, #0]
  416a3c:	3301      	adds	r3, #1
  416a3e:	6033      	str	r3, [r6, #0]
}
  416a40:	b002      	add	sp, #8
  416a42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		else if (fixedpt_abs(desired_speed) > fixedpt_abs(ref_speed))
  416a46:	ddf3      	ble.n	416a30 <vfd_scurve_exe+0x5c>
			acc_dec = 2;
  416a48:	4b09      	ldr	r3, [pc, #36]	; (416a70 <vfd_scurve_exe+0x9c>)
  416a4a:	2102      	movs	r1, #2
  416a4c:	6019      	str	r1, [r3, #0]
  416a4e:	e7ef      	b.n	416a30 <vfd_scurve_exe+0x5c>
  416a50:	00416305 	.word	0x00416305
  416a54:	20400c0c 	.word	0x20400c0c
  416a58:	20400be8 	.word	0x20400be8
  416a5c:	20400c10 	.word	0x20400c10
  416a60:	20400bd4 	.word	0x20400bd4
  416a64:	20406344 	.word	0x20406344
  416a68:	20400be4 	.word	0x20400be4
  416a6c:	20400c00 	.word	0x20400c00
  416a70:	20400bd0 	.word	0x20400bd0
  416a74:	0040eaa9 	.word	0x0040eaa9

00416a78 <check_speed_deviation>:
{
  416a78:	b510      	push	{r4, lr}
	if (SPEED_DEVIATION == 0) return; //speed deviation error disabled
  416a7a:	4c2a      	ldr	r4, [pc, #168]	; (416b24 <check_speed_deviation+0xac>)
  416a7c:	f8b4 308e 	ldrh.w	r3, [r4, #142]	; 0x8e
{
  416a80:	ed2d 8b02 	vpush	{d8}
	if (SPEED_DEVIATION == 0) return; //speed deviation error disabled
  416a84:	b38b      	cbz	r3, 416aea <check_speed_deviation+0x72>
  416a86:	ee05 1a10 	vmov	s10, r1
	base_speed /= MOTOR_POLEPAIR;
  416a8a:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
	float base_speed = (menue_drive_data_applied.m_motor_rated_freq);
  416a8e:	ed94 6a02 	vldr	s12, [r4, #8]
  416a92:	ee05 0a90 	vmov	s11, r0
	base_speed /= MOTOR_POLEPAIR;
  416a96:	ee06 1a90 	vmov	s13, r1
	base_speed *= M_TWO_PI;
  416a9a:	ed9f 4a23 	vldr	s8, [pc, #140]	; 416b28 <check_speed_deviation+0xb0>
	base_speed /= FIXEDPT_ONE;
  416a9e:	eeba 6ae8 	vcvt.f32.s32	s12, s12, #15
	float dev = fixedpt_abs(((measured_speed - cmd_speed)/base_speed) * 100);
  416aa2:	eddf 4a22 	vldr	s9, [pc, #136]	; 416b2c <check_speed_deviation+0xb4>
	base_speed /= MOTOR_POLEPAIR;
  416aa6:	eef8 6ae6 	vcvt.f32.s32	s13, s13
	float dev = fixedpt_abs(((measured_speed - cmd_speed)/base_speed) * 100);
  416aaa:	ee35 7a65 	vsub.f32	s14, s10, s11
	base_speed /= MOTOR_POLEPAIR;
  416aae:	eec6 7a26 	vdiv.f32	s15, s12, s13
	base_speed *= M_TWO_PI;
  416ab2:	ee67 7a84 	vmul.f32	s15, s15, s8
	float dev = fixedpt_abs(((measured_speed - cmd_speed)/base_speed) * 100);
  416ab6:	ee87 8a27 	vdiv.f32	s16, s14, s15
  416aba:	ee28 8a24 	vmul.f32	s16, s16, s9
  416abe:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  416ac2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416ac6:	d420      	bmi.n	416b0a <check_speed_deviation+0x92>
	if((dev >= SPEED_DEVIATION) && fault_set) 
  416ac8:	ee07 3a90 	vmov	s15, r3
  416acc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  416ad0:	eeb4 8a67 	vcmp.f32	s16, s15
  416ad4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416ad8:	db0c      	blt.n	416af4 <check_speed_deviation+0x7c>
  416ada:	b15a      	cbz	r2, 416af4 <check_speed_deviation+0x7c>
		if(speed_dev_timer_counter < SPEED_DEVIATION_TIME)
  416adc:	4a14      	ldr	r2, [pc, #80]	; (416b30 <check_speed_deviation+0xb8>)
  416ade:	6813      	ldr	r3, [r2, #0]
  416ae0:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  416ae4:	d218      	bcs.n	416b18 <check_speed_deviation+0xa0>
			speed_dev_timer_counter++;
  416ae6:	3301      	adds	r3, #1
  416ae8:	6013      	str	r3, [r2, #0]
}
  416aea:	ee18 0a10 	vmov	r0, s16
  416aee:	ecbd 8b02 	vpop	{d8}
  416af2:	bd10      	pop	{r4, pc}
		if (speed_dev_timer_counter > 0) 
  416af4:	4a0e      	ldr	r2, [pc, #56]	; (416b30 <check_speed_deviation+0xb8>)
  416af6:	6813      	ldr	r3, [r2, #0]
  416af8:	2b00      	cmp	r3, #0
  416afa:	d0f6      	beq.n	416aea <check_speed_deviation+0x72>
			speed_dev_timer_counter--;
  416afc:	3b01      	subs	r3, #1
}
  416afe:	ee18 0a10 	vmov	r0, s16
			speed_dev_timer_counter--;
  416b02:	6013      	str	r3, [r2, #0]
}
  416b04:	ecbd 8b02 	vpop	{d8}
  416b08:	bd10      	pop	{r4, pc}
	float dev = fixedpt_abs(((measured_speed - cmd_speed)/base_speed) * 100);
  416b0a:	ee75 5ac5 	vsub.f32	s11, s11, s10
  416b0e:	ee85 8aa7 	vdiv.f32	s16, s11, s15
  416b12:	ee28 8a24 	vmul.f32	s16, s16, s9
  416b16:	e7d7      	b.n	416ac8 <check_speed_deviation+0x50>
			speedDev_set; //todo dev_fault
  416b18:	4a06      	ldr	r2, [pc, #24]	; (416b34 <check_speed_deviation+0xbc>)
  416b1a:	4b07      	ldr	r3, [pc, #28]	; (416b38 <check_speed_deviation+0xc0>)
  416b1c:	7810      	ldrb	r0, [r2, #0]
  416b1e:	4798      	blx	r3
  416b20:	e7e3      	b.n	416aea <check_speed_deviation+0x72>
  416b22:	bf00      	nop
  416b24:	20404ff0 	.word	0x20404ff0
  416b28:	40c90fdb 	.word	0x40c90fdb
  416b2c:	42c80000 	.word	0x42c80000
  416b30:	20400c08 	.word	0x20400c08
  416b34:	20406cab 	.word	0x20406cab
  416b38:	0041282d 	.word	0x0041282d

00416b3c <regulators_init>:
{
  416b3c:	b510      	push	{r4, lr}
	vector_PM_init();
  416b3e:	4b04      	ldr	r3, [pc, #16]	; (416b50 <regulators_init+0x14>)
  416b40:	4798      	blx	r3
	vector_IM_init();
  416b42:	4b04      	ldr	r3, [pc, #16]	; (416b54 <regulators_init+0x18>)
  416b44:	4798      	blx	r3
	speed_PI_init();
  416b46:	4b04      	ldr	r3, [pc, #16]	; (416b58 <regulators_init+0x1c>)
}
  416b48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	speed_PI_init();
  416b4c:	4718      	bx	r3
  416b4e:	bf00      	nop
  416b50:	00411c81 	.word	0x00411c81
  416b54:	00411931 	.word	0x00411931
  416b58:	0040f5c9 	.word	0x0040f5c9

00416b5c <vfd_set_c_decay>:
{
  416b5c:	b508      	push	{r3, lr}
	current_decay_step = -cmd_tourque / decay_period;
  416b5e:	ee07 0a90 	vmov	s15, r0
  416b62:	4b0e      	ldr	r3, [pc, #56]	; (416b9c <vfd_set_c_decay+0x40>)
	flux_rat_step = -1.0 / flux_rat_step;
  416b64:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
	current_decay_step = -cmd_tourque / decay_period;
  416b68:	4a0d      	ldr	r2, [pc, #52]	; (416ba0 <vfd_set_c_decay+0x44>)
  416b6a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  416b6e:	edd3 7a00 	vldr	s15, [r3]
	flux_rat_step = -1.0 / flux_rat_step;
  416b72:	490c      	ldr	r1, [pc, #48]	; (416ba4 <vfd_set_c_decay+0x48>)
	current_decay_step = -cmd_tourque / decay_period;
  416b74:	eef1 7a67 	vneg.f32	s15, s15
	speed_PI_init();
  416b78:	4b0b      	ldr	r3, [pc, #44]	; (416ba8 <vfd_set_c_decay+0x4c>)
	flux_rat_step = -1.0 / flux_rat_step;
  416b7a:	ee86 6a87 	vdiv.f32	s12, s13, s14
	current_decay_step = -cmd_tourque / decay_period;
  416b7e:	eec7 6a87 	vdiv.f32	s13, s15, s14
	flux_rat_step = -1.0 / flux_rat_step;
  416b82:	ed81 6a00 	vstr	s12, [r1]
	current_decay_step = -cmd_tourque / decay_period;
  416b86:	edc2 6a00 	vstr	s13, [r2]
	speed_PI_init();
  416b8a:	4798      	blx	r3
	c_decay_f = 1;
  416b8c:	4907      	ldr	r1, [pc, #28]	; (416bac <vfd_set_c_decay+0x50>)
  416b8e:	2001      	movs	r0, #1
	flux_raise_permission = 0;
  416b90:	4b07      	ldr	r3, [pc, #28]	; (416bb0 <vfd_set_c_decay+0x54>)
  416b92:	2200      	movs	r2, #0
	c_decay_f = 1;
  416b94:	7008      	strb	r0, [r1, #0]
	flux_raise_permission = 0;
  416b96:	601a      	str	r2, [r3, #0]
  416b98:	bd08      	pop	{r3, pc}
  416b9a:	bf00      	nop
  416b9c:	20400bdc 	.word	0x20400bdc
  416ba0:	20400be0 	.word	0x20400be0
  416ba4:	20400bf4 	.word	0x20400bf4
  416ba8:	0040f5c9 	.word	0x0040f5c9
  416bac:	20400bd8 	.word	0x20400bd8
  416bb0:	20400bec 	.word	0x20400bec

00416bb4 <vfd_set_flux_raise>:
{
  416bb4:	b410      	push	{r4}
  416bb6:	b083      	sub	sp, #12
	if (raise_period > 0)
  416bb8:	9001      	str	r0, [sp, #4]
  416bba:	b930      	cbnz	r0, 416bca <vfd_set_flux_raise+0x16>
		flux_ratio = 0;
  416bbc:	4b0d      	ldr	r3, [pc, #52]	; (416bf4 <vfd_set_flux_raise+0x40>)
  416bbe:	2200      	movs	r2, #0
  416bc0:	601a      	str	r2, [r3, #0]
}
  416bc2:	b003      	add	sp, #12
  416bc4:	f85d 4b04 	ldr.w	r4, [sp], #4
  416bc8:	4770      	bx	lr
		flux_rat_raise_step = raise_period;
  416bca:	ee07 0a90 	vmov	s15, r0
		flux_rat_raise_step = 1.0 / flux_rat_raise_step;
  416bce:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  416bd2:	4b09      	ldr	r3, [pc, #36]	; (416bf8 <vfd_set_flux_raise+0x44>)
		flux_ratio = 0;
  416bd4:	2400      	movs	r4, #0
		flux_rat_raise_step = raise_period;
  416bd6:	eef8 7a67 	vcvt.f32.u32	s15, s15
		flux_ratio = 0;
  416bda:	4806      	ldr	r0, [pc, #24]	; (416bf4 <vfd_set_flux_raise+0x40>)
		flux_raise_permission = 1;
  416bdc:	2101      	movs	r1, #1
  416bde:	4a07      	ldr	r2, [pc, #28]	; (416bfc <vfd_set_flux_raise+0x48>)
		flux_ratio = 0;
  416be0:	6004      	str	r4, [r0, #0]
		flux_rat_raise_step = 1.0 / flux_rat_raise_step;
  416be2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
		flux_raise_permission = 1;
  416be6:	6011      	str	r1, [r2, #0]
		flux_rat_raise_step = 1.0 / flux_rat_raise_step;
  416be8:	ed83 7a00 	vstr	s14, [r3]
}
  416bec:	b003      	add	sp, #12
  416bee:	f85d 4b04 	ldr.w	r4, [sp], #4
  416bf2:	4770      	bx	lr
  416bf4:	20400bf8 	.word	0x20400bf8
  416bf8:	20400bf0 	.word	0x20400bf0
  416bfc:	20400bec 	.word	0x20400bec

00416c00 <vfd_clear_c_decay>:
	c_decay_f = 0;
  416c00:	4b01      	ldr	r3, [pc, #4]	; (416c08 <vfd_clear_c_decay+0x8>)
  416c02:	2200      	movs	r2, #0
  416c04:	701a      	strb	r2, [r3, #0]
  416c06:	4770      	bx	lr
  416c08:	20400bd8 	.word	0x20400bd8

00416c0c <vfd_get_l_dir>:
	
}

uint8_t l_dir_delay_counter = 0;
int32_t vfd_get_l_dir(void)
{
  416c0c:	b508      	push	{r3, lr}
	// use it with PM CVC only
	if(vfd_states_allowedtomove())
  416c0e:	4b0d      	ldr	r3, [pc, #52]	; (416c44 <vfd_get_l_dir+0x38>)
  416c10:	4798      	blx	r3
  416c12:	b178      	cbz	r0, 416c34 <vfd_get_l_dir+0x28>
	{
		if (l_dir_delay_counter > 5)
  416c14:	4a0c      	ldr	r2, [pc, #48]	; (416c48 <vfd_get_l_dir+0x3c>)
  416c16:	7813      	ldrb	r3, [r2, #0]
  416c18:	2b05      	cmp	r3, #5
  416c1a:	d90e      	bls.n	416c3a <vfd_get_l_dir+0x2e>
		{
			if(cmd_tourque < 0) return 1;
  416c1c:	4b0b      	ldr	r3, [pc, #44]	; (416c4c <vfd_get_l_dir+0x40>)
  416c1e:	edd3 7a00 	vldr	s15, [r3]
			else return -1;
  416c22:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  416c26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416c2a:	bf4c      	ite	mi
  416c2c:	2001      	movmi	r0, #1
  416c2e:	f04f 30ff 	movpl.w	r0, #4294967295
  416c32:	bd08      	pop	{r3, pc}
		}
		else l_dir_delay_counter++;
	}
	else l_dir_delay_counter = 0;
  416c34:	4a04      	ldr	r2, [pc, #16]	; (416c48 <vfd_get_l_dir+0x3c>)
  416c36:	7010      	strb	r0, [r2, #0]
	return 0;
}
  416c38:	bd08      	pop	{r3, pc}
		else l_dir_delay_counter++;
  416c3a:	3301      	adds	r3, #1
	return 0;
  416c3c:	2000      	movs	r0, #0
		else l_dir_delay_counter++;
  416c3e:	7013      	strb	r3, [r2, #0]
  416c40:	bd08      	pop	{r3, pc}
  416c42:	bf00      	nop
  416c44:	00416305 	.word	0x00416305
  416c48:	20400bfc 	.word	0x20400bfc
  416c4c:	20400bdc 	.word	0x20400bdc

00416c50 <vfd_set_regencount>:
#define REGEN_FILTER_HALF (25)
#define REGEN_FILTER	  (2 * REGEN_FILTER_HALF)
uint8_t regen_filter_counter = 0;
void vfd_set_regencount(void)
{
	if (regen_filter_counter < REGEN_FILTER) regen_filter_counter++;
  416c50:	4a03      	ldr	r2, [pc, #12]	; (416c60 <vfd_set_regencount+0x10>)
  416c52:	7813      	ldrb	r3, [r2, #0]
  416c54:	2b31      	cmp	r3, #49	; 0x31
  416c56:	d801      	bhi.n	416c5c <vfd_set_regencount+0xc>
  416c58:	3301      	adds	r3, #1
  416c5a:	7013      	strb	r3, [r2, #0]
  416c5c:	4770      	bx	lr
  416c5e:	bf00      	nop
  416c60:	20400c04 	.word	0x20400c04

00416c64 <vfd_clr_regencount>:
}

void vfd_clr_regencount(void)
{
	if (regen_filter_counter > 0) regen_filter_counter--;
  416c64:	4a02      	ldr	r2, [pc, #8]	; (416c70 <vfd_clr_regencount+0xc>)
  416c66:	7813      	ldrb	r3, [r2, #0]
  416c68:	b10b      	cbz	r3, 416c6e <vfd_clr_regencount+0xa>
  416c6a:	3b01      	subs	r3, #1
  416c6c:	7013      	strb	r3, [r2, #0]
  416c6e:	4770      	bx	lr
  416c70:	20400c04 	.word	0x20400c04

00416c74 <vfd_is_motor_regen>:
}

uint32_t vfd_is_motor_regen(void)
{
	if (regen_filter_counter >= REGEN_FILTER_HALF)
  416c74:	4b03      	ldr	r3, [pc, #12]	; (416c84 <vfd_is_motor_regen+0x10>)
  416c76:	7818      	ldrb	r0, [r3, #0]
	} 
	else
	{
		return 0;
	}
}
  416c78:	2818      	cmp	r0, #24
  416c7a:	bf94      	ite	ls
  416c7c:	2000      	movls	r0, #0
  416c7e:	2001      	movhi	r0, #1
  416c80:	4770      	bx	lr
  416c82:	bf00      	nop
  416c84:	20400c04 	.word	0x20400c04

00416c88 <vfd_activate_reg_reset>:

void vfd_activate_reg_reset(void)
{
  416c88:	b510      	push	{r4, lr}
	vectorIM_activate_reg_reset();
  416c8a:	4b03      	ldr	r3, [pc, #12]	; (416c98 <vfd_activate_reg_reset+0x10>)
  416c8c:	4798      	blx	r3
	vectorPM_activate_reg_reset();
  416c8e:	4b03      	ldr	r3, [pc, #12]	; (416c9c <vfd_activate_reg_reset+0x14>)
}
  416c90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	vectorPM_activate_reg_reset();
  416c94:	4718      	bx	r3
  416c96:	bf00      	nop
  416c98:	0041159d 	.word	0x0041159d
  416c9c:	00411a6d 	.word	0x00411a6d

00416ca0 <vfd_speed_loop_handler>:

void vfd_speed_loop_handler(void)
{
  416ca0:	b510      	push	{r4, lr}
	if(vfd_states_isTuning())
  416ca2:	4b4e      	ldr	r3, [pc, #312]	; (416ddc <vfd_speed_loop_handler+0x13c>)
{
  416ca4:	ed2d 8b02 	vpush	{d8}
	if(vfd_states_isTuning())
  416ca8:	4798      	blx	r3
  416caa:	b110      	cbz	r0, 416cb2 <vfd_speed_loop_handler+0x12>
		{
			vfd_flux_raise_exe();
			cmd_tourque = speed_regulate(cmd_speed, act_speed, speed_ref_stage);
		}
	}
}
  416cac:	ecbd 8b02 	vpop	{d8}
  416cb0:	bd10      	pop	{r4, pc}
	vfd_scurve_exe();
  416cb2:	4b4b      	ldr	r3, [pc, #300]	; (416de0 <vfd_speed_loop_handler+0x140>)
  416cb4:	4798      	blx	r3
	cmd_speed = (desired_speed);
  416cb6:	4a4b      	ldr	r2, [pc, #300]	; (416de4 <vfd_speed_loop_handler+0x144>)
	cmd_speed /= MOTOR_POLEPAIR;
  416cb8:	4b4b      	ldr	r3, [pc, #300]	; (416de8 <vfd_speed_loop_handler+0x148>)
	cmd_speed = (desired_speed);
  416cba:	ed92 7a00 	vldr	s14, [r2]
	cmd_speed /= MOTOR_POLEPAIR;
  416cbe:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
	cmd_speed /= FIXEDPT_ONE;
  416cc2:	eeba 7ae8 	vcvt.f32.s32	s14, s14, #15
	cmd_speed *= M_TWO_PI;
  416cc6:	ed9f 8a49 	vldr	s16, [pc, #292]	; 416dec <vfd_speed_loop_handler+0x14c>
	cmd_speed /= MOTOR_POLEPAIR;
  416cca:	ee07 2a90 	vmov	s15, r2
	if (MOTOR_IM_CVC)
  416cce:	f893 20c5 	ldrb.w	r2, [r3, #197]	; 0xc5
	cmd_speed /= MOTOR_POLEPAIR;
  416cd2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	if (MOTOR_IM_CVC)
  416cd6:	2a01      	cmp	r2, #1
	cmd_speed /= MOTOR_POLEPAIR;
  416cd8:	eec7 6a27 	vdiv.f32	s13, s14, s15
	cmd_speed *= M_TWO_PI;
  416cdc:	ee26 8a88 	vmul.f32	s16, s13, s16
	if (MOTOR_IM_CVC)
  416ce0:	d034      	beq.n	416d4c <vfd_speed_loop_handler+0xac>
	else if (MOTOR_IM_OVC)
  416ce2:	2a02      	cmp	r2, #2
  416ce4:	d1e2      	bne.n	416cac <vfd_speed_loop_handler+0xc>
  416ce6:	781b      	ldrb	r3, [r3, #0]
  416ce8:	2b00      	cmp	r3, #0
  416cea:	d1df      	bne.n	416cac <vfd_speed_loop_handler+0xc>
		act_speed = vectorIM_get_estimated_shaft_speed_rad();
  416cec:	4b40      	ldr	r3, [pc, #256]	; (416df0 <vfd_speed_loop_handler+0x150>)
		act_speed = enc_get_omega_shaft_rad_hat();
  416cee:	4798      	blx	r3
  416cf0:	4604      	mov	r4, r0
		sp_dev = check_speed_deviation(cmd_speed, act_speed, vfd_states_allowedtomove());
  416cf2:	4b40      	ldr	r3, [pc, #256]	; (416df4 <vfd_speed_loop_handler+0x154>)
  416cf4:	4798      	blx	r3
  416cf6:	4b40      	ldr	r3, [pc, #256]	; (416df8 <vfd_speed_loop_handler+0x158>)
  416cf8:	4602      	mov	r2, r0
  416cfa:	4621      	mov	r1, r4
  416cfc:	ee18 0a10 	vmov	r0, s16
  416d00:	4798      	blx	r3
		if(c_decay_f) vfd_current_decay_exe();
  416d02:	4b3e      	ldr	r3, [pc, #248]	; (416dfc <vfd_speed_loop_handler+0x15c>)
  416d04:	781b      	ldrb	r3, [r3, #0]
  416d06:	2b00      	cmp	r3, #0
  416d08:	d055      	beq.n	416db6 <vfd_speed_loop_handler+0x116>
	cmd_tourque += current_decay_step;
  416d0a:	4a3d      	ldr	r2, [pc, #244]	; (416e00 <vfd_speed_loop_handler+0x160>)
  416d0c:	4b3d      	ldr	r3, [pc, #244]	; (416e04 <vfd_speed_loop_handler+0x164>)
  416d0e:	ed92 7a00 	vldr	s14, [r2]
  416d12:	edd3 7a00 	vldr	s15, [r3]
	if (flux_ratio > 0) flux_ratio += flux_rat_step;
  416d16:	4b3c      	ldr	r3, [pc, #240]	; (416e08 <vfd_speed_loop_handler+0x168>)
	cmd_tourque += current_decay_step;
  416d18:	ee37 7a27 	vadd.f32	s14, s14, s15
	if (flux_ratio > 0) flux_ratio += flux_rat_step;
  416d1c:	edd3 7a00 	vldr	s15, [r3]
  416d20:	eef5 7ac0 	vcmpe.f32	s15, #0.0
	cmd_tourque += current_decay_step;
  416d24:	ed82 7a00 	vstr	s14, [r2]
	if (flux_ratio > 0) flux_ratio += flux_rat_step;
  416d28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416d2c:	dd06      	ble.n	416d3c <vfd_speed_loop_handler+0x9c>
  416d2e:	4a37      	ldr	r2, [pc, #220]	; (416e0c <vfd_speed_loop_handler+0x16c>)
  416d30:	ed92 7a00 	vldr	s14, [r2]
  416d34:	ee77 7a87 	vadd.f32	s15, s15, s14
  416d38:	edc3 7a00 	vstr	s15, [r3]
	if(flux_ratio < 0) flux_ratio = 0;
  416d3c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  416d40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416d44:	d5b2      	bpl.n	416cac <vfd_speed_loop_handler+0xc>
  416d46:	2200      	movs	r2, #0
  416d48:	601a      	str	r2, [r3, #0]
  416d4a:	e7af      	b.n	416cac <vfd_speed_loop_handler+0xc>
	if (MOTOR_IM_CVC)
  416d4c:	781b      	ldrb	r3, [r3, #0]
  416d4e:	2b00      	cmp	r3, #0
  416d50:	d03e      	beq.n	416dd0 <vfd_speed_loop_handler+0x130>
	else if (MOTOR_PM_CVC)
  416d52:	2b01      	cmp	r3, #1
  416d54:	d1aa      	bne.n	416cac <vfd_speed_loop_handler+0xc>
		act_speed = enc_get_omega_shaft_rad_hat();
  416d56:	4b2e      	ldr	r3, [pc, #184]	; (416e10 <vfd_speed_loop_handler+0x170>)
  416d58:	4798      	blx	r3
  416d5a:	4604      	mov	r4, r0
		sp_dev = check_speed_deviation(cmd_speed, act_speed, vfd_states_allowedtomove());
  416d5c:	4b25      	ldr	r3, [pc, #148]	; (416df4 <vfd_speed_loop_handler+0x154>)
  416d5e:	4798      	blx	r3
  416d60:	4b25      	ldr	r3, [pc, #148]	; (416df8 <vfd_speed_loop_handler+0x158>)
  416d62:	4602      	mov	r2, r0
  416d64:	4621      	mov	r1, r4
  416d66:	ee18 0a10 	vmov	r0, s16
  416d6a:	4798      	blx	r3
		if(c_decay_f) vfd_current_decay_exe();
  416d6c:	4b23      	ldr	r3, [pc, #140]	; (416dfc <vfd_speed_loop_handler+0x15c>)
  416d6e:	781b      	ldrb	r3, [r3, #0]
  416d70:	b323      	cbz	r3, 416dbc <vfd_speed_loop_handler+0x11c>
	cmd_tourque += current_decay_step;
  416d72:	4a23      	ldr	r2, [pc, #140]	; (416e00 <vfd_speed_loop_handler+0x160>)
  416d74:	4b23      	ldr	r3, [pc, #140]	; (416e04 <vfd_speed_loop_handler+0x164>)
  416d76:	edd2 7a00 	vldr	s15, [r2]
  416d7a:	ed93 7a00 	vldr	s14, [r3]
	if (flux_ratio > 0) flux_ratio += flux_rat_step;
  416d7e:	4b22      	ldr	r3, [pc, #136]	; (416e08 <vfd_speed_loop_handler+0x168>)
	cmd_tourque += current_decay_step;
  416d80:	ee77 7a87 	vadd.f32	s15, s15, s14
	if (flux_ratio > 0) flux_ratio += flux_rat_step;
  416d84:	ed93 7a00 	vldr	s14, [r3]
  416d88:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
	cmd_tourque += current_decay_step;
  416d8c:	edc2 7a00 	vstr	s15, [r2]
	if (flux_ratio > 0) flux_ratio += flux_rat_step;
  416d90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416d94:	dd06      	ble.n	416da4 <vfd_speed_loop_handler+0x104>
  416d96:	4a1d      	ldr	r2, [pc, #116]	; (416e0c <vfd_speed_loop_handler+0x16c>)
  416d98:	edd2 7a00 	vldr	s15, [r2]
  416d9c:	ee77 7a87 	vadd.f32	s15, s15, s14
  416da0:	edc3 7a00 	vstr	s15, [r3]
	if(flux_ratio < 0) flux_ratio = 0;
  416da4:	edd3 7a00 	vldr	s15, [r3]
  416da8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  416dac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  416db0:	f57f af7c 	bpl.w	416cac <vfd_speed_loop_handler+0xc>
  416db4:	e7c7      	b.n	416d46 <vfd_speed_loop_handler+0xa6>
	if (flux_raise_permission == 0) return;
  416db6:	4b17      	ldr	r3, [pc, #92]	; (416e14 <vfd_speed_loop_handler+0x174>)
  416db8:	681b      	ldr	r3, [r3, #0]
  416dba:	b95b      	cbnz	r3, 416dd4 <vfd_speed_loop_handler+0x134>
			cmd_tourque = speed_regulate(cmd_speed, act_speed, speed_ref_stage);
  416dbc:	4a16      	ldr	r2, [pc, #88]	; (416e18 <vfd_speed_loop_handler+0x178>)
  416dbe:	4621      	mov	r1, r4
  416dc0:	4b16      	ldr	r3, [pc, #88]	; (416e1c <vfd_speed_loop_handler+0x17c>)
  416dc2:	ee18 0a10 	vmov	r0, s16
  416dc6:	6812      	ldr	r2, [r2, #0]
  416dc8:	4798      	blx	r3
  416dca:	4b0d      	ldr	r3, [pc, #52]	; (416e00 <vfd_speed_loop_handler+0x160>)
  416dcc:	6018      	str	r0, [r3, #0]
  416dce:	e76d      	b.n	416cac <vfd_speed_loop_handler+0xc>
		act_speed = enc_get_omega_shaft_rad_hat();
  416dd0:	4b0f      	ldr	r3, [pc, #60]	; (416e10 <vfd_speed_loop_handler+0x170>)
  416dd2:	e78c      	b.n	416cee <vfd_speed_loop_handler+0x4e>
  416dd4:	4b12      	ldr	r3, [pc, #72]	; (416e20 <vfd_speed_loop_handler+0x180>)
  416dd6:	4798      	blx	r3
  416dd8:	e7f0      	b.n	416dbc <vfd_speed_loop_handler+0x11c>
  416dda:	bf00      	nop
  416ddc:	0041631d 	.word	0x0041631d
  416de0:	004169d5 	.word	0x004169d5
  416de4:	20400be8 	.word	0x20400be8
  416de8:	20404ff0 	.word	0x20404ff0
  416dec:	40c90fdb 	.word	0x40c90fdb
  416df0:	004113bd 	.word	0x004113bd
  416df4:	00416305 	.word	0x00416305
  416df8:	00416a79 	.word	0x00416a79
  416dfc:	20400bd8 	.word	0x20400bd8
  416e00:	20400bdc 	.word	0x20400bdc
  416e04:	20400be0 	.word	0x20400be0
  416e08:	20400bf8 	.word	0x20400bf8
  416e0c:	20400bf4 	.word	0x20400bf4
  416e10:	00413d3d 	.word	0x00413d3d
  416e14:	20400bec 	.word	0x20400bec
  416e18:	20400c0c 	.word	0x20400c0c
  416e1c:	0040f1bd 	.word	0x0040f1bd
  416e20:	00416955 	.word	0x00416955

00416e24 <vfd_tune_current_loop_handler>:

void vfd_tune_current_loop_handler(void)
{
  416e24:	b510      	push	{r4, lr}
	if (motor_excitation_is_motor_connected())
  416e26:	4b0e      	ldr	r3, [pc, #56]	; (416e60 <vfd_tune_current_loop_handler+0x3c>)
  416e28:	4798      	blx	r3
  416e2a:	b158      	cbz	r0, 416e44 <vfd_tune_current_loop_handler+0x20>
	{
		if (IM_PARAM_TUNE)
  416e2c:	4b0d      	ldr	r3, [pc, #52]	; (416e64 <vfd_tune_current_loop_handler+0x40>)
  416e2e:	781b      	ldrb	r3, [r3, #0]
  416e30:	b123      	cbz	r3, 416e3c <vfd_tune_current_loop_handler+0x18>
  416e32:	4b0d      	ldr	r3, [pc, #52]	; (416e68 <vfd_tune_current_loop_handler+0x44>)
  416e34:	781b      	ldrb	r3, [r3, #0]
  416e36:	b153      	cbz	r3, 416e4e <vfd_tune_current_loop_handler+0x2a>
		{
			IM_param_tune1_current_handler();
		}
		else if (PM_PARAM_TUNE)
  416e38:	2b01      	cmp	r3, #1
  416e3a:	d00c      	beq.n	416e56 <vfd_tune_current_loop_handler+0x32>
		{
			PM_param_tune2_current_handler();
		}
		else if(SPM_ENCODER_TUNE_STATIC)
  416e3c:	4b0b      	ldr	r3, [pc, #44]	; (416e6c <vfd_tune_current_loop_handler+0x48>)
  416e3e:	781b      	ldrb	r3, [r3, #0]
  416e40:	2b02      	cmp	r3, #2
  416e42:	d000      	beq.n	416e46 <vfd_tune_current_loop_handler+0x22>
  416e44:	bd10      	pop	{r4, pc}
		{
			SPMstatic_tune_current_handler();
  416e46:	4b0a      	ldr	r3, [pc, #40]	; (416e70 <vfd_tune_current_loop_handler+0x4c>)
		}
	}
}
  416e48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			SPMstatic_tune_current_handler();
  416e4c:	4718      	bx	r3
			IM_param_tune1_current_handler();
  416e4e:	4b09      	ldr	r3, [pc, #36]	; (416e74 <vfd_tune_current_loop_handler+0x50>)
}
  416e50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			IM_param_tune1_current_handler();
  416e54:	4718      	bx	r3
			PM_param_tune2_current_handler();
  416e56:	4b08      	ldr	r3, [pc, #32]	; (416e78 <vfd_tune_current_loop_handler+0x54>)
}
  416e58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			PM_param_tune2_current_handler();
  416e5c:	4718      	bx	r3
  416e5e:	bf00      	nop
  416e60:	00416125 	.word	0x00416125
  416e64:	204008e9 	.word	0x204008e9
  416e68:	20404ff0 	.word	0x20404ff0
  416e6c:	204008e8 	.word	0x204008e8
  416e70:	00411205 	.word	0x00411205
  416e74:	004102f5 	.word	0x004102f5
  416e78:	00410c81 	.word	0x00410c81

00416e7c <vfd_current_loop_handler>:

void vfd_current_loop_handler(void)
{
  416e7c:	b510      	push	{r4, lr}
	if (vfd_states_is_sctest_mode()) 
  416e7e:	4b21      	ldr	r3, [pc, #132]	; (416f04 <vfd_current_loop_handler+0x88>)
  416e80:	4798      	blx	r3
  416e82:	b998      	cbnz	r0, 416eac <vfd_current_loop_handler+0x30>
		vector_PM_init();
		vector_IM_init();
		return;
	}
	
	if(vfd_states_isTuning())
  416e84:	4b20      	ldr	r3, [pc, #128]	; (416f08 <vfd_current_loop_handler+0x8c>)
  416e86:	4798      	blx	r3
  416e88:	b9b0      	cbnz	r0, 416eb8 <vfd_current_loop_handler+0x3c>
	{
		vfd_tune_current_loop_handler();
		return;
	}
	
	if (MOTOR_IM_CVC)
  416e8a:	4a20      	ldr	r2, [pc, #128]	; (416f0c <vfd_current_loop_handler+0x90>)
  416e8c:	f892 30c5 	ldrb.w	r3, [r2, #197]	; 0xc5
  416e90:	2b01      	cmp	r3, #1
  416e92:	d01b      	beq.n	416ecc <vfd_current_loop_handler+0x50>
	else if (MOTOR_PM_CVC)
	{
		//closed loop vector PMSM
		vectorPM_perform(cmd_tourque);
	}
	else if (MOTOR_IM_OVC)
  416e94:	2b02      	cmp	r3, #2
  416e96:	d023      	beq.n	416ee0 <vfd_current_loop_handler+0x64>
		control_fault_set;
	}
	else
	{
		//V/F control
		if (ref_speed == 0)
  416e98:	4b1d      	ldr	r3, [pc, #116]	; (416f10 <vfd_current_loop_handler+0x94>)
		{
			vf_speed_out_handler(desired_speed, 1); //braking
  416e9a:	4a1e      	ldr	r2, [pc, #120]	; (416f14 <vfd_current_loop_handler+0x98>)
		if (ref_speed == 0)
  416e9c:	681b      	ldr	r3, [r3, #0]
  416e9e:	b17b      	cbz	r3, 416ec0 <vfd_current_loop_handler+0x44>
		}
		else
		{
			vf_speed_out_handler(desired_speed, 0); // don't apply braking current
  416ea0:	2100      	movs	r1, #0
  416ea2:	4b1d      	ldr	r3, [pc, #116]	; (416f18 <vfd_current_loop_handler+0x9c>)
  416ea4:	6810      	ldr	r0, [r2, #0]
		}
	}
}
  416ea6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			vf_speed_out_handler(desired_speed, 0); // don't apply braking current
  416eaa:	4718      	bx	r3
		vector_PM_init();
  416eac:	4b1b      	ldr	r3, [pc, #108]	; (416f1c <vfd_current_loop_handler+0xa0>)
  416eae:	4798      	blx	r3
		vector_IM_init();
  416eb0:	4b1b      	ldr	r3, [pc, #108]	; (416f20 <vfd_current_loop_handler+0xa4>)
}
  416eb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vector_IM_init();
  416eb6:	4718      	bx	r3
		vfd_tune_current_loop_handler();
  416eb8:	4b1a      	ldr	r3, [pc, #104]	; (416f24 <vfd_current_loop_handler+0xa8>)
}
  416eba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vfd_tune_current_loop_handler();
  416ebe:	4718      	bx	r3
			vf_speed_out_handler(desired_speed, 1); //braking
  416ec0:	2101      	movs	r1, #1
  416ec2:	4b15      	ldr	r3, [pc, #84]	; (416f18 <vfd_current_loop_handler+0x9c>)
  416ec4:	6810      	ldr	r0, [r2, #0]
}
  416ec6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			vf_speed_out_handler(desired_speed, 1); //braking
  416eca:	4718      	bx	r3
	if (MOTOR_IM_CVC)
  416ecc:	7813      	ldrb	r3, [r2, #0]
  416ece:	b18b      	cbz	r3, 416ef4 <vfd_current_loop_handler+0x78>
	else if (MOTOR_PM_CVC)
  416ed0:	2b01      	cmp	r3, #1
  416ed2:	d1e1      	bne.n	416e98 <vfd_current_loop_handler+0x1c>
		vectorPM_perform(cmd_tourque);
  416ed4:	4a14      	ldr	r2, [pc, #80]	; (416f28 <vfd_current_loop_handler+0xac>)
  416ed6:	4b15      	ldr	r3, [pc, #84]	; (416f2c <vfd_current_loop_handler+0xb0>)
  416ed8:	6810      	ldr	r0, [r2, #0]
}
  416eda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vectorPM_perform(cmd_tourque);
  416ede:	4718      	bx	r3
	else if (MOTOR_IM_OVC)
  416ee0:	7813      	ldrb	r3, [r2, #0]
  416ee2:	b13b      	cbz	r3, 416ef4 <vfd_current_loop_handler+0x78>
	else if (MOTOR_PM_OVC)
  416ee4:	2b01      	cmp	r3, #1
  416ee6:	d1d7      	bne.n	416e98 <vfd_current_loop_handler+0x1c>
		control_fault_set;
  416ee8:	4a11      	ldr	r2, [pc, #68]	; (416f30 <vfd_current_loop_handler+0xb4>)
  416eea:	4b12      	ldr	r3, [pc, #72]	; (416f34 <vfd_current_loop_handler+0xb8>)
  416eec:	7810      	ldrb	r0, [r2, #0]
}
  416eee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		control_fault_set;
  416ef2:	4718      	bx	r3
		vectorIM_perform(cmd_tourque, flux_ratio);
  416ef4:	4b0c      	ldr	r3, [pc, #48]	; (416f28 <vfd_current_loop_handler+0xac>)
  416ef6:	4a10      	ldr	r2, [pc, #64]	; (416f38 <vfd_current_loop_handler+0xbc>)
  416ef8:	6818      	ldr	r0, [r3, #0]
  416efa:	6811      	ldr	r1, [r2, #0]
  416efc:	4b0f      	ldr	r3, [pc, #60]	; (416f3c <vfd_current_loop_handler+0xc0>)
}
  416efe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vectorIM_perform(cmd_tourque, flux_ratio);
  416f02:	4718      	bx	r3
  416f04:	00416355 	.word	0x00416355
  416f08:	0041631d 	.word	0x0041631d
  416f0c:	20404ff0 	.word	0x20404ff0
  416f10:	20400c00 	.word	0x20400c00
  416f14:	20400be8 	.word	0x20400be8
  416f18:	00413029 	.word	0x00413029
  416f1c:	00411c81 	.word	0x00411c81
  416f20:	00411931 	.word	0x00411931
  416f24:	00416e25 	.word	0x00416e25
  416f28:	20400bdc 	.word	0x20400bdc
  416f2c:	00411a79 	.word	0x00411a79
  416f30:	20406caa 	.word	0x20406caa
  416f34:	0041282d 	.word	0x0041282d
  416f38:	20400bf8 	.word	0x20400bf8
  416f3c:	004115a9 	.word	0x004115a9

00416f40 <vfd_set_motion_acc>:
	m_dynamics_settings.j2 = motion_profile.j2;
}

void vfd_set_motion_acc(fixedpt acc)
{
	m_dynamics_settings.a = acc;
  416f40:	4b01      	ldr	r3, [pc, #4]	; (416f48 <vfd_set_motion_acc+0x8>)
  416f42:	6018      	str	r0, [r3, #0]
  416f44:	4770      	bx	lr
  416f46:	bf00      	nop
  416f48:	20406d18 	.word	0x20406d18

00416f4c <vfd_set_motion_j1>:
}

void vfd_set_motion_j1(fixedpt j1)
{
	m_dynamics_settings.j1 = j1;
  416f4c:	4b01      	ldr	r3, [pc, #4]	; (416f54 <vfd_set_motion_j1+0x8>)
  416f4e:	6058      	str	r0, [r3, #4]
  416f50:	4770      	bx	lr
  416f52:	bf00      	nop
  416f54:	20406d18 	.word	0x20406d18

00416f58 <vfd_set_motion_j2>:
}

void vfd_set_motion_j2(fixedpt j2)
{
	m_dynamics_settings.j2 = j2;
  416f58:	4b01      	ldr	r3, [pc, #4]	; (416f60 <vfd_set_motion_j2+0x8>)
  416f5a:	6098      	str	r0, [r3, #8]
  416f5c:	4770      	bx	lr
  416f5e:	bf00      	nop
  416f60:	20406d18 	.word	0x20406d18

00416f64 <vfd_set_accel_profile>:
}

void vfd_set_accel_profile(fixedpt speed)
{
	ref_speed = speed;
  416f64:	4a05      	ldr	r2, [pc, #20]	; (416f7c <vfd_set_accel_profile+0x18>)
{
  416f66:	b508      	push	{r3, lr}
	
	
	//generate curve details
	scurve_apply_precalc_accel_profile();
  416f68:	4b05      	ldr	r3, [pc, #20]	; (416f80 <vfd_set_accel_profile+0x1c>)
	ref_speed = speed;
  416f6a:	6010      	str	r0, [r2, #0]
	scurve_apply_precalc_accel_profile();
  416f6c:	4798      	blx	r3
	time_tick = 0;
  416f6e:	4905      	ldr	r1, [pc, #20]	; (416f84 <vfd_set_accel_profile+0x20>)
  416f70:	2000      	movs	r0, #0
	speed_ref_stage = 1;
  416f72:	4b05      	ldr	r3, [pc, #20]	; (416f88 <vfd_set_accel_profile+0x24>)
  416f74:	2201      	movs	r2, #1
	time_tick = 0;
  416f76:	6008      	str	r0, [r1, #0]
	speed_ref_stage = 1;
  416f78:	601a      	str	r2, [r3, #0]
  416f7a:	bd08      	pop	{r3, pc}
  416f7c:	20400c00 	.word	0x20400c00
  416f80:	0040e539 	.word	0x0040e539
  416f84:	20400c10 	.word	0x20400c10
  416f88:	20400c0c 	.word	0x20400c0c

00416f8c <vfd_set_ref_speed>:
// 	}
	
	// generate curve abs values
	motion_dynamics_t m_dynamics;
	
	if(m_dynamics_settings.a == 0)  m_dynamics_settings.a  = fixedpt_rconst(2.5);
  416f8c:	4b18      	ldr	r3, [pc, #96]	; (416ff0 <vfd_set_ref_speed+0x64>)
	ref_speed = speed;
  416f8e:	4919      	ldr	r1, [pc, #100]	; (416ff4 <vfd_set_ref_speed+0x68>)
{
  416f90:	b570      	push	{r4, r5, r6, lr}
	if(m_dynamics_settings.a == 0)  m_dynamics_settings.a  = fixedpt_rconst(2.5);
  416f92:	681a      	ldr	r2, [r3, #0]
{
  416f94:	b088      	sub	sp, #32
  416f96:	4604      	mov	r4, r0
	ref_speed = speed;
  416f98:	6008      	str	r0, [r1, #0]
	if(m_dynamics_settings.a == 0)  m_dynamics_settings.a  = fixedpt_rconst(2.5);
  416f9a:	b912      	cbnz	r2, 416fa2 <vfd_set_ref_speed+0x16>
  416f9c:	f44f 32a0 	mov.w	r2, #81920	; 0x14000
  416fa0:	601a      	str	r2, [r3, #0]
	if(m_dynamics_settings.j1 == 0) m_dynamics_settings.j1 = fixedpt_rconst(0.1);
  416fa2:	685a      	ldr	r2, [r3, #4]
  416fa4:	b912      	cbnz	r2, 416fac <vfd_set_ref_speed+0x20>
  416fa6:	f640 42cd 	movw	r2, #3277	; 0xccd
  416faa:	605a      	str	r2, [r3, #4]
	if(m_dynamics_settings.j2 == 0) m_dynamics_settings.j2 = fixedpt_rconst(0.1);
  416fac:	689a      	ldr	r2, [r3, #8]
  416fae:	b912      	cbnz	r2, 416fb6 <vfd_set_ref_speed+0x2a>
  416fb0:	f640 42cd 	movw	r2, #3277	; 0xccd
  416fb4:	609a      	str	r2, [r3, #8]
	
	m_dynamics = scurve_get_abs_from_relative(m_dynamics_settings);	
  416fb6:	a805      	add	r0, sp, #20
  416fb8:	4d0f      	ldr	r5, [pc, #60]	; (416ff8 <vfd_set_ref_speed+0x6c>)
  416fba:	cb0e      	ldmia	r3, {r1, r2, r3}
  416fbc:	47a8      	blx	r5
	
	//generate curve details
	scurve_generate_speed_profile(desired_speed, speed, c_acceleration, m_dynamics, &scurve_speed);
  416fbe:	4b0f      	ldr	r3, [pc, #60]	; (416ffc <vfd_set_ref_speed+0x70>)
  416fc0:	490f      	ldr	r1, [pc, #60]	; (417000 <vfd_set_ref_speed+0x74>)
  416fc2:	4a10      	ldr	r2, [pc, #64]	; (417004 <vfd_set_ref_speed+0x78>)
  416fc4:	681e      	ldr	r6, [r3, #0]
  416fc6:	6812      	ldr	r2, [r2, #0]
  416fc8:	9102      	str	r1, [sp, #8]
  416fca:	a908      	add	r1, sp, #32
  416fcc:	9b05      	ldr	r3, [sp, #20]
  416fce:	4d0e      	ldr	r5, [pc, #56]	; (417008 <vfd_set_ref_speed+0x7c>)
  416fd0:	e911 0003 	ldmdb	r1, {r0, r1}
  416fd4:	e88d 0003 	stmia.w	sp, {r0, r1}
  416fd8:	4630      	mov	r0, r6
  416fda:	4621      	mov	r1, r4
  416fdc:	47a8      	blx	r5
	//scurve_generate_speed_profile(desired_speed, speed, c_acceleration, m_dynamics, &scurve_speed);
	time_tick = 0;
  416fde:	490b      	ldr	r1, [pc, #44]	; (41700c <vfd_set_ref_speed+0x80>)
  416fe0:	2000      	movs	r0, #0
	speed_ref_stage = 1;
  416fe2:	4b0b      	ldr	r3, [pc, #44]	; (417010 <vfd_set_ref_speed+0x84>)
  416fe4:	2201      	movs	r2, #1
	time_tick = 0;
  416fe6:	6008      	str	r0, [r1, #0]
	speed_ref_stage = 1;
  416fe8:	601a      	str	r2, [r3, #0]
}
  416fea:	b008      	add	sp, #32
  416fec:	bd70      	pop	{r4, r5, r6, pc}
  416fee:	bf00      	nop
  416ff0:	20406d18 	.word	0x20406d18
  416ff4:	20400c00 	.word	0x20400c00
  416ff8:	0040e391 	.word	0x0040e391
  416ffc:	20400be8 	.word	0x20400be8
  417000:	20406344 	.word	0x20406344
  417004:	20400bd4 	.word	0x20400bd4
  417008:	0040e569 	.word	0x0040e569
  41700c:	20400c10 	.word	0x20400c10
  417010:	20400c0c 	.word	0x20400c0c

00417014 <vfd_get_Max_possible_speed>:


int32_t vfd_get_Max_possible_speed(int64_t int_displacement, fixedpt *r_speed, int32_t *stopping_displacement)
{
  417014:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	motion_dynamics_t acc_motion, dec_motion, dec_motionz;
	int32_t sign = 1;
	int64_t enc_count;
	fixedpt displacement, stp_displacement;
	int_displacement = fixedpt_fromint(int_displacement) / ((ENCODER_COUNTREV) / MOTOR_POLEPAIR);
  417018:	4f76      	ldr	r7, [pc, #472]	; (4171f4 <vfd_get_Max_possible_speed+0x1e0>)
{
  41701a:	4692      	mov	sl, r2
  41701c:	4604      	mov	r4, r0
	int_displacement = fixedpt_fromint(int_displacement) / ((ENCODER_COUNTREV) / MOTOR_POLEPAIR);
  41701e:	03c9      	lsls	r1, r1, #15
  417020:	f8b7 20ae 	ldrh.w	r2, [r7, #174]	; 0xae
{
  417024:	b099      	sub	sp, #100	; 0x64
	int_displacement = fixedpt_fromint(int_displacement) / ((ENCODER_COUNTREV) / MOTOR_POLEPAIR);
  417026:	f897 b03c 	ldrb.w	fp, [r7, #60]	; 0x3c
  41702a:	ea41 4154 	orr.w	r1, r1, r4, lsr #17
  41702e:	0052      	lsls	r2, r2, #1
{
  417030:	4699      	mov	r9, r3
	int_displacement = fixedpt_fromint(int_displacement) / ((ENCODER_COUNTREV) / MOTOR_POLEPAIR);
  417032:	03c0      	lsls	r0, r0, #15
  417034:	4c70      	ldr	r4, [pc, #448]	; (4171f8 <vfd_get_Max_possible_speed+0x1e4>)
  417036:	fb92 f2fb 	sdiv	r2, r2, fp
  41703a:	17d3      	asrs	r3, r2, #31
  41703c:	47a0      	blx	r4
	if(int_displacement < 0) int_displacement += CREEP_DISTANCE;
  41703e:	2800      	cmp	r0, #0
  417040:	f171 0300 	sbcs.w	r3, r1, #0
  417044:	f2c0 80be 	blt.w	4171c4 <vfd_get_Max_possible_speed+0x1b0>
	else if(int_displacement > 0) int_displacement -= CREEP_DISTANCE;
  417048:	ea50 0301 	orrs.w	r3, r0, r1
  41704c:	f000 80ce 	beq.w	4171ec <vfd_get_Max_possible_speed+0x1d8>
  417050:	4e6a      	ldr	r6, [pc, #424]	; (4171fc <vfd_get_Max_possible_speed+0x1e8>)
  417052:	6ff4      	ldr	r4, [r6, #124]	; 0x7c
  417054:	17e3      	asrs	r3, r4, #31
  417056:	f3c4 02d0 	ubfx	r2, r4, #3, #17
  41705a:	031b      	lsls	r3, r3, #12
  41705c:	ea43 5314 	orr.w	r3, r3, r4, lsr #20
  417060:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  417064:	fb02 f20b 	mul.w	r2, r2, fp
  417068:	1a84      	subs	r4, r0, r2
  41706a:	eb61 75e2 	sbc.w	r5, r1, r2, asr #31
	else return 0; //un-realizable distance
	
	if(int_displacement < 0) sign = -1;
  41706e:	2c00      	cmp	r4, #0
	
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  417070:	4622      	mov	r2, r4
	if(int_displacement < 0) sign = -1;
  417072:	f175 0300 	sbcs.w	r3, r5, #0
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  417076:	462b      	mov	r3, r5
	if(int_displacement < 0) sign = -1;
  417078:	bfac      	ite	ge
  41707a:	f04f 0801 	movge.w	r8, #1
  41707e:	f04f 38ff 	movlt.w	r8, #4294967295
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  417082:	f2c0 80af 	blt.w	4171e4 <vfd_get_Max_possible_speed+0x1d0>
	dec_motionz.a = MAXDEC;
	dec_motionz.j1 = J1/100;
	dec_motionz.j2 = J3/100;
	
	if(displacement < 0) sign = -1;
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  417086:	68f9      	ldr	r1, [r7, #12]
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  417088:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  41708c:	6b32      	ldr	r2, [r6, #48]	; 0x30
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  41708e:	a80e      	add	r0, sp, #56	; 0x38
  417090:	fb01 f10b 	mul.w	r1, r1, fp
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  417094:	f173 0300 	sbcs.w	r3, r3, #0
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  417098:	4b59      	ldr	r3, [pc, #356]	; (417200 <vfd_get_Max_possible_speed+0x1ec>)
  41709a:	f10d 0c18 	add.w	ip, sp, #24
  41709e:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  4170a2:	bfa8      	it	ge
  4170a4:	ebc8 74c8 	rsbge	r4, r8, r8, lsl #31
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  4170a8:	fb83 3b01 	smull	r3, fp, r3, r1
  4170ac:	17cb      	asrs	r3, r1, #31
  4170ae:	900b      	str	r0, [sp, #44]	; 0x2c
	if(displacement < 0) sign = -1;
  4170b0:	2c00      	cmp	r4, #0
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  4170b2:	448b      	add	fp, r1
  4170b4:	6ab0      	ldr	r0, [r6, #40]	; 0x28
	acc_motion.j1 = J1/100;
  4170b6:	4d53      	ldr	r5, [pc, #332]	; (417204 <vfd_get_Max_possible_speed+0x1f0>)
	if(displacement < 0) sign = -1;
  4170b8:	bfb8      	it	lt
  4170ba:	f04f 38ff 	movlt.w	r8, #4294967295
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  4170be:	ebc3 1b6b 	rsb	fp, r3, fp, asr #5
	acc_motion.j1 = J1/100;
  4170c2:	6db1      	ldr	r1, [r6, #88]	; 0x58
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  4170c4:	f10d 0e48 	add.w	lr, sp, #72	; 0x48
  4170c8:	fb8b 2302 	smull	r2, r3, fp, r2
  4170cc:	fb8b ab00 	smull	sl, fp, fp, r0
  4170d0:	0bd2      	lsrs	r2, r2, #15
  4170d2:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
	dec_motionz.j2 = J3/100;
  4170d6:	6e33      	ldr	r3, [r6, #96]	; 0x60
  4170d8:	e9cd ab0c 	strd	sl, fp, [sp, #48]	; 0x30
			c_acceleration, acc_motion, dec_motion, dec_motionz, sign * CRPSPEED, r_speed, &stp_displacement) ;
  4170dc:	fb85 0b02 	smull	r0, fp, r5, r2
  4170e0:	17d2      	asrs	r2, r2, #31
	acc_motion.j1 = J1/100;
  4170e2:	fb85 0a01 	smull	r0, sl, r5, r1
  4170e6:	17c9      	asrs	r1, r1, #31
			c_acceleration, acc_motion, dec_motion, dec_motionz, sign * CRPSPEED, r_speed, &stp_displacement) ;
  4170e8:	ebc2 126b 	rsb	r2, r2, fp, asr #5
	dec_motionz.j2 = J3/100;
  4170ec:	fb85 b003 	smull	fp, r0, r5, r3
	acc_motion.j1 = J1/100;
  4170f0:	ebc1 116a 	rsb	r1, r1, sl, asr #5
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  4170f4:	fb08 f202 	mul.w	r2, r8, r2
	dec_motionz.j2 = J3/100;
  4170f8:	17db      	asrs	r3, r3, #31
	dec_motionz.j1 = J1/100;
  4170fa:	9116      	str	r1, [sp, #88]	; 0x58
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  4170fc:	9209      	str	r2, [sp, #36]	; 0x24
	dec_motionz.j2 = J3/100;
  4170fe:	ebc3 1060 	rsb	r0, r3, r0, asr #5
	acc_motion.j2 = J2/100;
  417102:	6df3      	ldr	r3, [r6, #92]	; 0x5c
	dec_motionz.j2 = J3/100;
  417104:	9017      	str	r0, [sp, #92]	; 0x5c
	dec_motion.a = MAXDEC;
  417106:	6cb0      	ldr	r0, [r6, #72]	; 0x48
	dec_motion.j1 = J1/100;
  417108:	9113      	str	r1, [sp, #76]	; 0x4c
	dec_motionz.a = MAXDEC;
  41710a:	9015      	str	r0, [sp, #84]	; 0x54
	dec_motion.a = MAXDEC;
  41710c:	9012      	str	r0, [sp, #72]	; 0x48
	acc_motion.j1 = J1/100;
  41710e:	9110      	str	r1, [sp, #64]	; 0x40
  417110:	e9dd ab0c 	ldrd	sl, fp, [sp, #48]	; 0x30
  417114:	4652      	mov	r2, sl
  417116:	0bd2      	lsrs	r2, r2, #15
  417118:	ea42 424b 	orr.w	r2, r2, fp, lsl #17
	acc_motion.j2 = J2/100;
  41711c:	fb85 ab03 	smull	sl, fp, r5, r3
  417120:	17db      	asrs	r3, r3, #31
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  417122:	fb85 a502 	smull	sl, r5, r5, r2
  417126:	17d2      	asrs	r2, r2, #31
	acc_motion.j2 = J2/100;
  417128:	ebc3 136b 	rsb	r3, r3, fp, asr #5
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  41712c:	f10d 0a3c 	add.w	sl, sp, #60	; 0x3c
  417130:	ebc2 1565 	rsb	r5, r2, r5, asr #5
  417134:	f10d 0b0c 	add.w	fp, sp, #12
	dec_motion.j2 = J2/100;
  417138:	9314      	str	r3, [sp, #80]	; 0x50
	acc_motion.j2 = J2/100;
  41713a:	9311      	str	r3, [sp, #68]	; 0x44
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  41713c:	ab18      	add	r3, sp, #96	; 0x60
  41713e:	e913 0007 	ldmdb	r3, {r0, r1, r2}
  417142:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
  417146:	4930      	ldr	r1, [pc, #192]	; (417208 <vfd_get_Max_possible_speed+0x1f4>)
	acc_motion.a = MAXACC;
  417148:	6c73      	ldr	r3, [r6, #68]	; 0x44
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  41714a:	4a30      	ldr	r2, [pc, #192]	; (41720c <vfd_get_Max_possible_speed+0x1f8>)
	acc_motion.a = MAXACC;
  41714c:	930f      	str	r3, [sp, #60]	; 0x3c
	enc_count = scurve_get_maximumSpeed_fromDisplacement(displacement, sign * MAXSPEED, desired_speed,
  41714e:	f8d2 c000 	ldr.w	ip, [r2]
  417152:	680b      	ldr	r3, [r1, #0]
  417154:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
  417158:	e88b 0007 	stmia.w	fp, {r0, r1, r2}
  41715c:	e89a 0007 	ldmia.w	sl, {r0, r1, r2}
  417160:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 417210 <vfd_get_Max_possible_speed+0x1fc>
  417164:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
  417168:	fb08 f105 	mul.w	r1, r8, r5
  41716c:	4662      	mov	r2, ip
  41716e:	4620      	mov	r0, r4
  417170:	47d0      	blx	sl
	enc_count *= ((ENCODER_COUNTREV) / MOTOR_POLEPAIR);
  417172:	f8b7 10ae 	ldrh.w	r1, [r7, #174]	; 0xae
  417176:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
  41717a:	0049      	lsls	r1, r1, #1
	*stopping_displacement = fixedpt_toint(stp_displacement * ((ENCODER_COUNTREV) / MOTOR_POLEPAIR));
  41717c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
	enc_count *= ((ENCODER_COUNTREV) / MOTOR_POLEPAIR);
  41717e:	fb91 f1f3 	sdiv	r1, r1, r3
	*stopping_displacement = fixedpt_toint(stp_displacement * ((ENCODER_COUNTREV) / MOTOR_POLEPAIR));
  417182:	fb02 f201 	mul.w	r2, r2, r1
  417186:	13d2      	asrs	r2, r2, #15
  417188:	f8c9 2000 	str.w	r2, [r9]
  41718c:	6ff6      	ldr	r6, [r6, #124]	; 0x7c
	return fixedpt_toint(enc_count + (sign * CREEP_DISTANCE_m * ENCODER_COUNTREV)) + *stopping_displacement;
  41718e:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	; 0xae
  417192:	17f5      	asrs	r5, r6, #31
  417194:	f3c6 04d0 	ubfx	r4, r6, #3, #17
  417198:	005b      	lsls	r3, r3, #1
  41719a:	032d      	lsls	r5, r5, #12
  41719c:	ea45 5516 	orr.w	r5, r5, r6, lsr #20
  4171a0:	ea44 4445 	orr.w	r4, r4, r5, lsl #17
  4171a4:	fb04 f808 	mul.w	r8, r4, r8
  4171a8:	fb03 f808 	mul.w	r8, r3, r8
  4171ac:	ea4f 79e8 	mov.w	r9, r8, asr #31
  4171b0:	fbc1 8900 	smlal	r8, r9, r1, r0
  4171b4:	ea4f 30d8 	mov.w	r0, r8, lsr #15
  4171b8:	ea40 4049 	orr.w	r0, r0, r9, lsl #17
  4171bc:	4410      	add	r0, r2
}
  4171be:	b019      	add	sp, #100	; 0x64
  4171c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(int_displacement < 0) int_displacement += CREEP_DISTANCE;
  4171c4:	4e0d      	ldr	r6, [pc, #52]	; (4171fc <vfd_get_Max_possible_speed+0x1e8>)
  4171c6:	6ff4      	ldr	r4, [r6, #124]	; 0x7c
  4171c8:	17e3      	asrs	r3, r4, #31
  4171ca:	f3c4 02d0 	ubfx	r2, r4, #3, #17
  4171ce:	031b      	lsls	r3, r3, #12
  4171d0:	ea43 5314 	orr.w	r3, r3, r4, lsr #20
  4171d4:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
  4171d8:	fb02 f20b 	mul.w	r2, r2, fp
  4171dc:	1884      	adds	r4, r0, r2
  4171de:	eb41 75e2 	adc.w	r5, r1, r2, asr #31
  4171e2:	e744      	b.n	41706e <vfd_get_Max_possible_speed+0x5a>
	if(fixedpt_abs(int_displacement) > 0x7FFFFFFF) int_displacement = sign * 0x7FFFFFFF;
  4171e4:	4262      	negs	r2, r4
  4171e6:	eb65 0345 	sbc.w	r3, r5, r5, lsl #1
  4171ea:	e74c      	b.n	417086 <vfd_get_Max_possible_speed+0x72>
	else return 0; //un-realizable distance
  4171ec:	2000      	movs	r0, #0
}
  4171ee:	b019      	add	sp, #100	; 0x64
  4171f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4171f4:	20404ff0 	.word	0x20404ff0
  4171f8:	0041905d 	.word	0x0041905d
  4171fc:	204052b4 	.word	0x204052b4
  417200:	88888889 	.word	0x88888889
  417204:	51eb851f 	.word	0x51eb851f
  417208:	20400bd4 	.word	0x20400bd4
  41720c:	20400be8 	.word	0x20400be8
  417210:	0040e859 	.word	0x0040e859

00417214 <vfd_estop>:

void vfd_estop(void)
{
  417214:	b538      	push	{r3, r4, r5, lr}
	//protective function to immediately stop the motor and release the break.
	vfd_states_estop();
  417216:	4b07      	ldr	r3, [pc, #28]	; (417234 <vfd_estop+0x20>)
  417218:	4798      	blx	r3
	ref_speed = 0;
  41721a:	4d07      	ldr	r5, [pc, #28]	; (417238 <vfd_estop+0x24>)
  41721c:	2300      	movs	r3, #0
	desired_speed = 0;
  41721e:	4c07      	ldr	r4, [pc, #28]	; (41723c <vfd_estop+0x28>)
	speed_ref_stage =0;
  417220:	4807      	ldr	r0, [pc, #28]	; (417240 <vfd_estop+0x2c>)
	c_acceleration = 0;
  417222:	4908      	ldr	r1, [pc, #32]	; (417244 <vfd_estop+0x30>)
	time_tick = 0;
  417224:	4a08      	ldr	r2, [pc, #32]	; (417248 <vfd_estop+0x34>)
	ref_speed = 0;
  417226:	602b      	str	r3, [r5, #0]
	desired_speed = 0;
  417228:	6023      	str	r3, [r4, #0]
	speed_ref_stage =0;
  41722a:	6003      	str	r3, [r0, #0]
	c_acceleration = 0;
  41722c:	600b      	str	r3, [r1, #0]
	time_tick = 0;
  41722e:	6013      	str	r3, [r2, #0]
  417230:	bd38      	pop	{r3, r4, r5, pc}
  417232:	bf00      	nop
  417234:	00416781 	.word	0x00416781
  417238:	20400c00 	.word	0x20400c00
  41723c:	20400be8 	.word	0x20400be8
  417240:	20400c0c 	.word	0x20400c0c
  417244:	20400bd4 	.word	0x20400bd4
  417248:	20400c10 	.word	0x20400c10

0041724c <vfd_trip>:
}
void vfd_trip(void)
{
  41724c:	b538      	push	{r3, r4, r5, lr}
	//protective function to immediately stop the motor and release the break.
	//enter trip state
	if(vfd_states_initialized()) vfd_states_trip();
  41724e:	4b08      	ldr	r3, [pc, #32]	; (417270 <vfd_trip+0x24>)
  417250:	4798      	blx	r3
  417252:	b108      	cbz	r0, 417258 <vfd_trip+0xc>
  417254:	4b07      	ldr	r3, [pc, #28]	; (417274 <vfd_trip+0x28>)
  417256:	4798      	blx	r3
	ref_speed=0;
  417258:	2300      	movs	r3, #0
  41725a:	4d07      	ldr	r5, [pc, #28]	; (417278 <vfd_trip+0x2c>)
	desired_speed=0;
  41725c:	4c07      	ldr	r4, [pc, #28]	; (41727c <vfd_trip+0x30>)
	speed_ref_stage =0;
  41725e:	4808      	ldr	r0, [pc, #32]	; (417280 <vfd_trip+0x34>)
	c_acceleration = 0;
  417260:	4908      	ldr	r1, [pc, #32]	; (417284 <vfd_trip+0x38>)
	time_tick = 0;
  417262:	4a09      	ldr	r2, [pc, #36]	; (417288 <vfd_trip+0x3c>)
	ref_speed=0;
  417264:	602b      	str	r3, [r5, #0]
	desired_speed=0;
  417266:	6023      	str	r3, [r4, #0]
	speed_ref_stage =0;
  417268:	6003      	str	r3, [r0, #0]
	c_acceleration = 0;
  41726a:	600b      	str	r3, [r1, #0]
	time_tick = 0;
  41726c:	6013      	str	r3, [r2, #0]
  41726e:	bd38      	pop	{r3, r4, r5, pc}
  417270:	00416335 	.word	0x00416335
  417274:	004167d1 	.word	0x004167d1
  417278:	20400c00 	.word	0x20400c00
  41727c:	20400be8 	.word	0x20400be8
  417280:	20400c0c 	.word	0x20400c0c
  417284:	20400bd4 	.word	0x20400bd4
  417288:	20400c10 	.word	0x20400c10

0041728c <wdt_init>:
 * \param us_counter The value loaded in the 12-bit Watchdog Counter.
 * \param us_delta The permitted range for reloading the Watchdog Timer.
 */
void wdt_init(Wdt *p_wdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
  41728c:	b410      	push	{r4}
	p_wdt->WDT_MR = ul_mode |
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  41728e:	4c05      	ldr	r4, [pc, #20]	; (4172a4 <wdt_init+0x18>)
  417290:	f3c2 020b 	ubfx	r2, r2, #0, #12
  417294:	ea04 4303 	and.w	r3, r4, r3, lsl #16
}
  417298:	f85d 4b04 	ldr.w	r4, [sp], #4
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  41729c:	4313      	orrs	r3, r2
  41729e:	430b      	orrs	r3, r1
	p_wdt->WDT_MR = ul_mode |
  4172a0:	6043      	str	r3, [r0, #4]
}
  4172a2:	4770      	bx	lr
  4172a4:	0fff0000 	.word	0x0fff0000

004172a8 <wdt_restart>:
/**
 * \brief Restart the watchdog timer.
 */
void wdt_restart(Wdt *p_wdt)
{
	if (p_wdt == WDT) {
  4172a8:	4b03      	ldr	r3, [pc, #12]	; (4172b8 <wdt_restart+0x10>)
  4172aa:	4298      	cmp	r0, r3
  4172ac:	d000      	beq.n	4172b0 <wdt_restart+0x8>
  4172ae:	4770      	bx	lr
		p_wdt->WDT_CR = WDT_KEY_PASSWORD | WDT_CR_WDRSTT;
  4172b0:	4b02      	ldr	r3, [pc, #8]	; (4172bc <wdt_restart+0x14>)
  4172b2:	6003      	str	r3, [r0, #0]
  4172b4:	4770      	bx	lr
  4172b6:	bf00      	nop
  4172b8:	400e1850 	.word	0x400e1850
  4172bc:	a5000001 	.word	0xa5000001

004172c0 <wdt_get_status>:
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
	return p_wdt->WDT_SR;
  4172c0:	6880      	ldr	r0, [r0, #8]
}
  4172c2:	4770      	bx	lr

004172c4 <sch_update>:
#include <pmc.h>
#include <tc.h>


void sch_update(void)
{
  4172c4:	4b0d      	ldr	r3, [pc, #52]	; (4172fc <sch_update+0x38>)
  4172c6:	b410      	push	{r4}
  4172c8:	f503 7048 	add.w	r0, r3, #800	; 0x320
				sTasks[t_index].run_me++;
				if (!sTasks[t_index].overdue_enable)
				{
					if (sTasks[t_index].run_me > 1)
					{
						sTasks[t_index].run_me = 1;
  4172cc:	2401      	movs	r4, #1
		if (sTasks[t_index].task_handler > 0)
  4172ce:	681a      	ldr	r2, [r3, #0]
  4172d0:	b172      	cbz	r2, 4172f0 <sch_update+0x2c>
			if (sTasks[t_index].delay == 0)
  4172d2:	689a      	ldr	r2, [r3, #8]
					sTasks[t_index].delay = sTasks[t_index].period - 1;
				}
			} 
			else
			{
				sTasks[t_index].delay--;
  4172d4:	1e51      	subs	r1, r2, #1
			if (sTasks[t_index].delay == 0)
  4172d6:	b952      	cbnz	r2, 4172ee <sch_update+0x2a>
				sTasks[t_index].run_me++;
  4172d8:	68da      	ldr	r2, [r3, #12]
				if (!sTasks[t_index].overdue_enable)
  4172da:	6919      	ldr	r1, [r3, #16]
				sTasks[t_index].run_me++;
  4172dc:	3201      	adds	r2, #1
  4172de:	60da      	str	r2, [r3, #12]
					if (sTasks[t_index].run_me > 1)
  4172e0:	b911      	cbnz	r1, 4172e8 <sch_update+0x24>
  4172e2:	2a01      	cmp	r2, #1
						sTasks[t_index].run_me = 1;
  4172e4:	bf88      	it	hi
  4172e6:	60dc      	strhi	r4, [r3, #12]
				if(sTasks[t_index].period)
  4172e8:	685a      	ldr	r2, [r3, #4]
					sTasks[t_index].delay = sTasks[t_index].period - 1;
  4172ea:	1e51      	subs	r1, r2, #1
				if(sTasks[t_index].period)
  4172ec:	b102      	cbz	r2, 4172f0 <sch_update+0x2c>
				sTasks[t_index].delay--;
  4172ee:	6099      	str	r1, [r3, #8]
  4172f0:	3314      	adds	r3, #20
	for (t_index=0; t_index < SCH_TASK_MAX; t_index++)
  4172f2:	4283      	cmp	r3, r0
  4172f4:	d1eb      	bne.n	4172ce <sch_update+0xa>
			}
		}
	}
}
  4172f6:	f85d 4b04 	ldr.w	r4, [sp], #4
  4172fa:	4770      	bx	lr
  4172fc:	20406d24 	.word	0x20406d24

00417300 <sch_add_task>:

uByte_t sch_add_task(void (*a_task_handler)(void),
					uint_t task_delay,
					uint_t task_period, uint_t overdue_enable)
{
  417300:	b4f0      	push	{r4, r5, r6, r7}
	uByte_t t_index = 0;
	while((sTasks[t_index].task_handler != 0) && (t_index < SCH_TASK_MAX))
  417302:	4e0e      	ldr	r6, [pc, #56]	; (41733c <sch_add_task+0x3c>)
{
  417304:	4607      	mov	r7, r0
	while((sTasks[t_index].task_handler != 0) && (t_index < SCH_TASK_MAX))
  417306:	6830      	ldr	r0, [r6, #0]
  417308:	b130      	cbz	r0, 417318 <sch_add_task+0x18>
  41730a:	4634      	mov	r4, r6
  41730c:	2000      	movs	r0, #0
  41730e:	f854 5f14 	ldr.w	r5, [r4, #20]!
	{
		//search for empty task record space
		t_index++;
  417312:	3001      	adds	r0, #1
	while((sTasks[t_index].task_handler != 0) && (t_index < SCH_TASK_MAX))
  417314:	2d00      	cmp	r5, #0
  417316:	d1fa      	bne.n	41730e <sch_add_task+0xe>
		return SCH_TASKLIST_FULL;
	}
	
	//if you passed all of the above then you have empty record in your list
	
	sTasks[t_index].task_handler = a_task_handler;
  417318:	eb00 0480 	add.w	r4, r0, r0, lsl #2
	
	sTasks[t_index].delay = task_delay;
	sTasks[t_index].period = task_period;
	sTasks[t_index].run_me = 0;
  41731c:	2500      	movs	r5, #0
	sTasks[t_index].task_handler = a_task_handler;
  41731e:	00a4      	lsls	r4, r4, #2
  417320:	5137      	str	r7, [r6, r4]
  417322:	4426      	add	r6, r4
	sTasks[t_index].delay = task_delay;
  417324:	60b1      	str	r1, [r6, #8]
	sTasks[t_index].period = task_period;
  417326:	6072      	str	r2, [r6, #4]
	sTasks[t_index].run_me = 0;
  417328:	60f5      	str	r5, [r6, #12]
	if(overdue_enable) sTasks[t_index].overdue_enable = 1;
  41732a:	b913      	cbnz	r3, 417332 <sch_add_task+0x32>
	else sTasks[t_index].overdue_enable = 0;
  41732c:	6133      	str	r3, [r6, #16]
	
	return t_index;
}
  41732e:	bcf0      	pop	{r4, r5, r6, r7}
  417330:	4770      	bx	lr
	if(overdue_enable) sTasks[t_index].overdue_enable = 1;
  417332:	2301      	movs	r3, #1
  417334:	6133      	str	r3, [r6, #16]
}
  417336:	bcf0      	pop	{r4, r5, r6, r7}
  417338:	4770      	bx	lr
  41733a:	bf00      	nop
  41733c:	20406d24 	.word	0x20406d24

00417340 <sch_dispatch_tasks>:

void sch_dispatch_tasks(void)
{
  417340:	b538      	push	{r3, r4, r5, lr}
  417342:	4c0e      	ldr	r4, [pc, #56]	; (41737c <sch_dispatch_tasks+0x3c>)
  417344:	f504 7548 	add.w	r5, r4, #800	; 0x320
  417348:	e002      	b.n	417350 <sch_dispatch_tasks+0x10>
  41734a:	3414      	adds	r4, #20
	uByte_t t_index;
	
	for (t_index=0; t_index < SCH_TASK_MAX; t_index++)
  41734c:	42ac      	cmp	r4, r5
  41734e:	d014      	beq.n	41737a <sch_dispatch_tasks+0x3a>
	{
		if (sTasks[t_index].task_handler) if(sTasks[t_index].run_me)
  417350:	6823      	ldr	r3, [r4, #0]
  417352:	2b00      	cmp	r3, #0
  417354:	d0f9      	beq.n	41734a <sch_dispatch_tasks+0xa>
  417356:	68e2      	ldr	r2, [r4, #12]
  417358:	2a00      	cmp	r2, #0
  41735a:	d0f6      	beq.n	41734a <sch_dispatch_tasks+0xa>
		{
			(*sTasks[t_index].task_handler)();
  41735c:	4798      	blx	r3
			sTasks[t_index].run_me--;
  41735e:	68e3      	ldr	r3, [r4, #12]
			if (sTasks[t_index].period == 0)
  417360:	6862      	ldr	r2, [r4, #4]
			sTasks[t_index].run_me--;
  417362:	3b01      	subs	r3, #1
  417364:	60e3      	str	r3, [r4, #12]
			if (sTasks[t_index].period == 0)
  417366:	2a00      	cmp	r2, #0
  417368:	d1ef      	bne.n	41734a <sch_dispatch_tasks+0xa>

void sch_delete_task(uByte_t task_id)
{
	if(task_id >= SCH_TASK_MAX)	return;
	
	sTasks[task_id].task_handler=0;
  41736a:	6022      	str	r2, [r4, #0]
  41736c:	3414      	adds	r4, #20
	sTasks[task_id].period=0;
	sTasks[task_id].delay=0;
  41736e:	f844 2c0c 	str.w	r2, [r4, #-12]
	sTasks[task_id].run_me=0;
  417372:	f844 2c08 	str.w	r2, [r4, #-8]
	for (t_index=0; t_index < SCH_TASK_MAX; t_index++)
  417376:	42ac      	cmp	r4, r5
  417378:	d1ea      	bne.n	417350 <sch_dispatch_tasks+0x10>
}
  41737a:	bd38      	pop	{r3, r4, r5, pc}
  41737c:	20406d24 	.word	0x20406d24

00417380 <sch_init_timer>:
		sch_delete_task(t_index);
	}
}

void sch_init_timer(void)
{
  417380:	b570      	push	{r4, r5, r6, lr}
	//timer counter TC2 initialization for use with the schedular
	//return;
	pmc_enable_periph_clk(ID_TC7);
	
	tc_init(TC2, 1, TC_CMR_TCCLKS_TIMER_CLOCK2|TC_CMR_WAVSEL_UP_RC); //TC8 clk = MCK/8 = 18750000Hz
  417382:	4c11      	ldr	r4, [pc, #68]	; (4173c8 <sch_init_timer+0x48>)
	pmc_enable_periph_clk(ID_TC7);
  417384:	2030      	movs	r0, #48	; 0x30
  417386:	4b11      	ldr	r3, [pc, #68]	; (4173cc <sch_init_timer+0x4c>)
  417388:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  41738c:	4798      	blx	r3
	tc_init(TC2, 1, TC_CMR_TCCLKS_TIMER_CLOCK2|TC_CMR_WAVSEL_UP_RC); //TC8 clk = MCK/8 = 18750000Hz
  41738e:	4620      	mov	r0, r4
  417390:	f244 0201 	movw	r2, #16385	; 0x4001
  417394:	2101      	movs	r1, #1
  417396:	4b0e      	ldr	r3, [pc, #56]	; (4173d0 <sch_init_timer+0x50>)
  417398:	4798      	blx	r3
	tc_write_rc(TC2, 1, (18750000) / SCH_TICK_FREQ);
  41739a:	4620      	mov	r0, r4
  41739c:	f240 7253 	movw	r2, #1875	; 0x753
  4173a0:	2101      	movs	r1, #1
  4173a2:	4b0c      	ldr	r3, [pc, #48]	; (4173d4 <sch_init_timer+0x54>)
  4173a4:	4798      	blx	r3
	tc_enable_interrupt(TC2, 1, TC_IER_CPCS);
  4173a6:	4620      	mov	r0, r4
  4173a8:	2210      	movs	r2, #16
  4173aa:	2101      	movs	r1, #1
  4173ac:	4b0a      	ldr	r3, [pc, #40]	; (4173d8 <sch_init_timer+0x58>)
  4173ae:	4798      	blx	r3
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  4173b0:	4b0a      	ldr	r3, [pc, #40]	; (4173dc <sch_init_timer+0x5c>)
  4173b2:	2260      	movs	r2, #96	; 0x60
	NVIC_SetPriority(TC7_IRQn,3);
	NVIC_EnableIRQ(TC7_IRQn);
	tc_start(TC2, 1);
  4173b4:	4620      	mov	r0, r4
  4173b6:	2101      	movs	r1, #1
  4173b8:	f883 2330 	strb.w	r2, [r3, #816]	; 0x330
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4173bc:	605d      	str	r5, [r3, #4]
  4173be:	4a08      	ldr	r2, [pc, #32]	; (4173e0 <sch_init_timer+0x60>)
}
  4173c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tc_start(TC2, 1);
  4173c4:	4710      	bx	r2
  4173c6:	bf00      	nop
  4173c8:	40014000 	.word	0x40014000
  4173cc:	00417a25 	.word	0x00417a25
  4173d0:	00412689 	.word	0x00412689
  4173d4:	004126b9 	.word	0x004126b9
  4173d8:	004126c1 	.word	0x004126c1
  4173dc:	e000e100 	.word	0xe000e100
  4173e0:	004126a9 	.word	0x004126a9

004173e4 <sch_init>:
{
  4173e4:	b508      	push	{r3, lr}
	sch_init_timer();
  4173e6:	4b08      	ldr	r3, [pc, #32]	; (417408 <sch_init+0x24>)
  4173e8:	4798      	blx	r3
  4173ea:	4b08      	ldr	r3, [pc, #32]	; (41740c <sch_init+0x28>)
	sTasks[task_id].task_handler=0;
  4173ec:	2200      	movs	r2, #0
  4173ee:	f503 7148 	add.w	r1, r3, #800	; 0x320
  4173f2:	601a      	str	r2, [r3, #0]
  4173f4:	3314      	adds	r3, #20
	sTasks[task_id].period=0;
  4173f6:	f843 2c10 	str.w	r2, [r3, #-16]
	sTasks[task_id].delay=0;
  4173fa:	f843 2c0c 	str.w	r2, [r3, #-12]
	sTasks[task_id].run_me=0;
  4173fe:	f843 2c08 	str.w	r2, [r3, #-8]
	for (t_index=0; t_index<SCH_TASK_MAX; t_index++)
  417402:	428b      	cmp	r3, r1
  417404:	d1f5      	bne.n	4173f2 <sch_init+0xe>
}
  417406:	bd08      	pop	{r3, pc}
  417408:	00417381 	.word	0x00417381
  41740c:	20406d24 	.word	0x20406d24

00417410 <sch_edit_task_period>:


uByte_t sch_edit_task_period(uByte_t t_index, uint_t task_period)
{
	if(t_index >= SCH_TASK_MAX) return 1;
  417410:	2827      	cmp	r0, #39	; 0x27
  417412:	d809      	bhi.n	417428 <sch_edit_task_period+0x18>
	if(sTasks[t_index].task_handler==0) return 1;
  417414:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  417418:	4b04      	ldr	r3, [pc, #16]	; (41742c <sch_edit_task_period+0x1c>)
  41741a:	0080      	lsls	r0, r0, #2
  41741c:	581a      	ldr	r2, [r3, r0]
  41741e:	b11a      	cbz	r2, 417428 <sch_edit_task_period+0x18>
	
	sTasks[t_index].period = task_period;
  417420:	4403      	add	r3, r0
	return 0;
  417422:	2000      	movs	r0, #0
	sTasks[t_index].period = task_period;
  417424:	6059      	str	r1, [r3, #4]
	return 0;
  417426:	4770      	bx	lr
	if(t_index >= SCH_TASK_MAX) return 1;
  417428:	2001      	movs	r0, #1
  41742a:	4770      	bx	lr
  41742c:	20406d24 	.word	0x20406d24

00417430 <pio_pull_up>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  417430:	b90a      	cbnz	r2, 417436 <pio_pull_up+0x6>
		p_pio->PIO_PUER = ul_mask;
	} else {
		p_pio->PIO_PUDR = ul_mask;
  417432:	6601      	str	r1, [r0, #96]	; 0x60
  417434:	4770      	bx	lr
		p_pio->PIO_PUER = ul_mask;
  417436:	6641      	str	r1, [r0, #100]	; 0x64
  417438:	4770      	bx	lr
  41743a:	bf00      	nop

0041743c <pio_set>:
  41743c:	6301      	str	r1, [r0, #48]	; 0x30
  41743e:	4770      	bx	lr

00417440 <pio_clear>:
  417440:	6341      	str	r1, [r0, #52]	; 0x34
  417442:	4770      	bx	lr

00417444 <pio_set_peripheral>:

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  417444:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
	p_pio->PIO_IDR = ul_mask;
  417448:	6442      	str	r2, [r0, #68]	; 0x44
	switch (ul_type) {
  41744a:	d034      	beq.n	4174b6 <pio_set_peripheral+0x72>
  41744c:	d810      	bhi.n	417470 <pio_set_peripheral+0x2c>
  41744e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  417452:	d01c      	beq.n	41748e <pio_set_peripheral+0x4a>
  417454:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  417458:	d12a      	bne.n	4174b0 <pio_set_peripheral+0x6c>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  41745a:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  41745c:	4313      	orrs	r3, r2
  41745e:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  417460:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  417462:	6f41      	ldr	r1, [r0, #116]	; 0x74
  417464:	400b      	ands	r3, r1
  417466:	ea23 0302 	bic.w	r3, r3, r2
  41746a:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  41746c:	6042      	str	r2, [r0, #4]
  41746e:	4770      	bx	lr
	switch (ul_type) {
  417470:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  417474:	d01b      	beq.n	4174ae <pio_set_peripheral+0x6a>
  417476:	d829      	bhi.n	4174cc <pio_set_peripheral+0x88>
  417478:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  41747c:	d1f6      	bne.n	41746c <pio_set_peripheral+0x28>
		ul_sr = p_pio->PIO_ABCDSR[0];
  41747e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  417480:	4313      	orrs	r3, r2
  417482:	6703      	str	r3, [r0, #112]	; 0x70
		ul_sr = p_pio->PIO_ABCDSR[1];
  417484:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  417486:	4313      	orrs	r3, r2
  417488:	6743      	str	r3, [r0, #116]	; 0x74
	p_pio->PIO_PDR = ul_mask;
  41748a:	6042      	str	r2, [r0, #4]
  41748c:	4770      	bx	lr
		ul_sr = p_pio->PIO_ABCDSR[0];
  41748e:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  417490:	43d3      	mvns	r3, r2
{
  417492:	b410      	push	{r4}
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  417494:	6f04      	ldr	r4, [r0, #112]	; 0x70
  417496:	4021      	ands	r1, r4
  417498:	461c      	mov	r4, r3
  41749a:	4019      	ands	r1, r3
  41749c:	6701      	str	r1, [r0, #112]	; 0x70
		ul_sr = p_pio->PIO_ABCDSR[1];
  41749e:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4174a0:	6f41      	ldr	r1, [r0, #116]	; 0x74
  4174a2:	400b      	ands	r3, r1
  4174a4:	4023      	ands	r3, r4
}
  4174a6:	f85d 4b04 	ldr.w	r4, [sp], #4
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4174aa:	6743      	str	r3, [r0, #116]	; 0x74
	p_pio->PIO_PDR = ul_mask;
  4174ac:	6042      	str	r2, [r0, #4]
}
  4174ae:	4770      	bx	lr
	switch (ul_type) {
  4174b0:	2900      	cmp	r1, #0
  4174b2:	d1db      	bne.n	41746c <pio_set_peripheral+0x28>
  4174b4:	4770      	bx	lr
		ul_sr = p_pio->PIO_ABCDSR[0];
  4174b6:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4174b8:	6f01      	ldr	r1, [r0, #112]	; 0x70
  4174ba:	400b      	ands	r3, r1
  4174bc:	ea23 0302 	bic.w	r3, r3, r2
  4174c0:	6703      	str	r3, [r0, #112]	; 0x70
		ul_sr = p_pio->PIO_ABCDSR[1];
  4174c2:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4174c4:	4313      	orrs	r3, r2
  4174c6:	6743      	str	r3, [r0, #116]	; 0x74
	p_pio->PIO_PDR = ul_mask;
  4174c8:	6042      	str	r2, [r0, #4]
  4174ca:	4770      	bx	lr
	switch (ul_type) {
  4174cc:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  4174d0:	d0ed      	beq.n	4174ae <pio_set_peripheral+0x6a>
  4174d2:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  4174d6:	d0ea      	beq.n	4174ae <pio_set_peripheral+0x6a>
  4174d8:	e7c8      	b.n	41746c <pio_set_peripheral+0x28>
  4174da:	bf00      	nop

004174dc <pio_set_input>:
	if (ul_pull_up_enable) {
  4174dc:	07d3      	lsls	r3, r2, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4174de:	6441      	str	r1, [r0, #68]	; 0x44
	if (ul_pull_up_enable) {
  4174e0:	d515      	bpl.n	41750e <pio_set_input+0x32>
		p_pio->PIO_PUER = ul_mask;
  4174e2:	6641      	str	r1, [r0, #100]	; 0x64
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4174e4:	f012 0f0a 	tst.w	r2, #10
  4174e8:	d009      	beq.n	4174fe <pio_set_input+0x22>
	if (ul_attribute & PIO_DEGLITCH) {
  4174ea:	0793      	lsls	r3, r2, #30
		p_pio->PIO_IFER = ul_mask;
  4174ec:	6201      	str	r1, [r0, #32]
	if (ul_attribute & PIO_DEGLITCH) {
  4174ee:	d409      	bmi.n	417504 <pio_set_input+0x28>
		if (ul_attribute & PIO_DEBOUNCE) {
  4174f0:	0713      	lsls	r3, r2, #28
  4174f2:	d501      	bpl.n	4174f8 <pio_set_input+0x1c>
			p_pio->PIO_IFSCER = ul_mask;
  4174f4:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	p_pio->PIO_ODR = ul_mask;
  4174f8:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  4174fa:	6001      	str	r1, [r0, #0]
  4174fc:	4770      	bx	lr
	if (ul_attribute & PIO_DEGLITCH) {
  4174fe:	0793      	lsls	r3, r2, #30
		p_pio->PIO_IFDR = ul_mask;
  417500:	6241      	str	r1, [r0, #36]	; 0x24
	if (ul_attribute & PIO_DEGLITCH) {
  417502:	d5f5      	bpl.n	4174f0 <pio_set_input+0x14>
		p_pio->PIO_IFSCDR = ul_mask;
  417504:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
	p_pio->PIO_ODR = ul_mask;
  417508:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  41750a:	6001      	str	r1, [r0, #0]
  41750c:	4770      	bx	lr
		p_pio->PIO_PUDR = ul_mask;
  41750e:	6601      	str	r1, [r0, #96]	; 0x60
  417510:	e7e8      	b.n	4174e4 <pio_set_input+0x8>
  417512:	bf00      	nop

00417514 <pio_set_output>:
{
  417514:	b410      	push	{r4}
  417516:	9c01      	ldr	r4, [sp, #4]
	p_pio->PIO_IDR = ul_mask;
  417518:	6441      	str	r1, [r0, #68]	; 0x44
	if (ul_pull_up_enable) {
  41751a:	b194      	cbz	r4, 417542 <pio_set_output+0x2e>
		p_pio->PIO_PUER = ul_mask;
  41751c:	6641      	str	r1, [r0, #100]	; 0x64
	if (ul_multidrive_enable) {
  41751e:	b13b      	cbz	r3, 417530 <pio_set_output+0x1c>
		p_pio->PIO_MDER = ul_mask;
  417520:	6501      	str	r1, [r0, #80]	; 0x50
	if (ul_default_level) {
  417522:	b942      	cbnz	r2, 417536 <pio_set_output+0x22>
		p_pio->PIO_CODR = ul_mask;
  417524:	6341      	str	r1, [r0, #52]	; 0x34
}
  417526:	f85d 4b04 	ldr.w	r4, [sp], #4
	p_pio->PIO_OER = ul_mask;
  41752a:	6101      	str	r1, [r0, #16]
	p_pio->PIO_PER = ul_mask;
  41752c:	6001      	str	r1, [r0, #0]
}
  41752e:	4770      	bx	lr
		p_pio->PIO_MDDR = ul_mask;
  417530:	6541      	str	r1, [r0, #84]	; 0x54
	if (ul_default_level) {
  417532:	2a00      	cmp	r2, #0
  417534:	d0f6      	beq.n	417524 <pio_set_output+0x10>
		p_pio->PIO_SODR = ul_mask;
  417536:	6301      	str	r1, [r0, #48]	; 0x30
}
  417538:	f85d 4b04 	ldr.w	r4, [sp], #4
	p_pio->PIO_OER = ul_mask;
  41753c:	6101      	str	r1, [r0, #16]
	p_pio->PIO_PER = ul_mask;
  41753e:	6001      	str	r1, [r0, #0]
}
  417540:	4770      	bx	lr
		p_pio->PIO_PUDR = ul_mask;
  417542:	6601      	str	r1, [r0, #96]	; 0x60
  417544:	e7eb      	b.n	41751e <pio_set_output+0xa>
  417546:	bf00      	nop

00417548 <pio_get_interrupt_status>:
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  417548:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  41754a:	4770      	bx	lr

0041754c <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  41754c:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  41754e:	4770      	bx	lr

00417550 <pio_set_writeprotect>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_enable 1 to enable, 0 to disable.
 */
void pio_set_writeprotect(Pio *p_pio, const uint32_t ul_enable)
{
	p_pio->PIO_WPMR = PIO_WPMR_WPKEY_PASSWD | (ul_enable & PIO_WPMR_WPEN);
  417550:	f001 0101 	and.w	r1, r1, #1
  417554:	4b02      	ldr	r3, [pc, #8]	; (417560 <pio_set_writeprotect+0x10>)
  417556:	430b      	orrs	r3, r1
  417558:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
  41755c:	4770      	bx	lr
  41755e:	bf00      	nop
  417560:	50494f00 	.word	0x50494f00

00417564 <pio_toggle_pin>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  417564:	4b07      	ldr	r3, [pc, #28]	; (417584 <pio_toggle_pin+0x20>)
	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  417566:	2201      	movs	r2, #1
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  417568:	eb03 1350 	add.w	r3, r3, r0, lsr #5
	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  41756c:	f000 001f 	and.w	r0, r0, #31
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  417570:	025b      	lsls	r3, r3, #9
	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  417572:	fa02 f000 	lsl.w	r0, r2, r0
  417576:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  417578:	4202      	tst	r2, r0
  41757a:	d101      	bne.n	417580 <pio_toggle_pin+0x1c>
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  41757c:	6318      	str	r0, [r3, #48]	; 0x30
  41757e:	4770      	bx	lr
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  417580:	6358      	str	r0, [r3, #52]	; 0x34
  417582:	4770      	bx	lr
  417584:	00200707 	.word	0x00200707

00417588 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  417588:	b570      	push	{r4, r5, r6, lr}
	struct pll_config pllcfg;

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  41758a:	4810      	ldr	r0, [pc, #64]	; (4175cc <sysclk_init+0x44>)
  41758c:	4d10      	ldr	r5, [pc, #64]	; (4175d0 <sysclk_init+0x48>)
  41758e:	47a8      	blx	r5
	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
		break;

	case OSC_MAINCK_12M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  417590:	2020      	movs	r0, #32
  417592:	4b10      	ldr	r3, [pc, #64]	; (4175d4 <sysclk_init+0x4c>)
  417594:	4c10      	ldr	r4, [pc, #64]	; (4175d8 <sysclk_init+0x50>)
  417596:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  417598:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  41759a:	2800      	cmp	r0, #0
  41759c:	d0fc      	beq.n	417598 <sysclk_init+0x10>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  41759e:	4b0f      	ldr	r3, [pc, #60]	; (4175dc <sysclk_init+0x54>)
  4175a0:	4798      	blx	r3
  4175a2:	4c0f      	ldr	r4, [pc, #60]	; (4175e0 <sysclk_init+0x58>)
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4175a4:	4b0f      	ldr	r3, [pc, #60]	; (4175e4 <sysclk_init+0x5c>)
  4175a6:	4a10      	ldr	r2, [pc, #64]	; (4175e8 <sysclk_init+0x60>)
  4175a8:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
	return pmc_is_locked_pllack();
  4175aa:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  4175ac:	2800      	cmp	r0, #0
  4175ae:	d0fc      	beq.n	4175aa <sysclk_init+0x22>
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_mck_set_division(CONFIG_SYSCLK_DIV);
  4175b0:	2002      	movs	r0, #2
  4175b2:	4b0e      	ldr	r3, [pc, #56]	; (4175ec <sysclk_init+0x64>)
  4175b4:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4175b6:	4b0e      	ldr	r3, [pc, #56]	; (4175f0 <sysclk_init+0x68>)
  4175b8:	2000      	movs	r0, #0
  4175ba:	4798      	blx	r3
		pll_wait_for_lock(1);
		pmc_mck_set_division(CONFIG_SYSCLK_DIV);
		pmc_switch_mck_to_upllck(CONFIG_SYSCLK_PRES);
	}
	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  4175bc:	4b0d      	ldr	r3, [pc, #52]	; (4175f4 <sysclk_init+0x6c>)
  4175be:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  4175c0:	462b      	mov	r3, r5
  4175c2:	4802      	ldr	r0, [pc, #8]	; (4175cc <sysclk_init+0x44>)

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  4175c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	system_init_flash(sysclk_get_cpu_hz());
  4175c8:	4718      	bx	r3
  4175ca:	bf00      	nop
  4175cc:	11e1a300 	.word	0x11e1a300
  4175d0:	004008b5 	.word	0x004008b5
  4175d4:	004179a9 	.word	0x004179a9
  4175d8:	004179f5 	.word	0x004179f5
  4175dc:	00417a05 	.word	0x00417a05
  4175e0:	00417a15 	.word	0x00417a15
  4175e4:	400e0600 	.word	0x400e0600
  4175e8:	20183f01 	.word	0x20183f01
  4175ec:	00417925 	.word	0x00417925
  4175f0:	00417955 	.word	0x00417955
  4175f4:	004007d1 	.word	0x004007d1

004175f8 <afec_process_callback>:
 * \brief Call the callback function if the corresponding interrupt is asserted
 *
 * \param afec  Base address of the AFEC.
 */
static void afec_process_callback(Afec *const afec)
{
  4175f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (afec == AFEC1) {
  4175fc:	4f17      	ldr	r7, [pc, #92]	; (41765c <afec_process_callback+0x64>)
{
  4175fe:	b082      	sub	sp, #8
 *
 * \return The interrupt status value.
 */
static inline uint32_t afec_get_interrupt_status(Afec *const afec)
{
	return afec->AFEC_ISR;
  417600:	6b02      	ldr	r2, [r0, #48]	; 0x30
	uint32_t cnt, inst_num;

	status = afec_get_interrupt_status(afec) & afec_get_interrupt_mask(afec);
	inst_num = afec_find_inst_num(afec);

	for (cnt = 0; cnt < _AFEC_NUM_OF_INTERRUPT_SOURCE; cnt++) {
  417602:	2400      	movs	r4, #0
	if (afec == AFEC1) {
  417604:	1bc7      	subs	r7, r0, r7
 *
 * \return The interrupt mask value.
 */
static inline uint32_t afec_get_interrupt_mask(Afec *const afec)
{
	return afec->AFEC_IMR;
  417606:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  417608:	f8df 8054 	ldr.w	r8, [pc, #84]	; 417660 <afec_process_callback+0x68>
			if (status & (1 << cnt)) {
				afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
			}
		#endif
		} else if (cnt < AFEC_INTERRUPT_TEMP_CHANGE) {
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1))) {
  41760c:	2601      	movs	r6, #1
	if (afec == AFEC1) {
  41760e:	fab7 f787 	clz	r7, r7
	status = afec_get_interrupt_status(afec) & afec_get_interrupt_mask(afec);
  417612:	4013      	ands	r3, r2
	if (afec == AFEC1) {
  417614:	097f      	lsrs	r7, r7, #5
	status = afec_get_interrupt_status(afec) & afec_get_interrupt_mask(afec);
  417616:	9301      	str	r3, [sp, #4]
  417618:	01bf      	lsls	r7, r7, #6
  41761a:	eb08 0507 	add.w	r5, r8, r7
  41761e:	e009      	b.n	417634 <afec_process_callback+0x3c>
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1))) {
  417620:	9a01      	ldr	r2, [sp, #4]
  417622:	4213      	tst	r3, r2
  417624:	d002      	beq.n	41762c <afec_process_callback+0x34>
	if (afec_callback_pointer[inst_num][source]) {
  417626:	682b      	ldr	r3, [r5, #0]
  417628:	b103      	cbz	r3, 41762c <afec_process_callback+0x34>
		afec_callback_pointer[inst_num][source]();
  41762a:	4798      	blx	r3
	for (cnt = 0; cnt < _AFEC_NUM_OF_INTERRUPT_SOURCE; cnt++) {
  41762c:	3401      	adds	r4, #1
  41762e:	3504      	adds	r5, #4
  417630:	2c10      	cmp	r4, #16
  417632:	d010      	beq.n	417656 <afec_process_callback+0x5e>
		if (cnt < AFEC_INTERRUPT_DATA_READY) {
  417634:	2c0b      	cmp	r4, #11
			if (status & (1 << cnt)) {
  417636:	fa06 f304 	lsl.w	r3, r6, r4
		if (cnt < AFEC_INTERRUPT_DATA_READY) {
  41763a:	d9f1      	bls.n	417620 <afec_process_callback+0x28>
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1))) {
  41763c:	f104 030c 	add.w	r3, r4, #12
		} else if (cnt < AFEC_INTERRUPT_TEMP_CHANGE) {
  417640:	2c0f      	cmp	r4, #15
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1))) {
  417642:	fa06 f303 	lsl.w	r3, r6, r3
		} else if (cnt < AFEC_INTERRUPT_TEMP_CHANGE) {
  417646:	d1eb      	bne.n	417620 <afec_process_callback+0x28>
				afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
			}
		} else {
			if (status & (1 << (cnt + AFEC_INTERRUPT_GAP1 + AFEC_INTERRUPT_GAP2))) {
  417648:	9b01      	ldr	r3, [sp, #4]
  41764a:	005b      	lsls	r3, r3, #1
  41764c:	d503      	bpl.n	417656 <afec_process_callback+0x5e>
	if (afec_callback_pointer[inst_num][source]) {
  41764e:	4447      	add	r7, r8
  417650:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  417652:	b103      	cbz	r3, 417656 <afec_process_callback+0x5e>
		afec_callback_pointer[inst_num][source]();
  417654:	4798      	blx	r3
				afec_interrupt(inst_num, (enum afec_interrupt_source)cnt);
			}
		}
	}
}
  417656:	b002      	add	sp, #8
  417658:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41765c:	40064000 	.word	0x40064000
  417660:	2040704c 	.word	0x2040704c

00417664 <afec_ch_set_config>:
{
  417664:	b470      	push	{r4, r5, r6}
	reg &= ~(0x1u << channel);
  417666:	2301      	movs	r3, #1
	reg |= (config->diff) ? (0x1u << channel) : 0;
  417668:	7814      	ldrb	r4, [r2, #0]
	reg = afec->AFEC_DIFFR;
  41766a:	6e06      	ldr	r6, [r0, #96]	; 0x60
	reg &= ~(0x03u << (2 * channel));
  41766c:	2503      	movs	r5, #3
	reg &= ~(0x1u << channel);
  41766e:	408b      	lsls	r3, r1
	reg |= (config->diff) ? (0x1u << channel) : 0;
  417670:	2c00      	cmp	r4, #0
	reg &= ~(0x03u << (2 * channel));
  417672:	ea4f 0441 	mov.w	r4, r1, lsl #1
	reg &= ~(0x1u << channel);
  417676:	ea26 0103 	bic.w	r1, r6, r3
	reg |= (config->diff) ? (0x1u << channel) : 0;
  41767a:	bf08      	it	eq
  41767c:	2300      	moveq	r3, #0
	reg &= ~(0x03u << (2 * channel));
  41767e:	40a5      	lsls	r5, r4
	reg |= (config->diff) ? (0x1u << channel) : 0;
  417680:	430b      	orrs	r3, r1
	afec->AFEC_DIFFR = reg;
  417682:	6603      	str	r3, [r0, #96]	; 0x60
	reg |= (config->gain) << (2 * channel);
  417684:	7851      	ldrb	r1, [r2, #1]
	reg = afec->AFEC_CGR;
  417686:	6d43      	ldr	r3, [r0, #84]	; 0x54
	reg |= (config->gain) << (2 * channel);
  417688:	40a1      	lsls	r1, r4
	reg &= ~(0x03u << (2 * channel));
  41768a:	ea23 0305 	bic.w	r3, r3, r5
	reg |= (config->gain) << (2 * channel);
  41768e:	4319      	orrs	r1, r3
}
  417690:	bc70      	pop	{r4, r5, r6}
	afec->AFEC_CGR = reg;
  417692:	6541      	str	r1, [r0, #84]	; 0x54
}
  417694:	4770      	bx	lr
  417696:	bf00      	nop

00417698 <afec_get_config_defaults>:
		cfg->transfer = 1;
  417698:	2301      	movs	r3, #1
	cfg->resolution = AFEC_12_BITS;
  41769a:	2200      	movs	r2, #0
		cfg->tracktim = 2;
  41769c:	2102      	movs	r1, #2
	cfg->resolution = AFEC_12_BITS;
  41769e:	6002      	str	r2, [r0, #0]
		cfg->tracktim = 2;
  4176a0:	7401      	strb	r1, [r0, #16]
		cfg->useq = false;
  4176a2:	74c2      	strb	r2, [r0, #19]
		cfg->transfer = 1;
  4176a4:	7443      	strb	r3, [r0, #17]
		cfg->anach = true;
  4176a6:	7483      	strb	r3, [r0, #18]
		cfg->tag = true;
  4176a8:	7503      	strb	r3, [r0, #20]
		cfg->stm = true;
  4176aa:	7543      	strb	r3, [r0, #21]
		cfg->ibctl = 1;
  4176ac:	7583      	strb	r3, [r0, #22]
{
  4176ae:	b470      	push	{r4, r5, r6}
	cfg->mck = sysclk_get_cpu_hz();
  4176b0:	4e04      	ldr	r6, [pc, #16]	; (4176c4 <afec_get_config_defaults+0x2c>)
		cfg->startup_time = AFEC_STARTUP_TIME_4;
  4176b2:	f44f 2480 	mov.w	r4, #262144	; 0x40000
		cfg->afec_clock = 6000000UL;
  4176b6:	4d04      	ldr	r5, [pc, #16]	; (4176c8 <afec_get_config_defaults+0x30>)
	cfg->mck = sysclk_get_cpu_hz();
  4176b8:	6046      	str	r6, [r0, #4]
		cfg->afec_clock = 6000000UL;
  4176ba:	6085      	str	r5, [r0, #8]
		cfg->startup_time = AFEC_STARTUP_TIME_4;
  4176bc:	60c4      	str	r4, [r0, #12]
}
  4176be:	bc70      	pop	{r4, r5, r6}
  4176c0:	4770      	bx	lr
  4176c2:	bf00      	nop
  4176c4:	11e1a300 	.word	0x11e1a300
  4176c8:	005b8d80 	.word	0x005b8d80

004176cc <afec_ch_get_config_defaults>:
	cfg->diff = false;
  4176cc:	2200      	movs	r2, #0
   	cfg->gain = AFEC_GAINVALUE_1;
  4176ce:	2301      	movs	r3, #1
	cfg->diff = false;
  4176d0:	7002      	strb	r2, [r0, #0]
   	cfg->gain = AFEC_GAINVALUE_1;
  4176d2:	7043      	strb	r3, [r0, #1]
  4176d4:	4770      	bx	lr
  4176d6:	bf00      	nop

004176d8 <afec_init>:
	return afec->AFEC_ISR;
  4176d8:	6b02      	ldr	r2, [r0, #48]	; 0x30
	if ((afec_get_interrupt_status(afec) & AFEC_ISR_DRDY) == AFEC_ISR_DRDY) {
  4176da:	f012 7280 	ands.w	r2, r2, #16777216	; 0x1000000
  4176de:	d001      	beq.n	4176e4 <afec_init+0xc>
		return STATUS_ERR_BUSY;
  4176e0:	2019      	movs	r0, #25
  4176e2:	4770      	bx	lr
	afec->AFEC_CR = AFEC_CR_SWRST;
  4176e4:	2301      	movs	r3, #1
{
  4176e6:	b5f0      	push	{r4, r5, r6, r7, lr}
	afec->AFEC_CR = AFEC_CR_SWRST;
  4176e8:	6003      	str	r3, [r0, #0]
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  4176ea:	1d0b      	adds	r3, r1, #4
			AFEC_MR_TRACKTIM(config->tracktim) |
  4176ec:	7c0e      	ldrb	r6, [r1, #16]
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  4176ee:	f891 e013 	ldrb.w	lr, [r1, #19]
			AFEC_MR_TRACKTIM(config->tracktim) |
  4176f2:	0636      	lsls	r6, r6, #24
	if(afec == AFEC0) {
  4176f4:	4c26      	ldr	r4, [pc, #152]	; (417790 <afec_init+0xb8>)
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  4176f6:	f1be 0f00 	cmp.w	lr, #0
			AFEC_MR_TRACKTIM(config->tracktim) |
  4176fa:	f006 6670 	and.w	r6, r6, #251658240	; 0xf000000
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  4176fe:	bf18      	it	ne
  417700:	f04f 4200 	movne.w	r2, #2147483648	; 0x80000000
  417704:	cba8      	ldmia	r3, {r3, r5, r7}
			AFEC_MR_PRESCAL((config->mck / config->afec_clock )- 1) |
  417706:	fbb3 f3f5 	udiv	r3, r3, r5
  41770a:	3b01      	subs	r3, #1
			AFEC_MR_TRANSFER(config->transfer) |
  41770c:	7c4d      	ldrb	r5, [r1, #17]
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  41770e:	f447 0700 	orr.w	r7, r7, #8388608	; 0x800000
			AFEC_MR_PRESCAL((config->mck / config->afec_clock )- 1) |
  417712:	021b      	lsls	r3, r3, #8
			AFEC_MR_TRANSFER(config->transfer) |
  417714:	072d      	lsls	r5, r5, #28
			AFEC_MR_PRESCAL((config->mck / config->afec_clock )- 1) |
  417716:	b29b      	uxth	r3, r3
			AFEC_MR_TRANSFER(config->transfer) |
  417718:	f005 5540 	and.w	r5, r5, #805306368	; 0x30000000
	reg = (config->useq ? AFEC_MR_USEQ_REG_ORDER : 0) |
  41771c:	433b      	orrs	r3, r7
  41771e:	4333      	orrs	r3, r6
  417720:	432b      	orrs	r3, r5
  417722:	4313      	orrs	r3, r2
	afec->AFEC_MR = reg;
  417724:	6043      	str	r3, [r0, #4]
	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  417726:	7d0b      	ldrb	r3, [r1, #20]
			(config->stm ? AFEC_EMR_STM : 0);
  417728:	7d4d      	ldrb	r5, [r1, #21]
	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  41772a:	2b00      	cmp	r3, #0
  41772c:	680a      	ldr	r2, [r1, #0]
  41772e:	bf14      	ite	ne
  417730:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
  417734:	2300      	moveq	r3, #0
			(config->stm ? AFEC_EMR_STM : 0);
  417736:	2d00      	cmp	r5, #0
	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  417738:	ea43 0302 	orr.w	r3, r3, r2
			(config->stm ? AFEC_EMR_STM : 0);
  41773c:	bf14      	ite	ne
  41773e:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
  417742:	2200      	moveq	r2, #0
	if(afec == AFEC0) {
  417744:	42a0      	cmp	r0, r4
			(config->resolution) |
  417746:	ea43 0302 	orr.w	r3, r3, r2
	afec->AFEC_EMR = (config->tag ? AFEC_EMR_TAG : 0) |
  41774a:	6083      	str	r3, [r0, #8]
	afec->AFEC_ACR = AFEC_ACR_IBCTL(config->ibctl) | AFEC_ACR_PGA0EN | AFEC_ACR_PGA1EN;
  41774c:	7d8b      	ldrb	r3, [r1, #22]
  41774e:	ea4f 2303 	mov.w	r3, r3, lsl #8
  417752:	f403 7340 	and.w	r3, r3, #768	; 0x300
  417756:	f043 030c 	orr.w	r3, r3, #12
  41775a:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
	if(afec == AFEC0) {
  41775e:	d00d      	beq.n	41777c <afec_init+0xa4>
	if(afec == AFEC1) {
  417760:	4b0c      	ldr	r3, [pc, #48]	; (417794 <afec_init+0xbc>)
  417762:	4298      	cmp	r0, r3
  417764:	d001      	beq.n	41776a <afec_init+0x92>
	return STATUS_OK;
  417766:	2000      	movs	r0, #0
  417768:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41776a:	4b0b      	ldr	r3, [pc, #44]	; (417798 <afec_init+0xc0>)
			afec_callback_pointer[1][i] = 0;
  41776c:	2100      	movs	r1, #0
  41776e:	f103 0240 	add.w	r2, r3, #64	; 0x40
  417772:	f843 1b04 	str.w	r1, [r3], #4
		for (i = 0; i < _AFEC_NUM_OF_INTERRUPT_SOURCE; i++){
  417776:	4293      	cmp	r3, r2
  417778:	d1fb      	bne.n	417772 <afec_init+0x9a>
  41777a:	e7f4      	b.n	417766 <afec_init+0x8e>
  41777c:	4b07      	ldr	r3, [pc, #28]	; (41779c <afec_init+0xc4>)
			afec_callback_pointer[0][i] = 0;
  41777e:	2100      	movs	r1, #0
  417780:	f103 0240 	add.w	r2, r3, #64	; 0x40
  417784:	f843 1f04 	str.w	r1, [r3, #4]!
		for (i = 0; i < _AFEC_NUM_OF_INTERRUPT_SOURCE; i++){
  417788:	429a      	cmp	r2, r3
  41778a:	d1fb      	bne.n	417784 <afec_init+0xac>
  41778c:	e7eb      	b.n	417766 <afec_init+0x8e>
  41778e:	bf00      	nop
  417790:	4003c000 	.word	0x4003c000
  417794:	40064000 	.word	0x40064000
  417798:	2040708c 	.word	0x2040708c
  41779c:	20407048 	.word	0x20407048

004177a0 <afec_enable_interrupt>:
	if (interrupt_source == AFEC_INTERRUPT_ALL) {
  4177a0:	4b0b      	ldr	r3, [pc, #44]	; (4177d0 <afec_enable_interrupt+0x30>)
  4177a2:	4299      	cmp	r1, r3
  4177a4:	d007      	beq.n	4177b6 <afec_enable_interrupt+0x16>
	if (interrupt_source < AFEC_INTERRUPT_DATA_READY) {
  4177a6:	290b      	cmp	r1, #11
  4177a8:	d907      	bls.n	4177ba <afec_enable_interrupt+0x1a>
	} else if (interrupt_source < AFEC_INTERRUPT_TEMP_CHANGE) {
  4177aa:	290e      	cmp	r1, #14
  4177ac:	d90a      	bls.n	4177c4 <afec_enable_interrupt+0x24>
				+ AFEC_INTERRUPT_GAP2);
  4177ae:	310f      	adds	r1, #15
		afec->AFEC_IER = 1 << (interrupt_source + AFEC_INTERRUPT_GAP1
  4177b0:	2301      	movs	r3, #1
  4177b2:	fa03 f101 	lsl.w	r1, r3, r1
  4177b6:	6241      	str	r1, [r0, #36]	; 0x24
  4177b8:	4770      	bx	lr
		if (interrupt_source == AFEC_INTERRUPT_EOC_11) {
  4177ba:	d1f9      	bne.n	4177b0 <afec_enable_interrupt+0x10>
			afec->AFEC_IER = 1 << AFEC_TEMP_INT_SOURCE_NUM;
  4177bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4177c0:	6243      	str	r3, [r0, #36]	; 0x24
  4177c2:	4770      	bx	lr
		afec->AFEC_IER = 1 << (interrupt_source + AFEC_INTERRUPT_GAP1);
  4177c4:	310c      	adds	r1, #12
  4177c6:	2301      	movs	r3, #1
  4177c8:	fa03 f101 	lsl.w	r1, r3, r1
  4177cc:	6241      	str	r1, [r0, #36]	; 0x24
  4177ce:	4770      	bx	lr
  4177d0:	47000fff 	.word	0x47000fff

004177d4 <afec_set_callback>:
{
  4177d4:	b4f0      	push	{r4, r5, r6, r7}
	if (afec == AFEC1) {
  4177d6:	4c12      	ldr	r4, [pc, #72]	; (417820 <afec_set_callback+0x4c>)
  4177d8:	42a0      	cmp	r0, r4
  4177da:	d00f      	beq.n	4177fc <afec_set_callback+0x28>
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  4177dc:	015b      	lsls	r3, r3, #5
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  4177de:	4c11      	ldr	r4, [pc, #68]	; (417824 <afec_set_callback+0x50>)
  4177e0:	f04f 5500 	mov.w	r5, #536870912	; 0x20000000
	afec_callback_pointer[i][source] = callback;
  4177e4:	4e10      	ldr	r6, [pc, #64]	; (417828 <afec_set_callback+0x54>)
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  4177e6:	b2db      	uxtb	r3, r3
  4177e8:	f846 2021 	str.w	r2, [r6, r1, lsl #2]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  4177ec:	f8c4 5180 	str.w	r5, [r4, #384]	; 0x180
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  4177f0:	f884 331d 	strb.w	r3, [r4, #797]	; 0x31d
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4177f4:	6025      	str	r5, [r4, #0]
	afec_enable_interrupt(afec, source);
  4177f6:	4b0d      	ldr	r3, [pc, #52]	; (41782c <afec_set_callback+0x58>)
}
  4177f8:	bcf0      	pop	{r4, r5, r6, r7}
	afec_enable_interrupt(afec, source);
  4177fa:	4718      	bx	r3
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  4177fc:	015b      	lsls	r3, r3, #5
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  4177fe:	4c09      	ldr	r4, [pc, #36]	; (417824 <afec_set_callback+0x50>)
  417800:	f44f 7680 	mov.w	r6, #256	; 0x100
	afec_callback_pointer[i][source] = callback;
  417804:	4f08      	ldr	r7, [pc, #32]	; (417828 <afec_set_callback+0x54>)
  417806:	f101 0510 	add.w	r5, r1, #16
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  41780a:	b2db      	uxtb	r3, r3
  41780c:	f847 2025 	str.w	r2, [r7, r5, lsl #2]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  417810:	f8c4 6184 	str.w	r6, [r4, #388]	; 0x184
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  417814:	f884 3328 	strb.w	r3, [r4, #808]	; 0x328
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  417818:	6066      	str	r6, [r4, #4]
	afec_enable_interrupt(afec, source);
  41781a:	4b04      	ldr	r3, [pc, #16]	; (41782c <afec_set_callback+0x58>)
}
  41781c:	bcf0      	pop	{r4, r5, r6, r7}
	afec_enable_interrupt(afec, source);
  41781e:	4718      	bx	r3
  417820:	40064000 	.word	0x40064000
  417824:	e000e100 	.word	0xe000e100
  417828:	2040704c 	.word	0x2040704c
  41782c:	004177a1 	.word	0x004177a1

00417830 <AFEC0_Handler>:
/**
 * \brief Interrupt handler for AFEC0.
 */
void AFEC0_Handler(void)
{
	afec_process_callback(AFEC0);
  417830:	4801      	ldr	r0, [pc, #4]	; (417838 <AFEC0_Handler+0x8>)
  417832:	4b02      	ldr	r3, [pc, #8]	; (41783c <AFEC0_Handler+0xc>)
  417834:	4718      	bx	r3
  417836:	bf00      	nop
  417838:	4003c000 	.word	0x4003c000
  41783c:	004175f9 	.word	0x004175f9

00417840 <AFEC1_Handler>:
/**
 * \brief Interrupt handler for AFEC1.
 */
void AFEC1_Handler(void)
{
	afec_process_callback(AFEC1);
  417840:	4801      	ldr	r0, [pc, #4]	; (417848 <AFEC1_Handler+0x8>)
  417842:	4b02      	ldr	r3, [pc, #8]	; (41784c <AFEC1_Handler+0xc>)
  417844:	4718      	bx	r3
  417846:	bf00      	nop
  417848:	40064000 	.word	0x40064000
  41784c:	004175f9 	.word	0x004175f9

00417850 <afec_enable>:
	if (afec == AFEC1) {
  417850:	4a13      	ldr	r2, [pc, #76]	; (4178a0 <afec_enable+0x50>)
	Assert(afec);
	uint32_t pid;

	pid = afec_find_pid(afec);
	/* Enable peripheral clock. */
	pmc_enable_periph_clk(pid);
  417852:	4b14      	ldr	r3, [pc, #80]	; (4178a4 <afec_enable+0x54>)
  417854:	4290      	cmp	r0, r2
  417856:	bf0c      	ite	eq
  417858:	2028      	moveq	r0, #40	; 0x28
  41785a:	201d      	movne	r0, #29
{
  41785c:	b500      	push	{lr}
  41785e:	b083      	sub	sp, #12
	pmc_enable_periph_clk(pid);
  417860:	4798      	blx	r3
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  417862:	4a11      	ldr	r2, [pc, #68]	; (4178a8 <afec_enable+0x58>)
  417864:	7893      	ldrb	r3, [r2, #2]
  417866:	2bff      	cmp	r3, #255	; 0xff
  417868:	d018      	beq.n	41789c <afec_enable+0x4c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  41786a:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
  41786e:	fab3 f383 	clz	r3, r3
  417872:	095b      	lsrs	r3, r3, #5
  417874:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
  417876:	b672      	cpsid	i
  417878:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  41787c:	2000      	movs	r0, #0
  41787e:	490b      	ldr	r1, [pc, #44]	; (4178ac <afec_enable+0x5c>)
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
  417880:	7893      	ldrb	r3, [r2, #2]
  417882:	7008      	strb	r0, [r1, #0]
  417884:	3301      	adds	r3, #1
	return flags;
  417886:	9801      	ldr	r0, [sp, #4]
  417888:	7093      	strb	r3, [r2, #2]
	if (cpu_irq_is_enabled_flags(flags))
  41788a:	b120      	cbz	r0, 417896 <afec_enable+0x46>
		cpu_irq_enable();
  41788c:	2301      	movs	r3, #1
  41788e:	700b      	strb	r3, [r1, #0]
  417890:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  417894:	b662      	cpsie	i
	sleepmgr_lock_mode(SLEEPMGR_SLEEP_WFI);
}
  417896:	b003      	add	sp, #12
  417898:	f85d fb04 	ldr.w	pc, [sp], #4
  41789c:	e7fe      	b.n	41789c <afec_enable+0x4c>
  41789e:	bf00      	nop
  4178a0:	40064000 	.word	0x40064000
  4178a4:	00417a25 	.word	0x00417a25
  4178a8:	20407044 	.word	0x20407044
  4178ac:	2040000a 	.word	0x2040000a

004178b0 <afec_set_sample_hold_mode>:
		afec_ch_sanity_check(afec, channel);
	}
		
	uint32_t reg = 0;
	reg = afec->AFEC_SHMR;
	if (mode == AFEC_SAMPLE_HOLD_MODE_1) {
  4178b0:	2a01      	cmp	r2, #1
	reg = afec->AFEC_SHMR;
  4178b2:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
	if (mode == AFEC_SAMPLE_HOLD_MODE_1) {
  4178b6:	d00a      	beq.n	4178ce <afec_set_sample_hold_mode+0x1e>
		
		reg |= (channel == AFEC_CHANNEL_ALL)? AFEC_CHANNEL_ALL : 0x1u << channel;
	}
	else {
		
		reg = (channel == AFEC_CHANNEL_ALL)? 0 : ~(0x1u << channel);
  4178b8:	f640 73ff 	movw	r3, #4095	; 0xfff
  4178bc:	4299      	cmp	r1, r3
  4178be:	d013      	beq.n	4178e8 <afec_set_sample_hold_mode+0x38>
  4178c0:	2201      	movs	r2, #1
  4178c2:	fa02 f101 	lsl.w	r1, r2, r1
  4178c6:	43c9      	mvns	r1, r1
	}
	afec->AFEC_SHMR = reg;
  4178c8:	f8c0 10a0 	str.w	r1, [r0, #160]	; 0xa0
  4178cc:	4770      	bx	lr
{
  4178ce:	b410      	push	{r4}
		reg |= (channel == AFEC_CHANNEL_ALL)? AFEC_CHANNEL_ALL : 0x1u << channel;
  4178d0:	f640 74ff 	movw	r4, #4095	; 0xfff
  4178d4:	42a1      	cmp	r1, r4
		
}
  4178d6:	f85d 4b04 	ldr.w	r4, [sp], #4
		reg |= (channel == AFEC_CHANNEL_ALL)? AFEC_CHANNEL_ALL : 0x1u << channel;
  4178da:	bf18      	it	ne
  4178dc:	fa02 f101 	lslne.w	r1, r2, r1
  4178e0:	4319      	orrs	r1, r3
	afec->AFEC_SHMR = reg;
  4178e2:	f8c0 10a0 	str.w	r1, [r0, #160]	; 0xa0
}
  4178e6:	4770      	bx	lr
		reg = (channel == AFEC_CHANNEL_ALL)? 0 : ~(0x1u << channel);
  4178e8:	2100      	movs	r1, #0
	afec->AFEC_SHMR = reg;
  4178ea:	f8c0 10a0 	str.w	r1, [r0, #160]	; 0xa0
  4178ee:	4770      	bx	lr

004178f0 <dacc_reset>:
 *
 * \param p_dacc Pointer to a DACC instance. 
 */
void dacc_reset(Dacc *p_dacc)
{
	p_dacc->DACC_CR = DACC_CR_SWRST;
  4178f0:	2301      	movs	r3, #1
  4178f2:	6003      	str	r3, [r0, #0]
  4178f4:	4770      	bx	lr
  4178f6:	bf00      	nop

004178f8 <dacc_set_transfer_mode>:
		p_dacc->DACC_MR |= DACC_MR_WORD;
#elif (SAM4S) || (SAM4E)
		p_dacc->DACC_MR |= DACC_MR_ONE;
		p_dacc->DACC_MR |= DACC_MR_WORD_WORD;
#elif (SAMV70 || SAMV71 || SAME70 || SAMS70)
		p_dacc->DACC_MR = ul_mode;
  4178f8:	6041      	str	r1, [r0, #4]
#else
		p_dacc->DACC_MR &= (~DACC_MR_WORD_WORD);
#endif
	}
	return DACC_RC_OK;
}
  4178fa:	2000      	movs	r0, #0
  4178fc:	4770      	bx	lr
  4178fe:	bf00      	nop

00417900 <dacc_enable_channel>:
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_enable_channel(Dacc *p_dacc, uint32_t ul_channel)
{
	if (ul_channel > MAX_CH_NB)
  417900:	2901      	cmp	r1, #1
  417902:	d902      	bls.n	41790a <dacc_enable_channel+0xa>
		return DACC_RC_INVALID_PARAM;
  417904:	2301      	movs	r3, #1

	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
	return DACC_RC_OK;
}
  417906:	4618      	mov	r0, r3
  417908:	4770      	bx	lr
	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
  41790a:	2201      	movs	r2, #1
	return DACC_RC_OK;
  41790c:	2300      	movs	r3, #0
	p_dacc->DACC_CHER = DACC_CHER_CH0 << ul_channel;
  41790e:	fa02 f101 	lsl.w	r1, r2, r1
  417912:	6101      	str	r1, [r0, #16]
}
  417914:	4618      	mov	r0, r3
  417916:	4770      	bx	lr

00417918 <dacc_set_analog_control>:
 * \param ul_analog_control Analog control configuration.
 *
 * \return \ref DACC_RC_OK for OK.
 */
uint32_t dacc_set_analog_control(Dacc *p_dacc, uint32_t ul_analog_control)
{
  417918:	4603      	mov	r3, r0
	p_dacc->DACC_ACR = ul_analog_control;
	return DACC_RC_OK;
}
  41791a:	2000      	movs	r0, #0
	p_dacc->DACC_ACR = ul_analog_control;
  41791c:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
}
  417920:	4770      	bx	lr
  417922:	bf00      	nop

00417924 <pmc_mck_set_division>:
 * \brief Set the division of the MCK.
 *
 * \param ul_div Division value.
 */
void pmc_mck_set_division(uint32_t ul_div)
{
  417924:	3802      	subs	r0, #2
  417926:	2802      	cmp	r0, #2
  417928:	d80d      	bhi.n	417946 <pmc_mck_set_division+0x22>
  41792a:	4b08      	ldr	r3, [pc, #32]	; (41794c <pmc_mck_set_division+0x28>)
  41792c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
		default:
			ul_div = PMC_MCKR_MDIV_EQ_PCK;
			break;
	}
	PMC->PMC_MCKR =
			(PMC->PMC_MCKR & (~PMC_MCKR_MDIV_Msk)) | ul_div;
  417930:	4907      	ldr	r1, [pc, #28]	; (417950 <pmc_mck_set_division+0x2c>)
  417932:	6b0b      	ldr	r3, [r1, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  417934:	460a      	mov	r2, r1
			(PMC->PMC_MCKR & (~PMC_MCKR_MDIV_Msk)) | ul_div;
  417936:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  41793a:	4303      	orrs	r3, r0
	PMC->PMC_MCKR =
  41793c:	630b      	str	r3, [r1, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY));
  41793e:	6e93      	ldr	r3, [r2, #104]	; 0x68
  417940:	071b      	lsls	r3, r3, #28
  417942:	d5fc      	bpl.n	41793e <pmc_mck_set_division+0x1a>
}
  417944:	4770      	bx	lr
{
  417946:	2000      	movs	r0, #0
  417948:	e7f2      	b.n	417930 <pmc_mck_set_division+0xc>
  41794a:	bf00      	nop
  41794c:	0041d138 	.word	0x0041d138
  417950:	400e0600 	.word	0x400e0600

00417954 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  417954:	4913      	ldr	r1, [pc, #76]	; (4179a4 <pmc_switch_mck_to_pllack+0x50>)
  417956:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  417958:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  41795c:	4318      	orrs	r0, r3
  41795e:	6308      	str	r0, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  417960:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  417962:	0718      	lsls	r0, r3, #28
  417964:	d407      	bmi.n	417976 <pmc_switch_mck_to_pllack+0x22>
  417966:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  41796a:	e001      	b.n	417970 <pmc_switch_mck_to_pllack+0x1c>
			--ul_timeout) {
		if (ul_timeout == 0) {
  41796c:	3b01      	subs	r3, #1
  41796e:	d016      	beq.n	41799e <pmc_switch_mck_to_pllack+0x4a>
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  417970:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  417972:	0712      	lsls	r2, r2, #28
  417974:	d5fa      	bpl.n	41796c <pmc_switch_mck_to_pllack+0x18>
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  417976:	490b      	ldr	r1, [pc, #44]	; (4179a4 <pmc_switch_mck_to_pllack+0x50>)
  417978:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  41797a:	f023 0303 	bic.w	r3, r3, #3
  41797e:	f043 0302 	orr.w	r3, r3, #2
  417982:	630b      	str	r3, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  417984:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  417986:	0718      	lsls	r0, r3, #28
  417988:	d407      	bmi.n	41799a <pmc_switch_mck_to_pllack+0x46>
  41798a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  41798e:	e001      	b.n	417994 <pmc_switch_mck_to_pllack+0x40>
			--ul_timeout) {
		if (ul_timeout == 0) {
  417990:	3b01      	subs	r3, #1
  417992:	d004      	beq.n	41799e <pmc_switch_mck_to_pllack+0x4a>
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  417994:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  417996:	0712      	lsls	r2, r2, #28
  417998:	d5fa      	bpl.n	417990 <pmc_switch_mck_to_pllack+0x3c>
			return 1;
		}
	}

	return 0;
  41799a:	2000      	movs	r0, #0
}
  41799c:	4770      	bx	lr
			return 1;
  41799e:	2001      	movs	r0, #1
  4179a0:	4770      	bx	lr
  4179a2:	bf00      	nop
  4179a4:	400e0600 	.word	0x400e0600

004179a8 <pmc_switch_mainck_to_fastrc>:
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4179a8:	4a0e      	ldr	r2, [pc, #56]	; (4179e4 <pmc_switch_mainck_to_fastrc+0x3c>)
{
  4179aa:	b410      	push	{r4}
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4179ac:	4c0e      	ldr	r4, [pc, #56]	; (4179e8 <pmc_switch_mainck_to_fastrc+0x40>)

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4179ae:	4611      	mov	r1, r2
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4179b0:	6a13      	ldr	r3, [r2, #32]
  4179b2:	431c      	orrs	r4, r3
  4179b4:	6214      	str	r4, [r2, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4179b6:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  4179b8:	039a      	lsls	r2, r3, #14
  4179ba:	d5fc      	bpl.n	4179b6 <pmc_switch_mainck_to_fastrc+0xe>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4179bc:	6a0c      	ldr	r4, [r1, #32]
  4179be:	4b0b      	ldr	r3, [pc, #44]	; (4179ec <pmc_switch_mainck_to_fastrc+0x44>)
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4179c0:	4a08      	ldr	r2, [pc, #32]	; (4179e4 <pmc_switch_mainck_to_fastrc+0x3c>)
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4179c2:	4023      	ands	r3, r4
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  4179c4:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4179c8:	4318      	orrs	r0, r3
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4179ca:	6208      	str	r0, [r1, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4179cc:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4179ce:	039b      	lsls	r3, r3, #14
  4179d0:	d5fc      	bpl.n	4179cc <pmc_switch_mainck_to_fastrc+0x24>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  4179d2:	6a11      	ldr	r1, [r2, #32]
  4179d4:	4b06      	ldr	r3, [pc, #24]	; (4179f0 <pmc_switch_mainck_to_fastrc+0x48>)
  4179d6:	400b      	ands	r3, r1
  4179d8:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4179dc:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  4179de:	f85d 4b04 	ldr.w	r4, [sp], #4
  4179e2:	4770      	bx	lr
  4179e4:	400e0600 	.word	0x400e0600
  4179e8:	00370008 	.word	0x00370008
  4179ec:	ffc8ff8f 	.word	0xffc8ff8f
  4179f0:	fec8ffff 	.word	0xfec8ffff

004179f4 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4179f4:	4b02      	ldr	r3, [pc, #8]	; (417a00 <pmc_osc_is_ready_mainck+0xc>)
  4179f6:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4179f8:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  4179fc:	4770      	bx	lr
  4179fe:	bf00      	nop
  417a00:	400e0600 	.word	0x400e0600

00417a04 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  417a04:	4b02      	ldr	r3, [pc, #8]	; (417a10 <pmc_disable_pllack+0xc>)
  417a06:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  417a0a:	629a      	str	r2, [r3, #40]	; 0x28
  417a0c:	4770      	bx	lr
  417a0e:	bf00      	nop
  417a10:	400e0600 	.word	0x400e0600

00417a14 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  417a14:	4b02      	ldr	r3, [pc, #8]	; (417a20 <pmc_is_locked_pllack+0xc>)
  417a16:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  417a18:	f000 0002 	and.w	r0, r0, #2
  417a1c:	4770      	bx	lr
  417a1e:	bf00      	nop
  417a20:	400e0600 	.word	0x400e0600

00417a24 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  417a24:	283f      	cmp	r0, #63	; 0x3f
  417a26:	d81a      	bhi.n	417a5e <pmc_enable_periph_clk+0x3a>
		return 1;
	}

	if (ul_id < 32) {
  417a28:	281f      	cmp	r0, #31
  417a2a:	d80a      	bhi.n	417a42 <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  417a2c:	2301      	movs	r3, #1
  417a2e:	4a0e      	ldr	r2, [pc, #56]	; (417a68 <pmc_enable_periph_clk+0x44>)
  417a30:	fa03 f000 	lsl.w	r0, r3, r0
  417a34:	6991      	ldr	r1, [r2, #24]
  417a36:	ea30 0301 	bics.w	r3, r0, r1
  417a3a:	d012      	beq.n	417a62 <pmc_enable_periph_clk+0x3e>
			PMC->PMC_PCER0 = 1 << ul_id;
  417a3c:	6110      	str	r0, [r2, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  417a3e:	2000      	movs	r0, #0
  417a40:	4770      	bx	lr
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  417a42:	2301      	movs	r3, #1
		ul_id -= 32;
  417a44:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  417a46:	4a08      	ldr	r2, [pc, #32]	; (417a68 <pmc_enable_periph_clk+0x44>)
  417a48:	fa03 f000 	lsl.w	r0, r3, r0
  417a4c:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
  417a50:	ea30 0303 	bics.w	r3, r0, r3
  417a54:	d005      	beq.n	417a62 <pmc_enable_periph_clk+0x3e>
			PMC->PMC_PCER1 = 1 << ul_id;
  417a56:	f8c2 0100 	str.w	r0, [r2, #256]	; 0x100
	return 0;
  417a5a:	2000      	movs	r0, #0
  417a5c:	4770      	bx	lr
		return 1;
  417a5e:	2001      	movs	r0, #1
  417a60:	4770      	bx	lr
	return 0;
  417a62:	2000      	movs	r0, #0
}
  417a64:	4770      	bx	lr
  417a66:	bf00      	nop
  417a68:	400e0600 	.word	0x400e0600

00417a6c <speedLoop_init_timer>:
}

uByte_t heart_beat_flasher_index;

void speedLoop_init_timer(void)
{
  417a6c:	b570      	push	{r4, r5, r6, lr}
	//timer counter TC2 initialization for use with the schedular

	pmc_enable_periph_clk(ID_TC8);
	
	tc_init(TC2, 2, TC_CMR_TCCLKS_TIMER_CLOCK2|TC_CMR_WAVSEL_UP_RC); //TC8 clk = MCK/8 = 18750000
  417a6e:	4c11      	ldr	r4, [pc, #68]	; (417ab4 <speedLoop_init_timer+0x48>)
	pmc_enable_periph_clk(ID_TC8);
  417a70:	2031      	movs	r0, #49	; 0x31
  417a72:	4b11      	ldr	r3, [pc, #68]	; (417ab8 <speedLoop_init_timer+0x4c>)
  417a74:	f44f 3500 	mov.w	r5, #131072	; 0x20000
  417a78:	4798      	blx	r3
	tc_init(TC2, 2, TC_CMR_TCCLKS_TIMER_CLOCK2|TC_CMR_WAVSEL_UP_RC); //TC8 clk = MCK/8 = 18750000
  417a7a:	4620      	mov	r0, r4
  417a7c:	f244 0201 	movw	r2, #16385	; 0x4001
  417a80:	2102      	movs	r1, #2
  417a82:	4b0e      	ldr	r3, [pc, #56]	; (417abc <speedLoop_init_timer+0x50>)
  417a84:	4798      	blx	r3
	tc_write_rc(TC2, 2, (18750000 / 1000) - 1);
  417a86:	4620      	mov	r0, r4
  417a88:	f644 123d 	movw	r2, #18749	; 0x493d
  417a8c:	2102      	movs	r1, #2
  417a8e:	4b0c      	ldr	r3, [pc, #48]	; (417ac0 <speedLoop_init_timer+0x54>)
  417a90:	4798      	blx	r3
	tc_enable_interrupt(TC2, 2, TC_IER_CPCS);
  417a92:	4620      	mov	r0, r4
  417a94:	2210      	movs	r2, #16
  417a96:	2102      	movs	r1, #2
  417a98:	4b0a      	ldr	r3, [pc, #40]	; (417ac4 <speedLoop_init_timer+0x58>)
  417a9a:	4798      	blx	r3
    NVIC->IP[(uint32_t)(IRQn)]            = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts  */
  417a9c:	4b0a      	ldr	r3, [pc, #40]	; (417ac8 <speedLoop_init_timer+0x5c>)
  417a9e:	2240      	movs	r2, #64	; 0x40
	NVIC_SetPriority(TC8_IRQn,2);
	NVIC_EnableIRQ(TC8_IRQn);
	tc_start(TC2, 2);
  417aa0:	4620      	mov	r0, r4
  417aa2:	2102      	movs	r1, #2
  417aa4:	f883 2331 	strb.w	r2, [r3, #817]	; 0x331
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  417aa8:	605d      	str	r5, [r3, #4]
  417aaa:	4a08      	ldr	r2, [pc, #32]	; (417acc <speedLoop_init_timer+0x60>)
}
  417aac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	tc_start(TC2, 2);
  417ab0:	4710      	bx	r2
  417ab2:	bf00      	nop
  417ab4:	40014000 	.word	0x40014000
  417ab8:	00417a25 	.word	0x00417a25
  417abc:	00412689 	.word	0x00412689
  417ac0:	004126b9 	.word	0x004126b9
  417ac4:	004126c1 	.word	0x004126c1
  417ac8:	e000e100 	.word	0xe000e100
  417acc:	004126a9 	.word	0x004126a9

00417ad0 <reset_wdt>:
		supc_enable_backup_mode(SUPC);
			
	}
}
void reset_wdt(void)
{
  417ad0:	b510      	push	{r4, lr}
	wdt_restart(WDT);
  417ad2:	4804      	ldr	r0, [pc, #16]	; (417ae4 <reset_wdt+0x14>)
  417ad4:	4b04      	ldr	r3, [pc, #16]	; (417ae8 <reset_wdt+0x18>)
  417ad6:	4798      	blx	r3
	rswdt_restart(RSWDT);
  417ad8:	4804      	ldr	r0, [pc, #16]	; (417aec <reset_wdt+0x1c>)
  417ada:	4b05      	ldr	r3, [pc, #20]	; (417af0 <reset_wdt+0x20>)
}
  417adc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rswdt_restart(RSWDT);
  417ae0:	4718      	bx	r3
  417ae2:	bf00      	nop
  417ae4:	400e1850 	.word	0x400e1850
  417ae8:	004172a9 	.word	0x004172a9
  417aec:	400e1900 	.word	0x400e1900
  417af0:	00400595 	.word	0x00400595

00417af4 <main_reinit>:

void main_reinit(void)
{
	overload_init();
  417af4:	4b00      	ldr	r3, [pc, #0]	; (417af8 <main_reinit+0x4>)
  417af6:	4718      	bx	r3
  417af8:	004147c9 	.word	0x004147c9

00417afc <init_with_delay>:
	
}

void init_with_delay(void)
{
	encoder_init();
  417afc:	4b00      	ldr	r3, [pc, #0]	; (417b00 <init_with_delay+0x4>)
  417afe:	4718      	bx	r3
  417b00:	004132a5 	.word	0x004132a5

00417b04 <enable_pio_writeProtect>:
// 	bk_err_set;
// 	fx_err_set;
}

void enable_pio_writeProtect(void)
{
  417b04:	b510      	push	{r4, lr}
	pio_set_lc_writeProtect();
  417b06:	4b09      	ldr	r3, [pc, #36]	; (417b2c <enable_pio_writeProtect+0x28>)
  417b08:	4798      	blx	r3
	pio_set_writeprotect(PIOA, 1);
  417b0a:	4c09      	ldr	r4, [pc, #36]	; (417b30 <enable_pio_writeProtect+0x2c>)
  417b0c:	2101      	movs	r1, #1
  417b0e:	4809      	ldr	r0, [pc, #36]	; (417b34 <enable_pio_writeProtect+0x30>)
  417b10:	47a0      	blx	r4
	pio_set_writeprotect(PIOB, 1);
  417b12:	2101      	movs	r1, #1
  417b14:	4808      	ldr	r0, [pc, #32]	; (417b38 <enable_pio_writeProtect+0x34>)
  417b16:	47a0      	blx	r4
	pio_set_writeprotect(PIOC, 1);
  417b18:	2101      	movs	r1, #1
  417b1a:	4808      	ldr	r0, [pc, #32]	; (417b3c <enable_pio_writeProtect+0x38>)
  417b1c:	47a0      	blx	r4
	pio_set_writeprotect(PIOD, 1);
  417b1e:	4623      	mov	r3, r4
  417b20:	2101      	movs	r1, #1
  417b22:	4807      	ldr	r0, [pc, #28]	; (417b40 <enable_pio_writeProtect+0x3c>)
}
  417b24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	pio_set_writeprotect(PIOD, 1);
  417b28:	4718      	bx	r3
  417b2a:	bf00      	nop
  417b2c:	0040d2ad 	.word	0x0040d2ad
  417b30:	00417551 	.word	0x00417551
  417b34:	400e0e00 	.word	0x400e0e00
  417b38:	400e1000 	.word	0x400e1000
  417b3c:	400e1200 	.word	0x400e1200
  417b40:	400e1400 	.word	0x400e1400

00417b44 <poff_sleep_monitor>:
{
  417b44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  417b48:	4d23      	ldr	r5, [pc, #140]	; (417bd8 <poff_sleep_monitor+0x94>)
  417b4a:	b082      	sub	sp, #8
  417b4c:	6bec      	ldr	r4, [r5, #60]	; 0x3c
	if (ioport_get_pin_level(IOPORT_CREATE_PIN(PIOA, 5)) == 0)
  417b4e:	f014 0420 	ands.w	r4, r4, #32
  417b52:	d002      	beq.n	417b5a <poff_sleep_monitor+0x16>
}
  417b54:	b002      	add	sp, #8
  417b56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		vfd_trip();
  417b5a:	4b20      	ldr	r3, [pc, #128]	; (417bdc <poff_sleep_monitor+0x98>)
		pio_set_output(PIOA, 0xFFFFFFFF & (~PIO_PA5), LOW, DISABLE, ENABLE);
  417b5c:	2701      	movs	r7, #1
		vfd_trip();
  417b5e:	4798      	blx	r3
		sleep_err_set;
  417b60:	4a1f      	ldr	r2, [pc, #124]	; (417be0 <poff_sleep_monitor+0x9c>)
  417b62:	4b20      	ldr	r3, [pc, #128]	; (417be4 <poff_sleep_monitor+0xa0>)
  417b64:	7810      	ldrb	r0, [r2, #0]
  417b66:	4798      	blx	r3
		pio_set_output(PIOA, 0xFFFFFFFF & (~PIO_PA5), LOW, DISABLE, ENABLE);
  417b68:	4e1f      	ldr	r6, [pc, #124]	; (417be8 <poff_sleep_monitor+0xa4>)
  417b6a:	4623      	mov	r3, r4
  417b6c:	4622      	mov	r2, r4
  417b6e:	4628      	mov	r0, r5
  417b70:	9700      	str	r7, [sp, #0]
  417b72:	f06f 0120 	mvn.w	r1, #32
		pio_set_input(PIOA, PIO_PA5, 0);
  417b76:	f8df 8090 	ldr.w	r8, [pc, #144]	; 417c08 <poff_sleep_monitor+0xc4>
		pio_set_output(PIOA, 0xFFFFFFFF & (~PIO_PA5), LOW, DISABLE, ENABLE);
  417b7a:	47b0      	blx	r6
		pio_set_output(PIOB, 0xFFFFFFFF, LOW, DISABLE, ENABLE);
  417b7c:	4623      	mov	r3, r4
  417b7e:	4622      	mov	r2, r4
  417b80:	9700      	str	r7, [sp, #0]
  417b82:	f04f 31ff 	mov.w	r1, #4294967295
  417b86:	4819      	ldr	r0, [pc, #100]	; (417bec <poff_sleep_monitor+0xa8>)
  417b88:	47b0      	blx	r6
		pio_set_output(PIOC, 0xFFFFFFFF & (~PIO_PC28), LOW, DISABLE, ENABLE);
  417b8a:	4623      	mov	r3, r4
  417b8c:	4622      	mov	r2, r4
  417b8e:	9700      	str	r7, [sp, #0]
  417b90:	f06f 5180 	mvn.w	r1, #268435456	; 0x10000000
  417b94:	4816      	ldr	r0, [pc, #88]	; (417bf0 <poff_sleep_monitor+0xac>)
  417b96:	47b0      	blx	r6
		pio_set_output(PIOD, 0xFFFFFFFF, LOW, DISABLE, ENABLE);
  417b98:	4623      	mov	r3, r4
  417b9a:	4622      	mov	r2, r4
  417b9c:	9700      	str	r7, [sp, #0]
  417b9e:	f04f 31ff 	mov.w	r1, #4294967295
  417ba2:	4814      	ldr	r0, [pc, #80]	; (417bf4 <poff_sleep_monitor+0xb0>)
  417ba4:	47b0      	blx	r6
		pio_set_output(PIOE, 0xFFFFFFFF, LOW, DISABLE, ENABLE);
  417ba6:	4623      	mov	r3, r4
  417ba8:	4622      	mov	r2, r4
  417baa:	9700      	str	r7, [sp, #0]
  417bac:	f04f 31ff 	mov.w	r1, #4294967295
  417bb0:	4811      	ldr	r0, [pc, #68]	; (417bf8 <poff_sleep_monitor+0xb4>)
  417bb2:	47b0      	blx	r6
		pio_set_input(PIOA, PIO_PA5, 0);
  417bb4:	4622      	mov	r2, r4
  417bb6:	4628      	mov	r0, r5
  417bb8:	2120      	movs	r1, #32
  417bba:	47c0      	blx	r8
		pio_set_input(PIOC, PIO_PC28, 0);
  417bbc:	4622      	mov	r2, r4
  417bbe:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  417bc2:	480b      	ldr	r0, [pc, #44]	; (417bf0 <poff_sleep_monitor+0xac>)
  417bc4:	47c0      	blx	r8
		supc_backup_sram_off(SUPC);
  417bc6:	480d      	ldr	r0, [pc, #52]	; (417bfc <poff_sleep_monitor+0xb8>)
  417bc8:	4b0d      	ldr	r3, [pc, #52]	; (417c00 <poff_sleep_monitor+0xbc>)
  417bca:	4798      	blx	r3
		supc_enable_backup_mode(SUPC);
  417bcc:	480b      	ldr	r0, [pc, #44]	; (417bfc <poff_sleep_monitor+0xb8>)
  417bce:	4b0d      	ldr	r3, [pc, #52]	; (417c04 <poff_sleep_monitor+0xc0>)
}
  417bd0:	b002      	add	sp, #8
  417bd2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		supc_enable_backup_mode(SUPC);
  417bd6:	4718      	bx	r3
  417bd8:	400e0e00 	.word	0x400e0e00
  417bdc:	0041724d 	.word	0x0041724d
  417be0:	20406c9d 	.word	0x20406c9d
  417be4:	0041282d 	.word	0x0041282d
  417be8:	00417515 	.word	0x00417515
  417bec:	400e1000 	.word	0x400e1000
  417bf0:	400e1200 	.word	0x400e1200
  417bf4:	400e1400 	.word	0x400e1400
  417bf8:	400e1600 	.word	0x400e1600
  417bfc:	400e1810 	.word	0x400e1810
  417c00:	004006c1 	.word	0x004006c1
  417c04:	004006a1 	.word	0x004006a1
  417c08:	004174dd 	.word	0x004174dd

00417c0c <over_current_reset>:
	if (demand_sw_reset_oc == 0) return;
  417c0c:	4b06      	ldr	r3, [pc, #24]	; (417c28 <over_current_reset+0x1c>)
  417c0e:	781b      	ldrb	r3, [r3, #0]
  417c10:	b12b      	cbz	r3, 417c1e <over_current_reset+0x12>
	if (oc_confirm == 0)
  417c12:	4b06      	ldr	r3, [pc, #24]	; (417c2c <over_current_reset+0x20>)
  417c14:	781a      	ldrb	r2, [r3, #0]
  417c16:	b91a      	cbnz	r2, 417c20 <over_current_reset+0x14>
		oc_confirm = 1;
  417c18:	2201      	movs	r2, #1
  417c1a:	701a      	strb	r2, [r3, #0]
  417c1c:	4770      	bx	lr
  417c1e:	4770      	bx	lr
		rstc_start_software_reset(RSTC);
  417c20:	4803      	ldr	r0, [pc, #12]	; (417c30 <over_current_reset+0x24>)
  417c22:	4b04      	ldr	r3, [pc, #16]	; (417c34 <over_current_reset+0x28>)
  417c24:	4718      	bx	r3
  417c26:	bf00      	nop
  417c28:	20400b80 	.word	0x20400b80
  417c2c:	20400c14 	.word	0x20400c14
  417c30:	400e1800 	.word	0x400e1800
  417c34:	0040057d 	.word	0x0040057d

00417c38 <TC8_Handler>:
	uint32_t tc_status = tc_get_status(TC2, 2);
  417c38:	4b08      	ldr	r3, [pc, #32]	; (417c5c <TC8_Handler+0x24>)
  417c3a:	2102      	movs	r1, #2
  417c3c:	4808      	ldr	r0, [pc, #32]	; (417c60 <TC8_Handler+0x28>)
{
  417c3e:	b510      	push	{r4, lr}
	uint32_t tc_status = tc_get_status(TC2, 2);
  417c40:	4798      	blx	r3
	if (tc_status&TC_SR_CPCS)
  417c42:	06c3      	lsls	r3, r0, #27
  417c44:	d400      	bmi.n	417c48 <TC8_Handler+0x10>
  417c46:	bd10      	pop	{r4, pc}
		sincos_store_val();
  417c48:	4b06      	ldr	r3, [pc, #24]	; (417c64 <TC8_Handler+0x2c>)
  417c4a:	4798      	blx	r3
		encoder_inc_handler();
  417c4c:	4b06      	ldr	r3, [pc, #24]	; (417c68 <TC8_Handler+0x30>)
  417c4e:	4798      	blx	r3
		EMCM_decel_point_watch();
  417c50:	4b06      	ldr	r3, [pc, #24]	; (417c6c <TC8_Handler+0x34>)
  417c52:	4798      	blx	r3
		vfd_speed_loop_handler();
  417c54:	4b06      	ldr	r3, [pc, #24]	; (417c70 <TC8_Handler+0x38>)
}
  417c56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		vfd_speed_loop_handler();
  417c5a:	4718      	bx	r3
  417c5c:	004126c9 	.word	0x004126c9
  417c60:	40014000 	.word	0x40014000
  417c64:	0041381d 	.word	0x0041381d
  417c68:	00413cc1 	.word	0x00413cc1
  417c6c:	0040458d 	.word	0x0040458d
  417c70:	00416ca1 	.word	0x00416ca1

00417c74 <TC7_Handler>:
	uint32_t tc_status = tc_get_status(TC2, 1);
  417c74:	4b05      	ldr	r3, [pc, #20]	; (417c8c <TC7_Handler+0x18>)
  417c76:	2101      	movs	r1, #1
  417c78:	4805      	ldr	r0, [pc, #20]	; (417c90 <TC7_Handler+0x1c>)
{
  417c7a:	b510      	push	{r4, lr}
	uint32_t tc_status = tc_get_status(TC2, 1);
  417c7c:	4798      	blx	r3
	if(tc_status&TC_SR_CPCS)
  417c7e:	06c3      	lsls	r3, r0, #27
  417c80:	d400      	bmi.n	417c84 <TC7_Handler+0x10>
  417c82:	bd10      	pop	{r4, pc}
		sch_update();
  417c84:	4b03      	ldr	r3, [pc, #12]	; (417c94 <TC7_Handler+0x20>)
}
  417c86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		sch_update();
  417c8a:	4718      	bx	r3
  417c8c:	004126c9 	.word	0x004126c9
  417c90:	40014000 	.word	0x40014000
  417c94:	004172c5 	.word	0x004172c5

00417c98 <WDT_Handler>:
	uint32_t status = wdt_get_status(WDT);
  417c98:	4801      	ldr	r0, [pc, #4]	; (417ca0 <WDT_Handler+0x8>)
  417c9a:	4b02      	ldr	r3, [pc, #8]	; (417ca4 <WDT_Handler+0xc>)
  417c9c:	4718      	bx	r3
  417c9e:	bf00      	nop
  417ca0:	400e1850 	.word	0x400e1850
  417ca4:	004172c1 	.word	0x004172c1

00417ca8 <RSWDT_Handler>:
	uint32_t status = rswdt_get_status(RSWDT);
  417ca8:	4801      	ldr	r0, [pc, #4]	; (417cb0 <RSWDT_Handler+0x8>)
  417caa:	4b02      	ldr	r3, [pc, #8]	; (417cb4 <RSWDT_Handler+0xc>)
  417cac:	4718      	bx	r3
  417cae:	bf00      	nop
  417cb0:	400e1900 	.word	0x400e1900
  417cb4:	004005ad 	.word	0x004005ad

00417cb8 <afec1_EOC_handler>:
	afec->AFEC_CSELR = afec_ch;
  417cb8:	4b25      	ldr	r3, [pc, #148]	; (417d50 <afec1_EOC_handler+0x98>)
  417cba:	2102      	movs	r1, #2
  417cbc:	2201      	movs	r2, #1
  417cbe:	2003      	movs	r0, #3
{
  417cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
  417cc2:	6659      	str	r1, [r3, #100]	; 0x64
  417cc4:	b085      	sub	sp, #20
	return afec->AFEC_CDR;
  417cc6:	6e99      	ldr	r1, [r3, #104]	; 0x68
	afec->AFEC_CSELR = afec_ch;
  417cc8:	2708      	movs	r7, #8
  417cca:	2607      	movs	r6, #7
  417ccc:	2509      	movs	r5, #9
	adc_readings[0] = afec_channel_get_value(AFEC1, 2);
  417cce:	f8ad 1000 	strh.w	r1, [sp]
  417cd2:	2404      	movs	r4, #4
  417cd4:	665f      	str	r7, [r3, #100]	; 0x64
  417cd6:	210a      	movs	r1, #10
	return afec->AFEC_CDR;
  417cd8:	6e9f      	ldr	r7, [r3, #104]	; 0x68
	adc_readings[1] = afec_channel_get_value(AFEC1, 8);
  417cda:	f8ad 7002 	strh.w	r7, [sp, #2]
	afec->AFEC_CSELR = afec_ch;
  417cde:	665a      	str	r2, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417ce0:	6e9f      	ldr	r7, [r3, #104]	; 0x68
	if(menue_drive_data_applied.m_encoder_type == 2) //endat encoder
  417ce2:	4a1c      	ldr	r2, [pc, #112]	; (417d54 <afec1_EOC_handler+0x9c>)
	adc_readings[2] = afec_channel_get_value(AFEC1, 1);
  417ce4:	f8ad 7004 	strh.w	r7, [sp, #4]
	afec->AFEC_CSELR = afec_ch;
  417ce8:	665e      	str	r6, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417cea:	6e9e      	ldr	r6, [r3, #104]	; 0x68
	if(menue_drive_data_applied.m_encoder_type == 2) //endat encoder
  417cec:	f892 20ac 	ldrb.w	r2, [r2, #172]	; 0xac
	adc_readings[3] = afec_channel_get_value(AFEC1, 7);
  417cf0:	f8ad 6006 	strh.w	r6, [sp, #6]
	afec->AFEC_CSELR = afec_ch;
  417cf4:	6658      	str	r0, [r3, #100]	; 0x64
	if(menue_drive_data_applied.m_encoder_type == 2) //endat encoder
  417cf6:	2a02      	cmp	r2, #2
	return afec->AFEC_CDR;
  417cf8:	6e98      	ldr	r0, [r3, #104]	; 0x68
	adc_readings[4] = afec_channel_get_value(AFEC1, 3);
  417cfa:	b280      	uxth	r0, r0
  417cfc:	f8ad 0008 	strh.w	r0, [sp, #8]
	afec->AFEC_CSELR = afec_ch;
  417d00:	665d      	str	r5, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417d02:	6e9d      	ldr	r5, [r3, #104]	; 0x68
	adc_readings[5] = afec_channel_get_value(AFEC1, 9);
  417d04:	f8ad 500a 	strh.w	r5, [sp, #10]
	afec->AFEC_CSELR = afec_ch;
  417d08:	665c      	str	r4, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417d0a:	6e9c      	ldr	r4, [r3, #104]	; 0x68
	adc_readings[6] = afec_channel_get_value(AFEC1, 4);
  417d0c:	f8ad 400c 	strh.w	r4, [sp, #12]
	afec->AFEC_CSELR = afec_ch;
  417d10:	6659      	str	r1, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417d12:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	adc_readings[7] = afec_channel_get_value(AFEC1, 10);
  417d14:	f8ad 300e 	strh.w	r3, [sp, #14]
	if(menue_drive_data_applied.m_encoder_type == 2) //endat encoder
  417d18:	d013      	beq.n	417d42 <afec1_EOC_handler+0x8a>
	else if(menue_drive_data_applied.m_encoder_type == 1) //sincos encoder
  417d1a:	2a01      	cmp	r2, #1
  417d1c:	d003      	beq.n	417d26 <afec1_EOC_handler+0x6e>
	inverter_update_dcbus_val(adc_readings[4]);
  417d1e:	4b0e      	ldr	r3, [pc, #56]	; (417d58 <afec1_EOC_handler+0xa0>)
  417d20:	4798      	blx	r3
}
  417d22:	b005      	add	sp, #20
  417d24:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sincos_store_abs_adc_val(&adc_readings[0]);
  417d26:	4668      	mov	r0, sp
  417d28:	4b0c      	ldr	r3, [pc, #48]	; (417d5c <afec1_EOC_handler+0xa4>)
  417d2a:	4798      	blx	r3
		sincos_store_phs_adc_val(&adc_readings[2]);
  417d2c:	a801      	add	r0, sp, #4
  417d2e:	4b0c      	ldr	r3, [pc, #48]	; (417d60 <afec1_EOC_handler+0xa8>)
  417d30:	4798      	blx	r3
		sincos_store_val_abs();
  417d32:	4b0c      	ldr	r3, [pc, #48]	; (417d64 <afec1_EOC_handler+0xac>)
  417d34:	4798      	blx	r3
  417d36:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	inverter_update_dcbus_val(adc_readings[4]);
  417d3a:	4b07      	ldr	r3, [pc, #28]	; (417d58 <afec1_EOC_handler+0xa0>)
  417d3c:	4798      	blx	r3
}
  417d3e:	b005      	add	sp, #20
  417d40:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sincos_store_phs_adc_val(&adc_readings[0]);
  417d42:	4668      	mov	r0, sp
  417d44:	4b06      	ldr	r3, [pc, #24]	; (417d60 <afec1_EOC_handler+0xa8>)
  417d46:	4798      	blx	r3
  417d48:	f8bd 0008 	ldrh.w	r0, [sp, #8]
  417d4c:	e7e7      	b.n	417d1e <afec1_EOC_handler+0x66>
  417d4e:	bf00      	nop
  417d50:	40064000 	.word	0x40064000
  417d54:	20404ff0 	.word	0x20404ff0
  417d58:	00414c79 	.word	0x00414c79
  417d5c:	00413e91 	.word	0x00413e91
  417d60:	0041380d 	.word	0x0041380d
  417d64:	00413ff9 	.word	0x00413ff9

00417d68 <afec_EOC_handler>:
	afec->AFEC_CSELR = afec_ch;
  417d68:	4b23      	ldr	r3, [pc, #140]	; (417df8 <afec_EOC_handler+0x90>)
	afec->AFEC_CR = AFEC_CR_START;
  417d6a:	2002      	movs	r0, #2
  417d6c:	4923      	ldr	r1, [pc, #140]	; (417dfc <afec_EOC_handler+0x94>)
	afec->AFEC_CSELR = afec_ch;
  417d6e:	2200      	movs	r2, #0
{
  417d70:	b530      	push	{r4, r5, lr}
  417d72:	2406      	movs	r4, #6
  417d74:	ed2d 8b02 	vpush	{d8}
	afec->AFEC_CR = AFEC_CR_START;
  417d78:	6008      	str	r0, [r1, #0]
  417d7a:	b083      	sub	sp, #12
	afec->AFEC_CSELR = afec_ch;
  417d7c:	665a      	str	r2, [r3, #100]	; 0x64
  417d7e:	2003      	movs	r0, #3
	return afec->AFEC_CDR;
  417d80:	6e9d      	ldr	r5, [r3, #104]	; 0x68
	afec->AFEC_CSELR = afec_ch;
  417d82:	2109      	movs	r1, #9
	encoder_handler();
  417d84:	4a1e      	ldr	r2, [pc, #120]	; (417e00 <afec_EOC_handler+0x98>)
	adc_readings[0] = afec_channel_get_value(AFEC0, 0);
  417d86:	f8ad 5000 	strh.w	r5, [sp]
  417d8a:	665c      	str	r4, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417d8c:	6e9c      	ldr	r4, [r3, #104]	; 0x68
	adc_readings[1] = afec_channel_get_value(AFEC0, 6);
  417d8e:	f8ad 4002 	strh.w	r4, [sp, #2]
	afec->AFEC_CSELR = afec_ch;
  417d92:	6658      	str	r0, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417d94:	6e98      	ldr	r0, [r3, #104]	; 0x68
	overload_check(i_readout[0], i_readout[1], i_readout[2]);
  417d96:	4c1b      	ldr	r4, [pc, #108]	; (417e04 <afec_EOC_handler+0x9c>)
	adc_readings[2] = afec_channel_get_value(AFEC0, 3);
  417d98:	f8ad 0004 	strh.w	r0, [sp, #4]
	afec->AFEC_CSELR = afec_ch;
  417d9c:	6659      	str	r1, [r3, #100]	; 0x64
	return afec->AFEC_CDR;
  417d9e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	adc_readings[3] = afec_channel_get_value(AFEC0, 9);
  417da0:	f8ad 3006 	strh.w	r3, [sp, #6]
	encoder_handler();
  417da4:	4790      	blx	r2
	inverter_update_currents_val(&adc_readings[0]);
  417da6:	4668      	mov	r0, sp
  417da8:	4b17      	ldr	r3, [pc, #92]	; (417e08 <afec_EOC_handler+0xa0>)
  417daa:	4798      	blx	r3
	NTC_readout = NTC_readout >>1; //divide by 2 for filteration
  417dac:	4a17      	ldr	r2, [pc, #92]	; (417e0c <afec_EOC_handler+0xa4>)
	NTC_readout += fixedpt_fromint(adc_readings[3]);
  417dae:	f8bd 0006 	ldrh.w	r0, [sp, #6]
  417db2:	6813      	ldr	r3, [r2, #0]
	axt_clark_exe();
  417db4:	4916      	ldr	r1, [pc, #88]	; (417e10 <afec_EOC_handler+0xa8>)
	NTC_readout += fixedpt_fromint(adc_readings[3]);
  417db6:	eb03 33c0 	add.w	r3, r3, r0, lsl #15
	NTC_readout = NTC_readout >>1; //divide by 2 for filteration
  417dba:	105b      	asrs	r3, r3, #1
  417dbc:	6013      	str	r3, [r2, #0]
	axt_clark_exe();
  417dbe:	4788      	blx	r1
	ialpha = axt_get_ialpha();
  417dc0:	4b14      	ldr	r3, [pc, #80]	; (417e14 <afec_EOC_handler+0xac>)
  417dc2:	4798      	blx	r3
	ibeta = axt_get_ibeta();
  417dc4:	4b14      	ldr	r3, [pc, #80]	; (417e18 <afec_EOC_handler+0xb0>)
	ialpha = axt_get_ialpha();
  417dc6:	ee08 0a90 	vmov	s17, r0
	ibeta = axt_get_ibeta();
  417dca:	4798      	blx	r3
	isqr = (ialpha * ialpha) + (ibeta * ibeta);
  417dcc:	ee07 0a90 	vmov	s15, r0
	vfd_current_loop_handler();
  417dd0:	4b12      	ldr	r3, [pc, #72]	; (417e1c <afec_EOC_handler+0xb4>)
	isqr = (ialpha * ialpha) + (ibeta * ibeta);
  417dd2:	ee27 8aa7 	vmul.f32	s16, s15, s15
	vfd_current_loop_handler();
  417dd6:	4798      	blx	r3
	overload_check(i_readout[0], i_readout[1], i_readout[2]);
  417dd8:	4b11      	ldr	r3, [pc, #68]	; (417e20 <afec_EOC_handler+0xb8>)
	isqr = (ialpha * ialpha) + (ibeta * ibeta);
  417dda:	eea8 8aa8 	vfma.f32	s16, s17, s17
	overload_check(i_readout[0], i_readout[1], i_readout[2]);
  417dde:	689a      	ldr	r2, [r3, #8]
  417de0:	6859      	ldr	r1, [r3, #4]
  417de2:	6818      	ldr	r0, [r3, #0]
  417de4:	47a0      	blx	r4
	axt_integrate_current(isqr);
  417de6:	4b0f      	ldr	r3, [pc, #60]	; (417e24 <afec_EOC_handler+0xbc>)
  417de8:	ee18 0a10 	vmov	r0, s16
  417dec:	4798      	blx	r3
}
  417dee:	b003      	add	sp, #12
  417df0:	ecbd 8b02 	vpop	{d8}
  417df4:	bd30      	pop	{r4, r5, pc}
  417df6:	bf00      	nop
  417df8:	4003c000 	.word	0x4003c000
  417dfc:	40064000 	.word	0x40064000
  417e00:	0041327d 	.word	0x0041327d
  417e04:	004145b5 	.word	0x004145b5
  417e08:	00414db9 	.word	0x00414db9
  417e0c:	204003cc 	.word	0x204003cc
  417e10:	0040e1ad 	.word	0x0040e1ad
  417e14:	0040e2e9 	.word	0x0040e2e9
  417e18:	0040e2f5 	.word	0x0040e2f5
  417e1c:	00416e7d 	.word	0x00416e7d
  417e20:	20400b84 	.word	0x20400b84
  417e24:	0040e345 	.word	0x0040e345

00417e28 <main>:
#define WDT_RESET_HANDLER_DELAY (300 * WDT_RESET_TIME)
#define WDT_RESET_HANDLER_TIME  (300 * WDT_RESET_TIME)

#define WDT_WDVAL (256 * WDT_RESET_TIME)
int main (void)
{
  417e28:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	board_init();
  417e2c:	4b8a      	ldr	r3, [pc, #552]	; (418058 <main+0x230>)
{
  417e2e:	b091      	sub	sp, #68	; 0x44
	board_init();
  417e30:	4798      	blx	r3
	

	//wdt_disable(WDT);
	wdt_init(WDT, WDT_MR_WDRSTEN | WDT_MR_WDDBGHLT /*| WDT_MR_WDFIEN*/, WDT_WDVAL, (WDT_WDVAL - WDT_WDVAL/5));
  417e32:	4c8a      	ldr	r4, [pc, #552]	; (41805c <main+0x234>)
  417e34:	f44f 73cd 	mov.w	r3, #410	; 0x19a
  417e38:	f44f 7200 	mov.w	r2, #512	; 0x200
  417e3c:	4988      	ldr	r1, [pc, #544]	; (418060 <main+0x238>)
		MB0_USART_SERIAL_CHAR_LENGTH,
		MB0_USART_SERIAL_PARITY,
		MB0_USART_SERIAL_STOP_BIT,
		US_MR_CHMODE_NORMAL
	};
	mb_channel_init(0, MB0_USART_SERIAL, &mb0_usart_console_settings, MB0_USART_SERIAL_ID, 1, 5, 25);
  417e3e:	2601      	movs	r6, #1
	wdt_init(WDT, WDT_MR_WDRSTEN | WDT_MR_WDDBGHLT /*| WDT_MR_WDFIEN*/, WDT_WDVAL, (WDT_WDVAL - WDT_WDVAL/5));
  417e40:	4888      	ldr	r0, [pc, #544]	; (418064 <main+0x23c>)
	const sam_usart_opt_t mb0_usart_console_settings = {
  417e42:	2500      	movs	r5, #0
	wdt_init(WDT, WDT_MR_WDRSTEN | WDT_MR_WDDBGHLT /*| WDT_MR_WDFIEN*/, WDT_WDVAL, (WDT_WDVAL - WDT_WDVAL/5));
  417e44:	47a0      	blx	r4
	rswdt_init(RSWDT, /*RSWDT_MR_WDFIEN |*/ RSWDT_MR_WDDBGHLT /*| RSWDT_MR_WDIDLEHLT*/ | RSWDT_MR_ALLONES_Msk | RSWDT_MR_WDRSTEN, WDT_WDVAL, (WDT_WDVAL - WDT_WDVAL/5));
  417e46:	f44f 7200 	mov.w	r2, #512	; 0x200
  417e4a:	4987      	ldr	r1, [pc, #540]	; (418068 <main+0x240>)
  417e4c:	f44f 73cd 	mov.w	r3, #410	; 0x19a
  417e50:	4886      	ldr	r0, [pc, #536]	; (41806c <main+0x244>)
	mb_channel_init(0, MB0_USART_SERIAL, &mb0_usart_console_settings, MB0_USART_SERIAL_ID, 1, 5, 25);
  417e52:	f04f 0b05 	mov.w	fp, #5
	rswdt_init(RSWDT, /*RSWDT_MR_WDFIEN |*/ RSWDT_MR_WDDBGHLT /*| RSWDT_MR_WDIDLEHLT*/ | RSWDT_MR_ALLONES_Msk | RSWDT_MR_WDRSTEN, WDT_WDVAL, (WDT_WDVAL - WDT_WDVAL/5));
  417e56:	4c86      	ldr	r4, [pc, #536]	; (418070 <main+0x248>)
	const sam_usart_opt_t mb0_usart_console_settings = {
  417e58:	f44f 4a96 	mov.w	sl, #19200	; 0x4b00
	rswdt_init(RSWDT, /*RSWDT_MR_WDFIEN |*/ RSWDT_MR_WDDBGHLT /*| RSWDT_MR_WDIDLEHLT*/ | RSWDT_MR_ALLONES_Msk | RSWDT_MR_WDRSTEN, WDT_WDVAL, (WDT_WDVAL - WDT_WDVAL/5));
  417e5c:	47a0      	blx	r4
	sch_init();
  417e5e:	4b85      	ldr	r3, [pc, #532]	; (418074 <main+0x24c>)
  417e60:	4798      	blx	r3
 	sph_faults_init();
  417e62:	4b85      	ldr	r3, [pc, #532]	; (418078 <main+0x250>)
  417e64:	4798      	blx	r3
 	sph_timer_init();
  417e66:	4b85      	ldr	r3, [pc, #532]	; (41807c <main+0x254>)
  417e68:	4798      	blx	r3
 	io_interface_init();
  417e6a:	4b85      	ldr	r3, [pc, #532]	; (418080 <main+0x258>)
  417e6c:	4798      	blx	r3
 	elevator_init();
  417e6e:	4b85      	ldr	r3, [pc, #532]	; (418084 <main+0x25c>)
  417e70:	4798      	blx	r3
 	d_util_init();
  417e72:	4b85      	ldr	r3, [pc, #532]	; (418088 <main+0x260>)
  417e74:	4798      	blx	r3
 	fault_history_init();
  417e76:	4b85      	ldr	r3, [pc, #532]	; (41808c <main+0x264>)
  417e78:	4798      	blx	r3
 	fault_history_loadAll();
  417e7a:	4b85      	ldr	r3, [pc, #532]	; (418090 <main+0x268>)
	sch_add_task_ms(&speedLoop_init_timer,0 + VFD_INIT_DELAY, 0);
  417e7c:	4c85      	ldr	r4, [pc, #532]	; (418094 <main+0x26c>)
 	fault_history_loadAll();
  417e7e:	4798      	blx	r3
	sch_add_task_ms(&speedLoop_init_timer,0 + VFD_INIT_DELAY, 0);
  417e80:	4633      	mov	r3, r6
  417e82:	462a      	mov	r2, r5
  417e84:	f644 6120 	movw	r1, #20000	; 0x4e20
  417e88:	4883      	ldr	r0, [pc, #524]	; (418098 <main+0x270>)
  417e8a:	47a0      	blx	r4
	sch_add_task_ms_noOD(&inverter_check_dcbus_val_handler,VFD_INIT_DELAY + 1247, 2);
  417e8c:	462b      	mov	r3, r5
  417e8e:	2214      	movs	r2, #20
  417e90:	f243 01b8 	movw	r1, #12472	; 0x30b8
  417e94:	4881      	ldr	r0, [pc, #516]	; (41809c <main+0x274>)
	const sam_usart_opt_t mb0_usart_console_settings = {
  417e96:	f04f 09c0 	mov.w	r9, #192	; 0xc0
	sch_add_task_ms_noOD(&inverter_check_dcbus_val_handler,VFD_INIT_DELAY + 1247, 2);
  417e9a:	47a0      	blx	r4
	sch_add_task_ms(&vfd_states_handler, 5 + VFD_INIT_DELAY, 1);
  417e9c:	4633      	mov	r3, r6
  417e9e:	220a      	movs	r2, #10
  417ea0:	f644 6120 	movw	r1, #20000	; 0x4e20
  417ea4:	487e      	ldr	r0, [pc, #504]	; (4180a0 <main+0x278>)
	const sam_usart_opt_t mb0_usart_console_settings = {
  417ea6:	f44f 5700 	mov.w	r7, #8192	; 0x2000
	sch_add_task_ms(&vfd_states_handler, 5 + VFD_INIT_DELAY, 1);
  417eaa:	47a0      	blx	r4
	sch_add_task_ms(&ersdstates_handler, 5 + VFD_INIT_DELAY + 1500, 1);
  417eac:	4633      	mov	r3, r6
  417eae:	220a      	movs	r2, #10
  417eb0:	f643 219a 	movw	r1, #15002	; 0x3a9a
  417eb4:	487b      	ldr	r0, [pc, #492]	; (4180a4 <main+0x27c>)
  417eb6:	47a0      	blx	r4
	sch_add_task_ms_noOD(&io_interface_handler, 20, 1);
  417eb8:	462b      	mov	r3, r5
  417eba:	220a      	movs	r2, #10
  417ebc:	21c8      	movs	r1, #200	; 0xc8
  417ebe:	487a      	ldr	r0, [pc, #488]	; (4180a8 <main+0x280>)
  417ec0:	47a0      	blx	r4
 	heart_beat_flasher_index = sch_add_task_ms(&ST1_LED, 0, 500); //heart beat flash
  417ec2:	4633      	mov	r3, r6
  417ec4:	f241 3288 	movw	r2, #5000	; 0x1388
  417ec8:	4629      	mov	r1, r5
  417eca:	4878      	ldr	r0, [pc, #480]	; (4180ac <main+0x284>)
  417ecc:	47a0      	blx	r4
  417ece:	4978      	ldr	r1, [pc, #480]	; (4180b0 <main+0x288>)
	sch_add_task_ms(&IGBT_temp_handler,50,100);
  417ed0:	4633      	mov	r3, r6
  417ed2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 	heart_beat_flasher_index = sch_add_task_ms(&ST1_LED, 0, 500); //heart beat flash
  417ed6:	6008      	str	r0, [r1, #0]
	sch_add_task_ms(&IGBT_temp_handler,50,100);
  417ed8:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  417edc:	4875      	ldr	r0, [pc, #468]	; (4180b4 <main+0x28c>)
  417ede:	47a0      	blx	r4
	sch_add_task_ms(&d_twi_handler, 1 , 2);
  417ee0:	4633      	mov	r3, r6
  417ee2:	2214      	movs	r2, #20
  417ee4:	210a      	movs	r1, #10
  417ee6:	4874      	ldr	r0, [pc, #464]	; (4180b8 <main+0x290>)
  417ee8:	47a0      	blx	r4
	sch_add_task_ms(&at24cxx_dynamic_handler,2 ,4);	//sch_add_task_ms(&read_memory, 3000, 5000);
  417eea:	4633      	mov	r3, r6
  417eec:	2228      	movs	r2, #40	; 0x28
  417eee:	2114      	movs	r1, #20
  417ef0:	4872      	ldr	r0, [pc, #456]	; (4180bc <main+0x294>)
  417ef2:	47a0      	blx	r4
	sch_add_task_ms(&mb_handler, 100, 1);
  417ef4:	4633      	mov	r3, r6
  417ef6:	220a      	movs	r2, #10
  417ef8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  417efc:	4870      	ldr	r0, [pc, #448]	; (4180c0 <main+0x298>)
  417efe:	47a0      	blx	r4
	sch_add_task_ms(&sph_timer_handler, 100, 1);
  417f00:	4633      	mov	r3, r6
  417f02:	220a      	movs	r2, #10
  417f04:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  417f08:	486e      	ldr	r0, [pc, #440]	; (4180c4 <main+0x29c>)
  417f0a:	47a0      	blx	r4
	sch_add_task_ms(&sph_faults_handler, 370, 1);
  417f0c:	4633      	mov	r3, r6
  417f0e:	220a      	movs	r2, #10
  417f10:	f640 6174 	movw	r1, #3700	; 0xe74
  417f14:	486c      	ldr	r0, [pc, #432]	; (4180c8 <main+0x2a0>)
  417f16:	47a0      	blx	r4
	sch_add_task_ms_noOD(&reset_wdt, WDT_RESET_HANDLER_DELAY, WDT_RESET_HANDLER_TIME);
  417f18:	f241 7270 	movw	r2, #6000	; 0x1770
  417f1c:	462b      	mov	r3, r5
  417f1e:	486b      	ldr	r0, [pc, #428]	; (4180cc <main+0x2a4>)
  417f20:	4611      	mov	r1, r2
	mb_channel_init(0, MB0_USART_SERIAL, &mb0_usart_console_settings, MB0_USART_SERIAL_ID, 1, 5, 25);
  417f22:	f8df 8218 	ldr.w	r8, [pc, #536]	; 41813c <main+0x314>
	sch_add_task_ms_noOD(&reset_wdt, WDT_RESET_HANDLER_DELAY, WDT_RESET_HANDLER_TIME);
  417f26:	47a0      	blx	r4
	sch_add_task_ms_noOD(&u_glcd_screen_updater, 0, 20);
  417f28:	462b      	mov	r3, r5
  417f2a:	22c8      	movs	r2, #200	; 0xc8
  417f2c:	4629      	mov	r1, r5
  417f2e:	4868      	ldr	r0, [pc, #416]	; (4180d0 <main+0x2a8>)
  417f30:	47a0      	blx	r4
	sch_add_task_ms(&phasefail_handler, 1000, 2);
  417f32:	4633      	mov	r3, r6
  417f34:	2214      	movs	r2, #20
  417f36:	f242 7110 	movw	r1, #10000	; 0x2710
  417f3a:	4866      	ldr	r0, [pc, #408]	; (4180d4 <main+0x2ac>)
  417f3c:	47a0      	blx	r4
	sch_add_task_ms(&EMCM_handler, 571 + VFD_INIT_DELAY, 40);
  417f3e:	4633      	mov	r3, r6
  417f40:	f44f 72c8 	mov.w	r2, #400	; 0x190
  417f44:	f644 6120 	movw	r1, #20000	; 0x4e20
  417f48:	4863      	ldr	r0, [pc, #396]	; (4180d8 <main+0x2b0>)
  417f4a:	47a0      	blx	r4
	sch_add_task_ms(&init_with_delay, 1000 + VFD_INIT_DELAY, 0);
  417f4c:	4633      	mov	r3, r6
  417f4e:	462a      	mov	r2, r5
  417f50:	f644 6121 	movw	r1, #20001	; 0x4e21
  417f54:	4861      	ldr	r0, [pc, #388]	; (4180dc <main+0x2b4>)
  417f56:	47a0      	blx	r4
	sch_add_task_ms(&main_reinit, 1043, 1000);
  417f58:	4633      	mov	r3, r6
  417f5a:	f242 7210 	movw	r2, #10000	; 0x2710
  417f5e:	f642 01be 	movw	r1, #10430	; 0x28be
  417f62:	485f      	ldr	r0, [pc, #380]	; (4180e0 <main+0x2b8>)
  417f64:	47a0      	blx	r4
	sch_add_task_ms(&overload_update, 2343, 1000);
  417f66:	4633      	mov	r3, r6
  417f68:	f242 7210 	movw	r2, #10000	; 0x2710
  417f6c:	f645 3186 	movw	r1, #23430	; 0x5b86
  417f70:	485c      	ldr	r0, [pc, #368]	; (4180e4 <main+0x2bc>)
  417f72:	47a0      	blx	r4
	sch_add_task_ms(&auto_update_elevator_initilal_values, 1000, 0);
  417f74:	4633      	mov	r3, r6
  417f76:	462a      	mov	r2, r5
  417f78:	f242 7110 	movw	r1, #10000	; 0x2710
  417f7c:	485a      	ldr	r0, [pc, #360]	; (4180e8 <main+0x2c0>)
  417f7e:	47a0      	blx	r4
	sch_add_task_ms(&vfd_enable_handler, 2530, 1);
  417f80:	4633      	mov	r3, r6
  417f82:	220a      	movs	r2, #10
  417f84:	f246 21d4 	movw	r1, #25300	; 0x62d4
  417f88:	4858      	ldr	r0, [pc, #352]	; (4180ec <main+0x2c4>)
  417f8a:	47a0      	blx	r4
	sch_add_task_ms(&pop_ups_handler, 0xFF, 1);
  417f8c:	4633      	mov	r3, r6
  417f8e:	220a      	movs	r2, #10
  417f90:	f640 11f6 	movw	r1, #2550	; 0x9f6
  417f94:	4856      	ldr	r0, [pc, #344]	; (4180f0 <main+0x2c8>)
  417f96:	47a0      	blx	r4
	sch_add_task_ms(&con_toff_monitor_handler, 204, 1000);
  417f98:	4633      	mov	r3, r6
  417f9a:	f242 7210 	movw	r2, #10000	; 0x2710
  417f9e:	f44f 61ff 	mov.w	r1, #2040	; 0x7f8
  417fa2:	4854      	ldr	r0, [pc, #336]	; (4180f4 <main+0x2cc>)
  417fa4:	47a0      	blx	r4
	sch_add_task_100us(&poff_sleep_monitor, 1, 1);
  417fa6:	4633      	mov	r3, r6
  417fa8:	4632      	mov	r2, r6
  417faa:	210a      	movs	r1, #10
  417fac:	4852      	ldr	r0, [pc, #328]	; (4180f8 <main+0x2d0>)
  417fae:	47a0      	blx	r4
	sch_add_task_ms(&enable_pio_writeProtect, VFD_INIT_DELAY + 4000, 0);
  417fb0:	4633      	mov	r3, r6
  417fb2:	462a      	mov	r2, r5
  417fb4:	f649 4142 	movw	r1, #40002	; 0x9c42
  417fb8:	4850      	ldr	r0, [pc, #320]	; (4180fc <main+0x2d4>)
  417fba:	47a0      	blx	r4
	sch_add_task_ms(&over_current_reset, 3000, 3000);
  417fbc:	f247 5230 	movw	r2, #30000	; 0x7530
  417fc0:	4633      	mov	r3, r6
  417fc2:	484f      	ldr	r0, [pc, #316]	; (418100 <main+0x2d8>)
  417fc4:	4611      	mov	r1, r2
  417fc6:	47a0      	blx	r4
	sch_add_task_ms(&sedacio_output_handler, 3000, 5);
  417fc8:	4633      	mov	r3, r6
  417fca:	2232      	movs	r2, #50	; 0x32
  417fcc:	f247 5130 	movw	r1, #30000	; 0x7530
  417fd0:	484c      	ldr	r0, [pc, #304]	; (418104 <main+0x2dc>)
  417fd2:	47a0      	blx	r4
	sch_add_task_ms(&motor_excitation_handler, VFD_INIT_DELAY + 53, 1);
  417fd4:	220a      	movs	r2, #10
  417fd6:	f44f 7105 	mov.w	r1, #532	; 0x214
  417fda:	4633      	mov	r3, r6
  417fdc:	484a      	ldr	r0, [pc, #296]	; (418108 <main+0x2e0>)
  417fde:	47a0      	blx	r4
	dtwi_init();
  417fe0:	4b4a      	ldr	r3, [pc, #296]	; (41810c <main+0x2e4>)
  417fe2:	4798      	blx	r3
	vector_IM_init();
  417fe4:	4b4a      	ldr	r3, [pc, #296]	; (418110 <main+0x2e8>)
  417fe6:	4798      	blx	r3
	vector_PM_init();
  417fe8:	4b4a      	ldr	r3, [pc, #296]	; (418114 <main+0x2ec>)
  417fea:	4798      	blx	r3
	speed_PI_init();
  417fec:	4b4a      	ldr	r3, [pc, #296]	; (418118 <main+0x2f0>)
  417fee:	4798      	blx	r3
	mb_init();
  417ff0:	4b4a      	ldr	r3, [pc, #296]	; (41811c <main+0x2f4>)
  417ff2:	4798      	blx	r3
	inverter_fan_timer_init();
  417ff4:	4b4a      	ldr	r3, [pc, #296]	; (418120 <main+0x2f8>)
  417ff6:	4798      	blx	r3
	mb_channel_init(0, MB0_USART_SERIAL, &mb0_usart_console_settings, MB0_USART_SERIAL_ID, 1, 5, 25);
  417ff8:	2319      	movs	r3, #25
	const sam_usart_opt_t mb0_usart_console_settings = {
  417ffa:	f44f 6400 	mov.w	r4, #2048	; 0x800
	mb_channel_init(0, MB0_USART_SERIAL, &mb0_usart_console_settings, MB0_USART_SERIAL_ID, 1, 5, 25);
  417ffe:	aa04      	add	r2, sp, #16
  418000:	4628      	mov	r0, r5
  418002:	9302      	str	r3, [sp, #8]
  418004:	9600      	str	r6, [sp, #0]
  418006:	230e      	movs	r3, #14
  418008:	4946      	ldr	r1, [pc, #280]	; (418124 <main+0x2fc>)
  41800a:	f8cd b004 	str.w	fp, [sp, #4]
	const sam_usart_opt_t mb0_usart_console_settings = {
  41800e:	9406      	str	r4, [sp, #24]
  418010:	9508      	str	r5, [sp, #32]
  418012:	9509      	str	r5, [sp, #36]	; 0x24
  418014:	f8cd a010 	str.w	sl, [sp, #16]
  418018:	f8cd 9014 	str.w	r9, [sp, #20]
  41801c:	9707      	str	r7, [sp, #28]
	mb_channel_init(0, MB0_USART_SERIAL, &mb0_usart_console_settings, MB0_USART_SERIAL_ID, 1, 5, 25);
  41801e:	47c0      	blx	r8
	mb_chanel_add_reply_sub(0, &req_io_internal_reply_sub);
  418020:	4628      	mov	r0, r5
  418022:	4941      	ldr	r1, [pc, #260]	; (418128 <main+0x300>)
  418024:	4b41      	ldr	r3, [pc, #260]	; (41812c <main+0x304>)
  418026:	4798      	blx	r3
		MB1_USART_SERIAL_CHAR_LENGTH,
		MB1_USART_SERIAL_PARITY,
		MB1_USART_SERIAL_STOP_BIT,
		US_MR_CHMODE_NORMAL
	};
	mb_channel_init(1, MB1_USART_SERIAL, &mb1_usart_console_settings, MB1_USART_SERIAL_ID, 1, 5, 30);
  418028:	231e      	movs	r3, #30
  41802a:	4630      	mov	r0, r6
  41802c:	aa0a      	add	r2, sp, #40	; 0x28
  41802e:	9302      	str	r3, [sp, #8]
  418030:	230d      	movs	r3, #13
  418032:	493f      	ldr	r1, [pc, #252]	; (418130 <main+0x308>)
	const sam_usart_opt_t mb1_usart_console_settings = {
  418034:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
  418038:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
  41803c:	970d      	str	r7, [sp, #52]	; 0x34
  41803e:	950e      	str	r5, [sp, #56]	; 0x38
  418040:	950f      	str	r5, [sp, #60]	; 0x3c
  418042:	4c3c      	ldr	r4, [pc, #240]	; (418134 <main+0x30c>)
	mb_channel_init(1, MB1_USART_SERIAL, &mb1_usart_console_settings, MB1_USART_SERIAL_ID, 1, 5, 30);
  418044:	e88d 0840 	stmia.w	sp, {r6, fp}
	const sam_usart_opt_t mb1_usart_console_settings = {
  418048:	f44f 6600 	mov.w	r6, #2048	; 0x800
  41804c:	960c      	str	r6, [sp, #48]	; 0x30
	mb_channel_init(1, MB1_USART_SERIAL, &mb1_usart_console_settings, MB1_USART_SERIAL_ID, 1, 5, 30);
  41804e:	47c0      	blx	r8
	
	//Hoist_init();	
	menue_data_manager_load();
  418050:	4b39      	ldr	r3, [pc, #228]	; (418138 <main+0x310>)
  418052:	4798      	blx	r3
	//sch_add_task_ms(&test_faults, 600, 8000);
	
	while(1){
		sch_dispatch_tasks();
  418054:	47a0      	blx	r4
  418056:	e7fd      	b.n	418054 <main+0x22c>
  418058:	004001ad 	.word	0x004001ad
  41805c:	0041728d 	.word	0x0041728d
  418060:	10002000 	.word	0x10002000
  418064:	400e1850 	.word	0x400e1850
  418068:	1fff2000 	.word	0x1fff2000
  41806c:	400e1900 	.word	0x400e1900
  418070:	00400589 	.word	0x00400589
  418074:	004173e5 	.word	0x004173e5
  418078:	00412815 	.word	0x00412815
  41807c:	0040d019 	.word	0x0040d019
  418080:	0040d315 	.word	0x0040d315
  418084:	00403ee9 	.word	0x00403ee9
  418088:	00413021 	.word	0x00413021
  41808c:	004129e1 	.word	0x004129e1
  418090:	00412aa5 	.word	0x00412aa5
  418094:	00417301 	.word	0x00417301
  418098:	00417a6d 	.word	0x00417a6d
  41809c:	00414d41 	.word	0x00414d41
  4180a0:	00416741 	.word	0x00416741
  4180a4:	00414591 	.word	0x00414591
  4180a8:	0040ddf9 	.word	0x0040ddf9
  4180ac:	0041616d 	.word	0x0041616d
  4180b0:	20400c74 	.word	0x20400c74
  4180b4:	004154ad 	.word	0x004154ad
  4180b8:	0040a9dd 	.word	0x0040a9dd
  4180bc:	0040ab7d 	.word	0x0040ab7d
  4180c0:	0040a679 	.word	0x0040a679
  4180c4:	0040d035 	.word	0x0040d035
  4180c8:	004126d1 	.word	0x004126d1
  4180cc:	00417ad1 	.word	0x00417ad1
  4180d0:	0040c32d 	.word	0x0040c32d
  4180d4:	00414869 	.word	0x00414869
  4180d8:	00404549 	.word	0x00404549
  4180dc:	00417afd 	.word	0x00417afd
  4180e0:	00417af5 	.word	0x00417af5
  4180e4:	00414631 	.word	0x00414631
  4180e8:	004081d9 	.word	0x004081d9
  4180ec:	00413245 	.word	0x00413245
  4180f0:	0040c01d 	.word	0x0040c01d
  4180f4:	0040ada1 	.word	0x0040ada1
  4180f8:	00417b45 	.word	0x00417b45
  4180fc:	00417b05 	.word	0x00417b05
  418100:	00417c0d 	.word	0x00417c0d
  418104:	00400969 	.word	0x00400969
  418108:	00416071 	.word	0x00416071
  41810c:	0040a9e1 	.word	0x0040a9e1
  418110:	00411931 	.word	0x00411931
  418114:	00411c81 	.word	0x00411c81
  418118:	0040f5c9 	.word	0x0040f5c9
  41811c:	0040a6b1 	.word	0x0040a6b1
  418120:	00415439 	.word	0x00415439
  418124:	40028000 	.word	0x40028000
  418128:	0040df89 	.word	0x0040df89
  41812c:	0040a735 	.word	0x0040a735
  418130:	40024000 	.word	0x40024000
  418134:	00417341 	.word	0x00417341
  418138:	00409d21 	.word	0x00409d21
  41813c:	0040a6e1 	.word	0x0040a6e1

00418140 <arm_sin_f32>:
  418140:	ee06 0a90 	vmov	s13, r0
  418144:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 4181b4 <arm_sin_f32+0x74>
  418148:	eef5 6ac0 	vcmpe.f32	s13, #0.0
  41814c:	ee26 7a87 	vmul.f32	s14, s13, s14
  418150:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  418154:	eefd 7ac7 	vcvt.s32.f32	s15, s14
  418158:	d504      	bpl.n	418164 <arm_sin_f32+0x24>
  41815a:	ee17 3a90 	vmov	r3, s15
  41815e:	3b01      	subs	r3, #1
  418160:	ee07 3a90 	vmov	s15, r3
  418164:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  418168:	eddf 6a13 	vldr	s13, [pc, #76]	; 4181b8 <arm_sin_f32+0x78>
  41816c:	ee77 7a67 	vsub.f32	s15, s14, s15
  418170:	ee67 7aa6 	vmul.f32	s15, s15, s13
  418174:	eebc 7ae7 	vcvt.u32.f32	s14, s15
  418178:	ee17 3a10 	vmov	r3, s14
  41817c:	f3c3 0308 	ubfx	r3, r3, #0, #9
  418180:	ee07 3a10 	vmov	s14, r3
  418184:	eef8 6a47 	vcvt.f32.u32	s13, s14
  418188:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  41818c:	ee77 7ae6 	vsub.f32	s15, s15, s13
  418190:	4a0a      	ldr	r2, [pc, #40]	; (4181bc <arm_sin_f32+0x7c>)
  418192:	ee37 7a67 	vsub.f32	s14, s14, s15
  418196:	eb02 0183 	add.w	r1, r2, r3, lsl #2
  41819a:	ed91 6a00 	vldr	s12, [r1]
  41819e:	edd1 6a01 	vldr	s13, [r1, #4]
  4181a2:	ee27 7a06 	vmul.f32	s14, s14, s12
  4181a6:	ee67 7aa6 	vmul.f32	s15, s15, s13
  4181aa:	ee77 7a27 	vadd.f32	s15, s14, s15
  4181ae:	ee17 0a90 	vmov	r0, s15
  4181b2:	4770      	bx	lr
  4181b4:	3e22f983 	.word	0x3e22f983
  4181b8:	44000000 	.word	0x44000000
  4181bc:	0041d144 	.word	0x0041d144

004181c0 <arm_cos_f32>:
  4181c0:	eddf 7a1e 	vldr	s15, [pc, #120]	; 41823c <arm_cos_f32+0x7c>
  4181c4:	ee06 0a90 	vmov	s13, r0
  4181c8:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
  4181cc:	ee66 7aa7 	vmul.f32	s15, s13, s15
  4181d0:	ee77 7a87 	vadd.f32	s15, s15, s14
  4181d4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4181d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4181dc:	eebd 7ae7 	vcvt.s32.f32	s14, s15
  4181e0:	d504      	bpl.n	4181ec <arm_cos_f32+0x2c>
  4181e2:	ee17 3a10 	vmov	r3, s14
  4181e6:	3b01      	subs	r3, #1
  4181e8:	ee07 3a10 	vmov	s14, r3
  4181ec:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  4181f0:	eddf 6a13 	vldr	s13, [pc, #76]	; 418240 <arm_cos_f32+0x80>
  4181f4:	ee77 7ac7 	vsub.f32	s15, s15, s14
  4181f8:	ee67 7aa6 	vmul.f32	s15, s15, s13
  4181fc:	eefc 6ae7 	vcvt.u32.f32	s13, s15
  418200:	ee16 3a90 	vmov	r3, s13
  418204:	f3c3 0308 	ubfx	r3, r3, #0, #9
  418208:	ee07 3a10 	vmov	s14, r3
  41820c:	eef8 6a47 	vcvt.f32.u32	s13, s14
  418210:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  418214:	ee77 7ae6 	vsub.f32	s15, s15, s13
  418218:	4a0a      	ldr	r2, [pc, #40]	; (418244 <arm_cos_f32+0x84>)
  41821a:	ee37 7a67 	vsub.f32	s14, s14, s15
  41821e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
  418222:	ed91 6a00 	vldr	s12, [r1]
  418226:	edd1 6a01 	vldr	s13, [r1, #4]
  41822a:	ee27 7a06 	vmul.f32	s14, s14, s12
  41822e:	ee67 7aa6 	vmul.f32	s15, s15, s13
  418232:	ee77 7a27 	vadd.f32	s15, s14, s15
  418236:	ee17 0a90 	vmov	r0, s15
  41823a:	4770      	bx	lr
  41823c:	3e22f983 	.word	0x3e22f983
  418240:	44000000 	.word	0x44000000
  418244:	0041d144 	.word	0x0041d144

00418248 <sqrt>:
  418248:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41824c:	b08b      	sub	sp, #44	; 0x2c
  41824e:	4604      	mov	r4, r0
  418250:	460d      	mov	r5, r1
  418252:	f000 f857 	bl	418304 <__ieee754_sqrt>
  418256:	4b29      	ldr	r3, [pc, #164]	; (4182fc <sqrt+0xb4>)
  418258:	f993 a000 	ldrsb.w	sl, [r3]
  41825c:	f1ba 3fff 	cmp.w	sl, #4294967295
  418260:	4606      	mov	r6, r0
  418262:	460f      	mov	r7, r1
  418264:	d012      	beq.n	41828c <sqrt+0x44>
  418266:	4622      	mov	r2, r4
  418268:	462b      	mov	r3, r5
  41826a:	4620      	mov	r0, r4
  41826c:	4629      	mov	r1, r5
  41826e:	f000 fd59 	bl	418d24 <__aeabi_dcmpun>
  418272:	4683      	mov	fp, r0
  418274:	b950      	cbnz	r0, 41828c <sqrt+0x44>
  418276:	f04f 0800 	mov.w	r8, #0
  41827a:	f04f 0900 	mov.w	r9, #0
  41827e:	4642      	mov	r2, r8
  418280:	464b      	mov	r3, r9
  418282:	4620      	mov	r0, r4
  418284:	4629      	mov	r1, r5
  418286:	f000 fd25 	bl	418cd4 <__aeabi_dcmplt>
  41828a:	b920      	cbnz	r0, 418296 <sqrt+0x4e>
  41828c:	4630      	mov	r0, r6
  41828e:	4639      	mov	r1, r7
  418290:	b00b      	add	sp, #44	; 0x2c
  418292:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  418296:	4b1a      	ldr	r3, [pc, #104]	; (418300 <sqrt+0xb8>)
  418298:	f8cd b020 	str.w	fp, [sp, #32]
  41829c:	2201      	movs	r2, #1
  41829e:	e9cd 4504 	strd	r4, r5, [sp, #16]
  4182a2:	e9cd 4502 	strd	r4, r5, [sp, #8]
  4182a6:	e88d 000c 	stmia.w	sp, {r2, r3}
  4182aa:	f1ba 0f00 	cmp.w	sl, #0
  4182ae:	d017      	beq.n	4182e0 <sqrt+0x98>
  4182b0:	4642      	mov	r2, r8
  4182b2:	464b      	mov	r3, r9
  4182b4:	4640      	mov	r0, r8
  4182b6:	4649      	mov	r1, r9
  4182b8:	f000 fbc4 	bl	418a44 <__aeabi_ddiv>
  4182bc:	f1ba 0f02 	cmp.w	sl, #2
  4182c0:	e9cd 0106 	strd	r0, r1, [sp, #24]
  4182c4:	d10e      	bne.n	4182e4 <sqrt+0x9c>
  4182c6:	f001 f971 	bl	4195ac <__errno>
  4182ca:	2321      	movs	r3, #33	; 0x21
  4182cc:	6003      	str	r3, [r0, #0]
  4182ce:	9b08      	ldr	r3, [sp, #32]
  4182d0:	b973      	cbnz	r3, 4182f0 <sqrt+0xa8>
  4182d2:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
  4182d6:	4630      	mov	r0, r6
  4182d8:	4639      	mov	r1, r7
  4182da:	b00b      	add	sp, #44	; 0x2c
  4182dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4182e0:	e9cd 8906 	strd	r8, r9, [sp, #24]
  4182e4:	4668      	mov	r0, sp
  4182e6:	f000 f8c9 	bl	41847c <matherr>
  4182ea:	2800      	cmp	r0, #0
  4182ec:	d1ef      	bne.n	4182ce <sqrt+0x86>
  4182ee:	e7ea      	b.n	4182c6 <sqrt+0x7e>
  4182f0:	f001 f95c 	bl	4195ac <__errno>
  4182f4:	9b08      	ldr	r3, [sp, #32]
  4182f6:	6003      	str	r3, [r0, #0]
  4182f8:	e7eb      	b.n	4182d2 <sqrt+0x8a>
  4182fa:	bf00      	nop
  4182fc:	204003d0 	.word	0x204003d0
  418300:	0041d948 	.word	0x0041d948

00418304 <__ieee754_sqrt>:
  418304:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  418308:	4f5b      	ldr	r7, [pc, #364]	; (418478 <__ieee754_sqrt+0x174>)
  41830a:	438f      	bics	r7, r1
  41830c:	4605      	mov	r5, r0
  41830e:	460c      	mov	r4, r1
  418310:	f000 8092 	beq.w	418438 <__ieee754_sqrt+0x134>
  418314:	2900      	cmp	r1, #0
  418316:	460b      	mov	r3, r1
  418318:	4602      	mov	r2, r0
  41831a:	dd6f      	ble.n	4183fc <__ieee754_sqrt+0xf8>
  41831c:	150f      	asrs	r7, r1, #20
  41831e:	d07b      	beq.n	418418 <__ieee754_sqrt+0x114>
  418320:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
  418324:	f3c3 0313 	ubfx	r3, r3, #0, #20
  418328:	07f8      	lsls	r0, r7, #31
  41832a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  41832e:	d45c      	bmi.n	4183ea <__ieee754_sqrt+0xe6>
  418330:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
  418334:	2600      	movs	r6, #0
  418336:	440b      	add	r3, r1
  418338:	107f      	asrs	r7, r7, #1
  41833a:	0052      	lsls	r2, r2, #1
  41833c:	46b6      	mov	lr, r6
  41833e:	2016      	movs	r0, #22
  418340:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  418344:	eb0e 0401 	add.w	r4, lr, r1
  418348:	429c      	cmp	r4, r3
  41834a:	ea4f 75d2 	mov.w	r5, r2, lsr #31
  41834e:	ea4f 0242 	mov.w	r2, r2, lsl #1
  418352:	dc03      	bgt.n	41835c <__ieee754_sqrt+0x58>
  418354:	1b1b      	subs	r3, r3, r4
  418356:	eb04 0e01 	add.w	lr, r4, r1
  41835a:	440e      	add	r6, r1
  41835c:	3801      	subs	r0, #1
  41835e:	eb05 0343 	add.w	r3, r5, r3, lsl #1
  418362:	ea4f 0151 	mov.w	r1, r1, lsr #1
  418366:	d1ed      	bne.n	418344 <__ieee754_sqrt+0x40>
  418368:	4684      	mov	ip, r0
  41836a:	2420      	movs	r4, #32
  41836c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  418370:	e009      	b.n	418386 <__ieee754_sqrt+0x82>
  418372:	d020      	beq.n	4183b6 <__ieee754_sqrt+0xb2>
  418374:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
  418378:	3c01      	subs	r4, #1
  41837a:	ea4f 0151 	mov.w	r1, r1, lsr #1
  41837e:	442b      	add	r3, r5
  418380:	ea4f 0242 	mov.w	r2, r2, lsl #1
  418384:	d020      	beq.n	4183c8 <__ieee754_sqrt+0xc4>
  418386:	4573      	cmp	r3, lr
  418388:	eb01 050c 	add.w	r5, r1, ip
  41838c:	ddf1      	ble.n	418372 <__ieee754_sqrt+0x6e>
  41838e:	2d00      	cmp	r5, #0
  418390:	eb05 0c01 	add.w	ip, r5, r1
  418394:	db09      	blt.n	4183aa <__ieee754_sqrt+0xa6>
  418396:	46f0      	mov	r8, lr
  418398:	4295      	cmp	r5, r2
  41839a:	eba3 030e 	sub.w	r3, r3, lr
  41839e:	d900      	bls.n	4183a2 <__ieee754_sqrt+0x9e>
  4183a0:	3b01      	subs	r3, #1
  4183a2:	1b52      	subs	r2, r2, r5
  4183a4:	4408      	add	r0, r1
  4183a6:	46c6      	mov	lr, r8
  4183a8:	e7e4      	b.n	418374 <__ieee754_sqrt+0x70>
  4183aa:	f1bc 0f00 	cmp.w	ip, #0
  4183ae:	dbf2      	blt.n	418396 <__ieee754_sqrt+0x92>
  4183b0:	f10e 0801 	add.w	r8, lr, #1
  4183b4:	e7f0      	b.n	418398 <__ieee754_sqrt+0x94>
  4183b6:	4295      	cmp	r5, r2
  4183b8:	d8dc      	bhi.n	418374 <__ieee754_sqrt+0x70>
  4183ba:	2d00      	cmp	r5, #0
  4183bc:	eb05 0c01 	add.w	ip, r5, r1
  4183c0:	db44      	blt.n	41844c <__ieee754_sqrt+0x148>
  4183c2:	4698      	mov	r8, r3
  4183c4:	2300      	movs	r3, #0
  4183c6:	e7ec      	b.n	4183a2 <__ieee754_sqrt+0x9e>
  4183c8:	4313      	orrs	r3, r2
  4183ca:	d113      	bne.n	4183f4 <__ieee754_sqrt+0xf0>
  4183cc:	0840      	lsrs	r0, r0, #1
  4183ce:	1073      	asrs	r3, r6, #1
  4183d0:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
  4183d4:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4183d8:	07f2      	lsls	r2, r6, #31
  4183da:	eb03 5907 	add.w	r9, r3, r7, lsl #20
  4183de:	bf48      	it	mi
  4183e0:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
  4183e4:	4649      	mov	r1, r9
  4183e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4183ea:	005b      	lsls	r3, r3, #1
  4183ec:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
  4183f0:	0052      	lsls	r2, r2, #1
  4183f2:	e79d      	b.n	418330 <__ieee754_sqrt+0x2c>
  4183f4:	1c41      	adds	r1, r0, #1
  4183f6:	d02d      	beq.n	418454 <__ieee754_sqrt+0x150>
  4183f8:	3001      	adds	r0, #1
  4183fa:	e7e7      	b.n	4183cc <__ieee754_sqrt+0xc8>
  4183fc:	4606      	mov	r6, r0
  4183fe:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  418402:	433e      	orrs	r6, r7
  418404:	d0ef      	beq.n	4183e6 <__ieee754_sqrt+0xe2>
  418406:	bb69      	cbnz	r1, 418464 <__ieee754_sqrt+0x160>
  418408:	460f      	mov	r7, r1
  41840a:	0ad3      	lsrs	r3, r2, #11
  41840c:	3f15      	subs	r7, #21
  41840e:	0552      	lsls	r2, r2, #21
  418410:	2b00      	cmp	r3, #0
  418412:	d0fa      	beq.n	41840a <__ieee754_sqrt+0x106>
  418414:	02de      	lsls	r6, r3, #11
  418416:	d420      	bmi.n	41845a <__ieee754_sqrt+0x156>
  418418:	2400      	movs	r4, #0
  41841a:	e000      	b.n	41841e <__ieee754_sqrt+0x11a>
  41841c:	4604      	mov	r4, r0
  41841e:	005b      	lsls	r3, r3, #1
  418420:	02dd      	lsls	r5, r3, #11
  418422:	f104 0001 	add.w	r0, r4, #1
  418426:	d5f9      	bpl.n	41841c <__ieee754_sqrt+0x118>
  418428:	f1c0 0120 	rsb	r1, r0, #32
  41842c:	fa22 f101 	lsr.w	r1, r2, r1
  418430:	430b      	orrs	r3, r1
  418432:	1b3f      	subs	r7, r7, r4
  418434:	4082      	lsls	r2, r0
  418436:	e773      	b.n	418320 <__ieee754_sqrt+0x1c>
  418438:	4602      	mov	r2, r0
  41843a:	460b      	mov	r3, r1
  41843c:	f000 f9d8 	bl	4187f0 <__aeabi_dmul>
  418440:	462a      	mov	r2, r5
  418442:	4623      	mov	r3, r4
  418444:	f000 f822 	bl	41848c <__adddf3>
  418448:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41844c:	f1bc 0f00 	cmp.w	ip, #0
  418450:	daae      	bge.n	4183b0 <__ieee754_sqrt+0xac>
  418452:	e7b6      	b.n	4183c2 <__ieee754_sqrt+0xbe>
  418454:	3601      	adds	r6, #1
  418456:	4620      	mov	r0, r4
  418458:	e7b9      	b.n	4183ce <__ieee754_sqrt+0xca>
  41845a:	2000      	movs	r0, #0
  41845c:	2120      	movs	r1, #32
  41845e:	f04f 34ff 	mov.w	r4, #4294967295
  418462:	e7e3      	b.n	41842c <__ieee754_sqrt+0x128>
  418464:	4602      	mov	r2, r0
  418466:	460b      	mov	r3, r1
  418468:	f000 f80e 	bl	418488 <__aeabi_dsub>
  41846c:	4602      	mov	r2, r0
  41846e:	460b      	mov	r3, r1
  418470:	f000 fae8 	bl	418a44 <__aeabi_ddiv>
  418474:	e7b7      	b.n	4183e6 <__ieee754_sqrt+0xe2>
  418476:	bf00      	nop
  418478:	7ff00000 	.word	0x7ff00000

0041847c <matherr>:
  41847c:	2000      	movs	r0, #0
  41847e:	4770      	bx	lr

00418480 <__aeabi_drsub>:
  418480:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  418484:	e002      	b.n	41848c <__adddf3>
  418486:	bf00      	nop

00418488 <__aeabi_dsub>:
  418488:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0041848c <__adddf3>:
  41848c:	b530      	push	{r4, r5, lr}
  41848e:	ea4f 0441 	mov.w	r4, r1, lsl #1
  418492:	ea4f 0543 	mov.w	r5, r3, lsl #1
  418496:	ea94 0f05 	teq	r4, r5
  41849a:	bf08      	it	eq
  41849c:	ea90 0f02 	teqeq	r0, r2
  4184a0:	bf1f      	itttt	ne
  4184a2:	ea54 0c00 	orrsne.w	ip, r4, r0
  4184a6:	ea55 0c02 	orrsne.w	ip, r5, r2
  4184aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  4184ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4184b2:	f000 80e2 	beq.w	41867a <__adddf3+0x1ee>
  4184b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
  4184ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  4184be:	bfb8      	it	lt
  4184c0:	426d      	neglt	r5, r5
  4184c2:	dd0c      	ble.n	4184de <__adddf3+0x52>
  4184c4:	442c      	add	r4, r5
  4184c6:	ea80 0202 	eor.w	r2, r0, r2
  4184ca:	ea81 0303 	eor.w	r3, r1, r3
  4184ce:	ea82 0000 	eor.w	r0, r2, r0
  4184d2:	ea83 0101 	eor.w	r1, r3, r1
  4184d6:	ea80 0202 	eor.w	r2, r0, r2
  4184da:	ea81 0303 	eor.w	r3, r1, r3
  4184de:	2d36      	cmp	r5, #54	; 0x36
  4184e0:	bf88      	it	hi
  4184e2:	bd30      	pophi	{r4, r5, pc}
  4184e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4184e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4184ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4184f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4184f4:	d002      	beq.n	4184fc <__adddf3+0x70>
  4184f6:	4240      	negs	r0, r0
  4184f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4184fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  418500:	ea4f 3303 	mov.w	r3, r3, lsl #12
  418504:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  418508:	d002      	beq.n	418510 <__adddf3+0x84>
  41850a:	4252      	negs	r2, r2
  41850c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  418510:	ea94 0f05 	teq	r4, r5
  418514:	f000 80a7 	beq.w	418666 <__adddf3+0x1da>
  418518:	f1a4 0401 	sub.w	r4, r4, #1
  41851c:	f1d5 0e20 	rsbs	lr, r5, #32
  418520:	db0d      	blt.n	41853e <__adddf3+0xb2>
  418522:	fa02 fc0e 	lsl.w	ip, r2, lr
  418526:	fa22 f205 	lsr.w	r2, r2, r5
  41852a:	1880      	adds	r0, r0, r2
  41852c:	f141 0100 	adc.w	r1, r1, #0
  418530:	fa03 f20e 	lsl.w	r2, r3, lr
  418534:	1880      	adds	r0, r0, r2
  418536:	fa43 f305 	asr.w	r3, r3, r5
  41853a:	4159      	adcs	r1, r3
  41853c:	e00e      	b.n	41855c <__adddf3+0xd0>
  41853e:	f1a5 0520 	sub.w	r5, r5, #32
  418542:	f10e 0e20 	add.w	lr, lr, #32
  418546:	2a01      	cmp	r2, #1
  418548:	fa03 fc0e 	lsl.w	ip, r3, lr
  41854c:	bf28      	it	cs
  41854e:	f04c 0c02 	orrcs.w	ip, ip, #2
  418552:	fa43 f305 	asr.w	r3, r3, r5
  418556:	18c0      	adds	r0, r0, r3
  418558:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  41855c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  418560:	d507      	bpl.n	418572 <__adddf3+0xe6>
  418562:	f04f 0e00 	mov.w	lr, #0
  418566:	f1dc 0c00 	rsbs	ip, ip, #0
  41856a:	eb7e 0000 	sbcs.w	r0, lr, r0
  41856e:	eb6e 0101 	sbc.w	r1, lr, r1
  418572:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  418576:	d31b      	bcc.n	4185b0 <__adddf3+0x124>
  418578:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  41857c:	d30c      	bcc.n	418598 <__adddf3+0x10c>
  41857e:	0849      	lsrs	r1, r1, #1
  418580:	ea5f 0030 	movs.w	r0, r0, rrx
  418584:	ea4f 0c3c 	mov.w	ip, ip, rrx
  418588:	f104 0401 	add.w	r4, r4, #1
  41858c:	ea4f 5244 	mov.w	r2, r4, lsl #21
  418590:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  418594:	f080 809a 	bcs.w	4186cc <__adddf3+0x240>
  418598:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  41859c:	bf08      	it	eq
  41859e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  4185a2:	f150 0000 	adcs.w	r0, r0, #0
  4185a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4185aa:	ea41 0105 	orr.w	r1, r1, r5
  4185ae:	bd30      	pop	{r4, r5, pc}
  4185b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  4185b4:	4140      	adcs	r0, r0
  4185b6:	eb41 0101 	adc.w	r1, r1, r1
  4185ba:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4185be:	f1a4 0401 	sub.w	r4, r4, #1
  4185c2:	d1e9      	bne.n	418598 <__adddf3+0x10c>
  4185c4:	f091 0f00 	teq	r1, #0
  4185c8:	bf04      	itt	eq
  4185ca:	4601      	moveq	r1, r0
  4185cc:	2000      	moveq	r0, #0
  4185ce:	fab1 f381 	clz	r3, r1
  4185d2:	bf08      	it	eq
  4185d4:	3320      	addeq	r3, #32
  4185d6:	f1a3 030b 	sub.w	r3, r3, #11
  4185da:	f1b3 0220 	subs.w	r2, r3, #32
  4185de:	da0c      	bge.n	4185fa <__adddf3+0x16e>
  4185e0:	320c      	adds	r2, #12
  4185e2:	dd08      	ble.n	4185f6 <__adddf3+0x16a>
  4185e4:	f102 0c14 	add.w	ip, r2, #20
  4185e8:	f1c2 020c 	rsb	r2, r2, #12
  4185ec:	fa01 f00c 	lsl.w	r0, r1, ip
  4185f0:	fa21 f102 	lsr.w	r1, r1, r2
  4185f4:	e00c      	b.n	418610 <__adddf3+0x184>
  4185f6:	f102 0214 	add.w	r2, r2, #20
  4185fa:	bfd8      	it	le
  4185fc:	f1c2 0c20 	rsble	ip, r2, #32
  418600:	fa01 f102 	lsl.w	r1, r1, r2
  418604:	fa20 fc0c 	lsr.w	ip, r0, ip
  418608:	bfdc      	itt	le
  41860a:	ea41 010c 	orrle.w	r1, r1, ip
  41860e:	4090      	lslle	r0, r2
  418610:	1ae4      	subs	r4, r4, r3
  418612:	bfa2      	ittt	ge
  418614:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  418618:	4329      	orrge	r1, r5
  41861a:	bd30      	popge	{r4, r5, pc}
  41861c:	ea6f 0404 	mvn.w	r4, r4
  418620:	3c1f      	subs	r4, #31
  418622:	da1c      	bge.n	41865e <__adddf3+0x1d2>
  418624:	340c      	adds	r4, #12
  418626:	dc0e      	bgt.n	418646 <__adddf3+0x1ba>
  418628:	f104 0414 	add.w	r4, r4, #20
  41862c:	f1c4 0220 	rsb	r2, r4, #32
  418630:	fa20 f004 	lsr.w	r0, r0, r4
  418634:	fa01 f302 	lsl.w	r3, r1, r2
  418638:	ea40 0003 	orr.w	r0, r0, r3
  41863c:	fa21 f304 	lsr.w	r3, r1, r4
  418640:	ea45 0103 	orr.w	r1, r5, r3
  418644:	bd30      	pop	{r4, r5, pc}
  418646:	f1c4 040c 	rsb	r4, r4, #12
  41864a:	f1c4 0220 	rsb	r2, r4, #32
  41864e:	fa20 f002 	lsr.w	r0, r0, r2
  418652:	fa01 f304 	lsl.w	r3, r1, r4
  418656:	ea40 0003 	orr.w	r0, r0, r3
  41865a:	4629      	mov	r1, r5
  41865c:	bd30      	pop	{r4, r5, pc}
  41865e:	fa21 f004 	lsr.w	r0, r1, r4
  418662:	4629      	mov	r1, r5
  418664:	bd30      	pop	{r4, r5, pc}
  418666:	f094 0f00 	teq	r4, #0
  41866a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  41866e:	bf06      	itte	eq
  418670:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  418674:	3401      	addeq	r4, #1
  418676:	3d01      	subne	r5, #1
  418678:	e74e      	b.n	418518 <__adddf3+0x8c>
  41867a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  41867e:	bf18      	it	ne
  418680:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  418684:	d029      	beq.n	4186da <__adddf3+0x24e>
  418686:	ea94 0f05 	teq	r4, r5
  41868a:	bf08      	it	eq
  41868c:	ea90 0f02 	teqeq	r0, r2
  418690:	d005      	beq.n	41869e <__adddf3+0x212>
  418692:	ea54 0c00 	orrs.w	ip, r4, r0
  418696:	bf04      	itt	eq
  418698:	4619      	moveq	r1, r3
  41869a:	4610      	moveq	r0, r2
  41869c:	bd30      	pop	{r4, r5, pc}
  41869e:	ea91 0f03 	teq	r1, r3
  4186a2:	bf1e      	ittt	ne
  4186a4:	2100      	movne	r1, #0
  4186a6:	2000      	movne	r0, #0
  4186a8:	bd30      	popne	{r4, r5, pc}
  4186aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  4186ae:	d105      	bne.n	4186bc <__adddf3+0x230>
  4186b0:	0040      	lsls	r0, r0, #1
  4186b2:	4149      	adcs	r1, r1
  4186b4:	bf28      	it	cs
  4186b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  4186ba:	bd30      	pop	{r4, r5, pc}
  4186bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  4186c0:	bf3c      	itt	cc
  4186c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  4186c6:	bd30      	popcc	{r4, r5, pc}
  4186c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  4186cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  4186d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4186d4:	f04f 0000 	mov.w	r0, #0
  4186d8:	bd30      	pop	{r4, r5, pc}
  4186da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4186de:	bf1a      	itte	ne
  4186e0:	4619      	movne	r1, r3
  4186e2:	4610      	movne	r0, r2
  4186e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  4186e8:	bf1c      	itt	ne
  4186ea:	460b      	movne	r3, r1
  4186ec:	4602      	movne	r2, r0
  4186ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4186f2:	bf06      	itte	eq
  4186f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4186f8:	ea91 0f03 	teqeq	r1, r3
  4186fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  418700:	bd30      	pop	{r4, r5, pc}
  418702:	bf00      	nop

00418704 <__aeabi_ui2d>:
  418704:	f090 0f00 	teq	r0, #0
  418708:	bf04      	itt	eq
  41870a:	2100      	moveq	r1, #0
  41870c:	4770      	bxeq	lr
  41870e:	b530      	push	{r4, r5, lr}
  418710:	f44f 6480 	mov.w	r4, #1024	; 0x400
  418714:	f104 0432 	add.w	r4, r4, #50	; 0x32
  418718:	f04f 0500 	mov.w	r5, #0
  41871c:	f04f 0100 	mov.w	r1, #0
  418720:	e750      	b.n	4185c4 <__adddf3+0x138>
  418722:	bf00      	nop

00418724 <__aeabi_i2d>:
  418724:	f090 0f00 	teq	r0, #0
  418728:	bf04      	itt	eq
  41872a:	2100      	moveq	r1, #0
  41872c:	4770      	bxeq	lr
  41872e:	b530      	push	{r4, r5, lr}
  418730:	f44f 6480 	mov.w	r4, #1024	; 0x400
  418734:	f104 0432 	add.w	r4, r4, #50	; 0x32
  418738:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  41873c:	bf48      	it	mi
  41873e:	4240      	negmi	r0, r0
  418740:	f04f 0100 	mov.w	r1, #0
  418744:	e73e      	b.n	4185c4 <__adddf3+0x138>
  418746:	bf00      	nop

00418748 <__aeabi_f2d>:
  418748:	0042      	lsls	r2, r0, #1
  41874a:	ea4f 01e2 	mov.w	r1, r2, asr #3
  41874e:	ea4f 0131 	mov.w	r1, r1, rrx
  418752:	ea4f 7002 	mov.w	r0, r2, lsl #28
  418756:	bf1f      	itttt	ne
  418758:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  41875c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  418760:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  418764:	4770      	bxne	lr
  418766:	f092 0f00 	teq	r2, #0
  41876a:	bf14      	ite	ne
  41876c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  418770:	4770      	bxeq	lr
  418772:	b530      	push	{r4, r5, lr}
  418774:	f44f 7460 	mov.w	r4, #896	; 0x380
  418778:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  41877c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  418780:	e720      	b.n	4185c4 <__adddf3+0x138>
  418782:	bf00      	nop

00418784 <__aeabi_ul2d>:
  418784:	ea50 0201 	orrs.w	r2, r0, r1
  418788:	bf08      	it	eq
  41878a:	4770      	bxeq	lr
  41878c:	b530      	push	{r4, r5, lr}
  41878e:	f04f 0500 	mov.w	r5, #0
  418792:	e00a      	b.n	4187aa <__aeabi_l2d+0x16>

00418794 <__aeabi_l2d>:
  418794:	ea50 0201 	orrs.w	r2, r0, r1
  418798:	bf08      	it	eq
  41879a:	4770      	bxeq	lr
  41879c:	b530      	push	{r4, r5, lr}
  41879e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  4187a2:	d502      	bpl.n	4187aa <__aeabi_l2d+0x16>
  4187a4:	4240      	negs	r0, r0
  4187a6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4187aa:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4187ae:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4187b2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  4187b6:	f43f aedc 	beq.w	418572 <__adddf3+0xe6>
  4187ba:	f04f 0203 	mov.w	r2, #3
  4187be:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4187c2:	bf18      	it	ne
  4187c4:	3203      	addne	r2, #3
  4187c6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  4187ca:	bf18      	it	ne
  4187cc:	3203      	addne	r2, #3
  4187ce:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  4187d2:	f1c2 0320 	rsb	r3, r2, #32
  4187d6:	fa00 fc03 	lsl.w	ip, r0, r3
  4187da:	fa20 f002 	lsr.w	r0, r0, r2
  4187de:	fa01 fe03 	lsl.w	lr, r1, r3
  4187e2:	ea40 000e 	orr.w	r0, r0, lr
  4187e6:	fa21 f102 	lsr.w	r1, r1, r2
  4187ea:	4414      	add	r4, r2
  4187ec:	e6c1      	b.n	418572 <__adddf3+0xe6>
  4187ee:	bf00      	nop

004187f0 <__aeabi_dmul>:
  4187f0:	b570      	push	{r4, r5, r6, lr}
  4187f2:	f04f 0cff 	mov.w	ip, #255	; 0xff
  4187f6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  4187fa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  4187fe:	bf1d      	ittte	ne
  418800:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  418804:	ea94 0f0c 	teqne	r4, ip
  418808:	ea95 0f0c 	teqne	r5, ip
  41880c:	f000 f8de 	bleq	4189cc <__aeabi_dmul+0x1dc>
  418810:	442c      	add	r4, r5
  418812:	ea81 0603 	eor.w	r6, r1, r3
  418816:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  41881a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  41881e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  418822:	bf18      	it	ne
  418824:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  418828:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  41882c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  418830:	d038      	beq.n	4188a4 <__aeabi_dmul+0xb4>
  418832:	fba0 ce02 	umull	ip, lr, r0, r2
  418836:	f04f 0500 	mov.w	r5, #0
  41883a:	fbe1 e502 	umlal	lr, r5, r1, r2
  41883e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  418842:	fbe0 e503 	umlal	lr, r5, r0, r3
  418846:	f04f 0600 	mov.w	r6, #0
  41884a:	fbe1 5603 	umlal	r5, r6, r1, r3
  41884e:	f09c 0f00 	teq	ip, #0
  418852:	bf18      	it	ne
  418854:	f04e 0e01 	orrne.w	lr, lr, #1
  418858:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  41885c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  418860:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  418864:	d204      	bcs.n	418870 <__aeabi_dmul+0x80>
  418866:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  41886a:	416d      	adcs	r5, r5
  41886c:	eb46 0606 	adc.w	r6, r6, r6
  418870:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  418874:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  418878:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  41887c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  418880:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  418884:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  418888:	bf88      	it	hi
  41888a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  41888e:	d81e      	bhi.n	4188ce <__aeabi_dmul+0xde>
  418890:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  418894:	bf08      	it	eq
  418896:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  41889a:	f150 0000 	adcs.w	r0, r0, #0
  41889e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4188a2:	bd70      	pop	{r4, r5, r6, pc}
  4188a4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  4188a8:	ea46 0101 	orr.w	r1, r6, r1
  4188ac:	ea40 0002 	orr.w	r0, r0, r2
  4188b0:	ea81 0103 	eor.w	r1, r1, r3
  4188b4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  4188b8:	bfc2      	ittt	gt
  4188ba:	ebd4 050c 	rsbsgt	r5, r4, ip
  4188be:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  4188c2:	bd70      	popgt	{r4, r5, r6, pc}
  4188c4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4188c8:	f04f 0e00 	mov.w	lr, #0
  4188cc:	3c01      	subs	r4, #1
  4188ce:	f300 80ab 	bgt.w	418a28 <__aeabi_dmul+0x238>
  4188d2:	f114 0f36 	cmn.w	r4, #54	; 0x36
  4188d6:	bfde      	ittt	le
  4188d8:	2000      	movle	r0, #0
  4188da:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  4188de:	bd70      	pople	{r4, r5, r6, pc}
  4188e0:	f1c4 0400 	rsb	r4, r4, #0
  4188e4:	3c20      	subs	r4, #32
  4188e6:	da35      	bge.n	418954 <__aeabi_dmul+0x164>
  4188e8:	340c      	adds	r4, #12
  4188ea:	dc1b      	bgt.n	418924 <__aeabi_dmul+0x134>
  4188ec:	f104 0414 	add.w	r4, r4, #20
  4188f0:	f1c4 0520 	rsb	r5, r4, #32
  4188f4:	fa00 f305 	lsl.w	r3, r0, r5
  4188f8:	fa20 f004 	lsr.w	r0, r0, r4
  4188fc:	fa01 f205 	lsl.w	r2, r1, r5
  418900:	ea40 0002 	orr.w	r0, r0, r2
  418904:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  418908:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  41890c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  418910:	fa21 f604 	lsr.w	r6, r1, r4
  418914:	eb42 0106 	adc.w	r1, r2, r6
  418918:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  41891c:	bf08      	it	eq
  41891e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  418922:	bd70      	pop	{r4, r5, r6, pc}
  418924:	f1c4 040c 	rsb	r4, r4, #12
  418928:	f1c4 0520 	rsb	r5, r4, #32
  41892c:	fa00 f304 	lsl.w	r3, r0, r4
  418930:	fa20 f005 	lsr.w	r0, r0, r5
  418934:	fa01 f204 	lsl.w	r2, r1, r4
  418938:	ea40 0002 	orr.w	r0, r0, r2
  41893c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  418940:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  418944:	f141 0100 	adc.w	r1, r1, #0
  418948:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  41894c:	bf08      	it	eq
  41894e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  418952:	bd70      	pop	{r4, r5, r6, pc}
  418954:	f1c4 0520 	rsb	r5, r4, #32
  418958:	fa00 f205 	lsl.w	r2, r0, r5
  41895c:	ea4e 0e02 	orr.w	lr, lr, r2
  418960:	fa20 f304 	lsr.w	r3, r0, r4
  418964:	fa01 f205 	lsl.w	r2, r1, r5
  418968:	ea43 0302 	orr.w	r3, r3, r2
  41896c:	fa21 f004 	lsr.w	r0, r1, r4
  418970:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  418974:	fa21 f204 	lsr.w	r2, r1, r4
  418978:	ea20 0002 	bic.w	r0, r0, r2
  41897c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  418980:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  418984:	bf08      	it	eq
  418986:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  41898a:	bd70      	pop	{r4, r5, r6, pc}
  41898c:	f094 0f00 	teq	r4, #0
  418990:	d10f      	bne.n	4189b2 <__aeabi_dmul+0x1c2>
  418992:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  418996:	0040      	lsls	r0, r0, #1
  418998:	eb41 0101 	adc.w	r1, r1, r1
  41899c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4189a0:	bf08      	it	eq
  4189a2:	3c01      	subeq	r4, #1
  4189a4:	d0f7      	beq.n	418996 <__aeabi_dmul+0x1a6>
  4189a6:	ea41 0106 	orr.w	r1, r1, r6
  4189aa:	f095 0f00 	teq	r5, #0
  4189ae:	bf18      	it	ne
  4189b0:	4770      	bxne	lr
  4189b2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  4189b6:	0052      	lsls	r2, r2, #1
  4189b8:	eb43 0303 	adc.w	r3, r3, r3
  4189bc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  4189c0:	bf08      	it	eq
  4189c2:	3d01      	subeq	r5, #1
  4189c4:	d0f7      	beq.n	4189b6 <__aeabi_dmul+0x1c6>
  4189c6:	ea43 0306 	orr.w	r3, r3, r6
  4189ca:	4770      	bx	lr
  4189cc:	ea94 0f0c 	teq	r4, ip
  4189d0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  4189d4:	bf18      	it	ne
  4189d6:	ea95 0f0c 	teqne	r5, ip
  4189da:	d00c      	beq.n	4189f6 <__aeabi_dmul+0x206>
  4189dc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4189e0:	bf18      	it	ne
  4189e2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4189e6:	d1d1      	bne.n	41898c <__aeabi_dmul+0x19c>
  4189e8:	ea81 0103 	eor.w	r1, r1, r3
  4189ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4189f0:	f04f 0000 	mov.w	r0, #0
  4189f4:	bd70      	pop	{r4, r5, r6, pc}
  4189f6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4189fa:	bf06      	itte	eq
  4189fc:	4610      	moveq	r0, r2
  4189fe:	4619      	moveq	r1, r3
  418a00:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  418a04:	d019      	beq.n	418a3a <__aeabi_dmul+0x24a>
  418a06:	ea94 0f0c 	teq	r4, ip
  418a0a:	d102      	bne.n	418a12 <__aeabi_dmul+0x222>
  418a0c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  418a10:	d113      	bne.n	418a3a <__aeabi_dmul+0x24a>
  418a12:	ea95 0f0c 	teq	r5, ip
  418a16:	d105      	bne.n	418a24 <__aeabi_dmul+0x234>
  418a18:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  418a1c:	bf1c      	itt	ne
  418a1e:	4610      	movne	r0, r2
  418a20:	4619      	movne	r1, r3
  418a22:	d10a      	bne.n	418a3a <__aeabi_dmul+0x24a>
  418a24:	ea81 0103 	eor.w	r1, r1, r3
  418a28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  418a2c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  418a30:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  418a34:	f04f 0000 	mov.w	r0, #0
  418a38:	bd70      	pop	{r4, r5, r6, pc}
  418a3a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  418a3e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  418a42:	bd70      	pop	{r4, r5, r6, pc}

00418a44 <__aeabi_ddiv>:
  418a44:	b570      	push	{r4, r5, r6, lr}
  418a46:	f04f 0cff 	mov.w	ip, #255	; 0xff
  418a4a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  418a4e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  418a52:	bf1d      	ittte	ne
  418a54:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  418a58:	ea94 0f0c 	teqne	r4, ip
  418a5c:	ea95 0f0c 	teqne	r5, ip
  418a60:	f000 f8a7 	bleq	418bb2 <__aeabi_ddiv+0x16e>
  418a64:	eba4 0405 	sub.w	r4, r4, r5
  418a68:	ea81 0e03 	eor.w	lr, r1, r3
  418a6c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  418a70:	ea4f 3101 	mov.w	r1, r1, lsl #12
  418a74:	f000 8088 	beq.w	418b88 <__aeabi_ddiv+0x144>
  418a78:	ea4f 3303 	mov.w	r3, r3, lsl #12
  418a7c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  418a80:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  418a84:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  418a88:	ea4f 2202 	mov.w	r2, r2, lsl #8
  418a8c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  418a90:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  418a94:	ea4f 2600 	mov.w	r6, r0, lsl #8
  418a98:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  418a9c:	429d      	cmp	r5, r3
  418a9e:	bf08      	it	eq
  418aa0:	4296      	cmpeq	r6, r2
  418aa2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  418aa6:	f504 7440 	add.w	r4, r4, #768	; 0x300
  418aaa:	d202      	bcs.n	418ab2 <__aeabi_ddiv+0x6e>
  418aac:	085b      	lsrs	r3, r3, #1
  418aae:	ea4f 0232 	mov.w	r2, r2, rrx
  418ab2:	1ab6      	subs	r6, r6, r2
  418ab4:	eb65 0503 	sbc.w	r5, r5, r3
  418ab8:	085b      	lsrs	r3, r3, #1
  418aba:	ea4f 0232 	mov.w	r2, r2, rrx
  418abe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  418ac2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  418ac6:	ebb6 0e02 	subs.w	lr, r6, r2
  418aca:	eb75 0e03 	sbcs.w	lr, r5, r3
  418ace:	bf22      	ittt	cs
  418ad0:	1ab6      	subcs	r6, r6, r2
  418ad2:	4675      	movcs	r5, lr
  418ad4:	ea40 000c 	orrcs.w	r0, r0, ip
  418ad8:	085b      	lsrs	r3, r3, #1
  418ada:	ea4f 0232 	mov.w	r2, r2, rrx
  418ade:	ebb6 0e02 	subs.w	lr, r6, r2
  418ae2:	eb75 0e03 	sbcs.w	lr, r5, r3
  418ae6:	bf22      	ittt	cs
  418ae8:	1ab6      	subcs	r6, r6, r2
  418aea:	4675      	movcs	r5, lr
  418aec:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  418af0:	085b      	lsrs	r3, r3, #1
  418af2:	ea4f 0232 	mov.w	r2, r2, rrx
  418af6:	ebb6 0e02 	subs.w	lr, r6, r2
  418afa:	eb75 0e03 	sbcs.w	lr, r5, r3
  418afe:	bf22      	ittt	cs
  418b00:	1ab6      	subcs	r6, r6, r2
  418b02:	4675      	movcs	r5, lr
  418b04:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  418b08:	085b      	lsrs	r3, r3, #1
  418b0a:	ea4f 0232 	mov.w	r2, r2, rrx
  418b0e:	ebb6 0e02 	subs.w	lr, r6, r2
  418b12:	eb75 0e03 	sbcs.w	lr, r5, r3
  418b16:	bf22      	ittt	cs
  418b18:	1ab6      	subcs	r6, r6, r2
  418b1a:	4675      	movcs	r5, lr
  418b1c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  418b20:	ea55 0e06 	orrs.w	lr, r5, r6
  418b24:	d018      	beq.n	418b58 <__aeabi_ddiv+0x114>
  418b26:	ea4f 1505 	mov.w	r5, r5, lsl #4
  418b2a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  418b2e:	ea4f 1606 	mov.w	r6, r6, lsl #4
  418b32:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  418b36:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  418b3a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  418b3e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  418b42:	d1c0      	bne.n	418ac6 <__aeabi_ddiv+0x82>
  418b44:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  418b48:	d10b      	bne.n	418b62 <__aeabi_ddiv+0x11e>
  418b4a:	ea41 0100 	orr.w	r1, r1, r0
  418b4e:	f04f 0000 	mov.w	r0, #0
  418b52:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  418b56:	e7b6      	b.n	418ac6 <__aeabi_ddiv+0x82>
  418b58:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  418b5c:	bf04      	itt	eq
  418b5e:	4301      	orreq	r1, r0
  418b60:	2000      	moveq	r0, #0
  418b62:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  418b66:	bf88      	it	hi
  418b68:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  418b6c:	f63f aeaf 	bhi.w	4188ce <__aeabi_dmul+0xde>
  418b70:	ebb5 0c03 	subs.w	ip, r5, r3
  418b74:	bf04      	itt	eq
  418b76:	ebb6 0c02 	subseq.w	ip, r6, r2
  418b7a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  418b7e:	f150 0000 	adcs.w	r0, r0, #0
  418b82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  418b86:	bd70      	pop	{r4, r5, r6, pc}
  418b88:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  418b8c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  418b90:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  418b94:	bfc2      	ittt	gt
  418b96:	ebd4 050c 	rsbsgt	r5, r4, ip
  418b9a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  418b9e:	bd70      	popgt	{r4, r5, r6, pc}
  418ba0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  418ba4:	f04f 0e00 	mov.w	lr, #0
  418ba8:	3c01      	subs	r4, #1
  418baa:	e690      	b.n	4188ce <__aeabi_dmul+0xde>
  418bac:	ea45 0e06 	orr.w	lr, r5, r6
  418bb0:	e68d      	b.n	4188ce <__aeabi_dmul+0xde>
  418bb2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  418bb6:	ea94 0f0c 	teq	r4, ip
  418bba:	bf08      	it	eq
  418bbc:	ea95 0f0c 	teqeq	r5, ip
  418bc0:	f43f af3b 	beq.w	418a3a <__aeabi_dmul+0x24a>
  418bc4:	ea94 0f0c 	teq	r4, ip
  418bc8:	d10a      	bne.n	418be0 <__aeabi_ddiv+0x19c>
  418bca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  418bce:	f47f af34 	bne.w	418a3a <__aeabi_dmul+0x24a>
  418bd2:	ea95 0f0c 	teq	r5, ip
  418bd6:	f47f af25 	bne.w	418a24 <__aeabi_dmul+0x234>
  418bda:	4610      	mov	r0, r2
  418bdc:	4619      	mov	r1, r3
  418bde:	e72c      	b.n	418a3a <__aeabi_dmul+0x24a>
  418be0:	ea95 0f0c 	teq	r5, ip
  418be4:	d106      	bne.n	418bf4 <__aeabi_ddiv+0x1b0>
  418be6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  418bea:	f43f aefd 	beq.w	4189e8 <__aeabi_dmul+0x1f8>
  418bee:	4610      	mov	r0, r2
  418bf0:	4619      	mov	r1, r3
  418bf2:	e722      	b.n	418a3a <__aeabi_dmul+0x24a>
  418bf4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  418bf8:	bf18      	it	ne
  418bfa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  418bfe:	f47f aec5 	bne.w	41898c <__aeabi_dmul+0x19c>
  418c02:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  418c06:	f47f af0d 	bne.w	418a24 <__aeabi_dmul+0x234>
  418c0a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  418c0e:	f47f aeeb 	bne.w	4189e8 <__aeabi_dmul+0x1f8>
  418c12:	e712      	b.n	418a3a <__aeabi_dmul+0x24a>

00418c14 <__gedf2>:
  418c14:	f04f 3cff 	mov.w	ip, #4294967295
  418c18:	e006      	b.n	418c28 <__cmpdf2+0x4>
  418c1a:	bf00      	nop

00418c1c <__ledf2>:
  418c1c:	f04f 0c01 	mov.w	ip, #1
  418c20:	e002      	b.n	418c28 <__cmpdf2+0x4>
  418c22:	bf00      	nop

00418c24 <__cmpdf2>:
  418c24:	f04f 0c01 	mov.w	ip, #1
  418c28:	f84d cd04 	str.w	ip, [sp, #-4]!
  418c2c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  418c30:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418c34:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  418c38:	bf18      	it	ne
  418c3a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  418c3e:	d01b      	beq.n	418c78 <__cmpdf2+0x54>
  418c40:	b001      	add	sp, #4
  418c42:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  418c46:	bf0c      	ite	eq
  418c48:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  418c4c:	ea91 0f03 	teqne	r1, r3
  418c50:	bf02      	ittt	eq
  418c52:	ea90 0f02 	teqeq	r0, r2
  418c56:	2000      	moveq	r0, #0
  418c58:	4770      	bxeq	lr
  418c5a:	f110 0f00 	cmn.w	r0, #0
  418c5e:	ea91 0f03 	teq	r1, r3
  418c62:	bf58      	it	pl
  418c64:	4299      	cmppl	r1, r3
  418c66:	bf08      	it	eq
  418c68:	4290      	cmpeq	r0, r2
  418c6a:	bf2c      	ite	cs
  418c6c:	17d8      	asrcs	r0, r3, #31
  418c6e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  418c72:	f040 0001 	orr.w	r0, r0, #1
  418c76:	4770      	bx	lr
  418c78:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  418c7c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418c80:	d102      	bne.n	418c88 <__cmpdf2+0x64>
  418c82:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  418c86:	d107      	bne.n	418c98 <__cmpdf2+0x74>
  418c88:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  418c8c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418c90:	d1d6      	bne.n	418c40 <__cmpdf2+0x1c>
  418c92:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  418c96:	d0d3      	beq.n	418c40 <__cmpdf2+0x1c>
  418c98:	f85d 0b04 	ldr.w	r0, [sp], #4
  418c9c:	4770      	bx	lr
  418c9e:	bf00      	nop

00418ca0 <__aeabi_cdrcmple>:
  418ca0:	4684      	mov	ip, r0
  418ca2:	4610      	mov	r0, r2
  418ca4:	4662      	mov	r2, ip
  418ca6:	468c      	mov	ip, r1
  418ca8:	4619      	mov	r1, r3
  418caa:	4663      	mov	r3, ip
  418cac:	e000      	b.n	418cb0 <__aeabi_cdcmpeq>
  418cae:	bf00      	nop

00418cb0 <__aeabi_cdcmpeq>:
  418cb0:	b501      	push	{r0, lr}
  418cb2:	f7ff ffb7 	bl	418c24 <__cmpdf2>
  418cb6:	2800      	cmp	r0, #0
  418cb8:	bf48      	it	mi
  418cba:	f110 0f00 	cmnmi.w	r0, #0
  418cbe:	bd01      	pop	{r0, pc}

00418cc0 <__aeabi_dcmpeq>:
  418cc0:	f84d ed08 	str.w	lr, [sp, #-8]!
  418cc4:	f7ff fff4 	bl	418cb0 <__aeabi_cdcmpeq>
  418cc8:	bf0c      	ite	eq
  418cca:	2001      	moveq	r0, #1
  418ccc:	2000      	movne	r0, #0
  418cce:	f85d fb08 	ldr.w	pc, [sp], #8
  418cd2:	bf00      	nop

00418cd4 <__aeabi_dcmplt>:
  418cd4:	f84d ed08 	str.w	lr, [sp, #-8]!
  418cd8:	f7ff ffea 	bl	418cb0 <__aeabi_cdcmpeq>
  418cdc:	bf34      	ite	cc
  418cde:	2001      	movcc	r0, #1
  418ce0:	2000      	movcs	r0, #0
  418ce2:	f85d fb08 	ldr.w	pc, [sp], #8
  418ce6:	bf00      	nop

00418ce8 <__aeabi_dcmple>:
  418ce8:	f84d ed08 	str.w	lr, [sp, #-8]!
  418cec:	f7ff ffe0 	bl	418cb0 <__aeabi_cdcmpeq>
  418cf0:	bf94      	ite	ls
  418cf2:	2001      	movls	r0, #1
  418cf4:	2000      	movhi	r0, #0
  418cf6:	f85d fb08 	ldr.w	pc, [sp], #8
  418cfa:	bf00      	nop

00418cfc <__aeabi_dcmpge>:
  418cfc:	f84d ed08 	str.w	lr, [sp, #-8]!
  418d00:	f7ff ffce 	bl	418ca0 <__aeabi_cdrcmple>
  418d04:	bf94      	ite	ls
  418d06:	2001      	movls	r0, #1
  418d08:	2000      	movhi	r0, #0
  418d0a:	f85d fb08 	ldr.w	pc, [sp], #8
  418d0e:	bf00      	nop

00418d10 <__aeabi_dcmpgt>:
  418d10:	f84d ed08 	str.w	lr, [sp, #-8]!
  418d14:	f7ff ffc4 	bl	418ca0 <__aeabi_cdrcmple>
  418d18:	bf34      	ite	cc
  418d1a:	2001      	movcc	r0, #1
  418d1c:	2000      	movcs	r0, #0
  418d1e:	f85d fb08 	ldr.w	pc, [sp], #8
  418d22:	bf00      	nop

00418d24 <__aeabi_dcmpun>:
  418d24:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  418d28:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418d2c:	d102      	bne.n	418d34 <__aeabi_dcmpun+0x10>
  418d2e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  418d32:	d10a      	bne.n	418d4a <__aeabi_dcmpun+0x26>
  418d34:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  418d38:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  418d3c:	d102      	bne.n	418d44 <__aeabi_dcmpun+0x20>
  418d3e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  418d42:	d102      	bne.n	418d4a <__aeabi_dcmpun+0x26>
  418d44:	f04f 0000 	mov.w	r0, #0
  418d48:	4770      	bx	lr
  418d4a:	f04f 0001 	mov.w	r0, #1
  418d4e:	4770      	bx	lr

00418d50 <__aeabi_d2iz>:
  418d50:	ea4f 0241 	mov.w	r2, r1, lsl #1
  418d54:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  418d58:	d215      	bcs.n	418d86 <__aeabi_d2iz+0x36>
  418d5a:	d511      	bpl.n	418d80 <__aeabi_d2iz+0x30>
  418d5c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  418d60:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  418d64:	d912      	bls.n	418d8c <__aeabi_d2iz+0x3c>
  418d66:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  418d6a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  418d6e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  418d72:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  418d76:	fa23 f002 	lsr.w	r0, r3, r2
  418d7a:	bf18      	it	ne
  418d7c:	4240      	negne	r0, r0
  418d7e:	4770      	bx	lr
  418d80:	f04f 0000 	mov.w	r0, #0
  418d84:	4770      	bx	lr
  418d86:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  418d8a:	d105      	bne.n	418d98 <__aeabi_d2iz+0x48>
  418d8c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  418d90:	bf08      	it	eq
  418d92:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  418d96:	4770      	bx	lr
  418d98:	f04f 0000 	mov.w	r0, #0
  418d9c:	4770      	bx	lr
  418d9e:	bf00      	nop

00418da0 <__aeabi_d2f>:
  418da0:	ea4f 0241 	mov.w	r2, r1, lsl #1
  418da4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  418da8:	bf24      	itt	cs
  418daa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  418dae:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  418db2:	d90d      	bls.n	418dd0 <__aeabi_d2f+0x30>
  418db4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  418db8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  418dbc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  418dc0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  418dc4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  418dc8:	bf08      	it	eq
  418dca:	f020 0001 	biceq.w	r0, r0, #1
  418dce:	4770      	bx	lr
  418dd0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  418dd4:	d121      	bne.n	418e1a <__aeabi_d2f+0x7a>
  418dd6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  418dda:	bfbc      	itt	lt
  418ddc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  418de0:	4770      	bxlt	lr
  418de2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  418de6:	ea4f 5252 	mov.w	r2, r2, lsr #21
  418dea:	f1c2 0218 	rsb	r2, r2, #24
  418dee:	f1c2 0c20 	rsb	ip, r2, #32
  418df2:	fa10 f30c 	lsls.w	r3, r0, ip
  418df6:	fa20 f002 	lsr.w	r0, r0, r2
  418dfa:	bf18      	it	ne
  418dfc:	f040 0001 	orrne.w	r0, r0, #1
  418e00:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  418e04:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  418e08:	fa03 fc0c 	lsl.w	ip, r3, ip
  418e0c:	ea40 000c 	orr.w	r0, r0, ip
  418e10:	fa23 f302 	lsr.w	r3, r3, r2
  418e14:	ea4f 0343 	mov.w	r3, r3, lsl #1
  418e18:	e7cc      	b.n	418db4 <__aeabi_d2f+0x14>
  418e1a:	ea7f 5362 	mvns.w	r3, r2, asr #21
  418e1e:	d107      	bne.n	418e30 <__aeabi_d2f+0x90>
  418e20:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  418e24:	bf1e      	ittt	ne
  418e26:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  418e2a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  418e2e:	4770      	bxne	lr
  418e30:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  418e34:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  418e38:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  418e3c:	4770      	bx	lr
  418e3e:	bf00      	nop

00418e40 <__aeabi_frsub>:
  418e40:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  418e44:	e002      	b.n	418e4c <__addsf3>
  418e46:	bf00      	nop

00418e48 <__aeabi_fsub>:
  418e48:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00418e4c <__addsf3>:
  418e4c:	0042      	lsls	r2, r0, #1
  418e4e:	bf1f      	itttt	ne
  418e50:	ea5f 0341 	movsne.w	r3, r1, lsl #1
  418e54:	ea92 0f03 	teqne	r2, r3
  418e58:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
  418e5c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  418e60:	d06a      	beq.n	418f38 <__addsf3+0xec>
  418e62:	ea4f 6212 	mov.w	r2, r2, lsr #24
  418e66:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
  418e6a:	bfc1      	itttt	gt
  418e6c:	18d2      	addgt	r2, r2, r3
  418e6e:	4041      	eorgt	r1, r0
  418e70:	4048      	eorgt	r0, r1
  418e72:	4041      	eorgt	r1, r0
  418e74:	bfb8      	it	lt
  418e76:	425b      	neglt	r3, r3
  418e78:	2b19      	cmp	r3, #25
  418e7a:	bf88      	it	hi
  418e7c:	4770      	bxhi	lr
  418e7e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  418e82:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  418e86:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  418e8a:	bf18      	it	ne
  418e8c:	4240      	negne	r0, r0
  418e8e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  418e92:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  418e96:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  418e9a:	bf18      	it	ne
  418e9c:	4249      	negne	r1, r1
  418e9e:	ea92 0f03 	teq	r2, r3
  418ea2:	d03f      	beq.n	418f24 <__addsf3+0xd8>
  418ea4:	f1a2 0201 	sub.w	r2, r2, #1
  418ea8:	fa41 fc03 	asr.w	ip, r1, r3
  418eac:	eb10 000c 	adds.w	r0, r0, ip
  418eb0:	f1c3 0320 	rsb	r3, r3, #32
  418eb4:	fa01 f103 	lsl.w	r1, r1, r3
  418eb8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  418ebc:	d502      	bpl.n	418ec4 <__addsf3+0x78>
  418ebe:	4249      	negs	r1, r1
  418ec0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
  418ec4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
  418ec8:	d313      	bcc.n	418ef2 <__addsf3+0xa6>
  418eca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  418ece:	d306      	bcc.n	418ede <__addsf3+0x92>
  418ed0:	0840      	lsrs	r0, r0, #1
  418ed2:	ea4f 0131 	mov.w	r1, r1, rrx
  418ed6:	f102 0201 	add.w	r2, r2, #1
  418eda:	2afe      	cmp	r2, #254	; 0xfe
  418edc:	d251      	bcs.n	418f82 <__addsf3+0x136>
  418ede:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
  418ee2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  418ee6:	bf08      	it	eq
  418ee8:	f020 0001 	biceq.w	r0, r0, #1
  418eec:	ea40 0003 	orr.w	r0, r0, r3
  418ef0:	4770      	bx	lr
  418ef2:	0049      	lsls	r1, r1, #1
  418ef4:	eb40 0000 	adc.w	r0, r0, r0
  418ef8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
  418efc:	f1a2 0201 	sub.w	r2, r2, #1
  418f00:	d1ed      	bne.n	418ede <__addsf3+0x92>
  418f02:	fab0 fc80 	clz	ip, r0
  418f06:	f1ac 0c08 	sub.w	ip, ip, #8
  418f0a:	ebb2 020c 	subs.w	r2, r2, ip
  418f0e:	fa00 f00c 	lsl.w	r0, r0, ip
  418f12:	bfaa      	itet	ge
  418f14:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
  418f18:	4252      	neglt	r2, r2
  418f1a:	4318      	orrge	r0, r3
  418f1c:	bfbc      	itt	lt
  418f1e:	40d0      	lsrlt	r0, r2
  418f20:	4318      	orrlt	r0, r3
  418f22:	4770      	bx	lr
  418f24:	f092 0f00 	teq	r2, #0
  418f28:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
  418f2c:	bf06      	itte	eq
  418f2e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
  418f32:	3201      	addeq	r2, #1
  418f34:	3b01      	subne	r3, #1
  418f36:	e7b5      	b.n	418ea4 <__addsf3+0x58>
  418f38:	ea4f 0341 	mov.w	r3, r1, lsl #1
  418f3c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  418f40:	bf18      	it	ne
  418f42:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  418f46:	d021      	beq.n	418f8c <__addsf3+0x140>
  418f48:	ea92 0f03 	teq	r2, r3
  418f4c:	d004      	beq.n	418f58 <__addsf3+0x10c>
  418f4e:	f092 0f00 	teq	r2, #0
  418f52:	bf08      	it	eq
  418f54:	4608      	moveq	r0, r1
  418f56:	4770      	bx	lr
  418f58:	ea90 0f01 	teq	r0, r1
  418f5c:	bf1c      	itt	ne
  418f5e:	2000      	movne	r0, #0
  418f60:	4770      	bxne	lr
  418f62:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
  418f66:	d104      	bne.n	418f72 <__addsf3+0x126>
  418f68:	0040      	lsls	r0, r0, #1
  418f6a:	bf28      	it	cs
  418f6c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
  418f70:	4770      	bx	lr
  418f72:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
  418f76:	bf3c      	itt	cc
  418f78:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
  418f7c:	4770      	bxcc	lr
  418f7e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  418f82:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
  418f86:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  418f8a:	4770      	bx	lr
  418f8c:	ea7f 6222 	mvns.w	r2, r2, asr #24
  418f90:	bf16      	itet	ne
  418f92:	4608      	movne	r0, r1
  418f94:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
  418f98:	4601      	movne	r1, r0
  418f9a:	0242      	lsls	r2, r0, #9
  418f9c:	bf06      	itte	eq
  418f9e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
  418fa2:	ea90 0f01 	teqeq	r0, r1
  418fa6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
  418faa:	4770      	bx	lr

00418fac <__aeabi_ui2f>:
  418fac:	f04f 0300 	mov.w	r3, #0
  418fb0:	e004      	b.n	418fbc <__aeabi_i2f+0x8>
  418fb2:	bf00      	nop

00418fb4 <__aeabi_i2f>:
  418fb4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
  418fb8:	bf48      	it	mi
  418fba:	4240      	negmi	r0, r0
  418fbc:	ea5f 0c00 	movs.w	ip, r0
  418fc0:	bf08      	it	eq
  418fc2:	4770      	bxeq	lr
  418fc4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
  418fc8:	4601      	mov	r1, r0
  418fca:	f04f 0000 	mov.w	r0, #0
  418fce:	e01c      	b.n	41900a <__aeabi_l2f+0x2a>

00418fd0 <__aeabi_ul2f>:
  418fd0:	ea50 0201 	orrs.w	r2, r0, r1
  418fd4:	bf08      	it	eq
  418fd6:	4770      	bxeq	lr
  418fd8:	f04f 0300 	mov.w	r3, #0
  418fdc:	e00a      	b.n	418ff4 <__aeabi_l2f+0x14>
  418fde:	bf00      	nop

00418fe0 <__aeabi_l2f>:
  418fe0:	ea50 0201 	orrs.w	r2, r0, r1
  418fe4:	bf08      	it	eq
  418fe6:	4770      	bxeq	lr
  418fe8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
  418fec:	d502      	bpl.n	418ff4 <__aeabi_l2f+0x14>
  418fee:	4240      	negs	r0, r0
  418ff0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  418ff4:	ea5f 0c01 	movs.w	ip, r1
  418ff8:	bf02      	ittt	eq
  418ffa:	4684      	moveq	ip, r0
  418ffc:	4601      	moveq	r1, r0
  418ffe:	2000      	moveq	r0, #0
  419000:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
  419004:	bf08      	it	eq
  419006:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
  41900a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
  41900e:	fabc f28c 	clz	r2, ip
  419012:	3a08      	subs	r2, #8
  419014:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
  419018:	db10      	blt.n	41903c <__aeabi_l2f+0x5c>
  41901a:	fa01 fc02 	lsl.w	ip, r1, r2
  41901e:	4463      	add	r3, ip
  419020:	fa00 fc02 	lsl.w	ip, r0, r2
  419024:	f1c2 0220 	rsb	r2, r2, #32
  419028:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  41902c:	fa20 f202 	lsr.w	r2, r0, r2
  419030:	eb43 0002 	adc.w	r0, r3, r2
  419034:	bf08      	it	eq
  419036:	f020 0001 	biceq.w	r0, r0, #1
  41903a:	4770      	bx	lr
  41903c:	f102 0220 	add.w	r2, r2, #32
  419040:	fa01 fc02 	lsl.w	ip, r1, r2
  419044:	f1c2 0220 	rsb	r2, r2, #32
  419048:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
  41904c:	fa21 f202 	lsr.w	r2, r1, r2
  419050:	eb43 0002 	adc.w	r0, r3, r2
  419054:	bf08      	it	eq
  419056:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  41905a:	4770      	bx	lr

0041905c <__aeabi_ldivmod>:
  41905c:	b97b      	cbnz	r3, 41907e <__aeabi_ldivmod+0x22>
  41905e:	b972      	cbnz	r2, 41907e <__aeabi_ldivmod+0x22>
  419060:	2900      	cmp	r1, #0
  419062:	bfbe      	ittt	lt
  419064:	2000      	movlt	r0, #0
  419066:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
  41906a:	e006      	blt.n	41907a <__aeabi_ldivmod+0x1e>
  41906c:	bf08      	it	eq
  41906e:	2800      	cmpeq	r0, #0
  419070:	bf1c      	itt	ne
  419072:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
  419076:	f04f 30ff 	movne.w	r0, #4294967295
  41907a:	f000 b9ff 	b.w	41947c <__aeabi_idiv0>
  41907e:	f1ad 0c08 	sub.w	ip, sp, #8
  419082:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  419086:	2900      	cmp	r1, #0
  419088:	db09      	blt.n	41909e <__aeabi_ldivmod+0x42>
  41908a:	2b00      	cmp	r3, #0
  41908c:	db1a      	blt.n	4190c4 <__aeabi_ldivmod+0x68>
  41908e:	f000 f887 	bl	4191a0 <__udivmoddi4>
  419092:	f8dd e004 	ldr.w	lr, [sp, #4]
  419096:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  41909a:	b004      	add	sp, #16
  41909c:	4770      	bx	lr
  41909e:	4240      	negs	r0, r0
  4190a0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4190a4:	2b00      	cmp	r3, #0
  4190a6:	db1b      	blt.n	4190e0 <__aeabi_ldivmod+0x84>
  4190a8:	f000 f87a 	bl	4191a0 <__udivmoddi4>
  4190ac:	f8dd e004 	ldr.w	lr, [sp, #4]
  4190b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  4190b4:	b004      	add	sp, #16
  4190b6:	4240      	negs	r0, r0
  4190b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4190bc:	4252      	negs	r2, r2
  4190be:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4190c2:	4770      	bx	lr
  4190c4:	4252      	negs	r2, r2
  4190c6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4190ca:	f000 f869 	bl	4191a0 <__udivmoddi4>
  4190ce:	f8dd e004 	ldr.w	lr, [sp, #4]
  4190d2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  4190d6:	b004      	add	sp, #16
  4190d8:	4240      	negs	r0, r0
  4190da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4190de:	4770      	bx	lr
  4190e0:	4252      	negs	r2, r2
  4190e2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4190e6:	f000 f85b 	bl	4191a0 <__udivmoddi4>
  4190ea:	f8dd e004 	ldr.w	lr, [sp, #4]
  4190ee:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  4190f2:	b004      	add	sp, #16
  4190f4:	4252      	negs	r2, r2
  4190f6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4190fa:	4770      	bx	lr

004190fc <__aeabi_uldivmod>:
  4190fc:	b953      	cbnz	r3, 419114 <__aeabi_uldivmod+0x18>
  4190fe:	b94a      	cbnz	r2, 419114 <__aeabi_uldivmod+0x18>
  419100:	2900      	cmp	r1, #0
  419102:	bf08      	it	eq
  419104:	2800      	cmpeq	r0, #0
  419106:	bf1c      	itt	ne
  419108:	f04f 31ff 	movne.w	r1, #4294967295
  41910c:	f04f 30ff 	movne.w	r0, #4294967295
  419110:	f000 b9b4 	b.w	41947c <__aeabi_idiv0>
  419114:	f1ad 0c08 	sub.w	ip, sp, #8
  419118:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  41911c:	f000 f840 	bl	4191a0 <__udivmoddi4>
  419120:	f8dd e004 	ldr.w	lr, [sp, #4]
  419124:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  419128:	b004      	add	sp, #16
  41912a:	4770      	bx	lr

0041912c <__aeabi_f2lz>:
  41912c:	b510      	push	{r4, lr}
  41912e:	2100      	movs	r1, #0
  419130:	4604      	mov	r4, r0
  419132:	f000 fa13 	bl	41955c <__aeabi_fcmplt>
  419136:	b920      	cbnz	r0, 419142 <__aeabi_f2lz+0x16>
  419138:	4620      	mov	r0, r4
  41913a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  41913e:	f000 b809 	b.w	419154 <__aeabi_f2ulz>
  419142:	f104 4000 	add.w	r0, r4, #2147483648	; 0x80000000
  419146:	f000 f805 	bl	419154 <__aeabi_f2ulz>
  41914a:	4240      	negs	r0, r0
  41914c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  419150:	bd10      	pop	{r4, pc}
  419152:	bf00      	nop

00419154 <__aeabi_f2ulz>:
  419154:	b5d0      	push	{r4, r6, r7, lr}
  419156:	f7ff faf7 	bl	418748 <__aeabi_f2d>
  41915a:	2200      	movs	r2, #0
  41915c:	4b0e      	ldr	r3, [pc, #56]	; (419198 <__aeabi_f2ulz+0x44>)
  41915e:	4606      	mov	r6, r0
  419160:	460f      	mov	r7, r1
  419162:	f7ff fb45 	bl	4187f0 <__aeabi_dmul>
  419166:	f000 f98b 	bl	419480 <__aeabi_d2uiz>
  41916a:	4604      	mov	r4, r0
  41916c:	f7ff faca 	bl	418704 <__aeabi_ui2d>
  419170:	2200      	movs	r2, #0
  419172:	4b0a      	ldr	r3, [pc, #40]	; (41919c <__aeabi_f2ulz+0x48>)
  419174:	f7ff fb3c 	bl	4187f0 <__aeabi_dmul>
  419178:	4602      	mov	r2, r0
  41917a:	460b      	mov	r3, r1
  41917c:	4630      	mov	r0, r6
  41917e:	4639      	mov	r1, r7
  419180:	f7ff f982 	bl	418488 <__aeabi_dsub>
  419184:	f000 f97c 	bl	419480 <__aeabi_d2uiz>
  419188:	4623      	mov	r3, r4
  41918a:	2200      	movs	r2, #0
  41918c:	ea42 0200 	orr.w	r2, r2, r0
  419190:	4610      	mov	r0, r2
  419192:	4619      	mov	r1, r3
  419194:	bdd0      	pop	{r4, r6, r7, pc}
  419196:	bf00      	nop
  419198:	3df00000 	.word	0x3df00000
  41919c:	41f00000 	.word	0x41f00000

004191a0 <__udivmoddi4>:
  4191a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4191a4:	468c      	mov	ip, r1
  4191a6:	460d      	mov	r5, r1
  4191a8:	4604      	mov	r4, r0
  4191aa:	9e08      	ldr	r6, [sp, #32]
  4191ac:	2b00      	cmp	r3, #0
  4191ae:	d151      	bne.n	419254 <__udivmoddi4+0xb4>
  4191b0:	428a      	cmp	r2, r1
  4191b2:	4617      	mov	r7, r2
  4191b4:	d96d      	bls.n	419292 <__udivmoddi4+0xf2>
  4191b6:	fab2 fe82 	clz	lr, r2
  4191ba:	f1be 0f00 	cmp.w	lr, #0
  4191be:	d00b      	beq.n	4191d8 <__udivmoddi4+0x38>
  4191c0:	f1ce 0c20 	rsb	ip, lr, #32
  4191c4:	fa01 f50e 	lsl.w	r5, r1, lr
  4191c8:	fa20 fc0c 	lsr.w	ip, r0, ip
  4191cc:	fa02 f70e 	lsl.w	r7, r2, lr
  4191d0:	ea4c 0c05 	orr.w	ip, ip, r5
  4191d4:	fa00 f40e 	lsl.w	r4, r0, lr
  4191d8:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  4191dc:	0c25      	lsrs	r5, r4, #16
  4191de:	fbbc f8fa 	udiv	r8, ip, sl
  4191e2:	fa1f f987 	uxth.w	r9, r7
  4191e6:	fb0a cc18 	mls	ip, sl, r8, ip
  4191ea:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  4191ee:	fb08 f309 	mul.w	r3, r8, r9
  4191f2:	42ab      	cmp	r3, r5
  4191f4:	d90a      	bls.n	41920c <__udivmoddi4+0x6c>
  4191f6:	19ed      	adds	r5, r5, r7
  4191f8:	f108 32ff 	add.w	r2, r8, #4294967295
  4191fc:	f080 8123 	bcs.w	419446 <__udivmoddi4+0x2a6>
  419200:	42ab      	cmp	r3, r5
  419202:	f240 8120 	bls.w	419446 <__udivmoddi4+0x2a6>
  419206:	f1a8 0802 	sub.w	r8, r8, #2
  41920a:	443d      	add	r5, r7
  41920c:	1aed      	subs	r5, r5, r3
  41920e:	b2a4      	uxth	r4, r4
  419210:	fbb5 f0fa 	udiv	r0, r5, sl
  419214:	fb0a 5510 	mls	r5, sl, r0, r5
  419218:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  41921c:	fb00 f909 	mul.w	r9, r0, r9
  419220:	45a1      	cmp	r9, r4
  419222:	d909      	bls.n	419238 <__udivmoddi4+0x98>
  419224:	19e4      	adds	r4, r4, r7
  419226:	f100 33ff 	add.w	r3, r0, #4294967295
  41922a:	f080 810a 	bcs.w	419442 <__udivmoddi4+0x2a2>
  41922e:	45a1      	cmp	r9, r4
  419230:	f240 8107 	bls.w	419442 <__udivmoddi4+0x2a2>
  419234:	3802      	subs	r0, #2
  419236:	443c      	add	r4, r7
  419238:	eba4 0409 	sub.w	r4, r4, r9
  41923c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  419240:	2100      	movs	r1, #0
  419242:	2e00      	cmp	r6, #0
  419244:	d061      	beq.n	41930a <__udivmoddi4+0x16a>
  419246:	fa24 f40e 	lsr.w	r4, r4, lr
  41924a:	2300      	movs	r3, #0
  41924c:	6034      	str	r4, [r6, #0]
  41924e:	6073      	str	r3, [r6, #4]
  419250:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  419254:	428b      	cmp	r3, r1
  419256:	d907      	bls.n	419268 <__udivmoddi4+0xc8>
  419258:	2e00      	cmp	r6, #0
  41925a:	d054      	beq.n	419306 <__udivmoddi4+0x166>
  41925c:	2100      	movs	r1, #0
  41925e:	e886 0021 	stmia.w	r6, {r0, r5}
  419262:	4608      	mov	r0, r1
  419264:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  419268:	fab3 f183 	clz	r1, r3
  41926c:	2900      	cmp	r1, #0
  41926e:	f040 808e 	bne.w	41938e <__udivmoddi4+0x1ee>
  419272:	42ab      	cmp	r3, r5
  419274:	d302      	bcc.n	41927c <__udivmoddi4+0xdc>
  419276:	4282      	cmp	r2, r0
  419278:	f200 80fa 	bhi.w	419470 <__udivmoddi4+0x2d0>
  41927c:	1a84      	subs	r4, r0, r2
  41927e:	eb65 0503 	sbc.w	r5, r5, r3
  419282:	2001      	movs	r0, #1
  419284:	46ac      	mov	ip, r5
  419286:	2e00      	cmp	r6, #0
  419288:	d03f      	beq.n	41930a <__udivmoddi4+0x16a>
  41928a:	e886 1010 	stmia.w	r6, {r4, ip}
  41928e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  419292:	b912      	cbnz	r2, 41929a <__udivmoddi4+0xfa>
  419294:	2701      	movs	r7, #1
  419296:	fbb7 f7f2 	udiv	r7, r7, r2
  41929a:	fab7 fe87 	clz	lr, r7
  41929e:	f1be 0f00 	cmp.w	lr, #0
  4192a2:	d134      	bne.n	41930e <__udivmoddi4+0x16e>
  4192a4:	1beb      	subs	r3, r5, r7
  4192a6:	0c3a      	lsrs	r2, r7, #16
  4192a8:	fa1f fc87 	uxth.w	ip, r7
  4192ac:	2101      	movs	r1, #1
  4192ae:	fbb3 f8f2 	udiv	r8, r3, r2
  4192b2:	0c25      	lsrs	r5, r4, #16
  4192b4:	fb02 3318 	mls	r3, r2, r8, r3
  4192b8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  4192bc:	fb0c f308 	mul.w	r3, ip, r8
  4192c0:	42ab      	cmp	r3, r5
  4192c2:	d907      	bls.n	4192d4 <__udivmoddi4+0x134>
  4192c4:	19ed      	adds	r5, r5, r7
  4192c6:	f108 30ff 	add.w	r0, r8, #4294967295
  4192ca:	d202      	bcs.n	4192d2 <__udivmoddi4+0x132>
  4192cc:	42ab      	cmp	r3, r5
  4192ce:	f200 80d1 	bhi.w	419474 <__udivmoddi4+0x2d4>
  4192d2:	4680      	mov	r8, r0
  4192d4:	1aed      	subs	r5, r5, r3
  4192d6:	b2a3      	uxth	r3, r4
  4192d8:	fbb5 f0f2 	udiv	r0, r5, r2
  4192dc:	fb02 5510 	mls	r5, r2, r0, r5
  4192e0:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  4192e4:	fb0c fc00 	mul.w	ip, ip, r0
  4192e8:	45a4      	cmp	ip, r4
  4192ea:	d907      	bls.n	4192fc <__udivmoddi4+0x15c>
  4192ec:	19e4      	adds	r4, r4, r7
  4192ee:	f100 33ff 	add.w	r3, r0, #4294967295
  4192f2:	d202      	bcs.n	4192fa <__udivmoddi4+0x15a>
  4192f4:	45a4      	cmp	ip, r4
  4192f6:	f200 80b8 	bhi.w	41946a <__udivmoddi4+0x2ca>
  4192fa:	4618      	mov	r0, r3
  4192fc:	eba4 040c 	sub.w	r4, r4, ip
  419300:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  419304:	e79d      	b.n	419242 <__udivmoddi4+0xa2>
  419306:	4631      	mov	r1, r6
  419308:	4630      	mov	r0, r6
  41930a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  41930e:	f1ce 0420 	rsb	r4, lr, #32
  419312:	fa05 f30e 	lsl.w	r3, r5, lr
  419316:	fa07 f70e 	lsl.w	r7, r7, lr
  41931a:	fa20 f804 	lsr.w	r8, r0, r4
  41931e:	0c3a      	lsrs	r2, r7, #16
  419320:	fa25 f404 	lsr.w	r4, r5, r4
  419324:	ea48 0803 	orr.w	r8, r8, r3
  419328:	fbb4 f1f2 	udiv	r1, r4, r2
  41932c:	ea4f 4518 	mov.w	r5, r8, lsr #16
  419330:	fb02 4411 	mls	r4, r2, r1, r4
  419334:	fa1f fc87 	uxth.w	ip, r7
  419338:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  41933c:	fb01 f30c 	mul.w	r3, r1, ip
  419340:	42ab      	cmp	r3, r5
  419342:	fa00 f40e 	lsl.w	r4, r0, lr
  419346:	d909      	bls.n	41935c <__udivmoddi4+0x1bc>
  419348:	19ed      	adds	r5, r5, r7
  41934a:	f101 30ff 	add.w	r0, r1, #4294967295
  41934e:	f080 808a 	bcs.w	419466 <__udivmoddi4+0x2c6>
  419352:	42ab      	cmp	r3, r5
  419354:	f240 8087 	bls.w	419466 <__udivmoddi4+0x2c6>
  419358:	3902      	subs	r1, #2
  41935a:	443d      	add	r5, r7
  41935c:	1aeb      	subs	r3, r5, r3
  41935e:	fa1f f588 	uxth.w	r5, r8
  419362:	fbb3 f0f2 	udiv	r0, r3, r2
  419366:	fb02 3310 	mls	r3, r2, r0, r3
  41936a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  41936e:	fb00 f30c 	mul.w	r3, r0, ip
  419372:	42ab      	cmp	r3, r5
  419374:	d907      	bls.n	419386 <__udivmoddi4+0x1e6>
  419376:	19ed      	adds	r5, r5, r7
  419378:	f100 38ff 	add.w	r8, r0, #4294967295
  41937c:	d26f      	bcs.n	41945e <__udivmoddi4+0x2be>
  41937e:	42ab      	cmp	r3, r5
  419380:	d96d      	bls.n	41945e <__udivmoddi4+0x2be>
  419382:	3802      	subs	r0, #2
  419384:	443d      	add	r5, r7
  419386:	1aeb      	subs	r3, r5, r3
  419388:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  41938c:	e78f      	b.n	4192ae <__udivmoddi4+0x10e>
  41938e:	f1c1 0720 	rsb	r7, r1, #32
  419392:	fa22 f807 	lsr.w	r8, r2, r7
  419396:	408b      	lsls	r3, r1
  419398:	fa05 f401 	lsl.w	r4, r5, r1
  41939c:	ea48 0303 	orr.w	r3, r8, r3
  4193a0:	fa20 fe07 	lsr.w	lr, r0, r7
  4193a4:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  4193a8:	40fd      	lsrs	r5, r7
  4193aa:	ea4e 0e04 	orr.w	lr, lr, r4
  4193ae:	fbb5 f9fc 	udiv	r9, r5, ip
  4193b2:	ea4f 441e 	mov.w	r4, lr, lsr #16
  4193b6:	fb0c 5519 	mls	r5, ip, r9, r5
  4193ba:	fa1f f883 	uxth.w	r8, r3
  4193be:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  4193c2:	fb09 f408 	mul.w	r4, r9, r8
  4193c6:	42ac      	cmp	r4, r5
  4193c8:	fa02 f201 	lsl.w	r2, r2, r1
  4193cc:	fa00 fa01 	lsl.w	sl, r0, r1
  4193d0:	d908      	bls.n	4193e4 <__udivmoddi4+0x244>
  4193d2:	18ed      	adds	r5, r5, r3
  4193d4:	f109 30ff 	add.w	r0, r9, #4294967295
  4193d8:	d243      	bcs.n	419462 <__udivmoddi4+0x2c2>
  4193da:	42ac      	cmp	r4, r5
  4193dc:	d941      	bls.n	419462 <__udivmoddi4+0x2c2>
  4193de:	f1a9 0902 	sub.w	r9, r9, #2
  4193e2:	441d      	add	r5, r3
  4193e4:	1b2d      	subs	r5, r5, r4
  4193e6:	fa1f fe8e 	uxth.w	lr, lr
  4193ea:	fbb5 f0fc 	udiv	r0, r5, ip
  4193ee:	fb0c 5510 	mls	r5, ip, r0, r5
  4193f2:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  4193f6:	fb00 f808 	mul.w	r8, r0, r8
  4193fa:	45a0      	cmp	r8, r4
  4193fc:	d907      	bls.n	41940e <__udivmoddi4+0x26e>
  4193fe:	18e4      	adds	r4, r4, r3
  419400:	f100 35ff 	add.w	r5, r0, #4294967295
  419404:	d229      	bcs.n	41945a <__udivmoddi4+0x2ba>
  419406:	45a0      	cmp	r8, r4
  419408:	d927      	bls.n	41945a <__udivmoddi4+0x2ba>
  41940a:	3802      	subs	r0, #2
  41940c:	441c      	add	r4, r3
  41940e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  419412:	eba4 0408 	sub.w	r4, r4, r8
  419416:	fba0 8902 	umull	r8, r9, r0, r2
  41941a:	454c      	cmp	r4, r9
  41941c:	46c6      	mov	lr, r8
  41941e:	464d      	mov	r5, r9
  419420:	d315      	bcc.n	41944e <__udivmoddi4+0x2ae>
  419422:	d012      	beq.n	41944a <__udivmoddi4+0x2aa>
  419424:	b156      	cbz	r6, 41943c <__udivmoddi4+0x29c>
  419426:	ebba 030e 	subs.w	r3, sl, lr
  41942a:	eb64 0405 	sbc.w	r4, r4, r5
  41942e:	fa04 f707 	lsl.w	r7, r4, r7
  419432:	40cb      	lsrs	r3, r1
  419434:	431f      	orrs	r7, r3
  419436:	40cc      	lsrs	r4, r1
  419438:	6037      	str	r7, [r6, #0]
  41943a:	6074      	str	r4, [r6, #4]
  41943c:	2100      	movs	r1, #0
  41943e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  419442:	4618      	mov	r0, r3
  419444:	e6f8      	b.n	419238 <__udivmoddi4+0x98>
  419446:	4690      	mov	r8, r2
  419448:	e6e0      	b.n	41920c <__udivmoddi4+0x6c>
  41944a:	45c2      	cmp	sl, r8
  41944c:	d2ea      	bcs.n	419424 <__udivmoddi4+0x284>
  41944e:	ebb8 0e02 	subs.w	lr, r8, r2
  419452:	eb69 0503 	sbc.w	r5, r9, r3
  419456:	3801      	subs	r0, #1
  419458:	e7e4      	b.n	419424 <__udivmoddi4+0x284>
  41945a:	4628      	mov	r0, r5
  41945c:	e7d7      	b.n	41940e <__udivmoddi4+0x26e>
  41945e:	4640      	mov	r0, r8
  419460:	e791      	b.n	419386 <__udivmoddi4+0x1e6>
  419462:	4681      	mov	r9, r0
  419464:	e7be      	b.n	4193e4 <__udivmoddi4+0x244>
  419466:	4601      	mov	r1, r0
  419468:	e778      	b.n	41935c <__udivmoddi4+0x1bc>
  41946a:	3802      	subs	r0, #2
  41946c:	443c      	add	r4, r7
  41946e:	e745      	b.n	4192fc <__udivmoddi4+0x15c>
  419470:	4608      	mov	r0, r1
  419472:	e708      	b.n	419286 <__udivmoddi4+0xe6>
  419474:	f1a8 0802 	sub.w	r8, r8, #2
  419478:	443d      	add	r5, r7
  41947a:	e72b      	b.n	4192d4 <__udivmoddi4+0x134>

0041947c <__aeabi_idiv0>:
  41947c:	4770      	bx	lr
  41947e:	bf00      	nop

00419480 <__aeabi_d2uiz>:
  419480:	004a      	lsls	r2, r1, #1
  419482:	d211      	bcs.n	4194a8 <__aeabi_d2uiz+0x28>
  419484:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  419488:	d211      	bcs.n	4194ae <__aeabi_d2uiz+0x2e>
  41948a:	d50d      	bpl.n	4194a8 <__aeabi_d2uiz+0x28>
  41948c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  419490:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  419494:	d40e      	bmi.n	4194b4 <__aeabi_d2uiz+0x34>
  419496:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  41949a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  41949e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  4194a2:	fa23 f002 	lsr.w	r0, r3, r2
  4194a6:	4770      	bx	lr
  4194a8:	f04f 0000 	mov.w	r0, #0
  4194ac:	4770      	bx	lr
  4194ae:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  4194b2:	d102      	bne.n	4194ba <__aeabi_d2uiz+0x3a>
  4194b4:	f04f 30ff 	mov.w	r0, #4294967295
  4194b8:	4770      	bx	lr
  4194ba:	f04f 0000 	mov.w	r0, #0
  4194be:	4770      	bx	lr

004194c0 <__gesf2>:
  4194c0:	f04f 3cff 	mov.w	ip, #4294967295
  4194c4:	e006      	b.n	4194d4 <__cmpsf2+0x4>
  4194c6:	bf00      	nop

004194c8 <__lesf2>:
  4194c8:	f04f 0c01 	mov.w	ip, #1
  4194cc:	e002      	b.n	4194d4 <__cmpsf2+0x4>
  4194ce:	bf00      	nop

004194d0 <__cmpsf2>:
  4194d0:	f04f 0c01 	mov.w	ip, #1
  4194d4:	f84d cd04 	str.w	ip, [sp, #-4]!
  4194d8:	ea4f 0240 	mov.w	r2, r0, lsl #1
  4194dc:	ea4f 0341 	mov.w	r3, r1, lsl #1
  4194e0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  4194e4:	bf18      	it	ne
  4194e6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  4194ea:	d011      	beq.n	419510 <__cmpsf2+0x40>
  4194ec:	b001      	add	sp, #4
  4194ee:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
  4194f2:	bf18      	it	ne
  4194f4:	ea90 0f01 	teqne	r0, r1
  4194f8:	bf58      	it	pl
  4194fa:	ebb2 0003 	subspl.w	r0, r2, r3
  4194fe:	bf88      	it	hi
  419500:	17c8      	asrhi	r0, r1, #31
  419502:	bf38      	it	cc
  419504:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
  419508:	bf18      	it	ne
  41950a:	f040 0001 	orrne.w	r0, r0, #1
  41950e:	4770      	bx	lr
  419510:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  419514:	d102      	bne.n	41951c <__cmpsf2+0x4c>
  419516:	ea5f 2c40 	movs.w	ip, r0, lsl #9
  41951a:	d105      	bne.n	419528 <__cmpsf2+0x58>
  41951c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
  419520:	d1e4      	bne.n	4194ec <__cmpsf2+0x1c>
  419522:	ea5f 2c41 	movs.w	ip, r1, lsl #9
  419526:	d0e1      	beq.n	4194ec <__cmpsf2+0x1c>
  419528:	f85d 0b04 	ldr.w	r0, [sp], #4
  41952c:	4770      	bx	lr
  41952e:	bf00      	nop

00419530 <__aeabi_cfrcmple>:
  419530:	4684      	mov	ip, r0
  419532:	4608      	mov	r0, r1
  419534:	4661      	mov	r1, ip
  419536:	e7ff      	b.n	419538 <__aeabi_cfcmpeq>

00419538 <__aeabi_cfcmpeq>:
  419538:	b50f      	push	{r0, r1, r2, r3, lr}
  41953a:	f7ff ffc9 	bl	4194d0 <__cmpsf2>
  41953e:	2800      	cmp	r0, #0
  419540:	bf48      	it	mi
  419542:	f110 0f00 	cmnmi.w	r0, #0
  419546:	bd0f      	pop	{r0, r1, r2, r3, pc}

00419548 <__aeabi_fcmpeq>:
  419548:	f84d ed08 	str.w	lr, [sp, #-8]!
  41954c:	f7ff fff4 	bl	419538 <__aeabi_cfcmpeq>
  419550:	bf0c      	ite	eq
  419552:	2001      	moveq	r0, #1
  419554:	2000      	movne	r0, #0
  419556:	f85d fb08 	ldr.w	pc, [sp], #8
  41955a:	bf00      	nop

0041955c <__aeabi_fcmplt>:
  41955c:	f84d ed08 	str.w	lr, [sp, #-8]!
  419560:	f7ff ffea 	bl	419538 <__aeabi_cfcmpeq>
  419564:	bf34      	ite	cc
  419566:	2001      	movcc	r0, #1
  419568:	2000      	movcs	r0, #0
  41956a:	f85d fb08 	ldr.w	pc, [sp], #8
  41956e:	bf00      	nop

00419570 <__aeabi_fcmple>:
  419570:	f84d ed08 	str.w	lr, [sp, #-8]!
  419574:	f7ff ffe0 	bl	419538 <__aeabi_cfcmpeq>
  419578:	bf94      	ite	ls
  41957a:	2001      	movls	r0, #1
  41957c:	2000      	movhi	r0, #0
  41957e:	f85d fb08 	ldr.w	pc, [sp], #8
  419582:	bf00      	nop

00419584 <__aeabi_fcmpge>:
  419584:	f84d ed08 	str.w	lr, [sp, #-8]!
  419588:	f7ff ffd2 	bl	419530 <__aeabi_cfrcmple>
  41958c:	bf94      	ite	ls
  41958e:	2001      	movls	r0, #1
  419590:	2000      	movhi	r0, #0
  419592:	f85d fb08 	ldr.w	pc, [sp], #8
  419596:	bf00      	nop

00419598 <__aeabi_fcmpgt>:
  419598:	f84d ed08 	str.w	lr, [sp, #-8]!
  41959c:	f7ff ffc8 	bl	419530 <__aeabi_cfrcmple>
  4195a0:	bf34      	ite	cc
  4195a2:	2001      	movcc	r0, #1
  4195a4:	2000      	movcs	r0, #0
  4195a6:	f85d fb08 	ldr.w	pc, [sp], #8
  4195aa:	bf00      	nop

004195ac <__errno>:
  4195ac:	4b01      	ldr	r3, [pc, #4]	; (4195b4 <__errno+0x8>)
  4195ae:	6818      	ldr	r0, [r3, #0]
  4195b0:	4770      	bx	lr
  4195b2:	bf00      	nop
  4195b4:	204003d4 	.word	0x204003d4

004195b8 <__libc_init_array>:
  4195b8:	b570      	push	{r4, r5, r6, lr}
  4195ba:	4e0f      	ldr	r6, [pc, #60]	; (4195f8 <__libc_init_array+0x40>)
  4195bc:	4d0f      	ldr	r5, [pc, #60]	; (4195fc <__libc_init_array+0x44>)
  4195be:	1b76      	subs	r6, r6, r5
  4195c0:	10b6      	asrs	r6, r6, #2
  4195c2:	bf18      	it	ne
  4195c4:	2400      	movne	r4, #0
  4195c6:	d005      	beq.n	4195d4 <__libc_init_array+0x1c>
  4195c8:	3401      	adds	r4, #1
  4195ca:	f855 3b04 	ldr.w	r3, [r5], #4
  4195ce:	4798      	blx	r3
  4195d0:	42a6      	cmp	r6, r4
  4195d2:	d1f9      	bne.n	4195c8 <__libc_init_array+0x10>
  4195d4:	4e0a      	ldr	r6, [pc, #40]	; (419600 <__libc_init_array+0x48>)
  4195d6:	4d0b      	ldr	r5, [pc, #44]	; (419604 <__libc_init_array+0x4c>)
  4195d8:	1b76      	subs	r6, r6, r5
  4195da:	f004 f9bb 	bl	41d954 <_init>
  4195de:	10b6      	asrs	r6, r6, #2
  4195e0:	bf18      	it	ne
  4195e2:	2400      	movne	r4, #0
  4195e4:	d006      	beq.n	4195f4 <__libc_init_array+0x3c>
  4195e6:	3401      	adds	r4, #1
  4195e8:	f855 3b04 	ldr.w	r3, [r5], #4
  4195ec:	4798      	blx	r3
  4195ee:	42a6      	cmp	r6, r4
  4195f0:	d1f9      	bne.n	4195e6 <__libc_init_array+0x2e>
  4195f2:	bd70      	pop	{r4, r5, r6, pc}
  4195f4:	bd70      	pop	{r4, r5, r6, pc}
  4195f6:	bf00      	nop
  4195f8:	0041d960 	.word	0x0041d960
  4195fc:	0041d960 	.word	0x0041d960
  419600:	0041d968 	.word	0x0041d968
  419604:	0041d960 	.word	0x0041d960

00419608 <memcpy>:
  419608:	4684      	mov	ip, r0
  41960a:	ea41 0300 	orr.w	r3, r1, r0
  41960e:	f013 0303 	ands.w	r3, r3, #3
  419612:	d16d      	bne.n	4196f0 <memcpy+0xe8>
  419614:	3a40      	subs	r2, #64	; 0x40
  419616:	d341      	bcc.n	41969c <memcpy+0x94>
  419618:	f851 3b04 	ldr.w	r3, [r1], #4
  41961c:	f840 3b04 	str.w	r3, [r0], #4
  419620:	f851 3b04 	ldr.w	r3, [r1], #4
  419624:	f840 3b04 	str.w	r3, [r0], #4
  419628:	f851 3b04 	ldr.w	r3, [r1], #4
  41962c:	f840 3b04 	str.w	r3, [r0], #4
  419630:	f851 3b04 	ldr.w	r3, [r1], #4
  419634:	f840 3b04 	str.w	r3, [r0], #4
  419638:	f851 3b04 	ldr.w	r3, [r1], #4
  41963c:	f840 3b04 	str.w	r3, [r0], #4
  419640:	f851 3b04 	ldr.w	r3, [r1], #4
  419644:	f840 3b04 	str.w	r3, [r0], #4
  419648:	f851 3b04 	ldr.w	r3, [r1], #4
  41964c:	f840 3b04 	str.w	r3, [r0], #4
  419650:	f851 3b04 	ldr.w	r3, [r1], #4
  419654:	f840 3b04 	str.w	r3, [r0], #4
  419658:	f851 3b04 	ldr.w	r3, [r1], #4
  41965c:	f840 3b04 	str.w	r3, [r0], #4
  419660:	f851 3b04 	ldr.w	r3, [r1], #4
  419664:	f840 3b04 	str.w	r3, [r0], #4
  419668:	f851 3b04 	ldr.w	r3, [r1], #4
  41966c:	f840 3b04 	str.w	r3, [r0], #4
  419670:	f851 3b04 	ldr.w	r3, [r1], #4
  419674:	f840 3b04 	str.w	r3, [r0], #4
  419678:	f851 3b04 	ldr.w	r3, [r1], #4
  41967c:	f840 3b04 	str.w	r3, [r0], #4
  419680:	f851 3b04 	ldr.w	r3, [r1], #4
  419684:	f840 3b04 	str.w	r3, [r0], #4
  419688:	f851 3b04 	ldr.w	r3, [r1], #4
  41968c:	f840 3b04 	str.w	r3, [r0], #4
  419690:	f851 3b04 	ldr.w	r3, [r1], #4
  419694:	f840 3b04 	str.w	r3, [r0], #4
  419698:	3a40      	subs	r2, #64	; 0x40
  41969a:	d2bd      	bcs.n	419618 <memcpy+0x10>
  41969c:	3230      	adds	r2, #48	; 0x30
  41969e:	d311      	bcc.n	4196c4 <memcpy+0xbc>
  4196a0:	f851 3b04 	ldr.w	r3, [r1], #4
  4196a4:	f840 3b04 	str.w	r3, [r0], #4
  4196a8:	f851 3b04 	ldr.w	r3, [r1], #4
  4196ac:	f840 3b04 	str.w	r3, [r0], #4
  4196b0:	f851 3b04 	ldr.w	r3, [r1], #4
  4196b4:	f840 3b04 	str.w	r3, [r0], #4
  4196b8:	f851 3b04 	ldr.w	r3, [r1], #4
  4196bc:	f840 3b04 	str.w	r3, [r0], #4
  4196c0:	3a10      	subs	r2, #16
  4196c2:	d2ed      	bcs.n	4196a0 <memcpy+0x98>
  4196c4:	320c      	adds	r2, #12
  4196c6:	d305      	bcc.n	4196d4 <memcpy+0xcc>
  4196c8:	f851 3b04 	ldr.w	r3, [r1], #4
  4196cc:	f840 3b04 	str.w	r3, [r0], #4
  4196d0:	3a04      	subs	r2, #4
  4196d2:	d2f9      	bcs.n	4196c8 <memcpy+0xc0>
  4196d4:	3204      	adds	r2, #4
  4196d6:	d008      	beq.n	4196ea <memcpy+0xe2>
  4196d8:	07d2      	lsls	r2, r2, #31
  4196da:	bf1c      	itt	ne
  4196dc:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4196e0:	f800 3b01 	strbne.w	r3, [r0], #1
  4196e4:	d301      	bcc.n	4196ea <memcpy+0xe2>
  4196e6:	880b      	ldrh	r3, [r1, #0]
  4196e8:	8003      	strh	r3, [r0, #0]
  4196ea:	4660      	mov	r0, ip
  4196ec:	4770      	bx	lr
  4196ee:	bf00      	nop
  4196f0:	2a08      	cmp	r2, #8
  4196f2:	d313      	bcc.n	41971c <memcpy+0x114>
  4196f4:	078b      	lsls	r3, r1, #30
  4196f6:	d08d      	beq.n	419614 <memcpy+0xc>
  4196f8:	f010 0303 	ands.w	r3, r0, #3
  4196fc:	d08a      	beq.n	419614 <memcpy+0xc>
  4196fe:	f1c3 0304 	rsb	r3, r3, #4
  419702:	1ad2      	subs	r2, r2, r3
  419704:	07db      	lsls	r3, r3, #31
  419706:	bf1c      	itt	ne
  419708:	f811 3b01 	ldrbne.w	r3, [r1], #1
  41970c:	f800 3b01 	strbne.w	r3, [r0], #1
  419710:	d380      	bcc.n	419614 <memcpy+0xc>
  419712:	f831 3b02 	ldrh.w	r3, [r1], #2
  419716:	f820 3b02 	strh.w	r3, [r0], #2
  41971a:	e77b      	b.n	419614 <memcpy+0xc>
  41971c:	3a04      	subs	r2, #4
  41971e:	d3d9      	bcc.n	4196d4 <memcpy+0xcc>
  419720:	3a01      	subs	r2, #1
  419722:	f811 3b01 	ldrb.w	r3, [r1], #1
  419726:	f800 3b01 	strb.w	r3, [r0], #1
  41972a:	d2f9      	bcs.n	419720 <memcpy+0x118>
  41972c:	780b      	ldrb	r3, [r1, #0]
  41972e:	7003      	strb	r3, [r0, #0]
  419730:	784b      	ldrb	r3, [r1, #1]
  419732:	7043      	strb	r3, [r0, #1]
  419734:	788b      	ldrb	r3, [r1, #2]
  419736:	7083      	strb	r3, [r0, #2]
  419738:	4660      	mov	r0, ip
  41973a:	4770      	bx	lr

0041973c <register_fini>:
  41973c:	4b02      	ldr	r3, [pc, #8]	; (419748 <register_fini+0xc>)
  41973e:	b113      	cbz	r3, 419746 <register_fini+0xa>
  419740:	4802      	ldr	r0, [pc, #8]	; (41974c <register_fini+0x10>)
  419742:	f000 b805 	b.w	419750 <atexit>
  419746:	4770      	bx	lr
  419748:	00000000 	.word	0x00000000
  41974c:	0041975d 	.word	0x0041975d

00419750 <atexit>:
  419750:	2300      	movs	r3, #0
  419752:	4601      	mov	r1, r0
  419754:	461a      	mov	r2, r3
  419756:	4618      	mov	r0, r3
  419758:	f000 b81e 	b.w	419798 <__register_exitproc>

0041975c <__libc_fini_array>:
  41975c:	b538      	push	{r3, r4, r5, lr}
  41975e:	4c0a      	ldr	r4, [pc, #40]	; (419788 <__libc_fini_array+0x2c>)
  419760:	4d0a      	ldr	r5, [pc, #40]	; (41978c <__libc_fini_array+0x30>)
  419762:	1b64      	subs	r4, r4, r5
  419764:	10a4      	asrs	r4, r4, #2
  419766:	d00a      	beq.n	41977e <__libc_fini_array+0x22>
  419768:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  41976c:	3b01      	subs	r3, #1
  41976e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  419772:	3c01      	subs	r4, #1
  419774:	f855 3904 	ldr.w	r3, [r5], #-4
  419778:	4798      	blx	r3
  41977a:	2c00      	cmp	r4, #0
  41977c:	d1f9      	bne.n	419772 <__libc_fini_array+0x16>
  41977e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  419782:	f004 b8f1 	b.w	41d968 <_fini>
  419786:	bf00      	nop
  419788:	0041d978 	.word	0x0041d978
  41978c:	0041d974 	.word	0x0041d974

00419790 <__retarget_lock_acquire_recursive>:
  419790:	4770      	bx	lr
  419792:	bf00      	nop

00419794 <__retarget_lock_release_recursive>:
  419794:	4770      	bx	lr
  419796:	bf00      	nop

00419798 <__register_exitproc>:
  419798:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  41979c:	4d2c      	ldr	r5, [pc, #176]	; (419850 <__register_exitproc+0xb8>)
  41979e:	4606      	mov	r6, r0
  4197a0:	6828      	ldr	r0, [r5, #0]
  4197a2:	4698      	mov	r8, r3
  4197a4:	460f      	mov	r7, r1
  4197a6:	4691      	mov	r9, r2
  4197a8:	f7ff fff2 	bl	419790 <__retarget_lock_acquire_recursive>
  4197ac:	4b29      	ldr	r3, [pc, #164]	; (419854 <__register_exitproc+0xbc>)
  4197ae:	681c      	ldr	r4, [r3, #0]
  4197b0:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  4197b4:	2b00      	cmp	r3, #0
  4197b6:	d03e      	beq.n	419836 <__register_exitproc+0x9e>
  4197b8:	685a      	ldr	r2, [r3, #4]
  4197ba:	2a1f      	cmp	r2, #31
  4197bc:	dc1c      	bgt.n	4197f8 <__register_exitproc+0x60>
  4197be:	f102 0e01 	add.w	lr, r2, #1
  4197c2:	b176      	cbz	r6, 4197e2 <__register_exitproc+0x4a>
  4197c4:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  4197c8:	2401      	movs	r4, #1
  4197ca:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  4197ce:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  4197d2:	4094      	lsls	r4, r2
  4197d4:	4320      	orrs	r0, r4
  4197d6:	2e02      	cmp	r6, #2
  4197d8:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  4197dc:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  4197e0:	d023      	beq.n	41982a <__register_exitproc+0x92>
  4197e2:	3202      	adds	r2, #2
  4197e4:	f8c3 e004 	str.w	lr, [r3, #4]
  4197e8:	6828      	ldr	r0, [r5, #0]
  4197ea:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  4197ee:	f7ff ffd1 	bl	419794 <__retarget_lock_release_recursive>
  4197f2:	2000      	movs	r0, #0
  4197f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4197f8:	4b17      	ldr	r3, [pc, #92]	; (419858 <__register_exitproc+0xc0>)
  4197fa:	b30b      	cbz	r3, 419840 <__register_exitproc+0xa8>
  4197fc:	f44f 70c8 	mov.w	r0, #400	; 0x190
  419800:	f3af 8000 	nop.w
  419804:	4603      	mov	r3, r0
  419806:	b1d8      	cbz	r0, 419840 <__register_exitproc+0xa8>
  419808:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  41980c:	6002      	str	r2, [r0, #0]
  41980e:	2100      	movs	r1, #0
  419810:	6041      	str	r1, [r0, #4]
  419812:	460a      	mov	r2, r1
  419814:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  419818:	f04f 0e01 	mov.w	lr, #1
  41981c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  419820:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  419824:	2e00      	cmp	r6, #0
  419826:	d0dc      	beq.n	4197e2 <__register_exitproc+0x4a>
  419828:	e7cc      	b.n	4197c4 <__register_exitproc+0x2c>
  41982a:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  41982e:	430c      	orrs	r4, r1
  419830:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  419834:	e7d5      	b.n	4197e2 <__register_exitproc+0x4a>
  419836:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  41983a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  41983e:	e7bb      	b.n	4197b8 <__register_exitproc+0x20>
  419840:	6828      	ldr	r0, [r5, #0]
  419842:	f7ff ffa7 	bl	419794 <__retarget_lock_release_recursive>
  419846:	f04f 30ff 	mov.w	r0, #4294967295
  41984a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41984e:	bf00      	nop
  419850:	20400800 	.word	0x20400800
  419854:	0041d950 	.word	0x0041d950
  419858:	00000000 	.word	0x00000000

0041985c <temp_tw_options>:
  41985c:	08f0d180 0000c350 00000000 73616850     ....P.......Phas
  41986c:	61662065 72756c69 00000065 72656d45     e failure...Emer
  41987c:	636e6567 74732079 0000706f 6b636f4c     gency stop..Lock
  41988c:	69616620 0000006c 6b726f46 6e6f6320      fail...Fork con
  41989c:	61662074 00006c69 74736146 6d697420     t fail..Fast tim
  4198ac:	74756f65 00000000 776f6c53 6d697420     eout....Slow tim
  4198bc:	74756f65 00000000 6e776f44 20646620     eout....Down fd 
  4198cc:	696d696c 00003074 66207055 696c2064     limit0..Up fd li
  4198dc:	3074696d 00000000 6e776f44 6e696620     mit0....Down fin
  4198ec:	6c206c61 00006d69 66207055 6c616e69     al lim..Up final
  4198fc:	6d696c20 00000000 616e6946 696c206c      lim....Final li
  41990c:	7374696d 65686320 00006b63 73696f48     mits check..Hois
  41991c:	524c2074 7265204e 00726f72 73696f48     t LRN error.Hois
  41992c:	79615774 4e524c20 71657220 65726975     tWay LRN require
  41993c:	00000064 20425443 6d6d6f43 736f6c20     d...CTB Comm los
  41994c:	00000073 30424343 6d6f4320 6f6c206d     s...CCB0 Comm lo
  41995c:	00007373 31424343 6d6f4320 6f6c206d     ss..CCB1 Comm lo
  41996c:	00007373 46206261 746e6f72 6f6f6420     ss..ab Front doo
  41997c:	00000072 62206261 206b6361 726f6f64     r...ab back door
  41998c:	00000000                                ....

00419990 <dispOptions>:
  419990:	33323130 37363534 00003938 6f6f6c46     0123456789..Floo
  4199a0:	00002872 6f636e45 00726564 20636e49     r(..Encoder.Inc 
  4199b0:	00000000 20766552 00000000 00206456     ....Rev ....Vd .
  4199c0:	00207156 00206449 00207149 00732f4d     Vq .Id .Iq .M/s.
  4199d0:	004e524c 004e5554 00534e49 004d5020     LRN.TUN.INS. PM.
  4199e0:	004d4120 00000041 00007a48 706f7453      AM.A...Hz..Stop
  4199f0:	00000000 656c6449 00000000 726f6f44     ....Idle....Door
  419a00:	00000000 64707348 00000000 6470734c     ....Hspd....Lspd
  419a10:	00000000 76697241 00000000 6c756146     ....Ariv....Faul
  419a20:	00007374 00000044 0000004c 00000020     ts..D...L... ...
  419a30:	00002020 00004d20 006d6320 006d6d20       .. M.. cm. mm.
  419a40:	00002049 00204c4f 00206149 00206249     I ..OL .Ia .Ib .
  419a50:	00206349 00206d49 00002054 00002056     Ic .Im .T ..V ..
  419a60:	71726f74 00736575 20636341 00000000     torques.Acc ....
  419a70:	20535a50 00000000 0020544c 20544950     PZS ....LT .PIT 
  419a80:	00000000 7261654c 6166206e 64656c69     ....Learn failed
  419a90:	00000000 7261654c 7553206e 73656363     ....Learn Succes
  419aa0:	6c756673 00000000                       sful....

00419aa8 <advanced_p>:
  419aa8:	00380024 80000000 78f0e0c0 8e9c9cb8     $.8........x....
  419ab8:	87878f8e 87878787 8e8e8f87 78bc9c9e     ...............x
  419ac8:	80c0e0f0 00000000 0ffef8e0 030efd43     ............C...
  419ad8:	00000101 00000000 00000000 00000000     ................
  419ae8:	03010100 0fe3fd06 00e0fcff 0000ffff     ................
  419af8:	180e0700 20202030 20202020 20202020     ....0           
  419b08:	20202020 18302020 0000070c 00ffff00           0.........
  419b18:	0000ffff 0e000000 8e8a8a8a ca8a8a0e     ................
  419b28:	ca8e068a 8e0e8a8a 8e8aca8a 00000000     ................
  419b38:	00ffff00 00e0ff7f 00000000 30313131     ............1110
  419b48:	31313100 31310031 f8003131 f80d0d0d     .1111.1111......
  419b58:	000000e0 00ffffe0 3f0f0300 c0e0f07c     ...........?|...
  419b68:	06068686 06060600 06060006 07000606     ................
  419b78:	c78c8c0c 3e7cf0e1 0000070f 00000000     ......|>........
  419b88:	03010000 0f070703 1e0e0e0e 1e1c1c1c     ................
  419b98:	0f0e0e0e 03030707 00000001 00000000     ................

00419ba8 <basic_set>:
  419ba8:	0030004f 00000000 c0800000 fcf8f0e0     O.0.............
  419bb8:	070e3efc 00000001 00000000 00000000     .>..............
	...
  419bfc:	38000000 9f9f9fbe 013fbf9f 00000000     ...8......?.....
	...
  419c4c:	fffffe00 ffffffff 00feffff fcfcfc00     ................
  419c5c:	f0007cfc fffffffe ffffffff ffffffff     .|..............
  419c6c:	ffffffff ffffffff ffffffff ffffffff     ................
  419c7c:	ffffffff ffffffff ffffffff ffffffff     ................
  419c8c:	ffffffff ffffffff 0cffffff fcf8f000     ................
  419c9c:	fefefefc fefefefe f8fcfcfc 010100f1     ................
  419cac:	03030000 07070707 07070707 07070707     ................
  419cbc:	07070707 07070707 07070707 07070707     ................
  419ccc:	07070707 07070707 07070707 07070707     ................
  419cdc:	07070707 03070707 00000003 fdf9fbe3     ................
  419cec:	fefefcfc fcfefefe e3f3f9fd 00000000     ................
	...
  419d38:	07070301 0f0f0707 07070707 00000103     ................
	...

00419d88 <faults>:
  419d88:	00280080 fcfcf8e0 fffefefe 7f7fffff     ..(.............
  419d98:	fefeffff f8fcfefe 0000c0f0 fefefefe     ................
  419da8:	fefefefe fefefefe fefefefe fefefefe     ................
  419db8:	00fefefe 00000000 80000000 f8f0e0c0     ................
  419dc8:	f8f8f8f8 f8f8f8f8 f8f8f8f8 f8f8f8f8     ................
  419dd8:	80c0e0f0 00000000 00000000 fc000000     ................
  419de8:	fcfcfcfc fcfcfcfc fcfcfcfc f8fcfcfc     ................
  419df8:	e0f0f8f8 00000080 fcfcfcfc fcfcfcfc     ................
  419e08:	0000fcfc ffffffff ffffffff c0c0f0ff     ................
  419e18:	1f1f1f8f 1f1f1f1f 00001f1f 01010101     ................
  419e28:	ffff0101 ffffffff ffffffff 01010101     ................
  419e38:	00000101 78f0e000 7f3f3e3c 7f7fff7f     .......x<>?.....
  419e48:	7f7f7f7f ffff7f7f 3f3f3f7f ffff7f3f     .........????...
  419e58:	7f7f7fff 787c7e7f 0000e0f0 ff000000     .....~|x........
  419e68:	ffffffff ffffffff 010101ff ffffff07     ................
  419e78:	ffffffff 000000ff ffffffff ffffffff     ................
  419e88:	00007fff 0f070301 7f3f3f1f ffffffff     .........??.....
  419e98:	feffffff f0f8f8fc 000080e0 00000000     ................
  419ea8:	ffff0000 ffffffff ffffffff 00000000     ................
  419eb8:	00000000 6070ff00 08008240 fcfe3f18     ......p`@....?..
  419ec8:	00000000 00fffcfc 00000000 ff000000     ................
  419ed8:	000000ff c0c0800c 0000fff3 ff000000     ................
  419ee8:	ffffffff ffffffff fcf8f8ff ffffffff     ................
  419ef8:	7fffffff 0000001f ffffff07 ffffffff     ................
  419f08:	000000ff fcfcfcfc fcfcfcfc 030100fc     ................
  419f18:	ffffff07 ffffffff 00f8ffff 00000000     ................
  419f28:	ffff0000 ffffffff ffffffff 00000000     ................
  419f38:	00000000 f87c3f00 f8f0f1f0 fffffef8     .....?|.........
  419f48:	f0f0f0f8 fcffffff f0f0f0f8 fffcf8f0     ................
  419f58:	f0f0f0ff fffffff8 00003f7f ff000000     .........?......
  419f68:	ffffffff ffffffff 010103ff 01010101     ................
  419f78:	00000001 00000000 ffffff00 ffffffff     ................
  419f88:	0000007f 7f3f1f07 ffffff7f fcfcfeff     ......?.........
  419f98:	fffffffc 7f7fffff 00011f3f 00000000     ........?.......
  419fa8:	ffff0000 ffffffff ffffffff 00000000     ................
	...
  419fc0:	0f070301 ff7f3f1f ffffffff ffffffff     .....?..........
  419fd0:	ffffffff ffffffff 0f1f3f7f 00010307     .........?......
  419fe0:	00000000 ff000000 ffffffff ffffffff     ................
  419ff0:	000000ff 00000000 00000000 00000000     ................
  41a000:	fcfcfefc fcfcfcfc 000000fc 2c303078     ............x00,
  41a010:	31783020 31212d31 2c313179 30783020      0x11-!1y11, 0x0
  41a020:	30202c30 2c303078 30783020              0, 0x00, 0x0

0041a02c <intro_logo>:
  41a02c:	0036005b f8e08000 fefefcfc ffffffff     [.6.............
  41a03c:	feffffff f8fcfefe 0000e0f8 00000000     ................
  41a04c:	00000000 c0c08080 f8f0f0e0 7e3e3c7c     ............|<>~
  41a05c:	f8fcfc7c f8f8f8f8 c0b03070 00000000     |.......p0......
  41a06c:	f8f8f800 f8f8f8f8 f8f8f8f8 f8f8f8f8     ................
  41a07c:	f8f8f8f8 f8f8f8f8 e0f0f0f8 200080c0     ............... 
  41a08c:	ffffffff ffffffff 0100ffff ffffffff     ................
  41a09c:	ffffffff 000000ff ece4e000 9fdfcece     ................
  41a0ac:	3fbf9f9f 7c7c7e3f 9fbf7e7c f3f7efcf     ...??~|||~......
  41a0bc:	fe1e3df9 00ffffff 00000000 ffffffff     .=..............
  41a0cc:	ffffffff ffffffff 000000ff ffffffff     ................
  41a0dc:	ffffffff ffffffff ff0700ff ffffffff     ................
  41a0ec:	ffffffff fcfcfcff f0f8f8f8 00c0e0f0     ................
  41a0fc:	00000000 ffff7f00 03010101 ff070303     ................
  41a10c:	0000ffff c3c7ffff fffffffb ffff0e1c     ................
  41a11c:	000000ff ff000000 ffffffff ffffffff     ................
  41a12c:	ffffffff ff000000 ffffffff ffffffff     ................
  41a13c:	ffffffff 07010000 7f3f1f0f ffffffff     ..........?.....
  41a14c:	ffffffff ffffffff f8ffffff 00000000     ................
  41a15c:	fcffff04 00000000 ffff0000 ff0100ff     ................
  41a16c:	71e1c7ff 86feffff 0fffffc7 00000000     ...q............
  41a17c:	ffff0000 ffffffff ffffffff 00ffffff     ................
  41a18c:	ffff0000 ffffffff ffffffff 00ffffff     ................
  41a19c:	f8f8f8f0 f8f8f8f8 01f1f9f8 ffffff03     ................
  41a1ac:	ffffffff 00ffffff 00000000 f0ffff03     ................
  41a1bc:	00000000 ffff0f00 ffff0000 ff7870f9     .............px.
  41a1cc:	e383bfff 000007ff 00000000 ffffff00     ................
  41a1dc:	ffffffff ffffffff f0f0ffff fffffff0     ................
  41a1ec:	ffffffff ffffffff 07003f7f ffffff7f     .........?......
  41a1fc:	ffffffff e0e0ffff ffffffff ffffffff     ................
  41a20c:	00001fff 00000000 00ffff07 00000000     ................
  41a21c:	00ffff00 ffffff00 0f1f7cf8 00010307     .........|......
  41a22c:	10101030 0060f090 33e3c303 73331313     0.....`....3..3s
  41a23c:	c30303e3 131333e3 03e36313 31e3c303     .....3...c.....1
  41a24c:	20101011 000080e0 0f0f0701 1f1f1f1f     ... ............
  41a25c:	3f3f3f3f 1f1f1f3f 0003070f 00000000     ?????...........
  41a26c:	00000000 00030303 00000000 00000f0f     ................
  41a27c:	00010307 00000000 08080000 191b0a0c     ................
  41a28c:	00001818 10080f07 0f0c0810 0f070000     ................
  41a29c:	18101018 00000f0e 10080f07 0f1c1810     ................
  41a2ac:	00000003                                ....

0041a2b0 <p_lock>:
  41a2b0:	0030004d 00000000 80000000 c0c0c0c0     M.0.............
  41a2c0:	c0e0c0c0 c0c0c0c0 c0c0c0c0 c0e0c0e0     ................
  41a2d0:	fee0c0e0 fefefefe fefefefe fefefefe     ................
  41a2e0:	fefefefe fefefefe fefefefe fefefefe     ................
  41a2f0:	f8fcfcfc e0f0f0f8 0080c0c0 00000000     ................
  41a300:	f0c00000 7ffefef8 0f0f1f3f 07070707     ........?.......
  41a310:	07070707 07070707 07070707 07070707     ................
  41a320:	ffffffff ffffffff ffffffff ffffffff     ................
  41a330:	ffffffff ffffffff ffffffff ffffffff     ................
  41a340:	ffffffff ffffffff e0f8fcfe fffe0000     ................
  41a350:	03ffffff 00000000 00000000 00000000     ................
	...
  41a36c:	ffffff00 ffffffff ffffffff ffffffff     ................
  41a37c:	ffffffff 0103030f 03010101 0f0f0f03     ................
  41a38c:	0707070f ffff0707 ffffffff 0100ffff     ................
  41a39c:	ffff7f0f c0e0f8fe 00008080 00000000     ................
	...
  41a3b8:	ffff0000 ffffffff ffffffff ffffffff     ................
  41a3c8:	ffffffff fcfeffff f8f8f8f8 fffffefc     ................
  41a3d8:	ffffffff fffefefe ffffffff 000f3fff     .............?..
  41a3e8:	00000000 07070301 1f1f0f0f 1f1f1f1f     ................
  41a3f8:	1f1f1f1f 1f1f1f1f 1f1f1f1f ff1f1f1f     ................
  41a408:	ffffffff ffffffff ffffffff ffffffff     ................
  41a418:	ffffffff ffffffff ffffffff ffffffff     ................
  41a428:	7f7fffff 070f1f3f 00000003 00000000     ....?...........
	...
  41a454:	07070707 07070707 07070707 07070707     ................
  41a464:	07070707 07070707 03070707 01030303     ................
  41a474:	00000001 00000000 00000000 00000000     ................

0041a484 <timing>:
  41a484:	0038002e 00000000 00000000 70e0c080     ..8............p
  41a494:	0e0c1838 03070606 e3c30303 fefef3f3     8...............
  41a4a4:	fcfcfcfe f8f8fcfc c0e0f0f8 00000080     ................
  41a4b4:	c0000000 fcfcf8f0 fffffffe ffffffff     ................
  41a4c4:	8ebe7fff 63c0c0c4 6f676763 7f7f7f7f     .......ccggo....
  41a4d4:	ffffffff ffffffff ffffffff 000000fc     ................
  41a4e4:	ffffff7f ffffffff 7fffffff c3870f3f     ............?...
  41a4f4:	f8f8f1e3 fef4f8fc fefefefe f8fcfcfc     ................
  41a504:	e3f1f1f8 7b1f0f87 0003c7f7 01000000     .......{........
  41a514:	1f1f0f07 1fff030f fef80001 ffffffff     ................
  41a524:	f3f9fdff 1fcfe7e3 ffffff3f ffffffff     ........?.......
  41a534:	e7efffff 0700c0f4 0000f0ff 00000000     ................
  41a544:	00000000 00e07c1f fff73707 3fffffff     .....|...7.....?
  41a554:	f1e78f1f fffffcf8 ffffffff ffffffff     ................
  41a564:	011f7fff 033ff8c0 00000000 00000000     ......?.........
  41a574:	00000000 0c060301 47633118 9f8f8ec6     .........1cG....
  41a584:	1f1f1f9f 9b1f1f1f c7cf8f87 18303163     ............c10.
  41a594:	180f0f0c 00703038 00000000 00000000     ....80p.........
	...
  41a5ac:	071e3c10 01010101 01010101 00010101     .<..............
	...
  41a5cc:	7466694c 65707320 00006465 706f7453     Lift speed..Stop
  41a5dc:	616c7020 6c206574 74676e65 00000068      plate length...
  41a5ec:	00006d6d 706f7473 676e6970 73696420     mm..stopping dis
  41a5fc:	636e6174 00000065 65726944 74537463     tance...DirectSt
  41a60c:	4120706f 00007463 63616e49 65766974     op Act..Inactive
  41a61c:	00000000 69746341 00006576 73696f48     ....Active..Hois
  41a62c:	79615774 61656c20 00006e72 00006e4f     tWay learn..On..
  41a63c:	0066664f 6f6f6c46 654c2072 006c6576     Off.Floor Level.
  41a64c:	65746e45 6c662072 20726f6f 626d756e     Enter floor numb
  41a65c:	00007265 204d4143 61697274 0000736c     er..CAM trials..
  41a66c:	6b726150 20676e69 6f6f6c66 00000072     Parking floor...
  41a67c:	75716552 20747365 736e6950 6e6f6320     Request Pins con
  41a68c:	00676966 65722033 75622071 6e6f7474     fig.3 req button
  41a69c:	00000073 65722032 75622071 6e6f7474     s...2 req button
  41a6ac:	00000073 68732032 64657261 71657220     s...2 shared req
  41a6bc:	74756220 736e6f74 00000000 20716552      buttons....Req 
  41a6cc:	61736964 20656c62 68636574 00000000     disable tech....
  41a6dc:	656d6954 73696420 656c6261 00000000     Time disable....
  41a6ec:	76726553 73656369 73696420 656c6261     Services disable
  41a6fc:	00000000 0066666f 76726553 73656369     ....off.Services
  41a70c:	6f632073 00746e75 65746144 6d69542f     s count.Date/Tim
  41a71c:	00000065 20746553 65746164 00000000     e...Set date....
  41a72c:	20746553 656d6974 00000000 6f6f6c46     Set time....Floo
  41a73c:	63207372 746e756f 00000000 65746e45     rs count....Ente
  41a74c:	6f792072 62207275 646c6975 20676e69     r your building 
  41a75c:	626d756e 6f207265 6f642066 0073726f     number of doors.
  41a76c:	70736944 2079616c 65707974 00000000     Display type....
  41a77c:	65532037 6e656d67 00007374 616e6942     7 Segments..Bina
  41a78c:	00007972 616e6942 50207972 0000736f     ry..Binary Pos..
  41a79c:	6f636544 00726564 6f6f6c46 69642072     Decoder.Floor di
  41a7ac:	616c7073 00000079 6f6f6c46 69442072     splay...Floor Di
  41a7bc:	616c7073 00000079 726f6f64 70797420     splay...door typ
  41a7cc:	00000065 756e614d 00006c61 65746e49     e...Manual..Inte
  41a7dc:	6c616e72 74756120 74616d6f 00006369     rnal automatic..
  41a7ec:	6f747541 6974616d 204e2063 736f6c63     Automatic N clos
  41a7fc:	00006465 6f747541 6974616d 204e2063     ed..Automatic N 
  41a80c:	6e65706f 00000000 69676552 72657473     open....Register
  41a81c:	20676e69 74737973 00006d65 6e776f44     ing system..Down
  41a82c:	6c6f6320 7463656c 00343220 6e776f44      collect 24.Down
  41a83c:	6c6f6320 7463656c 00000000 64207055      collect....Up d
  41a84c:	206e776f 6c6c6f63 00746365 7466694c     own collect.Lift
  41a85c:	20707520 65726964 6f697463 0000006e      up direction...
  41a86c:	77726f46 00647261 65766552 00657372     Forward.Reverse.
  41a87c:	68676948 65707320 00006465 00000025     High speed..%...
  41a88c:	6964654d 73206d75 64656570 00000000     Medium speed....
  41a89c:	65657243 70732070 00646565 656c6552     Creep speed.Rele
  41a8ac:	206c6576 65657073 00000064 20736e49     vel speed...Ins 
  41a8bc:	65657073 00000064 65636341 6172656c     speed...Accelera
  41a8cc:	6e6f6974 00000000 00636553 20736e49     tion....Sec.Ins 
  41a8dc:	6c656341 74617265 006e6f69 20736e49     Aceleration.Ins 
  41a8ec:	65636544 6172656c 6e6f6974 00000000     Deceleration....
  41a8fc:	20736e49 6e726f63 00007265 6e726f43     Ins corner..Corn
  41a90c:	31207265 00000000 6e726f43 32207265     er 1....Corner 2
  41a91c:	00000000 6e726f43 33207265 00000000     ....Corner 3....
  41a92c:	20736e49 706f7473 646f6d20 00000065     Ins stop mode...
  41a93c:	75726241 00007470 65636544 6172656c     Abrupt..Decelera
  41a94c:	00006574 20445241 65657073 00000064     te..ARD speed...
  41a95c:	20445241 2f636341 00636544 20445241     ARD Acc/Dec.ARD 
  41a96c:	6e726f43 00007265 74666f53 61747320     Corner..Soft sta
  41a97c:	73207472 64656570 00000000 74666f53     rt speed....Soft
  41a98c:	65707320 74206465 00656d69 0000736d      speed time.ms..
  41a99c:	76697244 61702065 206d6172 75746573     Drive param setu
  41a9ac:	44282070 00000029 76697244 00007265     p (D)...Driver..
  41a9bc:	6f746f4d 61502072 656d6172 73726574     Motor Parameters
  41a9cc:	00000000 74636556 7020726f 6d617261     ....Vector param
  41a9dc:	00000000 6863654d 63696e61 64206c61     ....Mechanical d
  41a9ec:	00617461 6f636e45 20726564 61726170     ata.Encoder para
  41a9fc:	0000006d 20462f56 61726170 6574656d     m...V/F paramete
  41aa0c:	00007372 7265764f 64616f6c 00000000     rs..Overload....
  41aa1c:	6f746f4d 72622072 00656b61 00445241     Motor brake.ARD.
  41aa2c:	74736552 2065726f 74636146 2079726f     Restore Factory 
  41aa3c:	00746573 20657241 20756f79 65727573     set.Are you sure
  41aa4c:	0000003f 65766153 69726420 70206576     ?...Save drive p
  41aa5c:	6d617261 00000000 6978614d 206d756d     aram....Maximum 
  41aa6c:	71657246 636e6575 00000079 72726143     Frequency...Carr
  41aa7c:	20726569 71657246 636e6575 00000079     ier Frequency...
  41aa8c:	007a484b 746e6f43 206c6f72 65646f6d     KHz.Control mode
  41aa9c:	00000000 00662f76 736f6c43 6c206465     ....v/f.Closed l
  41aaac:	20706f6f 74636576 0000726f 6e65704f     oop vector..Open
  41aabc:	6f6f6c20 65762070 726f7463 00000000      loop vector....
  41aacc:	75706e49 68702074 20657361 6c696166     Input phase fail
  41aadc:	00000000 6f636e45 20726564 65707974     ....Encoder type
  41aaec:	00000000 72636e49 6e656d65 006c6174     ....Incremental.
  41aafc:	436e6953 0000736f 61646e45 00000074     SinCos..Endat...
  41ab0c:	6f636e45 20726564 736c7570 65722f65     Encoder pulse/re
  41ab1c:	00000076 00522f50 20636e45 65726964     v...P/R.Enc dire
  41ab2c:	6f697463 0000006e 73616850 20412065     ction...Phase A 
  41ab3c:	6461656c 00000000 73616850 20422065     lead....Phase B 
  41ab4c:	6461656c 00000000 6c676e41 72532065     lead....Angle Sr
  41ab5c:	69206863 6e65746e 79746973 00000000     ch intensity....
  41ab6c:	20636e45 73616850 75742065 0000656e     Enc Phase tune..
  41ab7c:	61206f4e 6f697463 0000006e 61746f52     No action...Rota
  41ab8c:	6e6f6974 00006c61 74617473 616e6f69     tional..stationa
  41ab9c:	00007972 65657073 69662064 7265746c     ry..speed filter
  41abac:	00000000 656c6f50 736f7020 6f697469     ....Pole positio
  41abbc:	666f206e 74657366 00000000 00676544     n offset....Deg.
  41abcc:	63617254 6e6f6974 65687320 20657661     Traction sheave 
  41abdc:	00616964 6f746f4d 6e692072 69747265     dia.Motor inerti
  41abec:	00000061 6d2e674b 00000032 70737553     a...Kg.m2...Susp
  41abfc:	69736e65 72206e6f 6f697461 00000000     ension ratio....
  41ac0c:	6e756f43 20726574 67696577 00007468     Counter weight..
  41ac1c:	0000674b 4c796150 2064616f 67696577     Kg..PayLoad weig
  41ac2c:	00007468 69626143 6577206e 74686769     ht..Cabin weight
  41ac3c:	00000000 69747345 6574616d 656e6920     ....Estimate ine
  41ac4c:	61697472 00000000 61746f54 6e69206c     rtia....Total in
  41ac5c:	69747265 00000061 6f746f4d 79742072     ertia...Motor ty
  41ac6c:	00006570 75646e49 6f697463 0000006e     pe..Induction...
  41ac7c:	636e7953 6e6f7268 0073756f 65746152     Synchronous.Rate
  41ac8c:	6f702064 00726577 0000574b 65746152     d power.KW..Rate
  41ac9c:	72662064 65757165 0079636e 65746152     d frequency.Rate
  41acac:	70732064 00646565 004d5052 65746152     d speed.RPM.Rate
  41acbc:	6f762064 6761746c 00000065 00000056     d voltage...V...
  41accc:	65746152 75632064 6e657272 00000074     Rated current...
  41acdc:	65776f50 61662072 726f7463 00000000     Power factor....
  41acec:	6f747541 6e757420 00000065 74617453     Auto tune...Stat
  41acfc:	7220726f 73697365 636e6174 00000065     or resistance...
  41ad0c:	006d684f 6f746f52 65722072 74736973     Ohm.Rotor resist
  41ad1c:	65636e61 00000000 6b61654c 20656761     ance....Leakage 
  41ad2c:	75646e69 00007463 0000486d 6e67614d     induct..mH..Magn
  41ad3c:	7a697465 20676e69 75646e69 00007463     etizing induct..
  41ad4c:	6c206f4e 2064616f 72727563 00746e65     No load current.
  41ad5c:	0000444c 0000514c 6b636142 464d4520     LD..LQ..Back EMF
  41ad6c:	00000000 656c6f50 69617020 6f632072     ....Pole pair co
  41ad7c:	00746e75 74746553 73676e69 00000000     unt.Settings....
  41ad8c:	20444656 6f746f6d 00000072 6d726f4e     VFD motor...Norm
  41ad9c:	6d206c61 726f746f 00000000 756c6156     al motor....Valu
  41adac:	00000065 656d6954 00000000 20525341     e...Time....ASR 
  41adbc:	20776f6c 00000050 20776f4c 65657073     low P...Low spee
  41adcc:	20502064 6e696167 00000000 20525341     d P gain....ASR 
  41addc:	20776f6c 00000049 20776f4c 65657073     low I...Low spee
  41adec:	6e692064 20676574 656d6974 00000000     d integ time....
  41adfc:	20525341 68676968 00005020 68676948     ASR high P..High
  41ae0c:	65707320 50206465 69616720 0000006e      speed P gain...
  41ae1c:	20525341 68676968 00004920 68676948     ASR high I..High
  41ae2c:	65707320 69206465 6765746e 6d697420      speed integ tim
  41ae3c:	00000065 20525041 6576654c 0050206c     e...APR Level P.
  41ae4c:	69736f70 6e6f6974 20676e69 6e696167     positioning gain
  41ae5c:	00000000 20525341 6f72657a 65707320     ....ASR zero spe
  41ae6c:	50206465 00000000 20525341 6f72657a     ed P....ASR zero
  41ae7c:	65707320 45206465 00004f53 20525041      speed ESO..APR 
  41ae8c:	6f72657a 65707320 50206465 00000000     zero speed P....
  41ae9c:	74697753 4c206863 6f702053 00746e69     Switch LS point.
  41aeac:	74697753 48206863 6f702053 00746e69     Switch HS point.
  41aebc:	2d524341 00502044 2d524341 00492044     ACR-D P.ACR-D I.
  41aecc:	2d524341 00502051 2d524341 00492051     ACR-Q P.ACR-Q I.
  41aedc:	20524341 646e6162 74646977 00000068     ACR bandwidth...
  41aeec:	20524341 646e6162 74646977 535a2068     ACR bandwidth ZS
  41aefc:	00000000 72756f54 20657571 61636564     ....Tourque deca
  41af0c:	00000079 6f6c6c41 20646577 65657073     y...Allowed spee
  41af1c:	65642064 00000076 6e696d56 00000000     d dev...Vmin....
  41af2c:	6e696d46 00000000 00006d56 00006d46     Fmin....Vm..Fm..
  41af3c:	71726f54 62206575 74736f6f 00000000     Torque boost....
  41af4c:	61657242 7266206b 65757165 0079636e     Break frequency.
  41af5c:	61657242 6f76206b 6761746c 00000065     Break voltage...
  41af6c:	20445241 65707974 00000000 74746142     ARD type....Batt
  41af7c:	00797265 00535055 20445241 2078616d     ery.UPS.ARD max 
  41af8c:	72727563 00746e65 62204344 656b6172     current.DC brake
  41af9c:	6c656420 00007961 6b617242 65722065      delay..Brake re
  41afac:	7361656c 65642065 0079616c 6b617242     lease delay.Brak
  41afbc:	6f682065 6420646c 79616c65 00000000     e hold delay....
  41afcc:	6f746f4d 6f6d2072 64206576 79616c65     Motor move delay
  41afdc:	00000000 614c2820 00297473 0000204e     .... (Last).N ..
  41afec:	46202f20 00000000 00003d20 45202f20      / F.... =.. / E
  41affc:	00000000 20714920 00000000 0000002f     .... Iq ..../...
  41b00c:	0000003a 204d5020 00000000 66206f4e     :... PM ....No f
  41b01c:	746c7561 206f7420 77656976 00000000     ault to view....
  41b02c:	6c756146 28207374 00002946 77656956     Faults (F)..View
  41b03c:	75616620 0073746c 61656c43 69682072      faults.Clear hi
  41b04c:	726f7473 00000079 00003858 00003958     story...X8..X9..
  41b05c:	00303158 00313158 00323158 00333158     X10.X11.X12.X13.
  41b06c:	00343158 00353158 00363158 00373158     X14.X15.X16.X17.
  41b07c:	00383158 00393158 00303258 00313258     X18.X19.X20.X21.
  41b08c:	20425443 00003058 20425443 00003158     CTB X0..CTB X1..
  41b09c:	20425443 00003258 20425443 00003358     CTB X2..CTB X3..
  41b0ac:	20425443 00003458 20425443 00003558     CTB X4..CTB X5..
  41b0bc:	20425443 00003658 20425443 00003758     CTB X6..CTB X7..
  41b0cc:	656e6f4e 00000000 7466694c 72617020     None....Lift par
  41b0dc:	73206d61 70757465 294c2820 00000000     am setup (L)....
  41b0ec:	69736142 65732063 00707574 61766441     Basic setup.Adva
  41b0fc:	6465636e 74657320 00007075 656d6954     nced setup..Time
  41b10c:	26207372 6c656420 00737961 65657053     rs & delays.Spee
  41b11c:	75632064 73657672 00000000 73696f48     d curves....Hois
  41b12c:	61642074 00006174 65766153 66696c20     t data..Save lif
  41b13c:	61702074 006d6172 65766153 696f4820     t param.Save Hoi
  41b14c:	64207473 00617461 74736552 2065726f     st data.Restore 
  41b15c:	74636166 2079726f 00746573 6f746f4d     factory set.Moto
  41b16c:	72422072 00656b61 004d4143 6867694c     r Brake.CAM.Ligh
  41b17c:	69742074 0072656d 6f727241 70752077     t timer.Arrow up
  41b18c:	00000000 6f727241 6f442077 00006e77     ....Arrow Down..
  41b19c:	00434f4d 676e6f47 00000000 20445241     MOC.Gong....ARD 
  41b1ac:	66666f54 00000000 00007846 726f6f44     Toff....Fx..Door
  41b1bc:	6c432031 0065736f 726f6f44 704f2031     1 Close.Door1 Op
  41b1cc:	00006e65 726f6f44 6c432032 0065736f     en..Door2 Close.
  41b1dc:	726f6f44 704f2032 00006e65 726f6f44     Door2 Open..Door
  41b1ec:	6c432033 0065736f 726f6f44 704f2033     3 Close.Door3 Op
  41b1fc:	00006e65 6c6c754e 00000000 776f6c53     en..Null....Slow
  41b20c:	6d697420 756f2d65 00000074 6e656857      time-out...When
  41b21c:	69687420 69742073 6520656d 7370616c      this time elaps
  41b22c:	66692065 65687420 66696c20 6f632074     e if the lift co
  41b23c:	6e646c75 66207427 20646e69 20656874     uldn't find the 
  41b24c:	726f6f64 76656c20 73206c65 616e6769     door level signa
  41b25c:	7469206c 6c697720 7473206c 6620706f     l it will stop f
  41b26c:	6967616c 6120676e 7265206e 00726f72     laging an error.
  41b27c:	74736146 6d697420 756f2d65 00000074     Fast time-out...
  41b28c:	6e656857 69687420 69742073 6520656d     When this time e
  41b29c:	7370616c 69207365 68742066 696c2065     lapses if the li
  41b2ac:	63207466 646c756f 2074276e 646e6966     ft couldn't find
  41b2bc:	6c657320 6f746365 69732072 6c616e67      selector signal
  41b2cc:	7469202c 6c697720 7473206c 6620706f     , it will stop f
  41b2dc:	6967616c 6120676e 7265206e 00726f72     laging an error.
  41b2ec:	204d4143 656d6974 74756f2d 00000000     CAM time-out....
  41b2fc:	706f7453 69617720 69742074 0000656d     Stop wait time..
  41b30c:	6867694c 6e6f2d74 6d697420 00000065     Light-on time...
  41b31c:	6b726150 20676e69 616c6564 00000079     Parking delay...
  41b32c:	735f7055 20706f74 616c6564 00000079     Up_stop delay...
  41b33c:	736d3034 00000000 6e776f44 6f74732d     40ms....Down-sto
  41b34c:	65642070 0079616c 20445241 664f2d54     p delay.ARD T-Of
  41b35c:	65642066 0079616c 20445241 706f7473     f delay.ARD stop
  41b36c:	6d697420 756f2d65 00000074 20445241      time-out...ARD 
  41b37c:	69442d4c 65642072 0079616c 20445241     L-Dir delay.ARD 
  41b38c:	69645f4c 65742072 74207473 00656d69     L_dir test time.
  41b39c:	6c697455 65697469 55282073 00000029     Utilities (U)...
  41b3ac:	61204f49 65726464 6e697373 00000067     IO addressing...
  41b3bc:	75746553 61502070 6f777373 00006472     Setup Password..
  41b3cc:	65766153 6c6c6120 74616420 00000061     Save all data...
  41b3dc:	65746e69 6c616e72 6c616320 0000006c     internal call...
  41b3ec:	726f6f44 76656c20 73206c65 616e6769     Door level signa
  41b3fc:	0000006c 726f6f44 756f6320 7265746e     l...Door counter
  41b40c:	67697320 006c616e 6b726f46 6e6f6320      signal.Fork con
  41b41c:	74636174 00000000 6b636f4c 6e6f6320     tact....Lock con
  41b42c:	74636174 00000000 65726946 646f6d20     tact....Fire mod
  41b43c:	00000065 70736e49 69746365 00006e6f     e...Inspection..
  41b44c:	70736e49 69746365 75206e6f 00000070     Inspection up...
  41b45c:	70736e49 69746365 64206e6f 006e776f     Inspection down.
  41b46c:	66207055 6365645f 6c206c65 0030746d     Up f_decel lmt0.
  41b47c:	6e776f44 645f6620 6c656365 746d6c20     Down f_decel lmt
  41b48c:	00000030 6c6c7546 69657720 00746867     0...Full weight.
  41b49c:	7265764f 69657720 00746867 6e65704f     Over weight.Open
  41b4ac:	6f6f6420 00000072 736f6c43 6f642065      door...Close do
  41b4bc:	0000726f 20445241 65646f6d 00000000     or..ARD mode....
  41b4cc:	6e69614d 6e6f6320 42462074 006b6361     Main cont FBack.
  41b4dc:	6b617242 6f632065 4620746e 6b636142     Brake cont FBack
  41b4ec:	00000000 63207846 20746e6f 63614246     ....Fx cont FBac
  41b4fc:	0000006b 66207055 6c616e69 6d696c20     k...Up final lim
  41b50c:	00007469 776f4420 6966206e 206c616e     it.. Down final 
  41b51c:	696d696c 00000074 20705520 65645f66     limit... Up f_de
  41b52c:	206c6563 31746d6c 00000000 20705520     cel lmt1.... Up 
  41b53c:	65645f66 206c6563 32746d6c 00000000     f_decel lmt2....
  41b54c:	776f4420 5f66206e 65636564 6d6c206c      Down f_decel lm
  41b55c:	00003174 776f4420 5f66206e 65636564     t1.. Down f_dece
  41b56c:	6d6c206c 00003274 73696f48 6e692074     l lmt2..Hoist in
  41b57c:	20747570 6e676973 00736c61 7074754f     put signals.Outp
  41b58c:	73207475 616e6769 0000736c 75716552     ut signals..Requ
  41b59c:	20747365 736e6970 00000000 00003659     est pins....Y6..
  41b5ac:	00003759 00003859 20425443 00003059     Y7..Y8..CTB Y0..
  41b5bc:	20425443 00003159 20425443 00003259     CTB Y1..CTB Y2..
  41b5cc:	20425443 00003359 20425443 00003459     CTB Y3..CTB Y4..
  41b5dc:	20425443 00003559                       CTB Y5..

0041b5e4 <compsin_lup_table>:
  41b5e4:	3f800000 3f7fff2e 3f7ffcb9 3f7ff8a0     ...?...?...?...?
  41b5f4:	3f7ff2e4 3f7feb84 3f7fe281 3f7fd7d9     ...?...?...?...?
  41b604:	3f7fcb8d 3f7fbd9c 3f7fae07 3f7f9ccd     ...?...?...?...?
  41b614:	3f7f89ee 3f7f7569 3f7f5f3d 3f7f476c     ...?iu.?=_.?lG.?
  41b624:	3f7f2df3 3f7f12d2 3f7ef60a 3f7ed799     .-.?...?..~?..~?
  41b634:	3f7eb77f 3f7e95bb 3f7e724d 3f7e4d33     ..~?..~?Mr~?3M~?
  41b644:	3f7e266e 3f7dfdfc 3f7dd3dc 3f7da80f     n&~?..}?..}?..}?
  41b654:	3f7d7a92 3f7d4b65 3f7d1a87 3f7ce7f6     .z}?eK}?..}?..|?
  41b664:	3f7cb3b3 3f7c7dbc 3f7c4610 3f7c0cad     ..|?.}|?.F|?..|?
  41b674:	3f7bd193 3f7b94c0 3f7b5634 3f7b15ec     ..{?..{?4V{?..{?
  41b684:	3f7ad3e7 3f7a9025 3f7a4aa3 3f7a0361     ..z?%.z?.Jz?a.z?
  41b694:	3f79ba5c 3f796f93 3f792305 3f78d4b0     \.y?.oy?.#y?..x?
  41b6a4:	3f788492 3f7832aa 3f77def6 3f778973     ..x?.2x?..w?s.w?
  41b6b4:	3f773220 3f76d8fc 3f767e04 3f762135      2w?..v?.~v?5!v?
  41b6c4:	3f75c28f 3f75620f 3f74ffb3 3f749b78     ..u?.bu?..t?x.t?
  41b6d4:	3f74355c 3f73cd5d 3f736379 3f72f7ac     \5t?].s?ycs?..r?
  41b6e4:	3f7289f5 3f721a50 3f71a8bc 3f713535     ..r?P.r?..q?55q?
  41b6f4:	3f70bfb9 3f704844 3f6fced4 3f6f5366     ..p?DHp?..o?fSo?
  41b704:	3f6ed5f6 3f6e5682 3f6dd506 3f6d517f     ..n?.Vn?..m?.Qm?
  41b714:	3f6ccbea 3f6c4443 3f6bba86 3f6b2eb0     ..l?CDl?..k?..k?
  41b724:	3f6aa0bc 3f6a10a9 3f697e70 3f68ea0e     ..j?..j?p~i?..h?
  41b734:	3f685380 3f67bac0 3f671fcb 3f66829c     .Sh?..g?..g?..f?
  41b744:	3f65e32f 3f65417e 3f649d85 3f63f73f     /.e?~Ae?..d??.c?
  41b754:	3f634ea7 3f62a3b9 3f61f66d 3f6146c0     .Nc?..b?m.a?.Fa?
  41b764:	3f6094ab 3f5fe029 3f5f2934 3f5e6fc5     ..`?)._?4)_?.o^?
  41b774:	3f5db3d7 3f5cf564 3f5c3464 3f5b70d1     ..]?d.\?d4\?.p[?
  41b784:	3f5aaaa4 3f59e1d6 3f591660 3f584839     ..Z?..Y?`.Y?9HX?
  41b794:	3f57775c 3f56a3bf 3f55cd5a 3f54f425     \wW?..V?Z.U?%.T?
  41b7a4:	3f541817 3f533928 3f52574e 3f517280     ..T?(9S?NWR?.rQ?
  41b7b4:	3f508ab5 3f4f9fe1 3f4eb1fb 3f4dc0f8     ..P?..O?..N?..M?
  41b7c4:	3f4ccccd 3f4bd56f 3f4adad2 3f49dcea     ..L?o.K?..J?..I?
  41b7d4:	3f48dbaa 3f47d706 3f46cef0 3f45c35b     ..H?..G?..F?[.E?
  41b7e4:	3f44b438 3f43a178 3f428b0c 3f4170e5     8.D?x.C?..B?.pA?
  41b7f4:	3f4052f1 3f3f3120 3f3e0b60 3f3ce19f     .R@? 1??`.>?..<?
  41b804:	3f3bb3ca 3f3a81cc 3f394b92 3f381106     ..;?..:?.K9?..8?
  41b814:	3f36d211 3f358e9c 3f344690 3f32f9d2     ..6?..5?.F4?..2?
  41b824:	3f31a849 3f3051d8 3f2ef664 3f2d95ce     I.1?.Q0?d..?..-?
  41b834:	3f2c2ff7 3f2ac4bd 3f2953fd 3f27dd94     ./,?..*?.S)?..'?
  41b844:	3f26615c 3f24df2b 3f2356d8 3f21c836     \a&?+.$?.V#?6.!?
  41b854:	3f203316 3f1e9746 3f1cf492 3f1b4ac1     .3 ?F..?...?.J.?
  41b864:	3f19999a 3f17e0dc 3f162045 3f14578e     ...?...?E .?.W.?
  41b874:	3f12866a 3f10ac8a 3f0ec995 3f0cdd2e     j..?...?...?...?
  41b884:	3f0ae6f1 3f08e672 3f06db3b 3f04c4ce     ...?r..?;..?...?
  41b894:	3f02a2a1 3f00741f 3efc7146 3ef7def6     ...?.t.?Fq.>...>
  41b8a4:	3ef32fc0 3eee61f2 3ee973a8 3ee462c8     ./.>.a.>.s.>.b.>
  41b8b4:	3edf2cf6 3ed9cf8b 3ed44788 3ece9180     .,.>...>.G.>...>
  41b8c4:	3ec8a986 3ec28b0c 3ebc30c3 3eb59463     ...>...>.0.>c..>
  41b8d4:	3eaeae6b 3ea775c3 3e9fdf38 3e97dcb7     k..>.u.>8..>...>
  41b8e4:	3e8f5c29 3e86459e 3e78f07f 3e6389ac     )\.>.E.>..x>..c>
  41b8f4:	3e4bc5ff 3e30b216 3e1073f6 3dcc8b39     ..K>..0>.s.>9..=
  41b904:	76697244 65732065 65722074 726f7473     Drive set restor
  41b914:	00216465 7466694c 74657320 73657220     ed!.Lift set res
  41b924:	65726f74 00002164 73696f48 61642074     tored!..Hoist da
  41b934:	73206174 64657661 00000021 74636146     ta saved!...Fact
  41b944:	2079726f 20746573 74736572 6465726f     ory set restored
  41b954:	00000021 61746144 76617320 00006465     !...Data saved..
  41b964:	76697244 61642065 73206174 64657661     Drive data saved
  41b974:	00000021 7466694c 74616420 61732061     !...Lift data sa
  41b984:	21646576 00000000                       ved!....

0041b98c <aucCRCHi>:
  41b98c:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41b99c:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41b9ac:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41b9bc:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41b9cc:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41b9dc:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41b9ec:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41b9fc:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41ba0c:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41ba1c:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41ba2c:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41ba3c:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41ba4c:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@
  41ba5c:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41ba6c:	4180c001 4081c100 4081c100 4180c001     ...A...@...@...A
  41ba7c:	4081c100 4180c001 4180c001 4081c100     ...@...A...A...@

0041ba8c <aucCRCLo>:
  41ba8c:	01c1c000 c20203c3 c70706c6 04c4c505     ................
  41ba9c:	cd0d0ccc 0ececf0f 0bcbca0a c80809c9     ................
  41baac:	d91918d8 1adadb1b 1fdfde1e dc1c1ddd     ................
  41babc:	15d5d414 d61617d7 d31312d2 10d0d111     ................
  41bacc:	f13130f0 32f2f333 37f7f636 f43435f5     .01.3..26..7.54.
  41badc:	3dfdfc3c fe3e3fff fb3b3afa 38f8f939     <..=.?>..:;.9..8
  41baec:	29e9e828 ea2a2beb ef2f2eee 2ceced2d     (..).+*.../.-..,
  41bafc:	e52524e4 26e6e727 23e3e222 e02021e1     .$%.'..&"..#.! .
  41bb0c:	a16160a0 62a2a363 67a7a666 a46465a5     .`a.c..bf..g.ed.
  41bb1c:	6dadac6c ae6e6faf ab6b6aaa 68a8a969     l..m.on..jk.i..h
  41bb2c:	79b9b878 ba7a7bbb bf7f7ebe 7cbcbd7d     x..y.{z..~..}..|
  41bb3c:	b57574b4 76b6b777 73b3b272 b07071b1     .tu.w..vr..s.qp.
  41bb4c:	51919050 92525393 97575696 54949555     P..Q.SR..VW.U..T
  41bb5c:	9d5d5c9c 5e9e9f5f 5b9b9a5a 98585999     .\]._..^Z..[.YX.
  41bb6c:	89494888 4a8a8b4b 4f8f8e4e 8c4c4d8d     .HI.K..JN..O.ML.
  41bb7c:	45858444 86464787 83434282 40808141     D..E.GF..BC.A..@

0041bb8c <font>:
  41bb8c:	02040007 000402ff 20000700 2040ff40     ........... @.@ 
  41bb9c:	00070000 ffe3ffff 070000ff f981ff00     ................
  41bbac:	0000ffed 1c3e0005 00000008 81ff0800     ......>.........
  41bbbc:	81a5a599 ff0800ff a5bda581 0800ff81     ................
  41bbcc:	18180000 00000018 06040008 00040607     ................
  41bbdc:	20000800 2060e060 00080000 66e76624     ... `.` ....$f.f
  41bbec:	08000024 00000000 00000000 00000008     $...............
  41bbfc:	00000000 00000800 00000000 00080000     ................
  41bc0c:	00000000 08000000 00000000 00000000     ................
  41bc1c:	00000008 00000000 00000800 00000000     ................
  41bc2c:	00080000 00000000 08000000 00000000     ................
  41bc3c:	00000000 00000008 00000000 00000800     ................
  41bc4c:	00000000 00080000 00000000 08000000     ................
	...
  41bc64:	00000008 00000000 00000800 00000000     ................
  41bc74:	00080000 00000000 08000000 00000000     ................
  41bc84:	00000000 00000008 00000000 00000800     ................
  41bc94:	00000000 00080000 00000000 08000000     ................
	...
  41bcac:	00000003 00000000 00000800 0000004f     ............O...
  41bcbc:	00080000 00070007 08000000 147f1400     ................
  41bccc:	0000147f 2a240008 00122a7f 23000800     ......$*.*.....#
  41bcdc:	62640813 00080000 22554936 08000040     ..db....6IU"@...
  41bcec:	03050000 00000000 221c0004 00000041     ..........."A...
  41bcfc:	41000400 00001c22 00080000 083e0814     ...A".........>.
  41bd0c:	08000014 3e080800 00000808 28000008     .......>.......(
  41bd1c:	00000018 08000800 08080808 00040008     ................
  41bd2c:	00003030 05000000 08102000 00000204     00....... ......
  41bd3c:	513e0007 003e4549 42000500 0000407f     ..>QIE>....B.@..
  41bd4c:	00070000 49516142 07000046 45412100     ....BaQIF....!AE
  41bd5c:	0000314b 14180007 00107f12 27000700     K1.............'
  41bd6c:	39454545 00070000 49494a3c 07000030     EEE9....<JII0...
  41bd7c:	09710100 00000305 49360007 00364949     ..q.......6III6.
  41bd8c:	06000700 1e294949 00040000 00003636     ....II).....66..
  41bd9c:	08000000 36560000 00000000 14080008     ......V6........
  41bdac:	00004122 24000800 24242424 00080000     "A.....$$$$$....
  41bdbc:	14224100 08000008 51010200 00000609     .A"........Q....
  41bdcc:	49320008 003e4179 7e000600 7e111111     ..2IyA>....~...~
  41bddc:	00060000 4949497f 06000036 41413e00     .....III6....>AA
  41bdec:	00002241 417f0006 001c2241 7f000600     A".....AA"......
  41bdfc:	41494949 00060000 0909097f 06000001     IIIA............
  41be0c:	49413e00 00003a49 087f0006 007f0808     .>AII:..........
  41be1c:	00000600 00417f41 00060000 3f414020     ....A.A..... @A?
  41be2c:	06000001 14087f00 00004122 407f0006     ........"A.....@
  41be3c:	00404040 7f000600 7f020c02 00060000     @@@.............
  41be4c:	1008047f 0600007f 41413e00 00003e41     .........>AAA>..
  41be5c:	097f0006 00060909 413e0500 005e2151     ..........>AQ!^.
  41be6c:	00060000 2919097f 06000046 49494600     .......)F....FII
  41be7c:	00003149 01010006 0001017f 3f000600     I1.............?
  41be8c:	3f404040 00060000 2040201f 0600001f     @@@?..... @ ....
  41be9c:	60403f00 00003f40 14630006 00631408     .?@`@?....c...c.
  41beac:	07000600 07087008 00060000 45495161     .....p......aQIE
  41bebc:	04000043 41417f00 00000000 16150006     C.....AA........
  41becc:	0015167c 41000400 00007f41 00060000     |......AA.......
  41bedc:	02010204 06000004 40404000 00004040     .........@@@@@..
  41beec:	02010004 00000004 20000600 78545454     ........... TTTx
  41befc:	00060000 4444447f 05000038 44443800     .....DDD8....8DD
  41bf0c:	00000044 44380006 007f4844 38000600     D.....8DDH.....8
  41bf1c:	18545454 00060000 01117e10 06000002     TTT......~......
  41bf2c:	52520c00 00003e52 087f0006 00780404     ..RRR>........x.
  41bf3c:	44000400 0000407d 00050000 3d404020     ...D}@...... @@=
  41bf4c:	05000000 28107f00 00000044 41000005     .......(D......A
  41bf5c:	0000407f 7c000600 78041804 00060000     .@.....|...x....
  41bf6c:	0404087c 06000078 44443800 00003844     |...x....8DDD8..
  41bf7c:	147c0006 00081414 08000600 7c181414     ..|............|
  41bf8c:	00060000 0404087c 06000008 54544800     ....|........HTT
  41bf9c:	00002054 3f040006 00204044 3c000600     T .....?D@ ....<
  41bfac:	7c204040 00060000 2040201c 0600001c     @@ |..... @ ....
  41bfbc:	20403c00 00003c40 14220006 00221408     .<@ @<...."...".
  41bfcc:	06000600 3e484848 00060000 4c546444     ....HHH>....DdTL
  41bfdc:	04000044 41360800 00000000 00000004     D.....6A........
  41bfec:	0000007f 41000400 00000836 00060000     .......A6.......
  41bffc:	1c2a0808 06000008 2a1c0800 00000808     ..*........*....
  41c00c:	423c0006 003c4241 04000700 24251d06     ..<BAB<.......%$
  41c01c:	20040020 003028a0 04000000 20b02020      .. .(0.....  . 
  41c02c:	00000000 28300008 3020a020 22200620     ......0( . 0 . "
  41c03c:	30282220 20060000 30222022 08000020      "(0... " "0 ...
  41c04c:	22283000 20302220 21222006 00302822     .0(" "0 . "!"(0.
  41c05c:	22200500 20202231 00082020 21222830     .. "1"    ..0("!
  41c06c:	06203022 28282820 202020b0 28282008     "0 . (((.   . ((
  41c07c:	20203028 28200820 2030282a 00062020     (0   . (*(0   ..
  41c08c:	38242424 06202020 24252400 20202038     $$$8   ..$%$8   
  41c09c:	80800006 20203040 80000620 20344080     ....@0   ....@4 
  41c0ac:	20062020 20382038 07000018 38203820       . 8 8 .... 8 8
  41c0bc:	00203820 80806008 20382078 38200618      8 ..`..x 8 .. 8
  41c0cc:	18223922 20072020 22392238 08202038     "9".  . 8"9"8  .
  41c0dc:	78808060 18223922 20302007 18282830     `..x"9".. 0 0((.
  41c0ec:	30200820 28283020 60082038 30608080      . 0 0((8 .`..`0
  41c0fc:	07382828 30203020 20182a28 20302008     ((8. 0 0(*. . 0 
  41c10c:	382a2830 80600820 28306080 2008382a     0(*8 .`..`0(*8. 
  41c11c:	28303e20 08203828 303e2020 20382a28      >0((8 .  >0(*8 
  41c12c:	28302005 20200028 30200520 20202828     . 0((.   . 0((  
  41c13c:	00072020 28b0a040 05202028 2a283020       ..@..((  . 0(*
  41c14c:	20202000 28302005 2020202a 40000720     .   . 0(*    ..@
  41c15c:	2a28b0a0 20052020 302a2830 06000000     ..(*  . 0(*0....
  41c16c:	2a283020 20202030 20180008 2a283020      0(*0   ...  0(*
  41c17c:	30200530 0032282a 20060000 32282a30     0. 0*(2.... 0*(2
  41c18c:	07202020 b2808060 20207aa8 25252208        .`....z  ."%%
  41c19c:	25252525 20200719 2021221c 30072020     %%%%..  ."!   .0
  41c1ac:	202a2c28 0320203f 00001f20 00000000     (,* ?  . .......
  41c1bc:	201f2003 20202020 30000620 203f4040     . .      ..0@@? 
  41c1cc:	20062020 48483020 06202030 48483020       .  0HH0  . 0HH
  41c1dc:	20202030 30408007 20304848 22200520     0   ..@0HH0  . "
  41c1ec:	20001820 20052020 2020201a 06202020      ..   . .      .
  41c1fc:	40444030 20202030 28302006 20182c3a     0@D@0   . 0(:,. 
  41c20c:	30200720 382c3a28 00062020 18141418      . 0(:,8  ......
  41c21c:	08202020 24222100 000f1028 a8b00005        ..!"$(.......
  41c22c:	20202078 a0200620 3028a020 20052020     x    . . .(0  . 
  41c23c:	20a030a0 08202020 80806000 201050a0     .0.    ..`...P. 
  41c24c:	201e0003 00000000 20000700 20282830     ... ....... 0(( 
  41c25c:	00080000 3a020204 07010202 3d060400     .......:.......=
  41c26c:	00000405 04000008 047dadb6 00000800     ..........}.....
  41c27c:	a0bfc080 04080080 a8958566 030048a8     ........f....H..
  41c28c:	00003f00 00000000 28300008 2820a020     .?........0( . (
  41c29c:	30000530 0032282a 00080000 20222830     0..0*(2.....0(" 
  41c2ac:	08302822 22283000 30282221 a8c00007     "(0..0("!"(0....
  41c2bc:	20b028a8 c0000720 30a8a8a8 00072020     .(.  ......0  ..
  41c2cc:	28aaa8c0 06202030 24242400 00000038     ...(0  ..$$$8...
  41c2dc:	25240006 00003824 80000600 00304080     ..$%$8.......@0.
  41c2ec:	00060000 40808000 08000034 78808060     .......@4...`..x
  41c2fc:	18203820 80806008 22392278 80600818      8 ..`..x"9"..`.
  41c30c:	28306080 60081828 30608080 07182a28     .`0((..`..`0(*..
  41c31c:	08142200 00002214 303e2007 00182828     ."..."... >0((..
  41c32c:	3e200700 182a2830 00070000 28b0a040     .. >0(*.....@..(
  41c33c:	07000028 b0a04000 0000282a 20202007     (....@..*(...   
  41c34c:	20202020 18000820 28302020 0008302a          ...  0(*0..
  41c35c:	b2808060 08007aa8 2c283000 003f202a     `....z...0(,* ?.
  41c36c:	a9400008 00f0a8aa 60000600 007e8080     ..@........`..~.
  41c37c:	00080000 aaa9aa40 080000f0 3020c000     ....@......... 0
  41c38c:	00302828 80600007 00608088 30000600     ((0...`...`....0
  41c39c:	00302828 00060000 78a8b000 08000000     ((0........x....
  41c3ac:	25252604 000f1028 22220408 0f102926     .&%%(.....""&)..
  41c3bc:	21000800 d0a82422 0008a0af aaa9aa70     ...!"$......p...
  41c3cc:	08000030 a8aa7000 000030aa 40300008     0....p...0....0@
  41c3dc:	08285040 30000800 28d040c0 00080008     @P(....0.@.(....
  41c3ec:	02790200 08000000 78020000 00000002     ..y........x....
  41c3fc:	00000008 05050000 00000805 0b030400     ................
  41c40c:	a0080606 0000a0a0 08000000 01010000     ................
  41c41c:	00000101 22210008 2f102824 00000820     ......!"$(./ ...
  41c42c:	04000000 00080303 80808000 08000080     ................
  41c43c:	10100000 00101054 02000008 02040204     ....T...........
  41c44c:	21000800 30282422 2008003f 35252624     ...!"$(0?.. $&%5
  41c45c:	08202020 8a8a6c08 201050a0 adb60408        ..l...P. ....
  41c46c:	2020247d 19000620 20181514 04080000     }$   ...... ....
  41c47c:	221a0202 08202122 50604000 40405048     ...""! ..@`PHP@@

0041c48c <map>:
  41c48c:	000000c1 000000c1 000000c1 000000c1     ................
	...
  41c4a4:	000000c2 000000c2 000000fe 000000fe     ................
  41c4b4:	00000001 00000000 000000c3 000000c3     ................
  41c4c4:	00000081 00000081 00000001 00000000     ................
  41c4d4:	000000c4 000000c4 000000fc 000000fc     ................
  41c4e4:	00000001 00000000 000000c5 000000c5     ................
  41c4f4:	000000c5 000000c5 00000001 00000001     ................
  41c504:	000000c6 000000bd 000000bf 000000be     ................
  41c514:	00000001 00000001 000000c7 000000c7     ................
  41c524:	000000c0 000000c0 00000001 00000000     ................
  41c534:	000000c8 00000082 00000084 00000083     ................
  41c544:	00000001 00000001 000000c9 000000c9     ................
  41c554:	000000fd 000000fd 00000001 00000000     ................
  41c564:	000000ca 00000085 00000087 00000086     ................
  41c574:	00000001 00000001 000000cb 00000088     ................
  41c584:	0000008a 00000089 00000001 00000001     ................
  41c594:	000000cc 0000008b 000000cc 0000008b     ................
  41c5a4:	00000001 00000001 000000cd 0000008c     ................
  41c5b4:	000000cd 0000008c 00000001 00000001     ................
  41c5c4:	000000ce 0000008d 000000ce 0000008d     ................
  41c5d4:	00000001 00000001 000000cf 000000cf     ................
  41c5e4:	0000008e 0000008e 00000001 00000000     ................
  41c5f4:	000000d0 000000d0 0000008f 0000008f     ................
  41c604:	00000001 00000000 000000d1 000000d1     ................
  41c614:	00000090 00000090 00000001 00000000     ................
  41c624:	000000d2 000000d2 00000091 00000091     ................
  41c634:	00000001 00000000 000000d3 00000092     ................
  41c644:	00000094 00000093 00000001 00000001     ................
  41c654:	000000d4 00000095 00000097 00000096     ................
  41c664:	00000001 00000001 000000d5 00000098     ................
  41c674:	0000009a 00000099 00000001 00000001     ................
  41c684:	000000d6 0000009b 0000009d 0000009c     ................
  41c694:	00000001 00000001 000000d7 000000d7     ................
  41c6a4:	000000d7 000000d7 00000000 00000000     ................
  41c6b4:	000000d8 000000d8 0000009e 0000009e     ................
  41c6c4:	00000001 00000001 000000d9 000000d9     ................
  41c6d4:	0000009f 0000009f 00000001 00000001     ................
  41c6e4:	000000da 000000a0 000000a2 000000a1     ................
  41c6f4:	00000001 00000001 000000db 000000a3     ................
  41c704:	000000a5 000000a4 00000001 00000001     ................
  41c714:	000000dc 000000dc 000000dc 000000dc     ................
	...
  41c72c:	000000dd 000000a6 000000a8 000000a7     ................
  41c73c:	00000001 00000001 000000de 000000a9     ................
  41c74c:	000000ab 000000aa 00000001 00000001     ................
  41c75c:	000000df 000000ac 000000ae 000000ad     ................
  41c76c:	00000001 00000001 000000e0 000000e0     ................
  41c77c:	000000e0 000000e0 00000000 00000000     ................
  41c78c:	000000e1 000000af 000000b1 000000b0     ................
  41c79c:	00000001 00000001 000000e2 000000e2     ................
  41c7ac:	0000010a 000000e2 00000000 00000000     ................
  41c7bc:	000000e3 000000b2 000000b4 000000b3     ................
  41c7cc:	00000001 00000001 000000e4 000000b5     ................
  41c7dc:	000000b7 000000b6 00000001 00000001     ................
  41c7ec:	000000e5 000000b8 000000ba 000000b9     ................
  41c7fc:	00000001 00000001 000000e6 000000e6     ................
  41c80c:	000000bc 000000bc 00000001 00000000     ................
  41c81c:	000000e7 000000e7 000000e7 000000e7     ................
	...
  41c834:	000000e8 000000e8 000000e8 000000e8     ................
	...
  41c84c:	000000e9 000000e9 000000e9 000000e9     ................
	...
  41c864:	000000ea 000000ea 000000ea 000000ea     ................
	...
  41c87c:	000000eb 000000eb 000000eb 000000eb     ................
	...
  41c894:	000000ec 000000bd 000000bf 000000be     ................
  41c8a4:	00000001 00000001 000000ed 000000bd     ................
  41c8b4:	000000bf 000000be 00000001 00000001     ................
  41c8c4:	000000ee 000000ee 000000ee 000000ee     ................
	...
  41c8dc:	000000ef 000000ef 000000ef 000000ef     ................
	...
  41c8f4:	000000f0 000000f0 000000f0 000000f0     ................
	...
  41c90c:	000000f1 000000f1 000000f1 000000f1     ................
	...
  41c924:	000000f2 000000f2 000000f2 000000f2     ................
	...
  41c93c:	000000f3 000000f3 000000f3 000000f3     ................
	...
  41c954:	000000f5 000000f5 000000f5 000000f5     ................
	...
  41c96c:	000000f6 000000f6 000000f6 000000f6     ................
	...
  41c984:	000000f7 000000f7 000000f7 000000f7     ................
	...
  41c99c:	000000f8 000000f8 000000f8 000000f8     ................
	...
  41c9b4:	000000fb 000000f9 000000fb 000000fa     ................
  41c9c4:	00000001 00000001 000000bb 000000bb     ................
  41c9d4:	000000f4 000000f4 00000001 00000000     ................
  41c9e4:	65746e45 61702072 6f777373 00006472     Enter password..
  41c9f4:	00006f4e 00736559 00003032              No..Yes.20..

0041ca00 <CSWTCH.9>:
  41ca00:	0041ca44 0041ca48 0041ca4c 0041ca50     D.A.H.A.L.A.P.A.
  41ca10:	0041ca28 0041ca54 0041ca58              (.A.T.A.X.A.

0041ca1c <month_max>:
  41ca1c:	1e1f1d1f 1f1f1e1f 1f1e1f1e 00697246     ............Fri.
  41ca2c:	65746144 74657320 00000021 656d6954     Date set!...Time
  41ca3c:	74657320 00000021 006e6f4d 00657554      set!...Mon.Tue.
  41ca4c:	00646557 00756854 00746153 006e7553     Wed.Thu.Sat.Sun.
  41ca5c:	5f434e45 656e7554 63755320 73736563     ENC_Tune Success
  41ca6c:	006c7566 00000001 00000002 00000004     ful.............
  41ca7c:	00000008 00000010 00000020 00000040     ........ ...@...
  41ca8c:	00000080 00000100 00000200 00000400     ................
  41ca9c:	7265764f 6c6f7620 65676174 00000000     Over voltage....
  41caac:	7265764f 72756320 746e6572 00000000     Over current....
  41cabc:	7074756f 73207475 74726f68 72696320     output short cir
  41cacc:	74697563 00000000 54424749 65766f20     cuit....IGBT ove
  41cadc:	65742072 7265706d 72757461 00000065     r temperature...
  41caec:	76697244 6e452065 72726520 0000726f     Drive En error..
  41cafc:	73616850 61662065 00006c69 6f746f4d     Phase fail..Moto
  41cb0c:	68502072 20657361 6c696166 00000000     r Phase fail....
  41cb1c:	43204750 004d4d4f 746e6f43 206c6f72     PG COMM.Control 
  41cb2c:	65646f6d 746f6e20 70757320 00000070     mode not supp...
  41cb3c:	65657053 65642064 74616976 006e6f69     Speed deviation.
  41cb4c:	20445241 65646e55 6f762072 6761746c     ARD Under voltag
  41cb5c:	00000065 7320535a 6f767265 74756f20     e...ZS servo out
  41cb6c:	20666f20 676e6172 00000065 656e7554      of range...Tune
  41cb7c:	72452031 00726f72 6b617242 68732065     1 Error.Brake sh
  41cb8c:	2074726f 00007463 65646e55 52412072     ort ct..Under AR
  41cb9c:	6f762044 6761746c 00000065 436e6953     D voltage...SinC
  41cbac:	7320736f 6d206769 69737369 0000676e     os sig missing..
  41cbbc:	65736552 656e2074 64656465 00000000     Reset needed....
  41cbcc:	65524457 00746573 44575352 65736552     WDReset.RSWDRese
  41cbdc:	00000074 74696e69 75616620 0000746c     t...init fault..
  41cbec:	20434f4d 66204246 746c7561 00000000     MOC FB fault....
  41cbfc:	206b7242 66204246 746c7561 00000000     Brk FB fault....
  41cc0c:	46207846 61662042 00746c75 20636341     Fx FB fault.Acc 
  41cc1c:	7265764f 72727543 00746e65 20636544     OverCurrent.Dec 
  41cc2c:	7265764f 72727543 00746e65 74736944     OverCurrent.Dist
  41cc3c:	65636e61 76656420 00000000 000f4240     ance dev....@B..
  41cc4c:	000000c0 00000003 00000000 00000001     ................
  41cc5c:	00000002 00000004 00000008 00000010     ................
  41cc6c:	00000020 00000040 00000080 00000100      ...@...........
  41cc7c:	00000200 00000400                       ........

0041cc84 <SVM_SIN_tab>:
  41cc84:	00000000 000725a9 000e4b4c 001570e4     .....%..LK...p..
  41cc94:	001c966b 0023bbda 002ae12e 0032065f     k.....#...*._.2.
  41cca4:	00392b68 00405043 004774ec 004e995b     h+9.CP@..tG.[.N.
  41ccb4:	0055bd8b 005ce177 00640518 006b286a     ..U.w.\...d.j(k.
  41ccc4:	00724b66 00796e07 00809047 0087b221     fKr..ny.G...!...
  41ccd4:	008ed38e 0095f489 009d150c 00a43511     .............5..
  41cce4:	00ab5494 00b2738e 00b991f9 00c0afd0     .T...s..........
  41ccf4:	00c7cd0e 00cee9ab 00d605a4 00dd20f1     ............. ..
  41cd04:	00e43b8e 00eb5575 00f26ea0 00f98709     .;..uU...n......
  41cd14:	01009eab 0107b580 010ecb82 0115e0ad     ................
  41cd24:	011cf4f9 01240862 012b1ae1 01322c72     ....b.$...+.r,2.
  41cd34:	01393d0e 01404cb0 01475b53 014e68f0     .=9..L@.S[G..hN.
  41cd44:	01557582 015c8103 01638b6e 016a94bd     .uU...\.n.c...j.
  41cd54:	01719cea 0178a3f1 017fa9ca 0186ae71     ..q...x.....q...
  41cd64:	018db1e1 0194b412 019bb501 01a2b4a7     ................
  41cd74:	01a9b2fe 01b0b001 01b7abab 01bea5f6     ................
  41cd84:	01c59edc 01cc9658 01d38c64 01da80fb     ....X...d.......
  41cd94:	01e17417 01e865b2 01ef55c8 01f64452     .t...e...U..RD..
  41cda4:	01fd314b 02041cad 020b0673 0211ee97     K1......s.......
  41cdb4:	0218d514 021fb9e5 02269d03 022d7e6a     ..........&.j~-.
  41cdc4:	02345e14 023b3bfa 02421819 0248f26a     .^4..;;...B.j.H.
  41cdd4:	024fcae8 0256a18e 025d7655 02644939     ..O...V.Uv].9Id.
  41cde4:	026b1a34 0271e940 0278b659 027f8179     4.k.@.q.Y.x.y...
  41cdf4:	02864a99 028d11b6 0293d6c9 029a99ce     .J..............
  41ce04:	02a15abe 02a81994 02aed64b 02b590de     .Z......K.......
  41ce14:	02bc4947 02c2ff81 02c9b386 02d06552     GI..........Re..
  41ce24:	02d714de 02ddc225 02e46d22 02eb15d1     ....%..."m......
  41ce34:	02f1bc2a 02f8602a 02ff01cb 0305a107     *...*`..........
  41ce44:	030c3dd9 0312d83c 0319702b 032005a1     .=..<...+p.... .
  41ce54:	03269897 032d290a 0333b6f3 033a424d     ..&..)-...3.MB:.
  41ce64:	0340cb14 03475142 034dd4d1 035455bd     ..@.BQG...M..UT.
  41ce74:	035ad401 03614f97 0367c879 036e3ea4     ..Z..Oa.y.g..>n.
  41ce84:	0374b211 037b22bc 0381909f 0387fbb5     ..t.."{.........
  41ce94:	038e63fa 0394c967 039b2bf9 03a18ba9     .c..g....+......
  41cea4:	03a7e873 03ae4252 03b49940 03baed39     s...RB..@...9...
  41ceb4:	03c13e37 03c78c35 03cdd72f 03d41f20     7>..5.../... ...
  41cec4:	03da6401 03e0a5d0 03e6e485 03ed201d     .d........... ..
  41ced4:	03f35892 03f98ddf 03ffc000 0405eeef     .X..............
  41cee4:	040c1aa8 04124326 04186863 041e8a5b     ....&C..ch..[...
  41cef4:	0424a90a 042ac469 0430dc74 0436f126     ..$.i.*.t.0.&.6.
  41cf04:	043d027b 0443106e 04491af9 044f2218     {.=.n.C...I.."O.
  41cf14:	045525c7 045b25ff 046122bd 04671bfc     .%U..%[.."a...g.
  41cf24:	046d11b7 047303e9 0478f28d 047edda0     ..m...s...x...~.
  41cf34:	0484c51b 048aa8fa 04908939 049665d3     ........9....e..
  41cf44:	049c3ec3 04a21405 04a7e593 04adb36a     .>..........j...
  41cf54:	04b37d85 04b943de 04bf0672 04c4c53b     .}...C..r...;...
  41cf64:	04ca8036 04d0375d 04d5eaac 04db9a1f     6...]7..........
  41cf74:	04e145b0 04e6ed5c 04ec911e 04f230f2     .E..\........0..
  41cf84:	04f7ccd2 04fd64bb 0502f8a7 05088894     .....d..........
  41cf94:	050e147b 05139c59 05192029 051e9fe6     {...Y...) ......
  41cfa4:	05241b8e 0529931a 052f0687 053475d0     ..$...).../..u4.
  41cfb4:	0539e0f2 053f47e7 0544aaab 054a093a     ..9..G?...D.:.J.
  41cfc4:	054f6390 0554b9a9 055a0b80 055f5910     .cO...T...Z..Y_.
  41cfd4:	0564a257 0569e74f 056f27f4 05746443     W.d.O.i..'o.Cdt.
  41cfe4:	05799c36 057ecfca 0583fefb 058929c4     6.y...~......)..
  41cff4:	058e5022 0593720f 05988f89 059da88b     "P...r..........
  41d004:	05a2bd11 05a7cd17 05acd899 05b1df93     ................
  41d014:	05b6e200 05bbdfdd 05c0d926 05c5cdd7     ........&.......
  41d024:	05cabdec 05cfa961 05d49032 05d9725b     ....a...2...[r..
  41d034:	05de4fd9 05e328a6 05e7fcc0 05eccc23     .O...(......#...
  41d044:	05f196cb 05f65cb3 05fb1dd9 05ffda38     .....\......8...
  41d054:	060491cc 06094493 060df287 06129ba6     .....D..........
  41d064:	06173feb 061bdf54 062079db 06250f7e     .?..T....y .~.%.
  41d074:	0629a039 062e2c08 0632b2e7 063734d4     9.)..,....2..47.
  41d084:	063bb1ca 064029c5 06449cc3 06490ac0     ..;..)@...D...I.
  41d094:	064d73b7 0651d7a7 0656368a 065a905e     .sM...Q..6V.^.Z.
  41d0a4:	065ee51f 066334ca 06677f5b 066bc4cf     ..^..4c.[.g...k.
  41d0b4:	06700522 06744051 06787659 067ca736     ".p.Q@t.Yvx.6.|.
  41d0c4:	0680d2e5 0684f963 06891aab 068d36bc     ....c........6..
  41d0d4:	06914d92 06955f29 06996b7e 069d728e     .M..)_..~k...r..
  41d0e4:	06a17456 06a570d2 06a967ff 06ad59db     Vt...p...g...Y..
  41d0f4:	06b14662 06b52d91 06b90f64 06bcebd9     bF...-..d.......
  41d104:	06c0c2ed 06c4949c 06c860e4 06cc27c1     .........`...'..
  41d114:	06cfe931 06d3a530 06d75bbb 06db0cd0     1...0....[......
  41d124:	06deb86b 06e25e8a 06e5ff2a 06e99a48     k....^..*...H...
  41d134:	06ed2fe0                                ./..

0041d138 <CSWTCH.7>:
  41d138:	00000100 00000300 00000200              ............

0041d144 <sinTable_f32>:
  41d144:	00000000 3c490e92 3cc90ab1 3d16c32b     ......I<...<+..=
  41d154:	3d48fb2e 3d7b2b75 3d96a904 3dafb680     ..H=u+{=...=...=
  41d164:	3dc8bd36 3de1bc2f 3dfab273 3e09cf87     6..=/..=s..=...>
  41d174:	3e164083 3e22abb5 3e2f10a2 3e3b6ecf     .@.>..">../>.n;>
  41d184:	3e47c5c2 3e541501 3e605c13 3e6c9a7f     ..G>..T>.\`>..l>
  41d194:	3e78cfcc 3e827dc0 3e888e93 3e8e9a22     ..x>.}.>...>"..>
  41d1a4:	3e94a032 3e9aa086 3ea09ae5 3ea68f12     2..>...>...>...>
  41d1b4:	3eac7cd4 3eb263ef 3eb8442a 3ebe1d49     .|.>.c.>*D.>I..>
  41d1c4:	3ec3ef15 3ec9b953 3ecf7bca 3ed53641     ...>S..>.{.>A6.>
  41d1d4:	3edae880 3ee0924f 3ee63375 3eebcbbb     ...>O..>u3.>...>
  41d1e4:	3ef15aea 3ef6e0cb 3efc5d27 3f00e7e4     .Z.>...>'].>...?
  41d1f4:	3f039c3d 3f064b82 3f08f59b 3f0b9a6b     =..?.K.?...?k..?
  41d204:	3f0e39da 3f10d3cd 3f13682a 3f15f6d9     .9.?...?*h.?...?
  41d214:	3f187fc0 3f1b02c6 3f1d7fd1 3f1ff6cb     ...?...?...?...?
  41d224:	3f226799 3f24d225 3f273656 3f299415     .g"?%.$?V6'?..)?
  41d234:	3f2beb4a 3f2e3bde 3f3085bb 3f32c8c9     J.+?.;.?..0?..2?
  41d244:	3f3504f3 3f373a23 3f396842 3f3b8f3b     ..5?#:7?Bh9?;.;?
  41d254:	3f3daef9 3f3fc767 3f41d870 3f43e201     ..=?g.??p.A?..C?
  41d264:	3f45e403 3f47de65 3f49d112 3f4bbbf8     ..E?e.G?..I?..K?
  41d274:	3f4d9f02 3f4f7a20 3f514d3d 3f531849     ..M? zO?=MQ?I.S?
  41d284:	3f54db31 3f5695e5 3f584853 3f59f26a     1.T?..V?SHX?j.Y?
  41d294:	3f5b941a 3f5d2d53 3f5ebe05 3f604621     ..[?S-]?..^?!F`?
  41d2a4:	3f61c597 3f633c5a 3f64aa59 3f660f88     ..a?Z<c?Y.d?..f?
  41d2b4:	3f676bd8 3f68bf3c 3f6a09a7 3f6b4b0c     .kg?<.h?..j?.Kk?
  41d2c4:	3f6c835e 3f6db293 3f6ed89e 3f6ff573     ^.l?..m?..n?s.o?
  41d2d4:	3f710908 3f721352 3f731447 3f740bdd     ..q?R.r?G.s?..t?
  41d2e4:	3f74fa0b 3f75dec6 3f76ba07 3f778bc5     ..t?..u?..v?..w?
  41d2f4:	3f7853f8 3f791298 3f79c79d 3f7a7302     .Sx?..y?..y?.sz?
  41d304:	3f7b14be 3f7baccd 3f7c3b28 3f7cbfc9     ..{?..{?(;|?..|?
  41d314:	3f7d3aac 3f7dabcc 3f7e1323 3f7e70b0     .:}?..}?#.~?.p~?
  41d324:	3f7ec46d 3f7f0e58 3f7f4e6d 3f7f84ab     m.~?X..?mN.?...?
  41d334:	3f7fb10f 3f7fd397 3f7fec43 3f7ffb11     ...?...?C..?...?
  41d344:	3f800000 3f7ffb11 3f7fec43 3f7fd397     ...?...?C..?...?
  41d354:	3f7fb10f 3f7f84ab 3f7f4e6d 3f7f0e58     ...?...?mN.?X..?
  41d364:	3f7ec46d 3f7e70b0 3f7e1323 3f7dabcc     m.~?.p~?#.~?..}?
  41d374:	3f7d3aac 3f7cbfc9 3f7c3b28 3f7baccd     .:}?..|?(;|?..{?
  41d384:	3f7b14be 3f7a7302 3f79c79d 3f791298     ..{?.sz?..y?..y?
  41d394:	3f7853f8 3f778bc5 3f76ba07 3f75dec6     .Sx?..w?..v?..u?
  41d3a4:	3f74fa0b 3f740bdd 3f731447 3f721352     ..t?..t?G.s?R.r?
  41d3b4:	3f710908 3f6ff573 3f6ed89e 3f6db293     ..q?s.o?..n?..m?
  41d3c4:	3f6c835e 3f6b4b0c 3f6a09a7 3f68bf3c     ^.l?.Kk?..j?<.h?
  41d3d4:	3f676bd8 3f660f88 3f64aa59 3f633c5a     .kg?..f?Y.d?Z<c?
  41d3e4:	3f61c597 3f604621 3f5ebe05 3f5d2d53     ..a?!F`?..^?S-]?
  41d3f4:	3f5b941a 3f59f26a 3f584853 3f5695e5     ..[?j.Y?SHX?..V?
  41d404:	3f54db31 3f531849 3f514d3d 3f4f7a20     1.T?I.S?=MQ? zO?
  41d414:	3f4d9f02 3f4bbbf8 3f49d112 3f47de65     ..M?..K?..I?e.G?
  41d424:	3f45e403 3f43e201 3f41d870 3f3fc767     ..E?..C?p.A?g.??
  41d434:	3f3daef9 3f3b8f3b 3f396842 3f373a23     ..=?;.;?Bh9?#:7?
  41d444:	3f3504f3 3f32c8c9 3f3085bb 3f2e3bde     ..5?..2?..0?.;.?
  41d454:	3f2beb4a 3f299415 3f273656 3f24d225     J.+?..)?V6'?%.$?
  41d464:	3f226799 3f1ff6cb 3f1d7fd1 3f1b02c6     .g"?...?...?...?
  41d474:	3f187fc0 3f15f6d9 3f13682a 3f10d3cd     ...?...?*h.?...?
  41d484:	3f0e39da 3f0b9a6b 3f08f59b 3f064b82     .9.?k..?...?.K.?
  41d494:	3f039c3d 3f00e7e4 3efc5d27 3ef6e0cb     =..?...?'].>...>
  41d4a4:	3ef15aea 3eebcbbb 3ee63375 3ee0924f     .Z.>...>u3.>O..>
  41d4b4:	3edae880 3ed53641 3ecf7bca 3ec9b953     ...>A6.>.{.>S..>
  41d4c4:	3ec3ef15 3ebe1d49 3eb8442a 3eb263ef     ...>I..>*D.>.c.>
  41d4d4:	3eac7cd4 3ea68f12 3ea09ae5 3e9aa086     .|.>...>...>...>
  41d4e4:	3e94a032 3e8e9a22 3e888e93 3e827dc0     2..>"..>...>.}.>
  41d4f4:	3e78cfcc 3e6c9a7f 3e605c13 3e541501     ..x>..l>.\`>..T>
  41d504:	3e47c5c2 3e3b6ecf 3e2f10a2 3e22abb5     ..G>.n;>../>..">
  41d514:	3e164083 3e09cf87 3dfab273 3de1bc2f     .@.>...>s..=/..=
  41d524:	3dc8bd36 3dafb680 3d96a904 3d7b2b75     6..=...=...=u+{=
  41d534:	3d48fb2e 3d16c32b 3cc90ab1 3c490e92     ..H=+..=...<..I<
  41d544:	00000000 bc490e92 bcc90ab1 bd16c32b     ......I.....+...
  41d554:	bd48fb2e bd7b2b75 bd96a904 bdafb680     ..H.u+{.........
  41d564:	bdc8bd36 bde1bc2f bdfab273 be09cf87     6.../...s.......
  41d574:	be164083 be22abb5 be2f10a2 be3b6ecf     .@....".../..n;.
  41d584:	be47c5c2 be541501 be605c13 be6c9a7f     ..G...T..\`...l.
  41d594:	be78cfcc be827dc0 be888e93 be8e9a22     ..x..}......"...
  41d5a4:	be94a032 be9aa086 bea09ae5 bea68f12     2...............
  41d5b4:	beac7cd4 beb263ef beb8442a bebe1d49     .|...c..*D..I...
  41d5c4:	bec3ef15 bec9b953 becf7bca bed53641     ....S....{..A6..
  41d5d4:	bedae880 bee0924f bee63375 beebcbbb     ....O...u3......
  41d5e4:	bef15aea bef6e0cb befc5d27 bf00e7e4     .Z......']......
  41d5f4:	bf039c3d bf064b82 bf08f59b bf0b9a6b     =....K......k...
  41d604:	bf0e39da bf10d3cd bf13682a bf15f6d9     .9......*h......
  41d614:	bf187fc0 bf1b02c6 bf1d7fd1 bf1ff6cb     ................
  41d624:	bf226799 bf24d225 bf273656 bf299415     .g".%.$.V6'...).
  41d634:	bf2beb4a bf2e3bde bf3085bb bf32c8c9     J.+..;....0...2.
  41d644:	bf3504f3 bf373a23 bf396842 bf3b8f3b     ..5.#:7.Bh9.;.;.
  41d654:	bf3daef9 bf3fc767 bf41d870 bf43e201     ..=.g.?.p.A...C.
  41d664:	bf45e403 bf47de65 bf49d112 bf4bbbf8     ..E.e.G...I...K.
  41d674:	bf4d9f02 bf4f7a20 bf514d3d bf531849     ..M. zO.=MQ.I.S.
  41d684:	bf54db31 bf5695e5 bf584853 bf59f26a     1.T...V.SHX.j.Y.
  41d694:	bf5b941a bf5d2d53 bf5ebe05 bf604621     ..[.S-]...^.!F`.
  41d6a4:	bf61c597 bf633c5a bf64aa59 bf660f88     ..a.Z<c.Y.d...f.
  41d6b4:	bf676bd8 bf68bf3c bf6a09a7 bf6b4b0c     .kg.<.h...j..Kk.
  41d6c4:	bf6c835e bf6db293 bf6ed89e bf6ff573     ^.l...m...n.s.o.
  41d6d4:	bf710908 bf721352 bf731447 bf740bdd     ..q.R.r.G.s...t.
  41d6e4:	bf74fa0b bf75dec6 bf76ba07 bf778bc5     ..t...u...v...w.
  41d6f4:	bf7853f8 bf791298 bf79c79d bf7a7302     .Sx...y...y..sz.
  41d704:	bf7b14be bf7baccd bf7c3b28 bf7cbfc9     ..{...{.(;|...|.
  41d714:	bf7d3aac bf7dabcc bf7e1323 bf7e70b0     .:}...}.#.~..p~.
  41d724:	bf7ec46d bf7f0e58 bf7f4e6d bf7f84ab     m.~.X...mN......
  41d734:	bf7fb10f bf7fd397 bf7fec43 bf7ffb11     ........C.......
  41d744:	bf800000 bf7ffb11 bf7fec43 bf7fd397     ........C.......
  41d754:	bf7fb10f bf7f84ab bf7f4e6d bf7f0e58     ........mN..X...
  41d764:	bf7ec46d bf7e70b0 bf7e1323 bf7dabcc     m.~..p~.#.~...}.
  41d774:	bf7d3aac bf7cbfc9 bf7c3b28 bf7baccd     .:}...|.(;|...{.
  41d784:	bf7b14be bf7a7302 bf79c79d bf791298     ..{..sz...y...y.
  41d794:	bf7853f8 bf778bc5 bf76ba07 bf75dec6     .Sx...w...v...u.
  41d7a4:	bf74fa0b bf740bdd bf731447 bf721352     ..t...t.G.s.R.r.
  41d7b4:	bf710908 bf6ff573 bf6ed89e bf6db293     ..q.s.o...n...m.
  41d7c4:	bf6c835e bf6b4b0c bf6a09a7 bf68bf3c     ^.l..Kk...j.<.h.
  41d7d4:	bf676bd8 bf660f88 bf64aa59 bf633c5a     .kg...f.Y.d.Z<c.
  41d7e4:	bf61c597 bf604621 bf5ebe05 bf5d2d53     ..a.!F`...^.S-].
  41d7f4:	bf5b941a bf59f26a bf584853 bf5695e5     ..[.j.Y.SHX...V.
  41d804:	bf54db31 bf531849 bf514d3d bf4f7a20     1.T.I.S.=MQ. zO.
  41d814:	bf4d9f02 bf4bbbf8 bf49d112 bf47de65     ..M...K...I.e.G.
  41d824:	bf45e403 bf43e201 bf41d870 bf3fc767     ..E...C.p.A.g.?.
  41d834:	bf3daef9 bf3b8f3b bf396842 bf373a23     ..=.;.;.Bh9.#:7.
  41d844:	bf3504f3 bf32c8c9 bf3085bb bf2e3bde     ..5...2...0..;..
  41d854:	bf2beb4a bf299415 bf273656 bf24d225     J.+...).V6'.%.$.
  41d864:	bf226799 bf1ff6cb bf1d7fd1 bf1b02c6     .g".............
  41d874:	bf187fc0 bf15f6d9 bf13682a bf10d3cd     ........*h......
  41d884:	bf0e39da bf0b9a6b bf08f59b bf064b82     .9..k........K..
  41d894:	bf039c3d bf00e7e4 befc5d27 bef6e0cb     =.......']......
  41d8a4:	bef15aea beebcbbb bee63375 bee0924f     .Z......u3..O...
  41d8b4:	bedae880 bed53641 becf7bca bec9b953     ....A6...{..S...
  41d8c4:	bec3ef15 bebe1d49 beb8442a beb263ef     ....I...*D...c..
  41d8d4:	beac7cd4 bea68f12 bea09ae5 be9aa086     .|..............
  41d8e4:	be94a032 be8e9a22 be888e93 be827dc0     2..."........}..
  41d8f4:	be78cfcc be6c9a7f be605c13 be541501     ..x...l..\`...T.
  41d904:	be47c5c2 be3b6ecf be2f10a2 be22abb5     ..G..n;.../...".
  41d914:	be164083 be09cf87 bdfab273 bde1bc2f     .@......s.../...
  41d924:	bdc8bd36 bdafb680 bd96a904 bd7b2b75     6...........u+{.
  41d934:	bd48fb2e bd16c32b bcc90ab1 bc490e92     ..H.+.........I.
  41d944:	80000000 74727173 00000000              ....sqrt....

0041d950 <_global_impure_ptr>:
  41d950:	204003d8                                ..@ 

0041d954 <_init>:
  41d954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41d956:	bf00      	nop
  41d958:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41d95a:	bc08      	pop	{r3}
  41d95c:	469e      	mov	lr, r3
  41d95e:	4770      	bx	lr

0041d960 <__init_array_start>:
  41d960:	0041973d 	.word	0x0041973d

0041d964 <__frame_dummy_init_array_entry>:
  41d964:	00400165                                e.@.

0041d968 <_fini>:
  41d968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41d96a:	bf00      	nop
  41d96c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41d96e:	bc08      	pop	{r3}
  41d970:	469e      	mov	lr, r3
  41d972:	4770      	bx	lr

0041d974 <__fini_array_start>:
  41d974:	00400141 	.word	0x00400141

Disassembly of section .relocate:

20400000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20400000:	f3bf 8f5f 	dmb	sy
20400004:	3801      	subs	r0, #1
20400006:	d1fb      	bne.n	20400000 <portable_delay_cycles>
20400008:	4770      	bx	lr

2040000a <g_interrupt_enabled>:
2040000a:	0001                                        ..

2040000c <SystemCoreClock>:
2040000c:	0900 003d                                   ..=.

20400010 <disSegmentData>:
20400010:	3030 0100                                        00.

20400013 <dir_limit_started>:
20400013:	0401                                             .

20400014 <selector_counter>:
20400014:	0004 0000                                   ....

20400018 <speed_sign>:
20400018:	0101                                             .

20400019 <temp_vfd_const>:
20400019:	0101                                             .

2040001a <Dstop_speed_sign>:
2040001a:	0001                                        ..

2040001c <auto_counter>:
2040001c:	0003 0000                                   ....

20400020 <floor_counter_save>:
20400020:	0001 0000                                   ....

20400024 <atan_lut>:
20400024:	0000 0000 24ab 0000 4956 0000 6e00 0000     .....$..VI...n..
20400034:	92a8 0000 b74f 0000 dbf3 0000 0095 0001     ....O...........
20400044:	2533 0001 49cd 0001 6e63 0001 92f5 0001     3%...I..cn......
20400054:	b781 0001 dc08 0001 0089 0002 2503 0002     .............%..
20400064:	4976 0002 6de2 0002 9246 0002 b6a2 0002     vI...m..F.......
20400074:	daf5 0002 ff3e 0002 237f 0003 47b5 0003     ....>....#...G..
20400084:	6be0 0003 9001 0003 b416 0003 d81f 0003     .k..............
20400094:	fc1c 0003 200d 0004 43f0 0004 67c6 0004     ..... ...C...g..
204000a4:	8b8e 0004 af48 0004 d2f3 0004 f68f 0004     ....H...........
204000b4:	1a1c 0005 3d99 0005 6105 0005 8461 0005     .....=...a..a...
204000c4:	a7ac 0005 cae5 0005 ee0d 0005 1123 0006     ............#...
204000d4:	3426 0006 5717 0006 79f4 0006 9cbe 0006     &4...W...y......
204000e4:	bf74 0006 e216 0006 04a4 0007 271c 0007     t............'..
204000f4:	4980 0007 6bce 0007 8e07 0007 b029 0007     .I...k......)...
20400104:	d235 0007 f42b 0007 1609 0008 37d1 0008     5...+........7..
20400114:	5981 0008 7b19 0008 9c9a 0008 be02 0008     .Y...{..........
20400124:	df51 0008 0088 0009 21a6 0009 42ab 0009     Q........!...B..
20400134:	6397 0009 8468 0009 a520 0009 c5be 0009     .c..h... .......
20400144:	e642 0009 06ab 000a 26f9 000a 472c 000a     B........&..,G..
20400154:	6745 000a 8742 000a a724 000a c6ea 000a     Eg..B...$.......
20400164:	e695 000a 0623 000b 2596 000b 44ec 000b     ....#....%...D..
20400174:	6426 000b 8343 000b a244 000b c128 000b     &d..C...D...(...
20400184:	dfef 000b fe9a 000b 1d27 000c 3b97 000c     ........'....;..
20400194:	59e9 000c 781e 000c 9636 000c b430 000c     .Y...x..6...0...
204001a4:	d20c 000c efcb 000c 0d6c 000d 2aef 000d     ........l....*..
204001b4:	4854 000d 659a 000d 82c3 000d 9fce 000d     TH...e..........
204001c4:	bcba 000d d988 000d f638 000d 12ca 000e     ........8.......
204001d4:	2f3d 000e 4b92 000e 67c8 000e 83e0 000e     =/...K...g......
204001e4:	9fda 000e bbb5 000e d771 000e f30f 000e     ........q.......
204001f4:	0e8f 000f 29f0 000f 4533 000f 6057 000f     .....)..3E..W`..
20400204:	7b5c 000f 9644 000f b10c 000f cbb7 000f     \{..D...........
20400214:	e643 000f 00b0 0010 1b00 0010 3531 0010     C...........15..
20400224:	4f43 0010 6938 0010 830e 0010 9cc6 0010     CO..8i..........
20400234:	b660 0010 cfdc 0010 e93a 0010 027a 0011     `.......:...z...
20400244:	1b9c 0011 34a0 0011 4d87 0011 664f 0011     .....4...M..Of..
20400254:	7efb 0011 9788 0011 aff8 0011 c84a 0011     .~..........J...
20400264:	e07f 0011 f897 0011 1092 0012 286f 0012     ............o(..
20400274:	402f 0012 57d2 0012 6f59 0012 86c2 0012     /@...W..Yo......
20400284:	9e0f 0012 b53f 0012 cc53 0012 e34a 0012     ....?...S...J...
20400294:	fa24 0012 10e3 0013 2785 0013 3e0b 0013     $........'...>..
204002a4:	5475 0013 6ac3 0013 80f5 0013 970b 0013     uT...j..........
204002b4:	ad06 0013 c2e6 0013 d8aa 0013 ee52 0013     ............R...
204002c4:	03e0 0014 1952 0014 2ea9 0014 43e6 0014     ....R........C..
204002d4:	5907 0014 6e0e 0014 82fa 0014 97cc 0014     .Y...n..........
204002e4:	ac84 0014 c121 0014 d5a4 0014 ea0e 0014     ....!...........
204002f4:	fe5d 0014 1292 0015 26ae 0015 3ab1 0015     ]........&...:..
20400304:	4e99 0015 6269 0015 761f 0015 89bc 0015     .N..ib...v......
20400314:	9d40 0015 b0ac 0015 c3fe 0015 d738 0015     @...........8...
20400324:	ea5a 0015 fd63 0015 1053 0016 232c 0016     Z...c...S...,#..
20400334:	35ec 0016 4895 0016 5b26 0016 6d9f 0016     .5...H..&[...m..
20400344:	8000 0016                                   ....

20400348 <surface_print>:
20400348:	56e4 2040                                   .V@ 

2040034c <temp_surface>:
2040034c:	5c04 2040                                   .\@ 

20400350 <buttons>:
20400350:	00ff 0000                                   ....

20400354 <buttons_read_status>:
20400354:	00ff 0000                                   ....

20400358 <KT>:
20400358:	0000 3f80                                   ...?

2040035c <current_limit>:
2040035c:	0000 425c                                   ..\B

20400360 <pos_zs_shutdown>:
20400360:	0001 0000                                   ....

20400364 <ski_hs_var>:
20400364:	0000 3f80                                   ...?

20400368 <ski_ls_var>:
20400368:	0000 3f80                                   ...?

2040036c <trq_in_weignt>:
2040036c:	0000 3f80                                   ...?

20400370 <rated_c>:
20400370:	0000 3f80                                   ...?

20400374 <start_pm_tune>:
20400374:	0001 0000                                   ....

20400378 <vector_min_time>:
20400378:	0000 4f80                                   ...O

2040037c <new_bemf_weight>:
2040037c:	0000 3f80                                   ...?

20400380 <reg_reset_flag>:
20400380:	0001 0000                                   ....

20400384 <vector_IM_flux>:
20400384:	126f 3a83                                   o..:

20400388 <regPM_reset_flag>:
20400388:	0001 0000                                   ....

2040038c <speed_weight>:
2040038c:	0000 3f80                                   ...?

20400390 <c_max>:
20400390:	0eee                                        ..

20400392 <c_min>:
20400392:	0154                                        T.

20400394 <cavg_max>:
20400394:	0eee                                        ..

20400396 <cavg_min>:
20400396:	0154                                        T.

20400398 <s_max>:
20400398:	0eee                                        ..

2040039a <s_min>:
2040039a:	0154                                        T.

2040039c <savg_max>:
2040039c:	0eee                                        ..

2040039e <savg_min>:
2040039e:	0154                                        T.

204003a0 <ersd_ldir>:
204003a0:	0001 0000                                   ....

204003a4 <IGBT_temp>:
204003a4:	8000 000c                                   ....

204003a8 <fan_timer_val>:
204003a8:	0001 0000                                   ....

204003ac <i_adc_v_offset>:
204003ac:	0000 4500 0000 4500 0000 4500               ...E...E...E

204003b8 <inverter_dead_comp>:
204003b8:	0001 0000                                   ....

204003bc <start_avg>:
204003bc:	0001 0000                                   ....

204003c0 <vin_filter_weight>:
204003c0:	8000 0000                                   ....

204003c4 <dead_time>:
204003c4:	0096 0000                                   ....

204003c8 <pwm_real_inv_freq>:
204003c8:	0000 45fa                                   ...E

204003cc <NTC_readout>:
204003cc:	8000 07ff                                   ....

204003d0 <__fdlib_version>:
204003d0:	0001 0000                                   ....

204003d4 <_impure_ptr>:
204003d4:	03d8 2040                                   ..@ 

204003d8 <impure_data>:
204003d8:	0000 0000 06c4 2040 072c 2040 0794 2040     ......@ ,.@ ..@ 
	...
20400480:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20400490:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20400800 <__atexit_recursive_mutex>:
20400800:	70cc 2040                                   .p@ 
